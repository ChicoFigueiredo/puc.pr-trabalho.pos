Martin Fowleré o pesquisador chefe da ThoughtWorks, empresa de desenvolvimento e integração 
de aplicações corporativas. Foi pioneiro no uso da tecnologia de objetos na criação de 
aplicações corporativas multicamadas na década de 1980. Êo autor de UML Essencial e Refatoração, 
traduzidos e publicados no Brasil pela Bookman Editora, e de Pla1111i11g Extreme Programmi11g 
e A11alysis Pattems, publicados pela Addison-Wesley. 

A634a Fowler, Martin 
Padrões de arquitetura de aplicações corporativas / Martin 
Fowler; tradução Acauan Fernandes. -Porto Alegre : Bookrnan, 
2006. 
493 p. ; 25 cm. 

ISBN 978-85-363-0638-4 

1. Computação -Projeto -Sistema. 2. Computadores. -Arquitetura. 
1. Título. 
CDU 004.41 

Catalogação na publicação: Júlia Angst Coelho -CRB 10/1712 


MARTIN FOWLER 

COM ACOLABORAÇÃO OE 

DAVID RICE, 
MATIHEW FOEMMEL. 
EDWARD H IEATT, 

ROBERT MEE, 

RANDY STAFFORD 

PADRÓESDE 
ARQUITETURA 
DE APLICAÇÕES 
CORPORATIVAS 

Tradução: 

Acauan Fernandes 
Mestre e.m Ciência da Computação pela UFRGS 

Consultoria, supervisão e revisão técnica desta edição: 

Jonas Knopman 

D. Se. COPPE/UFRJ 
Analista, Pesquisador e Professor do NCE/ UFRJ 

Reimpressão 2008 

2006 


Obra originalmente publicada sob o título 
Pntterns of E11terprise Applicntion Arc/1itecture, 1st Edition 
© 2003, Pearson Education, lnc. 

158 0-321-12742-0 

Tradução autorizada a partir do original em língua inglesa, publicado por Pearson Education, lnc. sob o 
selo Addison Wesley Professional. 
Capa: Gustavo Demarcl,i 
Leitura final: Mareei Pedro11 de Oliveira 
Supervisão ed itorial: Arysi11lln Jacques Affo11so e Rachel Gnrcin Vnltiez 
Editoração eletrônica: wser Ho11se 

Reservados todos os d ireitos de p ublicação, em língua portuguesa, à 
ARTMED® EDITORAS.A. 
(BOOKMA COMPANHIA EDITORA é uma divisão da ARTMED<D EDITORAS.A.) 
Av. Jerônimo de Omelas, 670 -Santana 
90040-340 Porto Alegre RS 
Fone (51) 3027-7000 Fax (51) 3027-7070 

É proibida a duplicação ou reprodução deste volume, no todo ou em parte, sob quaisquer 
formas ou por quaisquer meios (eletrônico, mecânico, gravação, fotocópia, distribuição na 
Web e outros), sem permissão expressa da Editora. 

SÃO PAULO 
Av. Angélica, 1091 -Higienópolis 
01227-100 São Paulo SP 
Fone (11) 3665-1100 Fax (11) 3667-1333 

SAC 0800 703-3444 

IMPRESSO NO BRASIL 

PRINTED IN BRAZlL 


Para Denys JtYillinm F~wler, 1922-2000 
1n memonam 

-Martin 


Prefácio 

N
N
o verão de 1999, fui para Chicago prestar consultoria em um projeto em execução 
pela ThoughtWorks, uma empresa de desenvolvimento de aplicações 
pequena, mas em rápido crescimento. Tratava-se de um daqueles projetos 
ambiciosos de aplicações corporativas: um sistema de apoio para contratos de leasing. 
O sistema lida, basicamente, com tudo o que acontece com o leasing após você ter assinado 
na linha pontilhada: enviarcontas, lidar com a atualização de um dos bens do 
leasing, procurar pessoas que não pagam suas contas em dia e descobrir o que acontece 
quando alguém devolve os bens mais cedo. Isso não parece muito dHícil até que 
você perceba que contratos de leasing têm variações infinitas e são terrivelmente 
complicados. A "lógica" de negócio raramente se ajusta a algum padrão lógico porque, 
antes de qualquer coisa, ela é escrita por pessoas de negócio com a finalidade de 
capturar negócios, em que pequenas variações estranhas pode fazer toda a diferença 
em fechar ou não uma operação. Cada uma dessas pequenas conquistas acrescenta 
ainda mais complexidade ao sistema. 

Este é o tipo de coisa que me deixa entusiasmado: como pegar toda essa complexidade 
e propor um sistema de objetos que possa tornar o problema mais tratável. 
De fato, acredito que o benefício principal dos objetos está em tornar tratável uma lógica 
complexa. Desenvolver um bom Modelo do Domínio (126) para um problema de 
negócio complexo é difícil, mas maravilhosamente gratificante. 

Mas este não é o fim do problema. Nosso modelo de domínio tinha que ser persistido 
em um banco de dados e, como em muitos projetos, estávamos usando um 
banco de dados relacional. Também tínhamos que conectar esse modelo a uma interface 
de usuário, fornecer suporte para permitir a aplicações remotas usarem nosso 
software e integrá-lo com pacotes de terceiros. Tudo isso em uma nova tecnologia chamada 
J2EE, a qual ninguém no mundo tinha experiência real de uso. 

Embora esta tecnologia fosse nova, tínhamos o benefício da experiência. Eu vinha 
trabalhando com esse tipo de coisa há muito tempo com C++, Smalltalk e CORBA. 
Muitos dos membros da ThoughtWorks tinham muita experiência com Forte. 


viii PREFÁCIO 

ós já tínhamos as idéias centrais da arquitetura em nossas cabeças, e só precisá amo 
de cobrir como aplicá-la a J2EE. Olhando para o proj to trê ano mai tard , 
v mos que não stá p rf ito, mas suportou muito b ma passagem do t mpo. 

É para e te tipo de ituação que este li ro foi e crito. Ao longo do ano tenho 
vi to muito projeto d aplicaÇe corporati a . E te projeto muita vez c ntAm 
idéias semelhantes de projeto que e mostraram efeti a na manipulação da complexidade 
inevitável que a aplicaçõe corporativas pos uem. Est livro é o ponto d 
partida para capturar essas idéias na forma de padrões. 

livro ' organizado m duas partes, ndo a prim ira um conjunto d capítulo 
d critivos sobr vário tópico important s obr o proj to d aplicaçõ corporativa 
. E capítulo introduz m vário pr bl ma da arquit tura d aplicaÇ c rporati 
as e uas soluções. o entanto, eles não entram em muitos detalhes a respeito 
d ssas soluçõe . detalhes das soluçõ stão na s gunda parte, organizada na forma 
de padrões. Esses padrões são uma referência, e não espero que ocê os leia do começo 
ao fim. eu bj tivo é que vocA I ia todo o capítulo d criti o da Parte 1 para 
t ruma idéia global do livro. Então vocA mergulha n capítulos d padrõ s da 
Part 2, na m <lida dos eus int resses e n ces idad s. A sim, e t ', ao me mo tempo, 
um livro descritivo curto e um li ro de referência mais longo. 

O tema da obra 'o proj to de aplicaçõe corporativa . Aplicaçõe corporati a 
dizem respeito à exibição, manipulação e armazenamento de grandes quantidades 
de dado , fr qüentemente complexo , e ao suporte ou automação do proce so de 
negócio que fazem uso dess s dados. Como os sistemas de reserva, sistema financ 
iro , cadeia d uprim nto e muito outro qu uportam o mod rno ambi nt s 
de negócio . A aplicaçõ corporati a tAm s u próprio de afio oluçõ e ão 
dif r nte do i t ma mbutido , do i t ma de controle, de t 1 e municação ou 
do oftwnre para desktop . Assim, se ocê trabalhar nesses outros campos, não há realmente 
nada neste livro que lhe inter sse (a menos que queira apenas saber o que são 
aplicaçõ s corporati as.) Para um livro geral sobre arquitetura d oftware, eu recom 
ndaria [P SA]. 

Há muito a p cto r fer nt s à arquitetura na con trução d aplicaçõ s corporativas. 
Rec io qu te livro não ja um guia abrang nte d todos les. Na con trução 
de software, acredito firmemente no desenvolvimento itera ti o. No âmago do de-

envolvimento itera ti o tá a noção de que v cê dev distribuir ver -do oftware 
assim que ti er algo útil para ou uário, ainda que e ta distribuições não stejam 
compl ta . mbora haja muita dif r nça ntr cr v rum li ro crever oftware, 
penso qu esta noção é compartilhada em ambos os casos. Isso dito, est livro é 
um compAndio incompl to, por'm (acredito u) útil, d con lhos obr arquitetura 
de aplicações corporativas. principai tópicos obre o quais eu falo são: 

• Di por aplicaçõe corporati a em camadas 
• Estruturar lógica d domínio (negócio) 
• truturnr uma interfac Web d usuário 
• Conectar módulos em memória (particularmente objetos) com um banco d 
dad s relacional 
• Manipular o tado da m ambiente em tad 
• Prinópio de di tribuição 

PREFÁCIO 

A lista de coisa sobre as quais não falo é longa. u realmente gostaria de e crever 
obr a organização de validaçõ s, incorporação de men agen comunicação 
assíncrona, segurança, manipulação d erros, clusterização, integração d aplicaçõe 
, refatoração de arquitetura, e truturação de interfac deu uário do tip client 
rico, entr outr tópico . Entretant , devid ar triçõ de paço e tempo falta 
de reflexão suficiente, ocê não irá encontrá-los neste li ro. Espero er alguns padrõ 
s para e te trabalho m um futuro próxímo. Tah ez eu cr va um egundo olume 
deste li ro e trate esses tópicos, ou tal ez alguma outra pessoa preencha esta 
outra lacuna . 

D stas, a comunicação bas ada mm nsag n ' uma qu tão particularm nt 
important . A p oa qu int gram múltipla aplicaçõ tão cada z mai faz ndo 
uso de abordagens de comunicação baseada em mensagens assíncrona . Há muito 
as r dito a favor d eu uso denh·o d uma aplicação também. 

Este livro não pretende ser específico para nenhuma plataforma de software em 
particular. Depar i-m pela primeira v z com t padr-s quando e tava trabalhando 
com Smalltalk, C++ CORBA no final da d'cada d 80 inído da d 90. o 
final da d ' cada de 90, com c i ar alizar trabalho m Java d cobri que e tes padrões 
se aplicavam bem tanto nos sistemas antigos Java/CORBA quanto no trabalho 
mai recent ba eado em J2EE. Mais r cent rn nt fiz um trabalho introdutório com 
a plataforma .NET da Micro oft e de cobri que no amente os padrõe e aplicavam. 
Meus col ga de ThoughtWork tamb 'm apr entaram ua exp ri ~ncia , e pedalmente 
com Forte. ão posso afirmar que o paclrõe são g néricos para todas as pla


taforma já u ada ou ainda em u o com apLicaÇ corporativa , ma até agora t s 
padrõ t~m mo trado recorrência ufici nt paras r rn úteis. 
Fom ci xemplo de código para a maioria do padr-es. Minha colha d lin


guagem para eles foi baseada no que acho que a maioria dos leitores pro a elmente 

erá capaz de ler e ntender. Java é uma boa escolha aqui. Qualquer um que possa ler 
C ou C++ pod l r Java , além disso, Java é menos compl xa que ++. Basicamente, 
a maioria d programad r C++ con gu 1 r pr grama e crit em Ja a, ma o 
contrário não é verdad iro. Sou um entusiasta de obj to , ntão in itavelmente tendo 
para uma linguag m 00. Em con eqü ~ncia, a maioria dos ex mplos de código tão 
em Java. Enquanto eu trabalhava no livro, a Microsoft começou a firmar seu ambiente 
.NET, e ua linguagem C# t rn a maioria das propriedades de Java que a tornam 
inter s ante para um autor. Assim, e cre i alguns dos exemplo d código tamb 
'm em C#, embora i o intr duzi c rto ri co já qu o d n olv dor não tAm 
muita experiência com .NET, e as t 'cnicas para usá-lo eficient mente são m nos madura 
. Amba ão linguag ns ba ada em C, de modo que você con guir l r 
uma de e er capaz de ler amba , me mo e não gostar profundamente de a linguag 
m ou plataforma. Meu obj tivo era u ar uma linguagem que a grand maioria do 
desenvol edores de software pudesse ler, ainda que esta não fosse a sua linguagem 
principal ou pr ferida. (Minhas de culpa àqu l qu go tam de Srnalltalk, Delphi, 
Visual Basic, P rl, Python, Ruby, COBOL, ou qualquer outra linguag m. u s i que 
v cA acham qu conh e m uma linguag mm lhor d qu Java ou #. Tudo o qu 
pos o dizer é que u também!) 

O xemplos e tão lá para in pirar e explicar as idéia nos padrõ . Eles não ão 
soluções enlatadas. m todos os casos ocê precisará efetuar uma quantidade razoável 
de h·abalho para aju tá-los à sua aplicação. Padrõe são pontos de partida úteis, 
e não d tinos. 


PREFÁCIO 

Para Quem é Este Livro 

Escrevi e te li ro para programadore , proj tistas e arquiteto que estejam construindo 
aplicações corporativas e que queiram melhorar sua compreensão sobr que tõ 
arqwt turai u ua comunicaçã br la . 

Pr umo qu a maioria do m u l itor di id.irá m doi grupos: aquel 
com nec idade mod rada qu qu r rn con truir u próprio oftware e leitor 
com necessidades maiores que usarão uma ferramenta. Para aqueles com necessidades 
mod rada , meu objetivo é que este padrões irvam como uma iniciação. m 
muitas áreas, você pr cisará d mais do que padrões, mas lhe darei uma vantagem 
inicial n t campo muito maior do qu a qu tive. A u uário d f rram nta 
p roque st livro dA alguma id 'ia do qu acont c por baixo do panos tamb ' m 
ajude-os a colh r quai padrõ s suportados por f rram ntas u ar. Por exemplo, 
você usa uma ferramenta para o mapeamento objeto-relacional, ainda as im tem que 
t mar deci -obr como map ar certa ituaçõ . Ler o padrõ deve lhe dar alguma 
orientação nesse sentido. 

Há uma terceira cat goria, aqu l s exig nt se que qu rem con truir seu próprio 
software. A prim ira coisa que u diria neste caso é para considerarem com at nçã 
a opção d u ar f rram nta . Já vi mai d um projeto virar um longo x rcício 
de con trução de framework , o que não era o objetivo inicial do projeto. e ce ainda 
não e tiver convencido, vá em fr nt . Lembre-e nes e caso de que muitos do 
exemplos de código neste livro são deliberadamente simples para ajudar a compreensão, 
e você descobrirá que preci ará fazer muitos ajustes para lidar com as demandas 
mruor qu nfr ntar. 

Já que padr-ã luçõe c mun para probl ma r c rrent , há uma boa 
chance d que você já t nha se deparado com alguns d les. Se você v m trabalhando 
com aplicaçõe corporativa há algum tempo, pode conhecer a maioria d les. ão 
reivindico a apresentação de nada no o neste livro. a verdade, afirmo o oposto 


st é um livro de (para no a indú tria) idéia antiga . S ocê é novo neste campo, 
p ro qu o livro o ajude a aprend r obre ta técnica . S o stiver familiariza


A 

do com a técnica , p ro que o livr o ajud a comunicar e n iná-la a outr . Uma 
part importante dos padrões é tentar construir um vocabulário comum, de modo 
que ocê po a dizer que essa elas e é uma Fachada Remota (368) e outros projeti ta 
saibam o que você quer dizer. 

Agradecimentos 

O que e tá escrito aqui deve-e muito à pe oa que trabalharam c migo de diver


as formas no decorr r do anos. Muita pessoas ajudaram d várias maneira diferente 
. Muita eze não con igo lembrar coi a importante que a p oa di 
ram e que estão neste li ro, mas posso reconhecer aquelas contribuições de que me 
1 mbro. 

Começarei com meus colaborador s. Da id Rice, um dos m us col gas na 
ThoughtWork , deu uma grande contribuição -cerca de um décimo do livro. Enquanto 
trabalhávamo duro para at nder o prazo (ao me mo t mpo que el da a uport 
a um cliente), ti emo ária con r a tarde da noite, via troca d men agen , 
em que ele confessou finalmente entender por que escrever um livro era, ao mesmo 
tempo, tão difícil e tão compul ivo. 


PREFÁCIO 

Matt Foemmel é outro colega da ThoughtWorks, e embora o Ártico vá precisar 
de ar condicionado ant que 1 e cr va pro a por diver ão, foi um grande colaborador 
d exemplos de código (assim como um crítico bastant sucinto do li ro.) Fiquei 
ati feito por Randy Stafford colaborar com Camada de Serviço (141), poi le é 
um firm d f n or d la. Tamb 'rn go taria de agrad c r Edward Hieatt e Rob M 
por suas colaborações, que se originaram da percepção de Rob de uma lacuna no texto 
enquanto fazia revi ão. lese tornou meu revisor favorito: ele não apenas perc b 
que algo está faltando como também escreve uma seção para consertá-lo! 

Como de costum , d o mai do qu po o dizer à minha equipe d r visor s 
oficiai d prim ira dass 

John Brewer RobMee 

Kyl Brown G rardM zaro 

Jens Coldewey Oirk Riehle 

JohnCrupi Rand y Stafford 

L onard F nst r David Si g l 

Alan Knight KaiYu 

u poderia quase listar a lista telefônica da houghtWorks aqui, devido à quantidade 
d col ga qu me ajudaram, conver ando sobr u próprio proj to e experi~
ncia . Muito padrões s formaram na minha mente porque ti e a oportunidad 
de com, rsar com projetistas tal ntosos, de modo que tenho d agradecer à companhia 
int ira. 

Kyle Brown, Raqu l Reinitz e Bobby Woolf não m diram e f rço para ter longas 
e detalhadas sessões de re i ão comigo na Carolina do orte. eu pente fino introduziu 
todo o tipo de bom en o aqui. Apr ci i m e pecial a di r a e longas 
conversas telefônicas com Kyle que contribuiu mais do que posso registrar. 

o início de 2000, preparei uma pale tra para a Java One, com Alan Knight e 
KaiYu,qu foiag "n d t rnat riaJ.Al ' md agrad c~-lo ,tamb ' md voagrad c 
r Jo h Mack nzi , R b cca Par on Dave Ric p la ajuda m r finar a pal tras 
e pelas contribuições posteriores. Jim ewkirk foi de grande alia ao ajudar a me 
familiarizar com o mundo . T. 
Aprendi muito com as pessoas que trabalham nesta área por meio de boas conv 
r a e colaboraçõ . o taria de agrad c reme p cial a oll en Ro , David Muirh 
ad Randy Stafford por compartilhar m seu trabalho no mplo do Foodsmart 
na Gem tone. Também tiv ótima con er a no work hop em Cre ted Butte que Bruce 
ckel organizou e de o agradecer a todas as pessoas que compareceram àquele 
evento no último ano . Jo hua Keriev ky não te e t mpo d fazer uma revi ão 
completa, mas foi um excelente consultor de padrões. 

Como mpre, ti a notáv l ajuda do grupo d l irura da UIUC. Meu agradecimentos: 
Ariel Gertz nst in, Bosko Zivalj ic, Brad Jon s, Brian Foote, Brian Marick, 
Federico Balaguer, Jo eph Yoder, John Brant, Mike Hewner, Ralph Johnson e 
Weera ak Witthawa kuJ. 

Drago Manol cu, ex-lzitman da UIUC, juntou u próprio grup para me dar 
retorno. eus agradecimentos a Muhammad Anan, Brain Doyle, mad Ghosheh, 
Glenn Graessl , Daniel Hein, Prabhaharan Kwnarakulasingam, Joe Quint, John 
Reinke, Ke in Reynolds, Sripriya Srini asan e TirumaJa Vaddiraju. 

Kent B ck me deu muita boa idéia . Lembr d que foi el que deu o n m 
ao padrão Ca o E pecial (462). Jim Od ll foi o r ponsável por m introduzir no 


XÍÍ PREFÁCIO 

mundo da consultoria, ensino e e crita -nenhum agradecimento jamais fará justiça 
a e a ajuda. 

Enquanto escr via este livro, coloquei esboços na W b. Durante sse tempo, 
muitas p soa m enviaram e-mails apontando problema , fazendo pergunta ou falando 
obr alt mativa . E a p oa indu rn Micha l Bank , Mark B m t in, raham 
Berrisford, Bjom Beskow, Bryan Boreham, Sean Broadley, Peri Brodsky, Paul 
CarnpbeU, Che t r Chen, John Coakley, Bob Corrick, Pa cal Co tanza, Andy Czerwonka, 
Martin Diehl, Daniel Drasin, Juan Gomez Duaso, Don Dwiggins, Peter Foreman, 
Ru ll Fr man, P ter Gas m, nn, Jason orman, Dan r en, Lar Gregori, 
Rick Hans n, Tobin Harri , Ru s l H aley, hri tian H li r, Richard H nderson, 
Kyl H rm n an, Car t n H yl, Akira Hirn awa, Eric Kaun, Kirk Kno rn child, J per 
Ladegaard, Chris Lopez, Paolo Marino, Jeremy Miller, I an Mitro ic, Thomas 

eumann, Judy Obe , Paolo Parovel, Tr vor Pinkney, Tornas R strepo, Joel Ri d r, 
Matthe Roberts, Stefan Roock, Ken Rosha, Andy Schneider, Alexandre Semenov, 
Stan Silv rt, e ff utt r, VoJk r 1i rmath, hri toph r Thame , Volker Turau, Knut 
Wannhed n, Marc Wallac , Stefan W nig, Brad Wi rn r lag , Mark Windholtz, Micha 
I Yoon. 

Há muitos outros colaboradores cujos nomes eu nunca soube ou não consigo 
lembrar, ma m us agradecimento nã ão m no incero . 
Meu maior agradecimento é, como sempre, para minha esposa Cindy, cuja companhia 
apr cio muito mai do que alguém poderá apr ciar e t livro. 

Colofão 

Este é o primeiro li ro que escre i usando XML e tecnologias relacionada . te to 
principal foi e crito como urna érie de documento XML u ando o fiel TextPad. 
Também usei um DTD feito em casa. Enquanto estava trabalhando, usei XSLT para 
g raras páginas Web para o ite HTML. Para os diagramas, bas ei-me no velho amigo 
Visio, usando os exc lentes gabaritos UML de Pa el Hruby (muito melhores qu 
aqu 1 com a ferram nta. 1i nho um link n m u W b ite, vocA qui r.) E cr i 
um pequeno programa que importava automaticamente o exemplo de código 
para a aída, o que me poupou do pesad lo costum iro d recortar e colar código. o 
meu primeiro esboço, experimentei XSL-FO com Apache FOP. a ocasião, ele não se 
mo trou muito apropriado para a tar fa, então para trabalhos post riore e crevi 

cript m XSLT em Ruby para importar o t xto para o rameMak r. 

U ei diver a f rram nta open ource nquanto trabalh a n te livr -em e pedal, 
JUnit, rut, ant, Xerces, Xalan, Tomcat, Jboss, Ruby e Hsql. Meus agrad cimento 
para os muitos desenvolvedores dessa ferramentas. Também houve uma 
longa lista de ferramentas comerciais. Em especial, baseei-me no Visual Studio for 
.NET no excel nte ldea da IntelliJ -a prim iro IDE que m entu ia mou d d 
Smalltalk -para Ja a. 

O livro foi adquirido para a Addi on-W l y por Mike H ndrickson que, a i tido 
por Ross Venab] s, sup rvisionou sua publicação. Comecei o trabalho no manu 
cri to em no embro d 2000 e lanc i o sboço final para produção m junho d 
2002. nquanto escre o isto, o livro está pronto para o lançamento em novembro de 
2002 na OOPSLA. 

Sai-ah Wea er foi a editora de produção, coordenando a edição, composição, reisão, 
indexação e produção dos arqui os finais. Dianne Wood foi a editora de cópia, 


PREFÁCIO xiii 

executando o complicado trabalho de polir meu inglês sem introduzir nenhum refinamento 
desagradável. Kim Arney Mulcahy compôs o livro no formato que você vê 
aqui, organizou os cLiagramas, configurou o texto no Sabon e preparou os arqujvos 
Framemaker finais para a impressão. O formato do texto é baseado no formato que 
usamos para Refntornção*. Cheryl Ferguson fez a revisão das páginas e desentocou todos 
os erros que tinham escorregado pelas fendas. Irv Hershman preparou o íncLice. 

A foto da capa 

Durante os dois anos em que escrevi este livro uma construção mais importante era 
feita em Boston. A ponte Leonard P. Zakim Bunker Hill (tente colocar esse nome em 
uma placa de sinalização à beira da estrada) vai substituir a feia ponte de dois andares 
usada pela rodovia interestadual 93 para atravessar o rio Charles. A ponte Zakim 
é uma ponte estaiada, um estilo incomum nos EUA mas muito utilizado na Europa. 
A ponte Zakim não é longa, mas é a ma.is longa do gênero no mundo e a 
primeira dos EUA com um projeto assimétrico. É linda, o que não impede que eu 
brinque com Cindy sobre a previsão de Henry Petroski de que vamos ter uma 
grande falha, em breve, em urna ponte estaiada. 

Martin Fowler, Melrose, Massachussets, agosto de 2002 
HTTP://martinfowler.com 

• N. de R.T.: Rcfotoração, Aperfeiçoando o Projeto de Código Existente, Bookman, 2004. 

Sumário 

Introdução......................................................23 
Arquitetura ............ .. ..... .. ............ . ................. . ...... 23 
Aplicações Corporativas ................................................24 
Tipos de Aplicações Corporativas ... . ..... . ..... . .........................26 
Pensando em Desempenho .............................................. 28 
Padrões .............................................................30 
A Estrutura dos Padrões..............................................32 
limitações Destes Padrões...... ...................................... 33 

PARTE I As NARRATIVAS . . ...................... . ............. . . 35 
CAPÍTULO 1 Criando Camadas . .....................................37 
A Evolução das Camadas nas Aplicações Corporativas ............ ............. 38 
As Três Camadas Principais ..............................................40 
Escolhendo Onde Rodar suas Camadas............ ......................... 42 

CAPÍTULO 2 Organizando a Lógica do Domínio . .......................45 

Fazendo uma Escolha ..................................................49 

Camada de Serviço .................................................... 50 

CAPÍTULO 3 Mapeando para Bancos de Dados Relacionais ........... . .. 52 
Padrões de Arquitetura ...... ................................. .......... 52 
O Problema Comportamental ............ ................................ 57 
Lendo Dados .................. .. ..... . ............................... 58 
Padrões de Mapeamento Estrutural .......................................59 
Mapeando Relacionamentos ..........................................59 
Herança .. .. ........ . ...... .. ............. .................. ..... . 62 
Construindo o Mapeamento .... ....................................., ...65 
Mapeamento Duplo ............................................, .... 66 
Usando Metadados ... ... .. ..... .......... . .... ... ..... ................ 66 
Conexões de Bancos de Dados ...........................................67 


16 SUMÁRIO 

Questões Diversas ... .. .. ..... . . . ...... .... . .. . .. .. ....... . . . . ......... 69 
Leitura Adicional .... . ..... ... ... .... ... .... ...... .. .... . . . ............ 

CAPÍTULO 4 Apresentação Web . .. . ......... ...... . .. ............... 71 
Padrões de Vista .... .. ..... .. .... ... ..... ... ............. ... ..... .. ... 74 
Padrões de Controlador de Entrada . ...... . . . ... . . . .... ..... .... ..... ..... 75 
Leitura Adicional .... .. .... ............ . ........... ... ................ . 77 

CAPÍTULO 5 Concorrência (por Martin Fowler e David Rice) ............... 78 
Problemas de Concorrência.............. ................................ 79 
Contextos de Execução .. . ....... . ........... .. ....... .. ...... . ......... 
Isolamento e Imutabilidade ..... ............................... ......... . 81 
Controles de Concorrência Otimista e Pessimista .......... ..... .... ..... .... . 82 
Evitando Leituras Inconsistentes ....................................... 83 
Deadlocks . .......... . ........................ .. ...... .. . ........ . . 84 
Transações ........... ................................................ 85 
ACID ............ . .. ..... ... .... . . ... .. ... . .. .. ..... .... . ..... .... 85 
Recursos Transacionais . . .. .. ..... .... ... ..... . . . . ........... . ........ 86 
Reduzindo o Isolamento Transacional para Aumentar a Vivacidade ............ 87 
Transações de Negócio e de Sistema .......... . . . .... .. . .. ............. . 88 
Padrões para o Controle de Concorrência Offline . .. . ....... .. ..... .. .... ..... 
Concorrência em Servidores de Aplicação................................... 91 
Leitura Adicional ... ... .. . ........................ .....................92 

CAPÍTULO 6 Estado da Sessão ...... . ............. .. ................ 93 
O Valor de Não Possuir Estado .. .... ..... ... ... ... ..... ..... . ..... .. ..... 93 
Estado da Sessão ... .......... ... .......... ....... . ............. . ...... 95 
Modos de Armazenar o Estado da Sessão... . ... ... . . .... ..... .... . ...... ... 95 

CAPÍTULO 7 Estratégias de Distribuição ......... . .. ..... . .. .......... 99 
O Fascínio dos Objetos Distribuídos . ..... .... ..... ... ... .... ............ .. 99 
Interfaces Locais e Remotas ..... ... .... .. ... . . ... ...... ... ........ ...... 
Onde Você tem que Distribuir ... ............ . . .. ............. . .......... 101 
Trabalhando com as Fronteiras da Distribuição ............................. 103 
Interfaces para Distribuição .............................................104 

CAPÍTULO 8 Juntando Tudo ....................................... 105 
Começando com a Camada de Domínio.................. ............ ..... 106 
Descendo para a Camada de Dados .... .. ............... .. .. .... . ...... .. 107 
Camada de Dados para o Roteiro de Transação (120) . .. ... ... ............. 107 
Camada de Dados para o Módulo Tabela (134)........................... 108 
Camada de Dados para o Modelo de Domínio (126) .......... . ........... 108 
A Camada de Apresentação . ..... .. ..... ... . . ..... . ...... ... .. ......... 109 
Alguns Conselhos Específicos para Determinadas Tecnologias .... . ..... .. ...... 109 
Java e J2EE ............... .. .. ...... .. ..... .... ............. .. .... 
.NET ..... . ........................ .. . ........ . . . ...... .. ..... ... 111 
Procedimentos Armazenados .... . .... .. ... .. ........................ 111 
Serviços Web .. . ..................... . ............................ 112 
Outros Esquemas de Camadas .. .. ..... . ...... ... .... . ................. . 112 

PARTE li Os PADRÕES ...... ... .............................. . 117 
CAPÍTULO 9 Padrões de Lógica de Domínio......................... 119 
Roteiro de Transação (Transaction Script) . . ....... ... ..... . . ....... ..... ... 
Como Funciona . . .................................................120 


SUMÁRIO 17 

Quando Usá-lo ...................................................121 
O Problema do Lançamento de Receitas ...... .. ....................... 122 
Exemplo: Lançamento de Receitas (Java) . ......... . .............. .. .... 122 
Modelo de Domínio (Domain Model) . . ............................. . ..... 126 
Como Funciona .... .. ................ . ...................... .... .. 126 
Quando usá-lo . .............. .. ... .. ........ . .................... 129 
Leitura Adicional ..... ...... ... ... .. ..... ...... ... ........... .. .... 129 
Exemplo: Lançamento de Receita (Java) ....... .. .... ... ................ 129 
Módulo Tabela (Table Module) .... .. ... . ....... .. ..... ... . ...... ....... . 134 
Como Funciona . ....... . . . ... .... .. ... ..... ........ ....... . ....... 134 
Quando Usá-lo . . .. .. ...... .. .... . ....... .. .... ...... .. .. ...... ... 137 
Exemplo: Lançamento de Receitas com um Módulo Tabela (C#) ............. 137 
Camada de Serviço (Service Layer) (por Randy Stafford) . ... . .................. 141 
Como Funciona .... .... . ..... .... ... .. ..... .... . ....... ..... ...... 141 
Quando Usá-la .... ... ... .... .... .. ....... . ..... .. ..... ..... ...... 144 
Leitura Adicional .. ........ ..... .. . . . ..... .. ...... ........... .. .... 145 
Exemplo: Lançamento de Receitas (Java) ............................... 145 

CAPÍTULO 1 O Padrões Arquiteturais de Fontes de Dados (Data Source) .. 150 
Gateway de Tabela de Dados (Table Data Gateway) ..... .. ... . ...... ..... .... 151 
Como Funciona . .. . . ...... . . . ............ .. ..... .... ....... . .. .... 151 
Quando Usá-lo . .............. ... ..... .. .......... . ..... ... . .. .. . . 152 
Leitura Adicional .................................................. 153 
Exemplo: O Gateway Pessoa (C#) .... ................................. 153 
Exemplo: Usando Conjuntos de Dados ADO.NET (C#) ... .. .............. .. 155 
Gateway de Linha de Dados (Row Data Gateway) ........................... 158 
Como Funciona .. .... ..... ... .... .. .... .... .... ... ..... . . . . . .. .... 158 
Quando Usá-lo ............... ... ... ..... .. .............. ... .. .... 159 
Exemplo: Um Registro Pessoa (Java) .. . ...... ..... ... ............. .... . 161 
Exemplo: Um Armazenador de Dados para um Objeto de Domínio (Java) ..... 164 
Registro Ativo (Active Record) .......................................... 165 
Como Funciona . ..... . . . ..... .... . ................................ 165 
Quando Usá-lo .................. ........................ ......... 166 
Exemplo: Uma Pessoa Simples (Java) . .. ...... .. ...... .......... .... ... 167 
Mapeador de Dados (Data Mapper) .. . .............. . .. ... . ... .. ....... .. 170 
Como Funciona . .. . .. ... . . .... ... . ... . .. ..... ... ..... .. ... . ....... 170 
Quando Usá-lo .... .. ..... . . . .... . ................................ 175 
Exemplo: Um Mapeador Simples de Banco de Dados (Java) ..... ... ... ..... 175 
Exemplo: Separando os Métodos de Busca (Java) ........................ 180 
Exemplo: Criando um Objeto Vazio (Java) .............................. 183 

CAPÍTULO 11 Padrões Comportamentais Objeto-Relacionais . .......... 186 
Unidade de Trabalho (Unit of Work) ......... ............................. 187 
Como Funciona .. . . .... ... ... .... .. . .............................. 187 
Quando Usá-la .... . .................. . ...... .. ............. ... ... 191 
Exemplo: Unidade de Trabalho com Registro de Objeto (Java) (por David Rice) . . 192 
Mapa de Identidade (ldentity Map) ............... ... .............. ... ... 196 
Como Funciona . . .. . ...... ... .... . ... . .. ... ............ . ... ... .. .. 196 
Quando Usá-lo . . ....... . ... . ............ .. ................... ... . 198 
Exemplo: Métodos para um Mapa de Identidade (Java) ................... 199 
Carga Tardia (Lazy Load) ...............................................200 
Como Funciona . .. . .. ..... ... .... . ..... .... .... . . . ..... .. ..... .... 200 
Quando Usá-la . . .. .......... .... . ... . ... ... .... .......... ........ 202 
Exemplo: Inicialização Tardia (Java) ................................... 203 


18 SUMÁRIO 

Exemplo: Proxy Virtual (Java) ........... . . . .. ............. .. ... ...... 203 
Exemplo: Usando um Armazenador de Valor (Java) .. ..................... 205 
Exemplo: Usando Fantasmas (C#) ..... ... ...... ........... .. .... . . ... 206 

CAPÍTULO 12 Padrões Estruturais Objeto-Relacionais ............. .... 214 
Campo Identidade (ldentity Field) . ... . ...... . ................. . . .. . . . .. . 215 
Como Funciona . .... ...... .. ... . . ........... .... ..... .. ... .. ...... 215 
Quando Usá-lo . ..... . ............... . . . ..... . .............. . ..... 219 
Leitura Adicional ..... . ... . ...... . .. ... ..... ... .... . ....... . ....... 219 
Exemplo: Chave Integral (C#) .. ... .... ..... .... ..... . ...... .. ..... .. . 219 
Exemplo: Usando uma Tabela de Chaves (Java) ........... .. ...... .. ..... 220 
Exemplo: Usando uma Chave Composta (Java) .... ..... .... ... . ...... ... 222 
Mapeamento de Chave Estrangeira (Foreign Key Mapping) ................... 233 
Como Funciona .................. . .... . .. .. .... ...... . ... ..... .... 233 
Quando Usá-lo ................................................... 236 
Exemplo: Referência Univalorada (Java) . ... ..... ... .... ... .... ... ...... 236 
Exemplo: Busca Multitabelas (Java) ... . ..... .... ... . .... .. ..... ... .... 239 
Exemplo: Coleção de Referências (C#) ..... ..... ...... . ..... .. ... ...... 240 
Mapeamento de Tabela Associativa (Association Table Mapping) ... ... .... ... .. 244 
Como Funciona ...... . . . ....................................... .. . 244 
Quando Usá-lo . ..... .... .... .... .. ......................... . ..... 245 
Exemplo: Empregados e Habilidades (C#) ..............................245 
Exemplo: Usando SQL Direto (Java) ......................... . ..... .... 248 
Exemplo: Usando uma Única Consulta para Vários Empregados (Java) 
(por Matt Foemmel e Martin Fowler) .. ............ .. . ..... .... .... ..... 251 
Mapeamento Dependente (Dependent Mapping) ... ....... . ...... . .. ....... 256 
Como Funciona . ..... .. ........................... . . ... ... ... ..... 256 
Quando Usá-lo ...................................................257 
Exemplo: Álbuns e Faixas (Java) ... . . .. ... ...... .. ...... .. .... . ....... 258 
Valor Embutido (Embedded Value) ... ...... . . . . .........................261 
Como Funciona . .... .... . . ...... . ... .. ..... .... ... . ...... .. ....... 261 
Quando Usá-lo . .... .. . .. ... .. .. ........ .... ..... . ................ 261 
Leitura Adicional ............ ... .... ...... .. ............. . .... . . .. . 262 
Exemplo: Objeto Valor Simples (Java) ........ .. ..... ... ...... . ... ...... 262 
LOB Serializado (Serialized LOB) ..... . . . .. ... . .. .. .... . ..... . .......... . . 264 
Como Funciona . .. ....... ... ... ...... . ....... . .. . . . ........ .... ... 264 
Quando Usá-lo . ...... ....... .. ........ .... ... . ................. . . 265 
Exemplo: Serializando uma Hierarquia de Departamentos em XML (Java) ..... 266 
Herança de Tabela Única (Single Table lnheritance) .......................... 269 
Como Funciona ........... .. . ............... .. .... . .. . .... . . . ..... 269 
Quando Usá-la ................................................... 270 
Exemplo: Uma Tabela Única para Jogadores (C#) . .... ..... .... . ..... .... 270 
Carregando um Objeto do Banco de Dados ............................. 272 
Herança de Tabela de Classes (Class Table lnheritance) ........... .. .......... 276 
Como Funciona ...... ... .... ... .... . . . .................... ... ..... 276 
Quando Usá-la ................... . ... . .. .. ...... ..... . ... . .. .. ... 277 
Leitura Adicional ...... .... .. ... .... .... .... .... ... .... .... . ... . ... 277 
Exemplo: Jogadores e Assemelhados (C#) .............................. 277 
Herança de Tabela Concreta (Concrete Table lnheritance) ......... . ........... 283 
Como Funciona . .. ......... . ... . . .. ... ..... .... ... . ....... . . ... ... 283 
Quando Usá-la ................................................... 285 
Exemplo: Jogadores Concretos (C#) ........ .. ... .. .. . .. .... .. .... .... . 285 
Mapeadores de Herança (lnheritance Mappers) ..... .... .... .. . .. .. ... ... . . 291 
Como Funciona . ..... ... .... ... ..... . ..................... . ....... 292 
Quando Usá-los ...... ....... ......... . . .... ......... ... ..... ..... 293 


SUMÁRIO 19 

CAPÍTULO 13 Padrões de Mapeamento em Metadados 
Objeto-Relacionais . ............................................294 
Mapeamento em Metadados (Metadata Mapping) .......................... 295 
Como Funciona . ...... ..... .. .... . ................................295 
Quando Usá-lo ........ . ...... . ............ .... ........ .. ... . ..... 297 
Exemplo: Usando Metadados e Reflexão (Java) .... . ..................... 297 
Objeto de Pesquisa {Query Object) .......................................304 
Como Funciona .. ............ .... ... ..... .. .................... ... 304 
Quando Usá-lo ................................................... 305 
Leitura Adicional ................. .. ....... . ...... .. ............... 306 
Exemplo: Um Objeto de Pesquisa Simples (Java) .. ...... . . ...... ......... 306 
Repositório (Repository) (por Edward Hieatt e Rob Mee) ...................... 309 
Como Funciona ........... ... ........ . .......... .. ................ 310 
Quando Usá-lo .... .. .... ..... ... .. ..... .................... .. .... 311 
Leitura Adicional ..................................................312 
Exemplo: Encontrando os Dependentes de uma Pessoa (Java) ... .. ..... .... 312 
Exemplo: Trocando Estratégias de Repositório (Java) ...................... 312 

Capítulo 14 Padrões de Apresentação Web ....................... 314 

Modelo Vista Controlador (Model View Controller) ................ . .. . ...... 31 5 
Como Funciona . . .. .. ............ ... .... ... .... ......... . ......... 315 
Quando Usá-lo .. .. .. ... ...... ... . ....... .. .............. ... .... .. 317 
Controlador de Página (Page Controller) . . ................................318 
Como Funciona . ..... . ........ .. ...... .. .... ... ......... . ... .. .... 318 
Quando Usá-lo .............. .. .............. .. ............ ...... . 319 
Exemplo: Apresentação Simples com um Controlador Servlet 
e uma Vista JSP (Java) .. .... .. ..... ...... . ... ..... .... ........... ... 320 
Exemplo: Usando uma JSP como Manipulador (Java) ........... . ....... .. 322 
Exemplo: Manipulador de Página com um Código Por Trás (C#) ........ ..... 325 
Controlador Frontal (Front Controller) ... .... .... .. .................... ... 328 
Como Funciona . .. . .. ... ...... . .... ...... .. ..... .. . . . ... . ... ... . . . 328 
Quando Usá-lo .. ............. . ............. .. .... . ............... 330 
Leitura Adicional .. . .. ....... .. ... .. ...... .. ..... ..... .. ... ........ 330 
Exemplo: Exibição Simples (Java) ..................................... 330 
Vista Padrão (Template View) . ..... .... .. ...... .. ...... . . . .... .. ...... .. 333 
Como Funciona .................. ... ..............................333 
Quando Usá-la .... .... . ... ...... . . . .... ... .... ... ...... .. . . ..... . 336 
Exemplo: Usando uma JSP como uma Vista com um Controle 
Separado (Java) .... .. ..... ... .... ... .... ... ..... . ........ . . . ...... 337 
Exemplo: Página Servidora ASP.NET (C#) ... . . ... .... ........... . . ... ... 339 
Vista de Transformação (Transform View) .. ...... ... ....... . .... .. .... .... 343 
Como Funciona . .. . . ... .... . . .... . ... . ... .. ..... .. ..... . . . ........ 343 
Quando Usá-la .... . ...... ... .... ..... ... .. ..... ...... . . ... . .. .... 344 
Exemplo: Transformação Simples (Java) .. . . ... .. ... ............ . . ... ... 344 
Vista em Duas Etapas (Two Step View) ... . .... . . .... .. .... . . ... .. ......... 347 
Como Funciona . .. . .. ... ..... .... . ....... .. ..... .. ..... . . . .... .. . . 347 
Quando Usá-la ...... .... ..... . . . . ....... .. .. ........... . ......... 350 
Exemplo: XSLT em Duas Etapas (XSLT) ................................. 353 
Exemplo: JSP e Identificadores Customizados (Java) ... ........... .. .. . ... 355 
Controlador de Aplicação (Application Controller) .......................... 360 
Como Funciona ...................................................360 
Quando Usá-lo ................................................... 362 
Leitura Adicional ..................................................362 
Exemplo: Controlador de Aplicação Modelo de Estados (Java) ...... . ....... 362 


20 SUMÁRIO 

CAPÍTULO 15 Padrões de Distribuição .............................367 
Fachada Remota (Remote Façade) ....................................... 368 
Como Funciona .......... . ....................................... . 368 
Quando Usá-la ..... .... ............ ....... .... ................ .. . 371 
Exemplo: Usando um Session Bean Java como Fachada Remota (Java) ........372 
Exemplo: Serviço Web (C#) . ........................................375 
Objeto de Transferência de Dados (Data Transfer Object) .....................380 
Como Funciona .... ...............................................380 
Quando Usá-lo ................................................ ...383 
Leitura Adicional .............. . ..... .... .......... . ... .. . ........ . 385 
Exemplo: Transferindo Informações Sobre Álbuns (Java) ................... 385 
Exemplo: Serializando Usando XML (Java) .............................. 389 

Capítulo 16 Padrões de Concorrência Offline . ....................391 
Bloqueio Offline Otimista (Optimistic Offline Lock) (por David Rice) ...... . ......392 
Como Funciona ................ . .. .. .... . ... . ...... ...... ... .. . ...393 
Quando Usá-lo . ........ ........ ... ....... . ..... . ....... . ..... ... . 396 
Exemplo: Camada de Domínio com Mapeadores de Dados (170) (Java) .......396 
Bloqueio Offline Pessimista (Pessimistic Ottline Lock) (por David Rice) . ........... 401 
Como Funciona ........................... . . ......... . . ...........402 
Quando Usá-lo .................... ............. ..................405 
Exemplo: Gerenciador de Bloqueios Simples (Java) ............. . .........406 
Bloqueio de Granularidade Alta (Coarse-Grained Lock) 
(por David Rice e Matt Foemmel) ............ ............................412 
Como Funciona .................. .... ........................... .. 412 
Quando Usá-lo ................................................... 41 5 
Exemplo: Bloqueio Offline Otimista (392) Compartilhado (Java) .............415 
Exemplo: Bloqueio Off/ine Pessimista (401} Compartilhado (Java) ........... 420 
Exemplo: Bloqueio Offline Otimista (392) de Raíz (Java) ................... 420 
Bloqueio Implícito (lmplicit Lock) (por David Rice) ............ .. . ............ 422 
Como Funciona .... ................................... .. ........ .. 422 
Quando Usá-lo •.................................................. 424 
Exemplo: Bloqueio Offline Pessimista (401) Implícito (Java) .... .. ..........424 

CAPÍTULO 17 Padrões de Estado de Sessão.........................426 
Estado da Sessão no Cliente (Client Session State) ........ . ............... .. 427 
Como Funciona ......................................... ..........427 
Quando Usá-lo ................................................... 428 
Estado da Sessão no Servidor (Server Session State) .. ..... . ............... .. 429 
Como Funciona ......................................... ......... . 429 
Quando Usá-lo ................................................... 431 
Estado da Sessão no Banco de Dados (Database Session State) ...... . .........432 
Como Funciona ...................................................432 
Quando Usá-lo ................................................... 433 

CAPÍTULO 18 Padrões Básicos .............. .....................43 5 
Gateway .................................................. .........436 
Como Funciona ................................................... 436 
Quando Usá·lo ...................................................437 
Exemplo: Um Gateway para um Serviço de Mensagens Proprietário (Java) .....438 
Mapeador (Mapper) .... ..... ........... .................... ......... . 442 
Como Funciona ... . . .......... . .... ...... . ... ........... . ... .. . ... 442 
Quando Usá-lo ...................................................442 


SUMÁRIO 21 

Camada Supertipo (Layer Supertype) .... ........... ... ......... . ... ... ... 444 
Como Funciona . . .. .......... .... .. ...... .. .... ... ....... ... ... ... 444 
Quando Usá-la .... .. ..... . . .. ... . ... . .. ... ..... ...... ..... . ... ... 444 
Exemplo: Objeto do Domínio (Java) ................................... 444 
Interface Separada (Separated Interface) ............... . ....... ... .. ......445 
Implementação da Unidade de Trabalho .... .... .................... . .. 445 
Como Funciona . ....... .. ..... . .............. ... .... .............. 446 
Quando Usá-la .... .. ... ..... .... . ....... .. ........ .. .... ... ...... 447 
Registro (Registry) ................... .................................448 
Como Funciona .............. .... .. .. ...... .. . . ....... . ... . .. ... .. 448 
Quando Usá-lo . ..... . ......... . .............. . ............... . ... 450 
Exemplo: Um Registro Singleton (Java) .... . . ...... . ... . ....... . .. .. . . . 450 
Exemplo: Registro à Prova de Thread (Java) (por Matt Foemmel e 
Martin Fowler) ... ..... .. .... ............ .... .. ....................452 
Objeto Valor (Value Object) ............................................453 
Como Funciona ......... . ........ . ... . .. .... .... .. . ... . . . . ........ 453 
Quando Usá-lo ................................................... 454 
Dinheiro (Money) .. ..... ............ . ....... ... .... .. ............. ... 455 
Como Funciona ............................ ..... ..... .. ... ..... ... 455 
Quando Usá-lo .... .. ... ...... ... ... ..... .. ...... ... ........... ... 457 
Exemplo: Uma Classe Dinheiro (Java) (por Matt Foemmel e Martin Fowler) . .... 457 
Caso Especial (Special Case) ............................................462 
Como Funciona .. ..... .... .... ... ..... ... .. ..... .................. 462 
Quando Usá-lo . . . ...... . ................ .. ...... . . . .............. 463 
Leitura Adicional ..... ... .. .............................. . ......... 463 
Exemplo: Um Objeto Nulo Simples (C#) .......... ... . ..................463 
Plugin (por David Rice e Matt Foemmef) . . . ............... . . ....... . .......465 
Como Funciona ...................................................465 
Quando Usá-lo .. .... . ........ .. ..................................466 
Exemplo: Um Gerador de Identidades (Java) ..................... . ... ... 466 
Stub de Serviço (Service Stub) (por David Rice) . . . .. ... ..... . ..... ... .... .. .. 469 
Como Funciona .. ..... .. ...... ........... ... . .....................469 
Quando Usá-lo ................................................... 470 
Exemplo: Serviço de Impostos Sobre Vendas (Java) . ..... ... .. .. ......... . 470 
Conjunto de Registros (Record Set) ..... .. ... ....... .. .......... ...... ... 473 
Como Funciona .... .. ... ... ...... . ....... .. ............ ... ........ 473 
Quando Usá-lo . ....... .. ...... .. . ... . ... .. ..... ..... .. ... .... .... 475 

Referências ........ ... .......................... . .............. 477 

Índice ............. .. ................... . ......... ...... . . .... . 481 


Introdução 

C
C
aso você não tenha percebido, criar sistemas computacionais é uma tarefa difí


cil. À medida que a complexidade do sistema aumenta, a tarefa de construir o 
software fica muito mais difícil. Assim como em qualquer profissão, só progrectimos 
aprendendo, tanto com os nossos erros quanto com nossos sucessos. Este livro 
descreve parte desse aprendizado de forma que, espero, o ajudará a aprender essas lições 
mais rapidamente do que aprendi, ou para se comunicar com os outros de modo 
mais eficaz do que eu pude fazer antes de descrever estes padrões. 

Nesta introdução, quero estabelecer o escopo do livro e fornecer alguns dos 
fundamentos que servirão de base para as idéias aqui descritas. 

Arquitetura 

A indústria de software se delicia em pegar palavras e estendê-las em uma miríade de 
significados sutil mente contraditórios. Uma das maiores sofredoras é "arquitetura". 
Vejo "arquitetura" com uma daquelas palavras que soam impressionantes, usadas 
principalmente para indicar que estamos falando algo importante. Contudo, sou 
pragmático o suficiente para não deixar que meu cinismo atrapalhe o desafio de 
atrair as pessoas para meu livro.:-) 

"Arquitetura" é um termo que muitas pessoas, com pouca concordância entre 
si, tentam definir. Existem dois elementos comuns: um é a decomposição em alto nivel 
de um sistema em suas partes; o outro são decisões difíceis de alterar. Percebe-se 
também, cada vez mais, que não há apenas um único modo de especificar a arquitetura 
de um sistema; ao contrário, existem diversas arquiteturas em um sistema, e a 
visão do que é significativo em termos de arquitetura pode mudar durante o ciclo de 
vida de um sistema. 

De tempos em tempos, Ralph Johnson envia uma mensagem verdadeiramente 
notável para uma Hsta de correio, e ele enviou uma dessas quando eu estava termi



24 INTRODUÇÃO 

nando o esboço deste livro. es a mensagem, ele le antou a questão de que a arquitetura 
é subj tiva, uma compre n ão do projeto de um sistema compartilhada pelos 
desenvolvedore experientes em um projeto. E ta compreensão compartilhada freqü 
ntement apr s nta na forma do compon nt s mai importantes do istema 
de como eles interagem. Também diz respeito a decisões, poi os desenvolvedores 
gostariam de tomar as deci ões certas desde o início, já que elas são vfatas como difíc 
i de alterar. A ubjetividade aparece aqui tamb 'rn porqu , você de c brir qu 
algo , rnai fácil d alterar do que você supô , então isso não é mais arquitetural. o 
final, a arquitetura s resume a coisa importante -seja lá o que isso signifique. 

t livro, apr nto minha p rc pção da part mais important d uma 
aplicação corporati a das d cisõ s qu eu gostaria d pod r tomar ac rtadam nt 
logo no princípio do proj to. padrão arquitetural d que mai go to é o de camada 
, o qual d cr vo m mai detalh no Capítulo 1. E te livro, é p rtanto, obr como 
d compor uma aplicação corporativa em camada como ta camada trabalham 
juntas. A maioria da aplicaçõ corporati a não-tri iais usa alguma forma de 
arquit tura m camada , mas, em alguma situaçõ s, outras abordag ns, tai como 
canais filtros, são valiosas. ão di cuto essas situaçõ s, focalizando em z disso o 
cont xto d uma arquit tura m camada porque ta , a mai amplarn nt útil. 

Algun do padr-d t li ro pod m, d modo ac itáv 1, r chamado d padrõ 
arquit turai , vi to qu r pre entam deci õ s ignificativa obre es a partes. 
Outros são mais sobre projeto e o ajudam a conceber essa arquitetura. ão faço nenhuma 
tentativa decidida de eparar os dois, visto que é tão ubjetivo o que venha a 
ser ou não um padrão arquitetural. 

Aplicações Corporativas 

Mtúta pessoa escrevem oftware para computadores, e chamamos a tudo i so de desenvolvimento 
de oftware. Entretanto, existem diferentes tipos de oftware, cada qual 
com u pr'prio d afio e complexidad . I o torna-e evidente quando conver


c m algun do m u amigo d ram da t lecomunicaçõe . Em algun a pecto , 
a aplicações corporativas são mLúto mais fáceis do que o software para telecomunicaçõ 
s-não t mos problemas d 111ultitlzreadi11g muito complicados não t mos a int 
gração de hardware e oftware. m outros a pectos, no entanto, elas ão muito mai 
difíceis. s aplicaçõ corporativa muitas vezes têm dados complexo -uma 
quantidade grande deles -para trabalhar, aliado a r gra de negócio que não pa 


amem nenhum t t de raci cinio lógico. Embora alguma técnica padrõe jam 
r levante para todos os tipos de software, muitos são rele antes apenas para um ramo 
pecífico. 

m minha carr ira, t nho m onc ntrado m aplicaç~ corp rati a , d modo 
qu todos os m us padrões aqui são sobr elas. (Outro termos para aplicaçõ s 
corporativas incluem" i t ma de informação" ou, para aqueles com boa memória, 
"processamento de dados".) Mas o que eu quero dizer com o termo "aplicação corporativa"? 
ão consigo dar uma definição precisa, mas posso dar algumas pistas do 
meu significado. 

Com çar i com x mplo . A aplicaçõ corporati a inclu m folha d pagamento, 
r gi tr d pacientes, ra tr am nto de rem a , análi e d cu to , pontuação 
de cr 'dito, eguro, cadeia de uprim nto , contabilidad , rviço de atendim nto 
ao cliente e comércio internacional. As aplicações corpora ti as não incluem a inje



INTRODUÇÃO 25 

ção de combustível em automóveis, proces adores de te to, controladore de ele adore 
, controladore de fábrica química , chave t lefônica , si tema op racionai , 
compiladores jogos. 

As aplicaçõe corporativa normalmente envol em dados persistentes. O dado 
ão p r i t nte porqu pr ci am tar di ponív i entr múltipla xecuÇ do 
programa -de fato, eles normalmente preci am persistir por vários anos. Além dis


o, durante este tempo haverá muita alteraçõe no programa que usam e tes dados. 
Eles freqüentemente durarão mais do que o hardware que originalmente os criou 
e sobr i erão aos i t ma operacionais compilador s. Durant e s p ríodo, hav 
rá muitas alt raçõ s na strutw·a dos dados a fim d armaz ar novas informações 

m p rtw·bar a já xi t nt . Amda qu haja uma alt ração fundam ntal, a c mpanhla 
instale uma aplicação completamente nova para lidar com o trabalho, os dados 
têm que er migrados para a nova aplicação. 

ormalmente existe uma grande quantidade de dados -um sistema moderado 
terá mai d 1 Bde dado organizado m dezena de milh -d r gi tr 
tantos, qu a g r"ncia d t s dado ' uma parte important do sistema. O i t ma 
mais antigo u avam estrutura d arqui o ind xado , tais como ISAM e VSAM da 
IBM. Os sistemas modernos normalmente usam bancos de dados, na ua maioria, relacionai 
. O proj to e carga d s banco d dado e tomou por i ó urna profi ão. 

ormalmente muitas pessoas acessam os dados concorrentemente. Em muitos 

i t ma i o pode r m no do qu uma cent na d p oas, ma para i tema bas 
ados na Web que conver am p la Int rnet, isso aumenta em orden de magnitud . 
Com tanta p oa ace ando o si t ma, xi tem que tõ b m-definida para as egurar 
qu toda las pos am fazê-lo apropriadam nt . Ma me mo em tanta pe 


oa , ainda xi t m problema para garantir qu dua p oa não ace mo rn mos 
dados ao mesmo tempo de uma forma que possa causar erros. As ferramentas 
para o controle de transaçõ s absorvem um pouco d ssa carga, mas muitas vezes é 
impossí el esconder esse probl ma dos desenvol edores das aplicaçõ s. 

Com tanto dad , normalm nt há uma grande quantidad d telas de interface 
com o usuário para lidar com les. ão ' raro ha er centenas de tela dif r ntes. 
O usuários das aplicações corporativas ão dos oca ionais àquel s qu usam r gularmente 
o sistema e, em geral, eles têm pouco conhecimento técnico. Assim, os dado 
têm que er apr s ntado de vária forma dif rente para atender a diferentes 
obj ti o . O si t mas muita ez s têm urna grande quantidad de proc amento 
em lot , o qu ' fácil d qu c r quando nfocamo o ca o d u o qu nfatiz, ma 
int ração com o usuário. 

aplicaçõ • corporativa raram nte viv mi ola da . Ela fr qüentem nte pr cisam 
falar com outras aplicações corporativas espalhadas pela corporação. diver 
o i tema ão con truído em épocas difer nte com dif rente t enologia 
até mesmo os mecanismo de colaboração são diferentes: arquivos de dados em COBOL, 
CORBA, sistemas de m n agens, etc. D ez em quando a empre a tenta integrar 
s us diferentes sistemas usando uma tecnologia comum d comunicação. É claro 
que trabalho qua nunca eh ga ao fim, d m do qu cti r o qu ma d integração 
diferente coexi tem ao me mo t mpo. I o fica ainda pior quando a empre


a t nta integrar também ao eu parceiro d n gócio. 

Mesmo se uma companhia unificar a tecnologia para a integração, ela ainda terá 
problemas com as diferenças nos proc ssos de negócio e com a dissonância conceituai 
com os dado . Uma divi ão da companhia pod achar qu um client alguém 
com qu m la tem um contrat vigente; outra divi ão também conta aquel 
cliente com os quais a companhia já teve um contrato, ma que não t m mais; uma 


26 INTRODUÇÃO 

outra conta a venda de produtos mas não a enda de serviço . Pode parecer fácil lidar 
com ssas diferenças, ma quando ocA tem centenas de registros no quai cada 
campo pode ter um significado sutil.mente dif rente, a grandeza do problema torna-

um d afio-m mo e a única p s oa qu saiba atam nt o qu o campo significa 
ainda esteja na companhia. (E, é d aro, tudo isso muda sem aviso pré io.) A conseqüência 
disso é que os dados têm de ser constantemente Jidos, alterado e gravado 
em todo o tip d format intática e emanticamente diferente . 

A seguir, temos a questão do que está por trá do termo "lógica de negócio." 
Acho e te um termo curioso porque exi tem poucas coi as que ão menos lógica do 
qu a lógica d n gócio. uando ocA cria um ist ma op racional, força-para 
manter toda a coisa lógica. o ntanto, as regras d negócio são sirnpl sm nte impo 
ta a você e, em um grande e forço poütico, não há nada que você po a fazer 
para alt rá-la . VocA t m que lidar com um conjunto aleatório d condiçõ e tranha 
que muitas veze interagem umas com a outra de forma surpreendente . É claro 
que elas ão a sim por alguma razão: algum v ndedor n gociou r ceber uma prestação 
anual dois dias mai ta.rd do que o usual porqu is os aju ta a ao fluxo de caixa 
do cliente e, assim, le conseguiu ganhar alguns milhões de dólar no n gócio. 
Alguns poucos milhare de ca o e p ciai ' o qu 1 va à compl xa "ilógica" de 
negócio, qu torna tão difícil o oftwnre d n g 'cio . ta ituação v cA t m qu organizar 
a lógica de negócio tão eficazrn nte quanto puder, porque a única coi a certa 
é que ela mudará com o decorrer do tempo. 

Para algumas pessoas, o termo "aplicação corporativa" sugere um sistema 
grande. Entr tanto, é importante lembrar que nem todas as aplicaçõ s corporati as 
são grand s, ainda qu la pos am agr gar muito valor ao negócio. Muitas p s oa 

nt nd m qu não vai a pena e pr cupar c m i t ma p qu no , , at' c rt , 
ponto ela tem razão. Se um i t ma pequeno falhar, ele normalmente faz meno barulho 
do que um sistema grande. Ainda assim, acredito que essa forma de pensar 
tende a não dar tanta at n ão ao feito cumulativo da coexistência de ários projetos 
pequeno . Se ocê puder fazer coisa qu melhorem o projeto pequeno , o efeito 
cumulativo pode r muito ignificati o para o negócio, e pecialment porque proj 
to p queno muita v z tArn um valor d pr p rcional. Urna da melhore coisas 
qu você pode fazer , transformar um proj to grande em um pequ no simplificando 
a arquitetura o proce so. 

Tipos de Aplicações Corporativas 

Quando discutimos como projetar aplicações corporativas e quais padrões usar, é 
importante p rceb r qu a aplicaçõ s corporati as ão inteiram nte dif r nt suma 
da utra qu pr bl ma dif r nt 1 vam a man ira dif r nt d faz r a e i a . 
Tenho um conjunto d campainha de alarm qu disparam quando as p ssoas dizem 
"S mpr faça is o". Para mim, muito do de afio (e inter ) do projeto e tá em 
conhecer as alternati as e julgar os compromisso envol idos em u ar esta ou aquela. 
Há muitas alterna ti as, mas escolherei aqui três pontos nesta área enorme. 

onsidere um ar ji ta online B2 (n gócio dir to com o client ): as p ssoas nav 
gam -com ort um carrinho d compra -compram. m um i t ma com 

e, preci amo er capaze de lidar com um grand volume de u uário , então n s a 
lução pr cisa não ap na er razoavelment fiei nte m termo d r cur o u ados, 
mas também escalá el, de modo que você possa aumentar a carga adicionando 


INTRODUÇÃO 27 

mais hardware. A lógica de domínio para tal aplicação pode r bastante direta: obter 
p d.ido, algun cálculo r lati amente imple de pr ço e rem a notificação d 
en io. Quer mos que qualquer um consiga acessar o sistema facilm nt , ntão isto 

ugere uma apre ntação Web ba tante genérica que po a er u ada p la maior faixa 
p ív l d navegador . font d dado inclui um banco de dad para armazenar 
pedidos e tal ez alguma comunicação com um sistema de estoque para ajudar 
com informaçõe sobr di ponibilidad entr ga. 

Compare isso com um sistema que automatize o processo de contratos de lea


ing. De c rto modo, t 'um i t ma muito mais impl do que o do varejista B2 
porqu há muito menos u uários -não mai do qu m torno d uma c nt na d cada 
v z. El ' mai complicado na l 'gica d n góci . Calcular conta m n ai m um 
lease, tratar eventos tais como retornos antecipados e pagamentos atrasados e validar 
dados quando um lea e ' r s rvado com ant c dência, são todas tar fas complicadas, 
já que muito da competição na indústria de leasing em na forma de pequenas ariaÇ 
e obre negócio feit no pa ado. Um domínio d n gócio c mplexo como e 
é d safiador porqu a r gras são arbitrária . 

Tal ist ma apr enta ainda uma int rfac com o u uário mai compl xa. o 
rrúnimo, isso significa uma interface HTML muito mais elaborada com telas mais 
complicada e em maior núm ro. Com fr qüência i tema tArn demanda de 
interface com o usuário que le am os usuádos a querer uma apresentação mais sofi 
ticada do qu o p rmitido por umfront end HTML, a im é n ce ária uma interfac 
mai convencional, do tipo cli nte rico. Uma interação mais complexa com o usuário 
tamb 'm 1 a a um comportam nto tran acional mai complicado: R rvar com 
ant cedência um /ea e pod 1 Vé\lº uma hora ou dua , p ríodo durant o qual o u uário 
e tá em uma tran ação lógica. Tamb 'm ob rvamo um e qu ma d banco d dados 
complexo com tal ez duas centenas de tabelas e conexões com pacotes para a aliação 
de bens e determinação de pr ços. 

Um terceiro xemplo é um sist ma simples d registro de gastos de uma pequena 
c mpanhia. Tal i tema t m pouco u uári lógica impl , pod nd r di ponibilizado 
facilm nt para a companhia com uma apr entação HTML. A única fonte 
d dados são algumas poucas tabelas m um banco d dado . Tão simple quanto 
possa parecer, um sistema como este não é despro ido de desafios. Você tem que 
con truí-lo mtúto rapidamente e t m que ter em m nte que ele pode cr c r à medida 
que as p oa queiram calcular reembolso , incluí-los na folha de pagamento, ent 
nd r implicaçõ d imp to , forn c r r latório para o dfr t r financ iro, con ctar 
o sist ma aos s rviços W b de r s r a de passagens aéreas, assim por diant . A 
t ntativa d u ar a arqtút tura d qualquer um do doi outro x mplo irá r tardar 

o desenvolvimento de te. Se um i tema traz benefícios para o negócio (como todas 
a aplicaçõe corporativa d veriam trazer), atra ar e e benefício cu ta dinheiro. 
Entretanto, você não quer tomar decisões agora que dificultem uma futura e pansão 
do istema. Contudo, se você acr centar flexibilidade agora e o fizer de forma equivocada, 
a complexidad adicionada obj tivando a flexibilidad pode, m verdad , 
t mar mai difícil t nd r i t ma n futur p d atra ar o d n olvim nto 
atual retardando a im o benefício . Embora tais i tema jam pequeno , a 
maioria da empr a têm muito dele , de modo que o ef ito cumulativo de uma arquitetura 
inapropriada pode ser significativo. 
Cada um de se três exemplo de aplicações co1porativas tem suas dificuldade 

toda elas ão dif r nt . Como cons qü Anda, , difícil propor uma arquit tura única 
qu eja apr priada para a tr~ ituaÇ . E c 1h r uma arquitetura ignifica nt 
nder os problemas específico do seu istema e definir um projeto apropriado ba



28 INTRODUÇÃO 

seado nesse entendimento. Eis por que, neste li ro, não dou uma solução única para 

ua necessidades corporativa . m ez di o, muitos dos padrões s r fer ma escolhas 
e alternativa . Mesmo quando ocê scolher um padrão específico, terá que modificá-
lo para sati faz r sua d manda . Você não pode criar oftwnrecorporativo m 
p n ar, e tudo que qualquer livro pode fazer é lhe dar mais informaçõe sobre as 
quais basear suas decisões. 

S i e aplica a padr-, tarnb 'm e aplica a ferramenta . Embora obviamente 
faça sentido scolh rum conjunto tão p qu no quanto po ível de ferramenta para 
desenvolver aplicaçõ , você também tem quer conhecer que cada ferram nta dif 
r nt é m lhor para uma tar fa dif rent . Tom cuidado para não u ar uma f rramenta 
qu s ja apropriada para um tipo dif r nte de aplicação -pod atrapalhar 
mai do que ajudar. 

Pensando em Desempenho 

Muitas decisões relacionadas à arquitetura dizem respeito ao desempenho. Para a 

maioria da qu C r ]acionada ao d mp nho, pr firo obt r um i t m, no ar 

rodando, in trum ntá-lo ntão u ar um proc cti ciplinado d otimização ba a


do mm diçõe . Entr tanto, alguma d ci õ d arquit tura afetam o des mpenho 

de um modo tal que é difícil consertá-lo com otimizações posteriores. E mesmo 

quando é fácil consertá-lo mais tarde, as pessoas envolvida no projeto e preocupam 

desde cedo com tais decisões. 

s mpr difícil faJar obr d mp nho em um livro como e t . A dificuldade 
advém do fat de que qualqu r con lho obr d empenh nã d ve r tratado como 
rdade ab oluta at' que seja a aliado na sua própria configuração.~ nho visto 
muita veze projeto aproveitados ou rejeitado de ido a con ideraçõe d de empenho 
que se tornam falsa assim que alguém faz algumas medidas na configuração 
real u ada para a aplicação. 

D u algumas diretrize ne t livro, incluindo minimizar o número de chamada 
remota , o qual t m ido um bom c n lho r lativo a d empenho há ba tant 
t rnpo. Mesmo assim, você d ve verificar cada dica avaliando-o m sua própria 
aplicação. D modo m lhant , há di rsas ocasiõ s m qu o x mplo d código 
neste Uvro acrificam o desempenho para tornar mais fácil a compreen ão do 
que se quer demonsb·ar. Mais uma vez, é sua tar fa aplicar as otimizações no seu 
ambiente. o entanto, toda vez qu você fizer uma otimização de desempenho, de-

medir o ganho obtido, caso contrário pod ap na e tar t rnando u código 
mais difícil de ler. 

Há uma con eqüência important disso: uma alt ração ignificati a na configuração 
p d invalidar quai qu r fato r f r nt ao d mp nho. A im, · vocA atualizar 
sua máquina virtual, s u hardware, u banco d dados ou praticam nt qualquer 
outra coi a, ocê d refazer sua otimizaçõe de d mpenho e a gurar-s 
de que elas ainda estão ajudando. Em muitos casos, uma nova configuração pode alterar 
as coisas. Você pode descobrir que uma otimização que fez no passado para melhorar 
odes mpenho, traz pr juízos no novo ambiente. 

Um outr probl ma ao falar obr d mp nho o fato d qu muito t rm 

ão u ado de forma incon istent . A mais famo a vítima a "e calabilidade," u ada 
regularm nte c m meia dúzia d ignificado diferentes. Aqui e tão o t rmo que 
eu uso. 


INTRODUÇÃO 29 

tempo de resposta é a quantidade de tempo que o sistema leva para procesar 
uma solicitação externa. Pode ser uma ação na interface com o usuário, como o 
pr ionam nto d um botão, ou uma chamada d API d rvidor. 

A agilidade de resposta diz r peito a quão rapidam nte o i t ma reconh c 
umas licitação (em op ição ao tempo que le a para processá-la). I o é importante 
em muitos sistemas porque os usuários podem ficar frustrados se um si tema demorar 
are pondera uma solicitação, ainda que seu tempo de resposta seja bom. e o seu 
sistema esperar durante toda a solicitação, então sua agilidade de resposta e seu tempo 
d r spo ta são o mesmos. Entretanto, se vocA incLicar que re eb u a olicitação 
ant s d c mpl tá-la, então ua agilidad d r po ta ' m lhor. F rn c r wna barra 
de progr o durant uma cópia d arqui o mefüora a agilidad de r po ta da ua 
int rface com u uário, emb ra não m lh r t mpo de re po ta. 

A latência é o tempo mínimo requerido para obter qualquer forma de re posta, 
mesmo se o trabalho a ser feito for inexistente. Geralmente é a grande questão em sistemas 
remotos. e eu pedir a um programa para não fazer nada, ma para me avisar 
quando tiver terminado de fazer nada, então devo receber uma respo ta quase instantân 
as o programa rodar no m u laptop. Entretanto, s o programa rodar m um 
computador r moto, pod d morar alguns gundos d ido ao t mpo ga to para qu 
a solicitação are posta eh guem ao eus d stinos atra é da con xão. Como desenvolvedor 
d aplicaçõ , g ralm nt , nada p o faz r para melhorar a latAncia. A latência 
é também motivo pelo qual você dev minimizar chamada r mota . 

O throughp11t é a quantidade de coi as que você pode fazer em uma dada quantidade 
de tempo. você estiver contabilizando o tempo gasto na cópia d um arquivo, 
o throughput pod ria r medido m byte por s gundo. Para aplicaçõ corporativas, 
uma m d.ida típica 'o número d transaçõ s por s gundo (tps), mas o probl ma 
' que i o d p nd da compl xjdade da ua transação. Para u si t ma e p dfico, 
vocA d v e colher um conjunto usual de tran açõe . 

e ta terminologia, desempenho pode significar tanto thro11 htput quanto tempo 
de re po ta -o qu formai importante para vocA. À veze , pode er difícil falar 

obre de mpenho quando uma técruca m lhora o throu hput, ma piora o tempo d 
r sposta. Assim, é melhor usar o t rmo mais preciso. Da persp ctiva de um usuário, 
a agilidad d r posta pod r mai important do qu o t mpo d r po ta, ntão 
melhorar a agilidade de r sposta em detrim nto do t mpo d resposta ou do thro11ghput 
aumentará o desemp nho. 

A carga é uma medida da pr ão a que o isterna e tá ubm tido, que pod ria 
ser medida pelo número de usuários a ele conectados em um determinado instante 
de tempo. A carga ' geralmente um cont xto para alguma outra m dida, corno um 
t mpo der po ta. A im, ocê pod dizer qu o t mpo de re po ta para alguma olicitação 
é de 0,5 segundo com 10 usuários e d 2 s gundos com 20 u uários. 

A sensibilidade de carga ' um m <lida de como o t mpo der po ta varia 
com a carga. Digamos que o sistema A tenha um tempo de re po ta de 0,5 segundo 
para um número de usuários entre 10 e 20, e o sistema B tenha um tempo de resposta 
de 0,2 segundo para 10 usuários que aumenta para 2 segundos com 20 usuários. 

e te caso o si terna A tem urna sensibilidade de carga menor do que o si tema B. 
Pod ríamos também u ar o termo degradação para dizer que o sist ma B degrada 
mai do que o i tema . 

A eficiência é o de mp nho dividido pelo recur o . Um i tema que obtenha 
30 tps com duas CPUs é mais ficiente que um que obtenha 40 tps com quatro CPUs 
idêntica . 


30 INTRODUÇÃO 

A capacidade de um is tema é uma indicação do máximo throughpul efetivo ou 
máxima carga feti a. E te pod ria er um máximo ab oluto ou um ponto a partir do 
qual o d semp nho caia abaixo de um limit aceitáv l. 

A escalabilidade é uma m dida de como o acr' cimo d recurs (normalment 
hardware) afeta o d emp nho. Um i tema e calável é aquele que lhe permite adicionar 
hardware obter uma melhora d de mpenh pr porcional, como dobrar o 
número de servidores disponíveis para dobrar o throughput. O escalabilidade vertical, 
ou escalar para cima, significa adjcionar mais poder a um úruco ervidor (por 
ex mplo, acr centar m mória). O escalabilidade horizontal, ou escalar para fora, 

ignifica adicionar mai r idor . 

O problema aqui é que as d cisões de proj to não af tarn todos e es fatore de 
desempenho d forma igual. Digamo que t mos dois istema d oftware rodando 
em um servidor: a capacidade do Peixe-Espada é de 20 tps, enquanto que a do Camelo 
é de 40 tp . Qual do doí tem melhor de mp nho? Qual é mai e calável? ão podemo 
r pondera que tão da e calabilidade com e t dado , a única coi a qu podemos 
dizer é que o Cam lo ' mais efici nt em um único ser idor. Se adicionarmos 
outro ervidor, perceb mo que o Peixe-Espada agora trata 35 tp , o Camelo 50 tp . 
A capacidade do Camelo ainda é melhor, ma parece que o Peixe-pada pode ter melhor 
calabilidad . S continuarmo adicionando rvidor s, de cobrir mo qu o 
Peixe-spada obtém 15 tps por ser idor adicional e que o Camelo obtém 10. Comes-

es dados, podemos dizer que o Peixe-Espada tem uma melhor escalabilidade horizontal, 
ainda que o Carn lo seja mais fiei nt com m nos de cinco r idor s. 

A criar aplicaç-corporativa , muita v z faz ntido vi ar à alabilidade 
de hardware em vez da capacidade ou m smo ficiência. A e calabilidad lhe dá a 
opção de melhor de empenho, se você precisar dela. A scalabilidade pode também 
ser mais fácil de obter. Os projetistas muitas vezes fazem coisas complicadas que a um 
ntam a capacidade d uma plataforma e p cifica de hardware quando, m verdade, 
poderia ser mai barato comprar mai hardware . Se o ameio tem um cu to 
maior do qu o P ix -• pada, cu to maior ' qui al nt a um par d rvidores, 
então o Peixe-E pada acaba endo mais barato, me mo e ocA preci ar de apena 
40tp . stá na moda reclamar por ter qu dep nd r de hardware melhor para faz 
r no o oftware rodar apropriadam nte, me junto a t coro empr que tenho 
que atualizar meu laptop apenas para poder rodar a ersão mais nova do Word. o 
entanto, adquirir hardware mai novo , com fr qüência mais barato do que fazer o 
software rodar m sistemas menos poderosos. D forma semelhante, adicionar mais 

ervid r ' fr qüent mente mai barato do que adicionar mai programadore de 
d que um istema ja caláv l. 

Padrões 

padrõ estão em cena há bastante tempo, então parte de mim não quer ficar rep 
tindo ua hi tória mais uma v z. o ntanto, ta , uma oportunidad para dar a 
minha i ão d padr-o qu toma uma abordag m valio a para d cr v r pr jetos. 


ão exist uma d finição univ r almente ac ita de padrão, ma talvez o m lhor 
seja começar por Cristopher Alexander, uma inspiração para muitos entusiastas de 
padrõe : " ada padrão de creve um problema que ocorr repetidament no no o 
ambiente e ntão de cre e a sência da solução d s problema, d tal forma que 

ocê po a usar e sa olução um milhão d ez , m jamai fazê-lo exatam nt da 


INTRODUÇÃO 31 

mesma forma" [Alexander et ai.]. Alexander é um arquiteto, de modo que ele estava 
falando d edifício , ma a definição funciona mlúto bem para oftware também. O 
foco do padrão ' uma solução específica, uma que seja, ao mesmo tempo, usual e efeti 
a na ab rdag m d um u maj probl ma r corr nt . Uma outra man ira d er 
é que um padrão é um conjunto de con elho , a arte de criar padrõe con i te em 

eparar os conselhos em grupos relativamente independentes de modo que você 
po sa se referir a eles e di cuti-los mais ou menos independ ntemente. 

Um elemento-cha e dos padrões 'que eles estão enraizados na prática. Você 
d c bre padr-ndo que a p oa faz m, ob rvando a coi a qu funcionam 
ntão bu cando a" ência da olução." ã ' um proc o fácil, ma uma 
vez qu você tenha encontrado alguns bons padrões, el s s tornam algo valioso. Para 
mim, o eu valor re id no fato de m po ibilitar rn criar um livro qu r como 
um.a referência. Você não preci a ler este livro, ou qualquer outro livro sobre padrões, 
do início ao fim, para achá-lo útil. Você só precisa ler o suficiente para ter uma 
noção do que os padrões ão, quais problemas eles re olvem e como eles o r solv 
m. VocA não pr ci a conh c r todo o d talh , mas ap nas o sufici nt , d modo 
qu , cA d parar com um d pr bl ma , p a ncontrar o padrão no li ro. 
Somente então ocê pr cisa r alment entender o padrão em profundidade. 

Uma vez que você precise do padrão, tem que de cobrir como aplicá-lo ao seu 
contexto. Uma coi a important sobre padrõe é que você não pod simple m nt 
aplicar cegamente a solução, que é o moti o pelo qual as ferramentas de padrõe têm 

ido um fracas o total. osto de dizer qu padrõ s são "meio a sado ," significando 
que ocê tem empre que terminar de assá-los no forno do seu próprio projeto. Sempr 
qu u o um padrão, adapto-o aqw ali. VocA A a rn ma olução mwta v z , 
ma la nunca ' xatam nt a m ma. 

Cada padrão é relativamente independente, mas padrões não isolados uns dos 
outros. Freqüentemente, um padrão le a a outro ou um ocorre apenas se outro estiver 
pr ent ·. A im, você normalmente ó verá uma Herança de Tabela de Cla se (276) 

houver um Modelo de Domínio (126) no seu projeto. As front ira entre os padrõ s 

ão naturalmente pouco clara , ma t nt i tornar cada padrão tão autocontido quanto 
po í el. Se alguém di er "U e uma Unidade de Trabalho (187)," ocA pod dar 
uma olhada e ver corno aplicá-la em ter que ler o livro inteiro. 

S você for um projeti ta experi nt d aplicaÇ corporativa , pro a, elm nte 
descobrirá que a maioria destes padrões lhe é familiar. Espero que ocê não fique 
muito de apontado (tentei avisá-lo no Prefácio). pach·-s não são idéia originai ; 
ele ão, m grande medida, ob ervaçõe da coi a qu ocorrem na prática. Em con


qü Ancia, nós, autor s d padrõ , não diz mos qu "inv ntamos" um padrão, mas, 
que "d cobrimo "um. Nos o pap l 'p rc bera solução usual, procurar sua ssência 
e então e cre er o padrão resultante. Para um projetista experiente, o alor dopadrão 
não é lhe dar uma idéia nova; eu valor reside no fato de ele lhe ajudar a comunicar 
sua id 'ia. S vocA todo o eu col ga ab m o qu é uma Fachada Remota 
(368), você pode dizer mwto simplesmente afirmando "Esta classe é uma Fachada Rer-
nota ." I o tamb'm Ih permit diz r a alguém mai no o, "U um Objeto de Tran ferência 
de Dado (380) para i o" e le p dem ir a t li r fazer a con ulta. O r sultado 
é que os padrõ s criam um vocabulário sobr proj to, que ' o motivo pelo 
qual a atribuição de nomes é uma questão tão important . 

Embora a maioria destes padrões eja verdadeiramente para aplicações corporativas, 
aqu le no capítulo d padrõe bá ico (Capítulo 1 ) ã mai g rai e localizado 
. Eu o incluo porqu m refiro a le m discu õ obr o padrõ de aplicações 
corporati as. 


32 INTRODUÇÃO 

A Estrutura dos Padrões 

Cada autor t m que colher eu formato de d crição d padrõ . Algun ba iam 
seus formatos em um li ro clássico de padrões como [Alexander et ai.], [ ang of 
Four] u [P SA]. utro criam eu próprio formato . Tenho lutado há tempo para 
descobrir o melhor formato. Por um lado, não quero algo tão pequeno quanto o 
formato do GOF; por outro, preciso ter s çõ s que d A m suporte a um li ro de r ferAncia. 
A im, i o ' qu u i n t li ro. 

primeiro item é o nome do padrão. orne de padrõ ão cruc1ai , porque 
parte do propó ito do padrão ' criar um vocabulário que permita ao projetista s 
comunicar m mais eficazmente. As im, se eu lhe di ser que meu ser idor W b é 
construído em torno de um Controlador Frontal (32 ) e uma Vista de Transformação 

(343) ocA conh cer e e padr-, v cê t rá uma idéia clara da arquit tura dom u 
s rvidor Web. 
A guir vêm dois it n qu estão sempr junto : a int nção o boço. A int nção 
re ume padrão em uma fra ou dua . O e boço ' uma r pre entação i ual do 
padrão, muitas ezes, mas nem empre, um diagrama da UML. A idéia é criar um 
brev lembrete do que e trata o padrão de modo que você po a rapidam nte relembrá-
lo. Se ocê já "tem o padrão", significando que ocê conhece a solução ainda que 
não aiba o eu nom , ntão a intenção o boço d m r tudo qu v cê p ei


a para ab r o que é o padrão. 
A próxima s ção descreve um problema que motiva o padrão. Este pod não ser 

o único pr bl ma que o padrão re olv , ma acredito que seja o quem lhor justifica 
o padrão. 
Como Funciona de cr e a olução. Aqui coloco a di cu ão de qu tões de implementação 
ariações com a quai me deparei. Adi cussão é tão independ nt 
quanto possí 1d qualqu r plataforma esp cifica -ond houver seções esp cíficas 
para alguma plataforma, di tanciei-a da margen de m do que você po a pulá-la 
facilmente. nde julguei útil, coloquei diagrama da UML para ajudar a explicar o 
padrõ s. 

Quando Usá-lo descreve quando o padrão de e ser usado. Aqui falo os compromis 
os que o le ama selecionar uma solução em comparação com outras. Muitos 
do padr~e d t livro ão alternativa , como o Controlador de Página (318) Controlador 
Frontal (328). Poucos padrõ s ão mpr a olha certa, ntão toda ez qu 

ncontro um padrão eu s mpre m p rgunto "Quando u não o usaria?" Essa qu tão 
freqü ntemente me leva a padrõe alterna ti os. 

A seção Leitura Adicional mostra-lhe outra discussões sobre o padrão sendo 
apr sentado. Esta não ' uma bibliografia completa. Limitei minha ref rências a textos 
que acho importantes para ajudá-lo a entender o padrão, por isso eliminei qualqu 
r di cus ão que, gundo m u ntendjm nto, não acr c nta muito ao qu e cr 
vi. Al 'm dis o liminei, 'claro, di cu õ obr padr-qu não li. Tamb 'm não 
m ncion i itens qu acho qu serão difíc is de ncontrar, ou link W b instá is que, 
temo, po sam já ter desaparecido quando voe A e tiv r lendo e te li ro. 

Gosto de acrescentar um ou mais exemplos. Cada um é um exemplo simples do 
padrão em u o, ilu trado com algum código em Java ou C#. E colhi e a linguagen 
porque las parecem eras que o maior número de programadores profissionais sab 
l r. ' absolutamente s ncial compr nder que o ex mplo não é o padrão. Quando 
você u ar padrão, ele não parecerá ex tamente com x mplo, então não o 
trate como algum tipo de macro completa. Deliberadament manti e o ex mplo tão 

imples quanto po sí el, de modo que oc" po sa v r o padrão da forma mais clara 


INTRODUÇÃO 33 

que consegtú imaginar. Várias questões que foram ignoradas, se tornarão, no entanto, 
importante quando você for usar o padrão, ma ela são específica do seu próprio 
arnbi nt . Ei p r qu ocê mpr t m que adaptar o padrão. 

Uma da con eqüência di ' que ti e d trabalhar dw· para mant r cada 
exemplo tão simple quanto pude e, no entanto, ainda tran mitindo sua men agem 
essencial. Assim, muita vezes escolhi um exemplo que fosse simples e e plícito, em 
vez de um que demonstrasse como um padrão funciona com os muitos ajuste requeridos 
em um sistema de produção. É um equiJJbrio complicado entre o simples e 

o simplista, ma também é rdade que mtútas que tõ s por demai r ali tas por'm 
p rif'rica , pod m tornar rnai difícil nt nd r o pont -ha d um padrão. 
Foi tamb ' m por este motivo qu u i xernplo impl s indep nd ntes m 
vez de ex mplo x cutávei con ctado . Exemplo ind p ndente ão mai fácei 
de ent nder eparadamente, ma dão menos orientação sobr como juntá-1 . Um 
exemplo conectado mostra como as coisas se ajustam, mas é difícil entender um padrão 
sem entender todos os outros en olvides no e emplo. Embora na teoria seja 
pos ível produzir e mplos que sejam conectados e, ainda assim, compreensíveis independ 
ntem nt , faz r isso ' mtúto difícil -ou pelo m nos, muito difícil para mim 
-ntão colhi o caminho ind p nd nt . 

O código nos exemplo é escrito com foco em tomar as idéias compr ensíveis. 
Em con qü~ncia, muita coi a ficaram de fora -em particular o tratamento de rro 
, ao qual não pr to muita at nção uma vez qu ainda não d n olvi nenhum 
padrão nessa área. Eles estão lá meramente para ilustrar o padrão. Eles não se propõem 
a mostrar como modelar qualquer problema esp cífico de negócio. 

Por e motivos, o código não stá di ponÍ\ l para download no meu ite Web. 
Cada x mplo de código n st livro é c reado com tantos anda.iro s para simplificar 

a idéia bá ica , qu el não t''m valor algum m um ambient d produção. 
m toda as eç apar cem em todo o padrõe . Para o qu não con gui 
pen ar em um bom xernplo ou texto de motivação, deixei-os de fora. 

Limitações Destes Padrões 

Como m ncion i no Pr fácio, ta col ção d padrõ não ', d forma alguma, um 
gtúa compl to para o d senvolvirnento d aplicaçõ s corporativas. Meu teste para 
t livro não , I , completo, ma imple m nt 'útil. O campo , mtúto ex-

t n o para uma única rn nte, que dirá para um único li ro. 

Os padrõ aqui ão todo padrõ com os quai me deparei na prática, mas 
não ou dizer que entendo compl tamente todas as ua ramificações int r-relacionam 
nto . E te livro r .flete minha c mpr n ão atual, e a compr en ão de nvolv 
u à medida que eu escr via o livro. Espero qu la continu a s desen ol er 
muito apó te li ro t r sido impre o. Uma cert za obr o de envol im nto d 
software e uas técnica é que le nunca e taciona. 

Quando você considerar a utilização dos padrões, nunca se esqueça de que 

ã um ponto de partida, não um d tino final. ão exi te corno um autor d crever 
todas as ariaçõe qu o projeto de oftware podem ter. Escrevi este padrões 
para ajudar a fornecer um início, de modo que ocê po sa ler sobre as liçõe que eu 
e a pe a que b er ei aprend mo faz ndo lutando. Al 'm d a , ocê t rá 

ua próprias lutas. Lembr -s sempr de qu cada padrão stá incompleto e qu 
você tem a responsabilidade, e a diversão, de completá-lo no contexto do seu próprio 
si tema. 


PARTE 

1 

As NARRATIVAS 


CAPÍTULO 

Criando Camadas 

A
A
criação de camadas é uma das técnicas mais comuns que os projetistas de 
software usam para quebrar em pedaços um sistema complexo de software. 
Você encontra esta técnka em arquiteturas de máquinas, em que as camadas 
descendem de uma linguagem de programação com chamadas do sistema operacionaJ 
aos drivers de dispositivos e conjtmtos de instruções da CPU, e às portas lógicas 
dentro de chips. Redes de computadores têm FTP como umé\ camada sobre TCP, o 
qual, por sua vez, está sobre o IP, que está sobre a ethernet. 

Ao pensarem um sistema em termos de camadas, você imagina os subsistem<1s 
principais no software dispostos de forma parecida com camadas de um bolo, em que 
cada camada repousa sobre uma camada mais baixa. Nesse esquema, a camada mais 
alta usa vários serviços definidos pela camada mais baixa, mas a camada mais baixa 
ignora a existência da camada mais alta. Além disso, cada camada normalmente esconde 
suas camadas mais baixas das camadas acima, então a camada 4 usa os serviços 
da camada 3, a qual usa os serviços da camada 2, mas a camada 4 ignora a existência 
da camada 2. (Nem todas as arquiteturas de camadas são opacas como essa, 
mas a maioria é.) 

Dividir um sistema em camadas tem uma série de benefícios importantes: 

• Você pode compreender uma única camada como um todo coerente sem saber 
muito sobre as outras camadas. Você pode compreender como construir 
um serviço FTP sobre TCP sem conhecer os detalhes de como funciona o protocolo 
ethernet. 
• Você pode substituir camadas por implementações alternativas dos mesmos 
serviços b~sicos. Um serviço FTP pode rodar sem modificações sobre ethernet, 
PPP ou seja lá o que o for usado pelo provedor. 
• Você minimiza as dependências entre as camadas. Se o provedor alterar o sistema 
físico de tnmsmjssão, niio precisamos alterar nosso serviço FTP. 

38 PARTE 1 • As NARRATIVAS 

• Camadas são bons lugares para padronização. TCP e lP são padrões porque 
eles definem como suas camadas devem operar. 
• Uma vez que você tenha construído uma camada, eJa pode ser usada por 
muitos serviços de nível mais alto. Desta forma, TCP /IPé usado por FfP, telnet, 
SSH e HTTP. De outra maneira, todos esses protocolos de nível mais alto 
teriam que escrever seus próprio protocolos de nível mais baixo. 
O uso de camadas é uma técnica importante, mas há aspectos negativos: 

• As camadas encapsuJa_m bem algumas coisas, mas não todas. Isso, às vezes, 
resulta emalterações em cascata. O exemplo clássico disto em uma aplicação 
corporativa cm camadas é o acréscimo de umcampo que precise ser mostra~ 
do na interface com o usuário e deva estar no banco de dados e assim deva 
também ser acrescentadoa cada camada entre elas. 
• Camadas extras podem prejudicar o desempenho. Em cada camada os dados 
precisam, tipicamente, ser transformados de uma representação parn 
outrn. O encapsulamento de uma função subjacente, no entanto, muitas vezes 
lhe dá ganhos de eficiência que mais do que compensam esse problema. 
Uma camada que controla transações pode ser otimizada e então tomará 
tudo mais rápido. 
Contudo, a parte mais difícil de uma arquitetura em camadas é decidir quais camadas 
são necessárias e quais as responsabilidades que cada uma deve receber. 

A Evolução das Camadas nas Aplicações Corporativas 

Embora eu seja jovem demais para ter feito algum trabalho nos velhos tempos dos 
sistemas em bntc/1, não sinto que as pessoas pensassem muito em camadas naquele 
tempo. Você escrevia um programa que manipulavA algum tipo de arquJvo (lSAM, 
VSAM, etc.) e essa era sua aplicação. Não era necessário aplicar nenhuma camada. 

A noção de camadas se tornou mais visível nos anos 1990, com o advento dos 
sistemas cliente-servidores. Estes eram sistemas em duas camadas: o cliente mantinha 
a interface com o usuário e um ou outro código da aplicação, e o servidor era 
normalmente um banco de dados rclacionaJ. Ferramentas comuns para o lado cliente 
eram, por exemplo, VB, Powcrbuilder e Dclplú. Essas ferramentas tornaram particularmente 
fácil criar aplicações que faziam uso intensivo de dados, uma vez que 
elRs disponfüilizavam componentes visuais que trabalhavam com SQL. Assim, você 
podia criar uma tele\ arrastando controles para uma área de desenho e então usando 
páginas de propriedades para conectar os controles ao b('lnco de dados. 

Se a aplicação tivesse somente de exfüir e fazer atualizações simples em dados 
relacionais, então esses sistemas cliente-servidor funcionavam muito bem. O problema 
surgiu com a lógica de domínio: regras de negócio, validações, cálculos, e assim 
por diante. Normalmente, as pessoas escreviam essa lógica no cliente, mas isso era 
desajeitado e, normalmente, feito embutindo-se a lógica diretamente nas telas da interface 
com o usuário. À medida que a lógica do domínio se tornava mais complexa, 
ficava muito difícil trabalhar com este código. Além disso, embutir lógica nas telas 


WÍTULO 1 • CRIANDO CAMADAS 39 

facilitava a duplicação de código, o que significa a que alterações simples resultavam 
em bu ca d código emelhante em muita tela . 

Uma alt rnati a era colocar a lógica d donúnio no banco d dados na forma d 
procedimento armazenado (stored procedure ). E t , n entanto, forn ciam mecani 
mo limitado de truturação, o qu mai uma v z le ava a código d aj itado. 
Além dis o, muitas pessoas go tavam de bancos de dados relacionais porque SQL 
era um padrão, o que lhe perrrtitia a qualquer t rnpo mudar o fornecedor do banco 
de dados. Ainda que poucas pessoas realmente fizessem isso, muitas gostavam de 
t r a opção d mudar de forn c dor s m que i o implicas m cu tos de migração 
alto demai . Por s r m todos propri tário , o proc dim ntos arm z nado liminavam 
a opção. 

Ao mesmo tempo em que a arqtútetura cliente-ser idor estava ganhando popularidad 
, o mundo orientado a obj tos stava a c nd ndo. comunidad d obj tos 
tinha a resposta para o problema da lógica de domínio: migrar para um sistema em 
três camadas. e ta abordagem, ocê tinha uma camada de apre entação para a ua 
interfac com o u uário, uma camada d domínio para a ua lógica d domínio 
uma camada de dados. D sta maneira, voe" pod ria tirar toda a compl xa lógica de 
domínio da interface com o usuário e colocá-la em uma camada na qual você poderia 
e truturá-la apropriadam nt utilizando obj to . 

Apesar disso, a popularidade dos objetos fez pouco progresso. A erdade era 
que muito isterna rarn impl , ou pelo rneno com çavam simpl . mbora a 
abordagem m três camadas tiv sse muitos ben fícios, o ferramental para o de envolvim 
nto client -s r idor ra con incent o eu probl ma f simpl . AI' m 
dis , a f rram nta pai-a o d envolvim nto cli nt -rvidor eram difícei , ou me mo 
impo ív i , d u ar em urna configuração com tr" camada . 

Acho que o abalo sísmico aqtú foi o advento da Web. De repente as pessoas passaram 
a querer instalar aplicações cliente-s rvidor usando um na egador Web. o 
entanto, se toda a sua lógica d n gócio estivesse enterrada m um cliente rico, ntão 
t da la pr ci a1·ia r r f ita p, ra t r uma int rfac W b. Um i t ma b m-pr j tado, 
em tr"s camada , pod ria impl ment acr centar uma no a camada d apr sentação 
e estaria pronto. Al 'm di o, com a linguagem Java, imos uma linguag m 
orientada a objetos ocupar a cena sem pudores. As ferramentas que surgiram para 
criar página Web eram muito meno amarrada à linguagem SQL e, as im, mais 
adaptá eis a uma terceira camada. 

Quando , p oa di cut ma criação d camada , fr qü nt m nt há c nfusão 
entre os termos layer tier. Muitas ez s os dois são usados corno sinôrúmos, mas 
a maioria da p oas con id ra qu o t rmo tíer implica uma paração fi ica. O si tema 
cliente-servidor são freqüentemente de critos como sistemas em duas camada 
(two-tier y tem ), e a paração é fi ica: o cli nt é um de ktop e o ervidor é um 
ser idor. Uso Jayer para enfatizar o fato de que você não tem que rodar as camadas 
em máquina dif rente . Uma camada distinta de lógica de domínio muita vezes 
pode rodar tanto em um desktop como no ser idor d banco de dados. ssa situação 
voe" t m doi nodo , ma tr~ camada di tinta . Com um bane d dado 1 cal, po 


o executar toda a trê camada em um único laptop, ma ainda a im ha erá trê 
camada di tinta . 

40 PARTE 1 • As NARRATIVAS 

As Três Camadas Principais 

e te li roe tou centralizando minha discussão em torno da arquit tura contendo 
três camadas principais: apres ntação, domínio e fonte de dados. ( stou seguindo os 
nom u ad m [Brown et ai.]). A Tab la 1.1 r um ta amada . 

A lógica d apresentação diz resp ito a como tratar a int ração entr ou uário 

o oftware. Is o pod ser tão imples quanto uma linha d comando ou um menu 
baseado em texto, porém, hoje é mais prová el que seja uma interface gráfica em um 
cliente rico ou um navegador com interface baseada em HTML. ( e t Livro, u o 
cliente rico significando um.a interfac com o usuário ao estilo Windows ou Swing, 
em v z d um na gador HTML.) A r pon abilidade primária da camada d 
apr ntação são xibir informaçõ para o u uário traduzir comando do u uário 
em ações sobre o domínio e a camada de dados. 

A lógica da camada de dados diz respeito à comunicação com outro i tema 
que executam tarefas no interes e da aplicação. stes podem ser monitore de tran


açõe , utra aplicaçõ , i t ma de m n agens a im por diant . Para a maioria 
das aplicações corporati as, a maior parte da lógica de dados , um banco de dados 
responsá el, antes d mais nada, p lo armazenamento de dado persistente . 

r to ' a lógica de domínio, também chamada d lógica de n gócio. 

o trabalho qu ta aplicação tem de faz r para o domínio c mo qual v cê e tá trabalhando. 
En olve cálculos baseados nas entradas e em dados armazenados, validação 
de quaisquer dados provenientes da camada de apre entação e a compr ensão 
exata de qual lógica de dados executar, dependendo dos comandos recebidos 
da apr ntação. 
Às vez as camadas são organizada d modo que a camada d domínio 
conda completamente a camada d dado da camada de apre entação. Com maior 
freqüência, contudo, a apresentação acessa diretamente o armazenamento de dados. 
Embora is o ja menos puro, tende a funcionar m lhor na prática. A apr entação 
pode interpretar um comando do usuário, u ar a camada de dados para trazer os dados 
rel ante do banco d dado então d ixar a lógica de domínio manipularess 
s dados antes d apres ntá-los na tela. 

Uma única aplicação fr qü nt m nt p d t r múltiplo pacot d cada uma 
de as trê áreas. Uma aplicação, projetada para er manipulada não apenas por 
u uário finai por meio d uma int rface de cliente rico, ma tarnb 'm por rn io d 
uma linha de comando teria duas apresentações: uma para a interface de cliente rico 
e uma para a linha de comando. Múltiplos compon ntes de dados podem estar present 
s para bancos d dados dif r nt s, mas, upostamente, tariam pre nt s par-

Tabela 1.1 Três Camadas Principais 

Camada Responsabilidades 

Apresentação Fornecimento de serviços, exibição de informações (p. ex., em Windows ou 
HTML, tratamento de solicitações do usuário (cliques com o mouse, 
pressionamento de teclas), requisições HTTP, chamadas em linhas de 
comando, API em lotes) 

Domínio Lógica que é o real propósito do sistema 

Fonte de Dados Comunicação com os bancos de dados, sistemas de mensagens, 
gerenciadores de transações, outros pacotes 


WÍTULO 1 • CRIANDO CAMADAS 41 

ticularmente para a comunicação com os pacotes existentes. Mesmo o domínio pode 
r quebrado em áreas distinta relativamente s paradas umas das outras. Certo pac 
t de dado ó pod m s r u ado por d t rminados pacot do dom.íni . 

Até ag ra falei br um único u uári . I o naturalmente 1 vanta a qu tã d 
que acontec quando não há um er humano guiando o oftwnre. Pode r algo novo 
e moderno como um erviço Web ou algo banal e útil como um processo em lote. 

este último caso, o usuário é o programa cliente. este ponto toma-se e idente que 
há muita semelhança entre as camadas de apresentação e de dados visto que ambas 

ão relacionadas à conexão com o mundo externo. E ta , a lógica por trá do padrão 
Arquitetura Hexagonal [wiki] d Ali tair Cockburn, qu enxerga qualqu r si t ma como 
um núcl o e reado d int rfac s para ist mas xtemos. a Arquitet11ra Hcxngonn/, 
tudo que é externo a i tema é tratado encialment como uma interfac ext 
ma. Consiste, portanto, em uma visão imétrica ao in é do meu esquema assimétrico 
de camadas. 

No entanto, considero essa assimetria útil, porque há uma boa distinção a ser 
feita entre uma interface que ocê fornece como um serviço para outros e o ser iço 
qu ocA utiliza de outra p s oa qualqu r. o fundo, sta , a distinção real qu faço 

ntr a apr ntação a camada d dados. A apr ntação ' uma int rfac t rna 
para ums rviço que o u si tema ofer c a outra pes oa, eja um humano complexo 
ou um programa r moto imple . A camada d dado ' a int rface para coi a qu 
e tão prov ndo um erviço para voe A. É b néfico pen ar nela de forma difer nt , 
porque a diferença nos clientes altera a maneira de pensar sobre o ser iço. 

Embora pos amos identificar as três camadas usuais, apresentação, domínio e 
fonte d dado , m cada aplicação corporati a, a man ira como você a epara d p 
nd do quão compl xa é a aplicação. Um roteiro simples para xtrair dados de um 
banco d dado xibi-lo em uma página W b pode, todo ele, con istir d um único 
proc dimento. Eu ainda m e forçaria paras parar as trê camada , ma , n t ca


o, poderia fazê-lo implesmente colocando o comportamento d cada camada em 

ub-rotina eparada . Se ist ma toma mai compl xo, quebraria a trê camada 
melas es eparadas. Se a complexidade aumenta ainda mais, di idiria a 
classes em pacot s s parados. M u cons lho geral ' scolh r a forma mais apropriada 
d paração para o u probl ma mas tar guro d qu vocA tenha algum tipo 
d s paração -ao menos ao ní 1 d sub-rotinas. 

Junto com a eparação, há também uma regra estabelecida sobre d pendência 
: o domínio e a camada de dado nunca d vem r dep ndent da apre ntação, 
isto é, não deve haver chamadas de sub-rotinas da apresentação a partir do códjgo 
do dom.ínio ou da camada de dado . s a regra torna mai fácil utilizar apre


ntaçõ diferente obr a m ma ba e torna mai fácil modificar a apr ntação 
em ramificações s 'rias mais abaixo. O relacionamento entre o domínio e a camada 
d dado ' mais compl xo depende do padrõ s arquiteturai u ado para 
a fonte de dados. 

Urna das partes mais difíceis de trabalhar com Jógica de domínio parece ser que 
as pes oas freqüentemente acham difícil reconhecer o que é lógica de domínio e o 
que ão outras formas de lógica. Um test informal que go to de aplicar é imaginar a 
adição de uma camada radicalmente difer nt a uma aplicação, como uma interface 
em linha de comand a uma aplicação Web. S , para fazer i o, v cê tiver qu duplicar 
alguma funcionalidad , ' um inal d que a lógica de domínio vazou para a apre


entação. De maneira emelhante, ocê tem que duplicar lógica para sub tituir um 
banco de dado relacional por um arquivo XML? 


42 PARTE 1 • As NARRATIVAS 

Falaram-me certa vez sobre um sistema que era um bom exemplo disso: ele 
contin11a uma lista de produtos em que todos que tivessem um acréscimo de vendas 
de 10% ou mais, em relctç:cio ao mês anterior, eram coloridos de vermelho. Para fazer 
isso, os desenvolvedores colocMam lógica na camada de apresentação que comparava 
as vendas do mês atual com as do mês anterior e, se a diferença fosse maior do 
que 10%, eles a coloriam de vermelho. 

O problema é que essa solução coloca lógica de domínio na apresentação. Para 
separnr corretamente as camadas, você precisct de um método na camada de domínio 
para indicar se um produto aumentou suas vendas. Este método faz a comparação 
entre os dois meses e retorna um valor booleano. A camada de apresentação então, 
simplesmente chama este método booleano e, se o valor retornado é verdadeiro, 
destaca o produto em vermelho. Desta forma o processo é di idido em suas duas 
partes: decidir se há algo a ser destacado e decidir como destacá-lo. 

Preocupo-me a estar sendo demasiadamente categórico a esse respeito. Ao rever 
este livro, Alan Knight comentou que ele estava "em dúvida se colocar lógica do 
negócio mt interface com o usuário é o primeiro passo em direção a uma rampa escorregadia 
para o inferno ou uma coisa perfeitamente razoável a fazer a que apenas 
um purista categórico farict objeção". A razão pela qual nos sentimos desconfortáveis 
é porque ambos são verdadeiros! 

Escolhendo Onde Rodar suas Camadas 

Na maior parte deste livro estarei ralando sobre camadas lógicas -isto é, a divisão de 
um sistema em pedaços separados para reduzir o acoplamento entre as diferentes 
partes do sistema. A separação entre camadas é útil mesmo se todas as camadas estiverem 
rodando na mesma máquina física. Entretanto, há lugares onde a estrutura física 
de um sistema faz diferença. 

Na maioria das aplicações de sistemas de irúormaçâo, a decisão diz respeito a rodru· 

o processamento em um cliente, em uma máquina desktop, ou em um servidor. 
Muitas vezes, a solução mais simples é rodar tudo e111 servidores. Umfro11I cmd• 
HTML usando um navegador Web é uma boa maneira de fazer isso. A grande vantagem 
de rodar no servidor é que, por estar em uma quantidade limitada de lugares, tudo 
é fácil de atualizar e reparar. Você não tem que se preocupar com a distribuição para 
muitos dcsktops e em m<'tntê-los todos em sincronia com o servidor. Você também não 
tem que se preocupar com compatibilidades com outros softwares de desktop. 

O argumento gemi a favor da execução em um cliente gira em torno da capacidade 
de respost« ou operação desconectada. Qualquer lógica que rode no servidor 
precisa de uma viagem de ida e volt<1 ao servidor para responder a qualquer coisa 
que o usuário faça . Se esse usuário quiser brincar com alguma coisa e receber retorno 
imediato, essa ida e volta atrapalha. Ela também precisa de uma conexão de rede 
para rodar. A rede pode estar por toda parte, mas, enquanto digito isso, ela não está 
a 10.000 metros. Em breve, poderá estar em todo lugar, mas há pessoas que querem 
trabt1lhar agora, sem ter de esperar que a cobertura sem fios chegue a lugares muito 
clistantes. As operações desconectadas trazem desafios específicos, e lamento tê-los 
colocado fora do escopo deste livro. 

• . de R. T.: Pilrtc do program.l rei.ponAAvel pela interface com o usuário. 

WÍTULO 1 • CRIANDO CAMADAS 43 

om essas forças gerais posicionadas, podemos considerar as opções, camada 
por camada. A camada de dado qua e empre roda em s rvidore . A exceção são as 

ituaçõ m qu vocA poderia duplicar a funcionaLidad do rvidor m um cli nt 
c n enientem nt pod r o, geralm nt quando ocA qu ruma peração de e n ctada. 
e teca o, a alteraç-e na fonte de dado do cliente d conectado pr ci am 
ser incronizadas com o ser idor. omo mencionei anteriormente, decidi dei ar es-

as questões para outro dia -ou outro autor. 

A decisão sobre onde rodar a apresentação depende, em sua maior parte, do tipo 
de interfac de usuário que vocA quer. Um cliente rico implica, qua certamente, 
m rodar a apr entação n cli nt . Uma int rfac W b implica, qua c rtam nt , 
em rodá-la no s r idor. Exist m xceçõ s -por x mplo, a op ração r mota d um 
oftware cliente (tai como r id re X n mundo Unix) r dando um ervidor Web 

no de ktop -ma sta exceçõ s são rara . 

Se ocê estiver criando um sistema B2C, você não tem escolha. Qualquer usuário, 
Tom, Dick ou Harriet, pode estar e conectando aos eus servidores, e ocê não 
quer mandar ninguém embora porque eles insistem em fazer suas compras online 
com um TRS-80. este caso, vocA faz todo o proc ssam nto nos rvidor d olv 
HTML para o brow er manipular. A limitação da opção HTML ' qu cada p daço d 
uma tomada de d cisão pr ci a de uma viagem d ida olta do client para o servidor, 
i o pod diminuir a capacidad der po ta. VocA poder <luzir parte do atra-

c m cript n navegador applet , ma ele reduzem a compatibilidade do eu navegador 
e tendem a acrescentar outras dores de cabeça. Quanto mais puro for seu 
HTML, mas fácil será sua vida. 

E ta ida fácil ' atra nt mesmo se cada uma das sua ár a d trabalho for 
construída à mão, com todo o carinho, p lo seu d partam nto d sistemas d informação. 
Mant r li nt atualizado evitar erro de compatibilidad com outro oftware 
ão problema qu m mo o mai impl istema ba eado em cliente ricos 

tAm, 
A razão principal pela qual a pe oa de ejarn uma apre entação ba eada em 
clientes rico é que algumas tarefa são complicada para o usuário realizar m , 
ness s casos, para ter uma aplicação amigá el, 1 s precisarão d mais do qu uma 
int rfac W b pode dar. Cada z mai , ntr tanto, a p oa tão aco tumando 
às t ' cnicas para construir front ends Web mais amigá eis, isso reduz a n c ssidad 
de uma apresentação em um cliente rico. Hoje, enquanto e crevo e t livro, sou muito 
fa orável à apr entação Web, e voce puder; ao cliente rico, e você preci ar. 
Isso nos deixa com a lógica do domínio. VocA pode rodar toda a lógica de n gócio 
no ervidor, toda ela no cliente, ou ocê pode dividi-la. Uma v z mai , toda a lógica 
no er idor é a melhor e colha para facilitar a manut nção. A motivação m movê-
la para o cliente visa a m lhorar a capacidade de resposta ou pos ibilitar o uso 
de con ctado. 
Se você tiver que rodar alguma lógica no cliente, de e con iderar a possibilidade 
de executá-la toda lá -pelo menos assim ela fica toda em um único lugar. 
ormalmente esse cenário ocorre de mão dadas com um cliente rico -rodar um 
rvidor Web em uma máquina cliente não irá ajudar muito a capacidade d resposta, 
mbora po a rum modo d tratar op rações desconectadas. este caso, 
você ainda p d manter ua lógica d domíni em módulo eparado da apr ntação, 
com um Roteiro de Tran açiio (110) ou um Modelo do Domínio (116). O probl ma 
em colocar toda a lógica do domínio no cliente , que ocê tem mais coisas para 
atualizar e manter. 


44 PARTE 1 • A5 NARRATIVAS 

Dividir a lógica de domínio entre o desktop e o servidor parece ser o pior de dois 
mundos, porque você não sabe onde cada parte da lógica vai estar. O motivo principal 
para fazer isso é se apenas uma pequena parte da lógica precisar rodar no cliente. 
O truque então é isolar esta parte da lógica em um módulo que não seja dependente 
de nenhuma outra parte do sistema. Dessa forma, você pode rodar esse módulo 
no cliente ouno servidor. Isso irá requerer uma boa quantidade de código malicioso, 
mas é um bom modo de realizar esse trabalho. 

Uma vez que você tenha escolhido seus nós de processamento, você deve tentar 
manter todo o código em um único processo, seja em um único nó ou copiado em 
diversos nós em um cluster. Não tente separar as camadas em processos discretos a 
menos que seja absolutamente necessário. Fazer isso irá degradar o desempenho e 
acrescentar complexidade ao sistema, uma vez que você terá que acrescentar coisas 
como Fnchndns Remotas (368) e Objetos de Transferência de Dndos (380). 

É importante lembrar que muitas dessas coisas são o que Jens Coldewey se refere 
como impulsionadores de complexidade -distribuição, nwltitlireading explícito, 
mudanças de paradigma (como objeto/relacional), desenvolvimento multiplataforma 
e requisitos extremos de desempenho (como mais de 100 transações por segundo). 
Tudo isso carrega um alto custo. Certamente há ocasiões em que você tem 
que fazê-lo, mas nunca se esqueça de que cada um deles carrega um custo tanto no 
desenvolvimento quanto na manutenção. 


CAPÍTULO 

Organizando a Lógica do Domínio 

D
D
e modo a organizaI a lógica do domínio, eu a separei em três padiões principais: 
Roteiro de Transação (120), Modelo do Domínio (126) e Módulo Tnbeln 

(134). 

A abordagem mais simples para armazenar lógica de dorrúnio é o Roteiro de 
Trnnsnçào (120). Um Roteiro de Transação (120) é, essencialmente, um procedimento 
que recebe os dados de entrada da camada de apresentação, efehta o processamento 
com validações e cálculos, armazena dados no banco de dados e invoca quaisquer 
operações necessárh:ls em outros sistemas. Ele então responde com mais dados para 
a apresentação, talvez executando mais cálculos para ajudar a organizar e formatar a 
resposta. A organização fundamental é a de um único procedimento para cada ação 
(1ue o usuário possa querer executar. Assim, podemos pensar neste padrão como sendo 
um roteiro para uma ação ou transação de negócio. Ele não tem de ser constHuído, 
necessariamente, de um único procedimento. As partes podem ser separadas cm 
sub-rotinas, e estas podem ser compartilhadas por diferentes Roteiros de Transação 
(120). Entretanto, a motivação ainda é a de um procedimento para cada ação, de modo 
que um sistema de varejo pode ter Roteiros de Trn11snçiio (120) para a checagem de 
saída, par<l acrescentar algo élO carrinho de compras, para mostrar a situação atual da 
entrega e assim por diélnte. 

Um Roteiro de Transação (120) oferece diversas vantagens; 

• É um modelo procedural simples que a mru.otia dos desenvolvedores compreende. 
• Funciona bem com uma camada de dados simples usando o Gnleway de Li11h11 
de Dndos (158) ou o Gntewny de Tabelas de Dados (151). 
• O modo de estabelecer as fronteiras da transação é uma tarefa óbvia: comece 
abrindo uma transação e termine fe.chando-a. É fácil para as ferrnmentas fazer 
isso por trás dos panos. 

46 PART1: 1 • As NARRATIVAS 

Infelizmente, existem também muitas desvantagens, que tendem a aparecer à 
medida que a complexidade da lógica do domínio aumenta. Freqüentemente, haverá 
código duplicado, uma vez que diversas transações precisam faze1· coisas parecidas. 
Este problema pode, em parte, ser trntado fatorando-se o código comum em 
sub-rotinas, mas, mesmo assim✓ muito da duplicação é complicada de ser removida 
e mais difícil ainda de ser locaJizada. A aplicação resultante pode acabar sendo uma 
teia confusa de sub-rotinas sem uma estrutura clara. 

Éclaro que a lógica complexa é o cenário ideal pai·a os objetos, e a maneira pela 
qual a orientaç~o a objetos lida com este problema épor meio de um Modelo de Domi11io 
(126). Com um Modelo de Domfnio (126), construímos um modelo de nosso domínio 
o qual, pelo menos em uma primeira aproximação, é organizado primariamente 
em torno dos nomes do domínfo. Assim, um sistema de lensí11g teria classes 
para o anendamento, propriedades, e assim por diante. A lógica para lidar com validações 
e cálculos seria colocada neste modelo de dominio, de modo que um objeto 
remessa poderia conter a lógica para calcular o preço da remessa para uma entrega. 
Poderia ainda haver rotinas para calcular uma fatura, mas tal procedimento logo delegaria 
para um método do Modelo de Domínio (126). 

Usar um Modelo de Domínio (126), cm oposição a um Roteiro de Transação (120), é 
a essência da mudança de paradigma que as pessoas de orientação a objetos faJam 
tanto. Em vez de urna rotina contendo toda a lógica para uma ação do usuário, cada 
objeto realiza uma parte da lógica que seja relevante para ele. Se você não estiver 
acostumado com um Modelode Domínio (126), aprender a trabalhar com um pode ser 
muito frustrante quando você começa a correr de objeto em objeto téntando descobrir 
em qual está o comportamento. 

É ctifícil capturar a essência da diferença entre osdois padrões com um exemplo 
simples, mas nas discussões sobre os padrões tentei fazer isso criando um pedaço 
simples de lógica de donúnio de ambas as maneiras. A maneira mais fácil de ver a diferença 
é olhar os diagramas de seqüência das duas abordagens (Figuras 2.1 e 2.2). O 
problema essencial é que diferentes tipos de produtos têm algoritmos diferentes para 
o lançamento de receitas em um dado contrato (veja o Capítulo 9, parn uma melhor 
fondamcntação). O método de cálculo tem que determinar a que tipo de produ


um Serviço de um Gateway 
Lançamento de Dad~ 

calcularlançamentos (IDdoContrato) . 
-----~e-,· encontrarContrato(IDdoContrato) 

um conjunto de 
contratos 

ler dados 

1 

• inserir lançamento de receita 
Figura 2.1 Um Roteiro de Transação (120) para o lançamento de receitas. 


CAPi'l'lJLO 2 • ORGANIZANDO A LOGICA DO D0MfNIO 4 7 

uma Estratégia de 

um Contrato um Produto 

Lançamento 

1 

calcularlançamentos 1 
---------.calcularlanç,amento (um Contrato) 1 
1 
calcularlanç,amentos (um Contrato) 

um Lançamento 
de Receita

1> novo 
Figura 2.2 Um Modelo de Domínio {126) para o lançamento de receitas. 

to um dado contrato se refere, aplicar o algoritmo correto e então criar os objetos lançamento 
de receita para capturar os resultadosdo cálculo. (Para simplificar estou ignorando 
as questões relativas à interaç-ão com o banco de dados). 

Na Figura 2.1, o método no Roteiro de Trnnsnção (120) faz todo o trabalho. Os objetos 
subjacentes são apenas Gnteways de Tabela de Dndos (151) e tudo o que eles fazem 
é passar d<1dos para o roteiro de transação. 

Aocontrário, a Figura 2.2 mostra múltiplos objetos, cada um passando parte do 
comportamento para outro até que umobjeto de estratégia crie os resultados. 

O valor de um Modelo de Domfnio (126) é que, depois que você se acostuma, há 
mlútas técnicas que lhe permitem lidar com lógica cada vez mais complexa de uma 
forma bem-organizada. À medida que mais e mais algoritmos para calculnr o lal"lçamento 
de receitas vão sendo adicionados, podemos acrescentá-los adicionando novos 
objetos contendo a estratégia de lançamento. Com o Roteiro de Tt·nnsnçiio (120), teremos 
de adicionar mais condições à lógica condicional do roteiro. Assim que sua 
mente estiver tão voltada para objetos como a minha, você descobrirá que prefere 
um Modelode Dor11[11io (126) mesmo em casos bastante simples. 

Os custos de um Modelo de Domínio (126) decorrem da complexidade de usá-lo 
e da complexidade da sua camada de déldos. Leva tempo para que pessoas nov<1tas 
cm modelos ricos de objetos se acostumema um Modelo de D0111í11io (126) rico. Os desenvolvedores 
freqüentemente precisam gastar djvei-sos meses trabalhando em um 
projeto que usa este padrão antes que seus paradigmas mudem. No entanto,quando 
você se acostuma no Modelo de Domf11io (126), geralmente está contagiado para oresto 
da vida e torna-se fácil trabalhar com ele no futuro ..... é assim que fanáticos por objetos, 
comoeu, são criados. No entanto, uma minoria significativa de desenvolvedores 
parece não ser capaz de dar o salto. 

Mesmo depois de ter dado o salto, você ainda tem que lidar com o mapeamento 
do banco de dados. Quanto mais rico for o seu Modelo de D0111f11io (126), mais complexo 
será o mapeamento para um banco de dados relacional (geralmente com um 
Mnpendor de Dados (170)). Uma sofisticada camada de dados se aproxima bastante de 
um custo fixo -obter u1na boa camada de dados custa uma quantidade razoável de 
dinheiro (se você comprar) ou tempo (se você fizer), mas assim que você tiver uma, 
pode fazer muito com ela. 


48 PARTE 1 • As NARRATIVAS 

Há uma terceira escolha para estruturar a lógica do domínio, o Módulo Tabela 
(134). À primeira vista, o Módulo Tabela (134) se parece com o Modelo de Domínio (126), 
já que ambo t''m ela para contrato , pr duto lançamento d r c ita . A dif rença 
vital é qu um Modelo de Domínio (126) t m uma instância d contrato para cada 
contrato no banco d dado , nquanto um Módulo Tabela (134) tem apena uma 
instância. Um Módulo Tabela , projetado para trabalhar com um Conjunto de Registros 
(473). Assim, o cliente de um Módulo Tabela (134) referente a contratos, irá primeiro 
fazer consultas ao banco de dados para formru· um Conjunto de Registros (473), então 
criará um objeto contrato e pa ará a le o Conjunto de Regi tro (473) como parãm tro. 
cliente pod então in cara operações no contrato para fazer diversas coisa 
(Figura 2.3). S el qui r faz r algo com um contrato individual, d v passru· o 1D 
de e contrato. 

Um Módulo Tabela (l 4) , de muitas man iras um andar int rm diário entr um 
Roteiro de Transaçiio (120) e um Modelo de Domínio (126). 1'ganizar a lógica do donúnio 
ao r dor de tabelas em ez de procedimento seqüenciais fornece mai estruttrra 
e torna mai fácil ncontrar r mover duplicação. o entanto, ocA não pode u ar 
várias das técnicas que um Modelo de Domínio (126) usa para estruturar a lógica em 
granularidade mai fina, tais como herança, e tra t 'gia outro padrõe 

A maior vantag m d um Módulo Tabela (134) é como le adapta ao r sto da 
arquit tt1ra. Muitos ambi ntes u ando uma int rfac gráfica com o u uário ( UI) ão 
criado para trabalhar obr os resultado de um con ulta SQL organizado m um 
Conjunto de Re i tro (473). Uma z qu um Módulo Tabela (134) tamb 'm trabalha obre 
um Conjunto de Registros (473), você pode facilmente executar uma consulta, manipular 
o r ultado no Módulo Tabela (134) e pa ar o dado manipulados para 
apr sentação na interface gráfica. Você também pode usar o Módulo Tabela (134) no 

ntido contrário parar alizar mai validaçõe e cálculo . Vária plataforma , particularmente 
Microsoft COM e . T, usam esse estilo de de envolvimento. 

novo(oConj untoDeDados) 
------=-~ um Contrato 

calcularlançamentos (IDdoContrato) 1 

1 

-----~,..., novo(oConjuntoDeDados) 
um Produto 

novo(oConjuntoDeDados) ,...._______, 

um Lansamento 
De Receita

obterTipoDoProduto (IDdoProduto) 

*inserir 

Figura 2.3 Calculando lançamentos de receitas com um Módulo Tabela (134). 


CAPITULO 2 • ORGANIZANDO A LÓGICA DO DOMÍNIO 49 

Fazendo uma Escolha 

Então, como você escolhe entre os três padrões? Não é un1a escolha fácil e depende 
muito do quão complexa é sua lógica de domínio. A Figura 2.4 é um daqueles gráficos 
não-científicos que realmente me irritam em apresentações PowerPoint porque 
têm eixos sem quantificação alguma. No entanto, o gráfico ajuda a visualizar minha 
percepção de como comparar os três. O Modelo de Domfnio (126) é menos atrativo com 
lógica de domínio simples porque o custo de compreendê-lo e a complexidade da camada 
de dados adicionam muito esforço ao desenvolvimento, esforço esse que não 
terá retorno. No entanto, à medida que a complexidade da lógica do domínio aumenta, 
as outras abordagens tendem a atingir uma barreira em que acrescentar mais 
características se torna muito mais difícil. 

Seu problema, claro, é descobrir onde nesse eixo X sua aplicação se encontra. A 
boa notícia é que posso dizer que você deveria usar um Modelo de Domínio (126) sempre 
que a complexidade da sua lógica de domínio for maior que 7.42. A má notícia é 
que ninguém sabe como medir a complexidade da lógica do domínio. Na prática, então, 
tudo que o você pode fazer é encontrar pessoas experientes que possam fazer 
uma análise inicial dos requisitos e fazer um julgamento. 

Há alguns fatores que alteram um pouco as curvas. Uma equipe familiarizada 
com o Modelo de Domínio (126) diminuirá o custo iniciaJ do uso deste padrão. Isso não 
irá rebaixá-lo ao mesmo ponto inicial dos outros padrões devido à complexidade da 
camada de dados. Ainda assim, quanto melhor for a equipe, maior minha inclinação 
a usar o Modelo de Domínio (126). 

A atratividade de um Módulo de Tnbeln (134) depende muito do suporte existente 
emseu ambiente a uma estrutura do tipo Conjunto de Registros (473) comum. Se você 
tiver um ambiente como .NET ou Visual Studio, onde várias ferramentas traba-

Roteiro de Transação 

Esforço para 
Melhorar 

Complexidade da Lógica do Domínio 

Figura 2.4 Um sentimento sobre o relacionamento entre complexidade e esforço para 
diferentes estilos de lógica de domínio. 


50 PARTE 1 • As NARRATIVAS 

lham ao redor de um Conjunto de Regi tro (473), então isso torna um Módulo Tabela 

(134) muito mai atrativo. D fato, não vejo uma boa razão para u ar um Roteiro de 
Trnn ação (120) em um ambiente .NET. Assim, s não hou r f rramentas especiais 
para Conjunto de Regi tros (473), eu não perderia tempo com o Módulo Tabela (134). 
Sua d ci ão, uma v z qu vocA a t nha tomado, não tará compl tamente graada 
em pedra, mas erá mais complicado alterá-la posteriormente. Dessa forma, va1 
a pena realizar alguma reflexão inicial para decidir qual caminho tomar. Se vocA 
descobrir que tomou o caminho errado, então, se você começou com um Roteiro de 
Trnn ação (120), não hesite m r fatorar em dir ção a um Modelo de Domínio (126). o 
entanto, voe" com çou com um Modelo de Domínio (126), g ralm nt val menos a 
p na ir para um Roteiro de Tran ação (120), a não r qu ocA p a implificar ua camada 
de dados. 

E t trAs padrões não ão escolha mutuam nt xcludentes. Na v rdade, , 
muito comum usar um Roteiro de Transação (120) para uma parte da lógica do domínio 
e um Módulo Tabela (134) ou Modelo de Domínio (126) para o r to. 

Camada de Serviço 

Uma abordagem comum para lidar com a lógica do domínio é dividir a camada de 

domínio m dua . Uma Camada de Serviço (141) é colocada obre um Modelo de Do


mínio (126) ou M6d11lo Tabela (134) subjacente. ormalmente, você só con egue isso 

com um Modelo de Domínio (126) ou Módulo Tabela (134), uma v z qu uma camada 

de domínio qu u e ap nas um Roteiro de Tran ação (120) não ' compl xa o suficien


t para justificar uma camadas parada. A lógica da apr s ntação int rag com a d 

domínio puramente por meio da Camada de Serviço (141), a qual age como uma API 

para a aplicação. 

Além de fornecer uma API dara, a Camada de Serviço (141) é também um bom 
local para colocar coi as como control de tran ação s gurança. I o 1h dá um modelo 
simples para pegar cada m ' todo na Camada de Serviço (141) e descr er suas caract 
rí tica tran acionai d gurança. Uma colha comum parai c n i t m 
um arquivo eparado d propriedade , mas o atributo .NET fornecem uma maneira 
elegante de fazer i o diretam nt no código. 

Quando você tenta uma Camada de Serviço (141), uma decisão-chave é quanto 
comportamento colocar nela. ca o mínimo ' tomar a Camada de Serviço (141) uma 
fachada, d modo qu todo o comportam nto real e t ja em obj to subjac nt . D 


a f rma, tudo qu a Camada de Serviço (141) faz é encaminhar a chamada à fachada 
para o objeto de mais baixo nível. est ca o, a Camada de S rviço (141) fornec 
uma API mais fácil de usar porque, tipicamente, ela é orientada aos caso d uso. Ela 
também é um ponto conveniente para acrescentar invólucros transacionais e verilicaçõe 
d egurança. 

o outro extremo, a maior part da lógica d negócio é colocada nos Roteiros de 
Tran ação (120), d ntro da Cn111ada de Se,viço (141). O objeto d domínio ubjac nte 
são muito sirnpl s; s for um Modelo de Dornínio (126), eles t rão urna corr spond Ancia 
um-para-um com o banco de dado e, as im, você pode usar uma camada d dados 
mais simples, tal como um Registro Ativo (165). 

A m io caminho ntr e a alt rnativa tá uma combinação mais r gular d 

comportamento: o estilo controle-entidade. Este nome em de uma prática comum, 

muito influenciada por Uacob on et ai.]. O principal aqui é colocar a lógica que seja 


CAPÍTULO 2 • ORGANIZANDO A LÓGICA DO DOMÍNIO 51 

particular a uma única transação ou caso de uso em Roteiros de Transação (120), os 
quais comumente são referidos como controles ou serviços. Estes são controles diferentes 
do controle de entrada no Modelo Vista Controle (315) ou Controle de Aplicação 

(360) que encontraremos mais adiante, por isso uso o termo controle do caso de uso. 
O comportamento usado em mais de um caso de uso vai para os objetos de domínio, 
os quais são chamados de entidades. 
Ainda que a abordagem controle-entidade seja comum, nunca gostei muito dela. 
Os controles de casos de uso, como qualquer Roteiro de Transação (120), tendem a 
encorajar o cóctigo duplicado. Minha opinião é que, se você decidir usar um Modelo 
de Domínio (126), realmente deveria ir fundo e fazê-lo dominante. A exceção a isso é 
se você começou com um projeto que usa o Roteiro de Transação (120) com um Gateway 
de Linha de Dados (134). Neste caso, faz sentido mover o comportamento duplicado 
para os Gateways de Linhas de Dados (158), o que os tomará em um Modelo de Domínio 
(126) simples usando Registro Ativo (165). No entanto, eu não começaria dessa forma. 
Eu faria isso apenas para melhorar um projeto que esteja mostrando falhas. 

Não estou dizendo que você nunca deva ter objetos de serviço que contenham 
lógica de domínio, mas sim que você não deve, necessariamente, fazer deles uma camada 
fixa. Objetos de serviço procedurais podem, às vezes, ser uma maneira muito 
útil de fatorar lógica, mas tendo a usá-los quando necessário, em vez de usá-los como 
urna camada da arquitetura. 

Minha preferência é, portanto, ter a mais fina Carnada de Serviço (141) que você 
puder, se realmente necessitar de uma. Minha abordagem normal é supor que eu não 
preciso de uma e apenas acrescentá-la se parecer que a aplicação precisa dela. Entretanto, 
conheço muitos bons projetistas que sempre usam uma Camada de Serviço (141) 
com razoável quantidade de lógica, então sinta-se à vontade para não me dar atenção 
a esse respeito. Randy Stafford tem tido muito sucesso com uma Camada de Serviço 
(141) rica. Por este motivo pedi a ele que escrevesse o padrão Camada de Serviço 

(141) para este livro. 

CAPÍTULO 

3 

Mapeando para Bancos de Dados 
Relacionais 

º
º
papel da camada de fonte de dados é a comunicação com as diversas partes 
da infra-estrutura que uma aplicação precisa para executar sua tarefa. 
Uma parte proeminente deste problema é se comunicar com o banco de dados, 
o que, na majoria dos sistemas criados hoje, significa um banco de dados relacional. 
Certamente ainda há muitos dados em for-matos de armazenamento mais 
antigos, como arquivos ISAM e VSAM de 111ai11Jrnmes, mas a maior parte dr1s pessoas 
que está construindo sistemas hoje se preocupa em h·abalhar com um banco 
de dados relacional. 

Uma das maiores ra7.ões para o sucesso dos bancos de dados relacionais é a presença 
da SQL, a linguagem mais padroniznda para comunicação com bancos de dados. 
Embora a SQL seja cheia de acréscimos aborrecidos e complicados específicos de 
vendedores, o núcleo da sua sintaxe é comum e bem compreendido. 

Padrões de Arquitetura 

O primeiro conjunto de padrões abrange os padrões de arquitetura, que direcionam 

o modo pelo qual a lógica de domínio se comunica com o banco de dados. A escolha 
que você faz aqui tem amplas conseqüências sobre o seu projeto e, desta forma, dificulta 
a refatoração1 de modo que é uma decisão na qual você deve prestar certa atenção. 
É também urna escolha fortemente afetada pelo modo como você projeta sua lógica 
de domínio. 
Apesar de toda a difusão do uso da SQL em software corporativo, ainda há a1·madilhas. 
Muitos desenvolvedores de aplicação não entendem bem SQL e, como resultado, 
têm problemas para definir consultas e comandos eficazes. Embora existam 
várias técnicas para embutir SQL em uma linguagem de programação, cfas são todas 
um pouco deselegantes. Seria melhor acessar os dados usando mecanismos que se 
encaixem com a linguagem de desenvolvimento da aplicação. Administradores de 


CAPÍTULO 3 • MAPEANDO PARA BANCOS DE DADOS RELACIONAIS 53 

bancos de dados (DBAs) também gostam de acessar a SQL que acessa uma tabela de 
modo que possam compreender como melhor ajustá-la e como organizar os índices. 

Por essas razões, é sábio separar o acesso SQL da lógica de domínio e colocá-la 
em classes separadas. Uma boa maneira de organizar essas classes é baseá-las na estrutura 
da tabela do banco de dados de modo que você tenha uma classe por tabela 
do banco de dados. Essas classes então formam um Gateway (436) para a tabela. O 
resto da aplicação não precisa saber nada da SQL, e é fácil de encontrar toda a SQL 
que acessa o banco de dados. Os desenvolvedores que se especializam no banco de 
dados têm um claro lugar aonde ir. 

Há duas maneiras principais por meio das quais você pode usar um Gateway 
(136). A mais óbvia é ter uma instância dela para cada linha retornada por uma consulta 
(Figura 3.1). Este Gateway de Linhas de Dados (158) é uma abordagem que naturalmente 
se ajusta em um modo orientado a objetos de pensar sobre os dados. 

Muitos ambientes fornecem um Conjunto de Registros (473)-ou seja, uma estrutura 
de dados genérica de tabelas e linhas que simula a natureza tabular de um banco 
de dados. Devido ao fato de um Conjunto de Registros (473) ser uma estrutura de 
dados genérica, os ambientes podem usá-la em muitas partes de uma aplicação. É 
bastante comum que ferramentas de interfaces gráficas com o usuário (GUI) tenham 
controlesque trabalhem com um Conjunto de Registros (473). Se você usar um Conjunto 
de Registros (473), só precisa de um objeto para cada tabela no banco de dados. Este 
Gateway de Tabelas de Dados (151) (veja a Figura 3.2) fornece métodos para pesquisar 
o banco de dados que retornam um Co11j11nto de Registros (473). 

Gateway Pessoa 

sobrenome 
prenome 
numeroDeDependentes 

inserir 
atualizar 
apagar 
encontrar (id) 
encontrarPelaComQanhia{idDaComQanhia} 

Figura 3.1 Um Gateway de Linhas de Dados (158) tem uma instância por linha retornada 
por uma consulta. 

Gateway Pessoa 

encontrar (id): ConjuntoDeRegistros 
encontrarPeloSobrenome (String): ConjuntoDeRegistros 
atualizar (id. sobrenome. prenome, numeroDeDependentes) 
inserir (sobrenome, prenome, numeroDeDependentes) 
apagar (id) 

Figura 3.2 Um Gateway de Tabelas de Dados (151) tem uma instância por tabela. 


54 PARTE 1 • As NARRATIVAS 

Até mesmo em aplicações simples, tendo a usar um dos padrões ateway. Uma 
olhada rápida no meu roteiros Ruby Python confirmará is o. Con id ro muito 
útil a s paração clara entr SQL lógica do domínio. 

O fato do Gateway de Tabelas de Dado (151) e aju tar tão bem ao Conjunto de Re


i tro (473) toma-a colha óbvia voe A tiv r u ando Módulo Tabela (134). Também 
é um padrão que você pode usar para pensar em organizar procedures armazenadas 
( tored procedure ). Muito projeti ta gostam de executar todo u ace so d 
banco de dados por meio de procedimentos armazenados em vez de SQL explicita. 

est caso, você pod pen ar na coleção de pr cedim ntos armaz nados como definindo 
um Gateway de Tabela de Dado (151) para uma tab la. u ainda teria um Gatewny 
de Tabela de Dado (151) mm mória para encap ular a chamada ao pr c dirnentos 
armazenado , uma vez que isso mantém encapsulados os mecanismos de 
chamada ao proc dirnento armaz nado. 

Se você esti er usando um Modelo de Domínio (126), há mais algumas opções. 
Você c rtamente pode u ar um Gateway de Linha de Dado (158) ou Gatewny de Tabela 
de Dados (151) com um Modelo de Domínio (126). Para o meu gosto, entr tanto, isso pode 
er ou indireção d mai , ou não o uficient . 

Em aplicações simples, o Modelo de Domínio (126) é uma estrutura sem complicação 
qu em v rdad corre ponde ba tante à e trutura do banco d dado , com 
uma classe de domínio por tabela do banco de dados. Tais objetos de domínio muitas 
v zes têm lógica de negócio apenas moderadamente complexa. e ca o faz 

entido deixar cada objeto do domínio r responsáv I por carregar salvar no banco 
d dado , o que caracteriza o Regi tro Ati o (165) ( ja a Figura 3.3). Outra forma 
de pen ar no Regi tro Ativo (165) é qu vocA começa com um Gateway de Linha de Dado 
(158) então acr centa lógica de domínio à ela , p cialm nt quando vê código 
repetido em diversos Roteiros de Transação (120). 

este tipo de situação, a indir ção adicionada de um Gateway (436) não fomec 
grand alor. À medida que a lógica de domínio ficar mais complicada você começar 
a ir na dir ção d um Modelo de Domínio (126) rico, a ab rdag m impl de um 
Regi tro Ativo (165) começa a não funcionar. A as ociação um-para-um das ela do 
domínio com as tab la com ça a falhar quando vocA fatora a lógica de domínio m 
classes menores. Bancos de dados relacionais não lidam com herança, de modo que 

toma difícil usar e tratégia [ ang of our] e outro padrõe el gante . À medida 
que a lógica d domínio fica pior, você irá querer te tá-la sem t r que se comunicar 
c m o banco d dado todo o tempo. 

Todas ssas forças 1h empurram para a indir ção à m dida que s u Modelo de 
Dornínio (126) se torna rnai rico. e s , ca o o Gatewny (436) pod r solv r algun 

Cliente 

carr ar(Con·untoDeR istros 
apagar 
inserir 
atualizar 
verificarCrédito 

Tabela

enviarCobrança 

Figura 3.3 No Registro Ativo (165), um objeto de domínio cliente sabe como interagir 
com tabelas do banco de dados. 


CAPÍTULO 3 • MAPEANDO PARA BANCOS DE DADOS RELACIONAIS 55 

problemas, mas ainda lhe deixa com o Modelo de Domínio (126) acoplado ao esquema 
do banco de dados. Como re ultado, há alguma transf rmaçõe do campo do Gateway 
(436) para os campos dos objetos do domínio, transformaçõ sestas que complicam 
eu objeto de domínio. 

Um caminho melh r ' i olar compl tam nte o Modelo de Domínio (126) do banco 
de dados, tornando sua camada de indireção inteiramente responsá el pelo mapeamento 
ntre o objetos do domínio e as tab la do banco de dado . E te Mapeador 
de Dados (170) (veja a Figura 3.4) lida com toda a carga e armazenamento entre o banco 
d dados o Modelo do Domínio (126) p rmit a ambo ariar indep ndentemen


t . a mais complicada das arquit tura d map am nto d banco d dados, mas 
u b n fício é c mpl to i olam nto da dua camada . 
ão recomendo o uso de um Gateway (436) como mecanismo principal de persistAncia 
para um Modelo de Domínio (126). S a lógica do domínio for simples vocA 
ti er uma correspondência próxima entre classes e tabelas, o Registro Ativo (165) é a 

lução mai imple ; e você ti er aJgo mai complicado, é do Mapeador de Dado 

(170) qu o pr cisa. 
E s padrõ não ão mutuament exclud nte . Em boa parte d ta discu ão 
estamos pen ando no mecanismo principal de persistência, isto é, o modo comovocA 
alva o dado d algum tipo de modelo em m mória para o banco de dado . Para 
tal, escolheremos um destes padrões. Você não irá querer misturá-los, porque isso 
acaba ficando muito confu o. Entretanto, mesmo e e ti er u ando o Mapeador de Dado 
(170) como mecanismo principal d persistência, você poderá usar um Gateway 

(436) de dados para ncap ular tab la ou rviço que est jam ndo tratados como 
int rface externa . 
a minha di cu ão ar p ito d a id 'ia , tanto aqui quanto no próprio pa


drões, tendo a usar a pala ra "tabela". Todavia, a maioria dessas técnicas pode ser 
aplicada igualmente em isões, consultas ncapsuladas por meio de procedimentos 
armazenados, e consultas dinâmicas freqüentemente usadas. Infelizmente, não há 
um t rmo amplam nt u ado para tab la/vi ão/con ulta/proc dim nt armaz nado, 
de modo qu u o "tabela" porque r pres nta uma e trutura d dado tabular. 
Geralm nte penso em visões como tabela virtuais, qu , , claro, ' como também SQL 
pensa nelas. A mesma sintaxe é usada para pesquisar isões e tabelas. 

A atualização é obviament mais complicada com vi õe e consulta , já que você 
nem empre pode atualizar uma visão diretamente, ma , em vez disso, tem que manipular 
a tab la qu dã uport a la. ca o, ncap ular a i ão/ on ulta com 
um padrão apropriado ' uma maneira muito boa d implementar a lógica d atualização 
m apena um lugar, o qu toma o uso da vi õ mai simple e confiável. 

Mapeador de Cliente 
Cliente 

criar 
verificarCréclito !<------carregar 

enviarContas salvar 

Tabela Cliente 

Figura 3.4 Um Mapeador de Dados (170) isola os objetos do domínio do banco de dados. 


56 PARTE 1 • As NARRATIVAS 

Um dos problemas do uso de isões e consultas dessa forma é que ele pode levar 
a inconsi t"ncias qu surpr ndam o d nvolvedor que não ntend m como 
uma i ão é formada. Ele p dem executar atualizaçõ em dua trutura dif rent 
, amba atualizando as me mas tab las d uporte m que a segunda atualização 
sobrescreve uma atualização feita pela primeira. stabelecendo que a lógica de atualização 
execute a validação apropriada, você não deveria obter dados inconsistentes, 
ma p d urpr end r eu d nvolvedore . 

Também devo mencionar a maneira mai impl d r alizar per i tência m mo 
com o mais complexo Modelo de Domínio (126). os primórdios dos obj tos, muitas 
pessoas perceberam que havia um "d sacordo de impedância" fundamental entre 
obj to e relaçõe . A im, eguiu-e um grande e forço m bancos de dado orientado 
a objeto , o quai encialm nt troux ramo paradigma O ao armaz namento 
em disco. om um banco de dado , você não tem que se preocupar com 
mapeamento. Você trabalha com uma grande estrutura de objetos int rconectados, e 

o b, nco d dado d cobr quando mov r obj to do di co para os di co . Al,m 
disso, oc" pode usa1· transaçõ para agrupar atualizações permitir compartilhamento 
dos dados armazenados. Para os programador s isso parece uma quantidade 
infinita de memória tran acional que é suportada transparent mente pelo armazenamento 
m di co. 
A maior vantagem do banco de dado é que 1 aumentam a produti idad 
. mbora eu não e teja ciente de testes controlado , observaçõe informais estimam 
o esforço d map amento para um banco d dado r !acional m c rca d um 
t rço do sforço de programação -um custo qu continua durant a manut nção. 

o ntanto, a maior part do proj to não u a bane de dado . A razão 
principal contra eles é o ri co. Banco de dados relacionais ão urna tecnologia bastante 
conhecida e pro ada, suportada por endedores grandes existentes já há bastant 
tempo. A SQL fornece uma int rface r !ativam nt padrão para todo o tipo 
d f rram nta . (S voe" e tiv r pr ocupado com d semp nho, tudo qu po o diz r 
é qu não t nho visto quaisquer dados conclusivos d comparaçõ s ntr odes mpenho 
de O e o de i tema relacionai . ) 
Me mo e ocê não puder usar um banco de dados 00, de e considerar seriamente 
a compra de uma f rramenta de mapeamento O/R e tiver um Modelo de Domínio 
(116). Embora os padrões neste li rolhe digam muito sobre como construir um 
Mnpendor de Dados (170), esta ainda é uma tarefa complicada. Vendedores de ferramentas 
pa saram muitos ano trabalhando sobre e se problema, e ferramenta com 
rciai d map arnento O /R ão muito mai ofi ticada do que qualquer coi a qu 
pos a razoavelmente er feita à mão. mbora a ferramenta não ejam barata , você 
t m qu comparar u pr ço com o cu to con id rável de ocê me mo cr v r 
manter tal camada. 

Há açõ a realizar para forn c r uma camada estilo banco de dados 00 que 
pos a trabalhar com banco d dados r !acionais. AJDO' urna proposta para a solução 
de te probl ma no mundo Java, mas ainda é muito cedo para diz r s saua 
b m. Ainda não ti e experiência uficient com ela para chegar a qualquer conclu ão 
para t livro. 

Contudo, mesmo se voe" comprar urna ferramenta, é uma boa idéia t r ciência 
destes padrões. Boas ferramentas O/R lhe dão muitas opções no mapeamento para 
um banco d dados, e te padrõe irão lhe ajudar a entender quando u ai· a difer 
nt pç~ ão parta do princípi d qu uma f rramenta acaba com t do 
forço. Ela o r duz con ideravelrnente, ma ocê d cobrirá que u ar e aju tar uma 
ferramenta O/R demanda um pequeno, porém significati o, trabalho. 


CAPÍTULO 3 • MAPEANDO PARA BANCOS DE DADOS RELACIONAIS 5 7 

O Problema Comportamental 

Quando as pes oas falam sobre mapeamento /R, normalmente enfocam os aspecto 
e truturai -como voe" r laciona tab la obj to . ntretanto, de cobri que a 
part mais difícil do x rácio sãos usa pectos arquit turais comportamentai . Já 
fal i sobr as principai abordag n arquit turais; o próximo pas o , p n ar no aspecto 
comportamental. 

O problema comportamental é como fazer os di ersos objetos carregarem e gravar 
m a i próprio n banco de dad . À primeira vi ta, i to nã par ce er um grande 
problema. Um objeto cliente pode ter m ' todos para carregar e gra ar que executem 
e sa tar fa. Com cert za, com Regi tro Ativo (165), ste é um caminho óbvio a tomar. 

S v c" carr gar um punhad d obj to para a m mória modificá-lo , voe" 
t m qu mant r r gistrado quais modificou se assegurar d gra á-lo d volta no 
banco d dado . S você carr gar apenas alguns objetos, isso ' fácil. À medida qu 
carrega mais e mais objetos, o trabalho aumenta, especialmente quando você cria alguma 
linha em difica outra , já que preci ará da chav da linha criada ant 
que pos a modificar as linhas que se referem a elas. Este é um problema um pouco 
traiço iro a er r solvido. 

Enquanto oc" lê modifica bj t , t m que a gurar d qu 
banco de dados com o qual tá trabalhando p rmaneça consist nt . S voe" ler alguns 
objetos, ' importante garantir que a leitura seja isolada, de modo que nenhum 
outro processo altere qualquer um dos objetos que leu enquanto estiver trabalhando 
e mele. De outra forma, você poderia t r dado inconsi tente e inválido em u 
objetos. Esta é a que tão da concorrência, que é um problema traiçoeiro a erre ol ido; 
falar mo obr le no Capítulo 5. 

Um padrão ncial à oluçã d ambo o probl ma ' a Unidade de Trabalho 
(187). Uma Unidade de Trabalho (187) mantém r gistro de todos os obj tos lido do 
banco de dados, junto com todo os objetos modificado d alguma maneira. Ela 
também trata a maneira como as atualizações são feitas no banco de dados. Em ez 
do programador da aplicação chamar explicitamente método de gravação, ele manda 
a unidade de trabalho confirmar (commit). Es a unidade d b:abalho então organiza 
em umas qü "ncia todo o comportam nto apropriado para o banco de dados, colocando 
todo o complexo processamento de confirmação em um local. A Unidade de 
Trabalho (187) ' um padrão e ncial mpr qu a int raçõ e mportam ntai com 

o banco de dados e tornarem difíceis de manejar. 
Uma boa maneira de pensar na Unidade de Trabalho (187) é como um objeto que 
age como o contr lador do mapeamento do banco de dado . Sem uma Unidade de 
Trnbal/10 (187), normalmente a camada do domínio age como o controlador, decidindo 
quando l regravar no banco d dados. A Unidade de Trabalho (187) r sulta da fatoração 
do comportamento do controlador de map am nto do banco de dados em 

u próprio obj t . 

' medida que voe" carrega objetos, t m qu er cuidado o para não carregar o 
mesmo objeto duas vezes. e ocê fizer isso, terá dois objetos na memória que correspondem 
a urna única linha do banco de dado . Atualiz ambo , e tudo fica muito 
confu o. Para lidar com is o, você precisa manter um registro de cada linha que lê m 
um Mapa de Identidade (196). Cada vez que voe" l" algum dado, prim iro de rificar 
o Mapa de Identidade (196) para se ass gurar d que já não o t nha lido. Se o dado 
já tiv r carr gad , v c" pod r t mar uma gunda r f r"ncia para 1 . D a maneira, 
quaisquer atualizações serão apropriadamente coordenadas. Como benefício, 


58 PARTE 1 • As NARRATIVAS 

ocê também pode conseguir evitar uma chamada ao banco de dados já que o Mapa 
de Identidade (196) também funciona como um cach para o banco de dado . ão e queça, 
nti·etanto, qu o propósito principal d um Mapa de Identidade (196) é manter 
a identidade correta , e não aum ntar o de empenho. 

S oc tiv r u ando um Modelo de Domínio (126), normalment irá arranjar a 
coisas de modo que objetos conectado sejam can-egados junto de tal maneira que a 
l itura de um objeto Pedido carr ga também u bjeto Client a ociad . Entr tanto, 
com muitos objetos conectados, qualquer leitura de um objeto pode trazer um 
enorme grafo de objeto do banco de dados. Para evitar tai ineficiências, você pr cisa 
reduzir o que traz de olta, mas manter a porta aberta para pegar mais dados s 
pr j ar d 1 mai tard . A Carga Tardia (200) ba ia na xi tAncia d um um r cipient 
para uma referência a um objeto. Há diver a variaçõe obr e e tema, ma 
toda la modificam a ref rAncia ao objeto d modo qu , em v z d apontar para o 
objeto real, elas referenciam o recipiente. Apenas se ocê tentar segUÍl~ a conexão fará 
com que o objeto reaJ eja trazido do banco de dados. Usando Carga Tardia (200) 
em pontos conv ni nt , vocA pod traz r do banco d dado apenas o ufici nt m 
cada chamada. 

Lendo Dados 

Ao ler dado , go to d p n ar no método como buscadores que encap ulam comando 
SQL select com uma interface e truturada na forma de um método. As im, 

ocA poderia t r método como bu car(id) ou bu carPorCliente(cliente). E ses m 'todo 
claramente podem s tomar muito difíceis de lidar s ocA tiver 23 cláusulas dif r nt 
no comando Select; ma f lizm nt i o ' rar . 

lugar onde você coloca eu m 'todo de bu ca d pende do padrão de interface 
u ad . Se ua ela de int ração com o banco de dado forem ba ada em tabela 
-ou seja, você tem uma instância da classe por tab la no banco de dados -então 
pode combinar o métodos de bu ca com as in erçõe atualizaçõ . S ua ela s 
de interação forem bas adas m linhas -ou s ja, ocê t m uma classe de interação 
por linha no banco de dado -i o não funciona. 

Com ela s ba ada m linha vocA pod tomar tática a op raçõ d bu ca, 
ma fazer is o impedirá que você torne a operaçõe d banco de dado ubstituí


v i . I o ignifica qu voc A não pod , com o propó ito de te te, ub tituir o banco d 
dados por um Stub de Serviço (469). Para e itar esse problema a melhor abordagem é 
ter objetos de bu ca separados. Cada elas e d busca tem muitos métodos que encapsulam 
uma consulta SQL. uando ocA x cuta a consulta, o obj to de buscar torna 
uma e 1 ção d bj to apr priado ba ado m linha . 
Algo a r ob r ado m m'todo d busca 'qu el trabalham obr o tado 
do banco de dado , não br o tad do obj to. Se vocA executar uma con ulta no 
banco de dados para encontrar todas as pessoas em um clube, lembre-se de que 
quaisquer obj tos pes oa que ocê tiv r acrescentado ao club na memória não rão 
pegos pela consulta. Como resultado disso, normalmente é sensato executar as con


ulta no início. 
Ao l r dados, qu tõ s r }ativas a d mp nho pod m muitas vez surgir. I a 
a alguma r gra bá ica . 
Ti nt traz r div r a linha d uma z. D m do p cial, nunca x cute consultas 
repetidas sobre a mesma tabela para obter di ersas linhas. Qua e sempre é 


CAPÍTULO 3 • MAPEANDO PARA BANCOS DE DADOS RELACIONAIS 59 

melhor pegar dados demais do que de menos (embora você tenha que er cuidado


º em relação ao bloqueio d linha demai com controle d concorrAncia pe imi ta). 
Assim, consid r uma situação em qu ocê pr cisa obter 50 p ssoas que pod 
identificar por uma chave primária no eu modelo de donúnio, ma só pode con truir 
uma p qui a que btenha 200 p oa , obre a qual irá x cutar alguma lógica 
adicional para isolar as 50 de que você precisa. ormalmente, é melhor usar uma 
con ulta que traga linha de n c ária do que realizar 50 con ulta individuai . 

Outra forma de e itar ir ao banco de dados mais do que uma ez é usar junções 
de modo que ocA possa traz r diver as tabelas com urna única con ulta. O conjunto 
de registros resultante parec estranho, mas pode r almente acelerar as coisas. 
N t ca , vo Apod ter um Gat rwny (436) qu tenha dado oriundo da junçã d 
di er as tab ]a ou um Mnpeador de Dado (170) que carregu diver o objeto de domínio 
com uma única chamada. 

ntretanto, se esti er usando junçõe , tenha em mente que bancos de dados 
ão otimizado para lidar com até trê ou quatro junçõ por con ulta. Acima di so, 
o desemp nho sofre, embora você possa restaurar uma boa parte dele com i


~e em cache. 

Muita otimizaçõ ão po sív i no banco d dado . la n olv m agrupar 
dado fr qüentemente referenciados, o u o cuidadoso de índice e a habilidad do 
banco de dado d u ar cache em memória. I o e tá f ra do e copo de te livr , ma 
dentro do escopo de um bom DBA. 

Em todo o ca os, cê dev moldar ua aplicação com u banco de dado 
dados específicos. Regras gerais podem guiar seu pensamento, mas suas circunstâncias 
particulares irão sempre ter suas próprias ariações. Sistemas de banco de dados 
rvidor de aplicação fr qü nt rn nt tAm e qu ma d cach ofi ticado , 
não há c mo u pr diz r o qu acontecerá em ua aplicaçã . Para cada r gra qu u o, 
tenho visto exceções surpreendentes, então reserve tempo para testes e ajustes de de-

empenho. 

Padrões de Mapeamento Estrutural 

Quando a pe oa falam em mapeam nt bj to-r lacional, na maioria da v ze e 
referem aos padrões de map arnento struturais, os quais você u a ao efetuar o mapeamento 
entr objeto na memória e tabela do banco d dados. E te padrõe geralmente 
não são relevantes para o Gate-wny de Tabelas de Dndo (151), mas você pode 
u ar algun dele e u ar o Gateway de Linha de Dndo (158) ou o Regi tro Ativo (165). 
Você provavelmente preci ará u ar todos ele para o Mapendor de Dndo (170). 

Mapeando Relacionamentos 

A questão central aqui , o modo dif r nte como obj tos r laçõ lidam com a sociaçõe 
, o que le a a dois problemas. Primeiro, há uma diferença na representação. s 
objeto lidam com a ociaç-e armazenando referência qu ão mantida em tempo 
de execução ou por ambientes gerenciados por memória ou por endereços de memória. 
Os bancos d dado r }acionai lidam com a sociaçõ s, criando uma chave para 
outra tab la. Segundo, os obj tos pod m usar facilment coleçõ s para lidar com ret rAncia 
múltipla a partir d um únic campo, nquanto qu a normalização força todas 
as as ociações da relação a terem um único valor. I so leva a in ersões da estrutu



60 PARTE 1 • As NARRATIVAS 

ra de dados entre objetos e tabelas. Um objeto pedido e identemente tem uma coleção 
de objetos Item de p d.ido que não preci am d qualqu r r f rência d volta ao p d.
ido. Entr tanto, a strutura da tabela , d.if r nt -o lt m d e incluir uma cha estrangeira 
para o pedido, já que o p dido não pode ter um campo multi alorado. 

A man ira d lidar com o probl ma dar pr ntação é mant r a id ntidad r !
acional de cada objeto como um Campo Identidade (226) no objeto e bu car estes valor 
s para realizar o mapeamento nos dois entido entre as referências do objeto e 
as chaves relacionais. É um processo tedioso, mas não tão difícil, uma vez que ocê 
e mpr enda a t 'cnica básica. Quando ocê 1 A obj to do disco, usa um Mapa de Identidade 
(196) como tab la d bu ca das cha s r !acionai para objetos. ada v z qu 
v e d parar com uma chav trang ira na tab la, u Mapeamento de Chnv E trnngeira 
(233) ( eja a Figura 3.5) para ligar a referência interobjetos apropriada. Se 
você não ti era chave no Mapa de Identidade (196), voe" precisa ir ao banco d dado 
para obtê-la ou usar Car a Tardia (200). Cada vez que ocê gra a um objeto, ocê o 
faz em uma linha com acha e rr ta. Qualquer r ferAncia interobjeto ' ub tituída 
p lo campo 10 do obj to al o. 

Estabelecidos s fundamentos, a manipulação da col ção r quer uma er ão 
mais complexa do Mapeamento de Cha e Estrangeira (233) (veja a Figura 3.6). Se um 
obj to tiv ruma col ção, voe" pr ci ará ex cutar outra bu capara ncontrar t da a 
linhas que referenciam o 1D do objeto fonte (ou ocê pode agora evitar a consulta 
com Carga Tardia (200)). Cada obj to qu r torna é criado e acrescentado à coleção. 
Salvar a coleção envol sal ar cada objeto nela assegurar d qu tenha uma chav 

trang ira para obj to fonte. I o torna confu o, specialm nte quando voc A 
tem qu det ctar objeto adicionado ou r movido da coleção. Pod e tornar r p ti 
tivo quando vocA domina o proc , é por i qu alguma forma d abordag m 
baseada em metadados torna-se um procedimento óbvio para sistemas maiores (entrarei 
em mais detalhes sobre is o mais tarde). S a coleção de objetos não for usada 
fora do scopo do dono d ssa coleção, você pod usar o Mapeamento Dependente (256) 
para implificar o map am nto. 

Um ca o dif rent ocorr com um r lacionam nto muitos-para-muito , o qual 
t m uma coleção em ambos as extrernidad s. Um xernplo ' uma pes oa qu t nha 

Álbum 

título:String 

«tabela» 
Álbuns 

10: int 
título: varchar 
I0doArtista: int 
1 

.....

-

* 

Artista 

título: String 

«tabela» 
Artistas 

10: int 
nome: varchar 
Figura 3.5 Use um Mapeamento de Chave Estrangeira (233) para mapear um campo 
mo nova torado. 


CAPÍTULO 3 • MAPEANDO PAAA BANCOS DE DADOS RELACIONAIS 61 

,

Álbum Faixa 

...... 

-

título: String titulo: String 
*1 

«tabela» «tabela» 
Álbuns Faixas 

1D: int 1D: int 
título: varchar IDdoÁlbum: int 
título: varchar 

Figura 3.6 Use um Mapeamento de Chave Estrangeira (233) para mapear um campo 
coleção. 

muitas habilidades e cada habilidade conheça as pessoas que a possuem. Bancos de 
dados relacionais não podem lidar com isso diretamente, de modo que você usa um 
Mapeamento de Tabela de Associação (244) (veja a Figura 3.7) para criar uma nova tabela 
relacional apenas para lidar com a associação muitos-para-muitos. 

Ao trabalhar com coleções, um erro freqüente é se basear na ordenação dentro 
delas. Em linguagens 00, é comum o uso de coleções ordenadas, como listas e vetores 
-com certeza, isso freqüentemente torna os testes mais fáceis. Entretanto, é muito 
difícil manter uma coleção ordenada arbitrariamente quando salva em um banco 
de dados relacional. Por este motivo, vale a pena considerar o uso de conjuntos desordenados 
para armazenar coleções. Outra opção é escolher uma forma de ordenação 
sempre que executar uma pesquisa em uma coleção, embora isso possa ser bastante 
custoso. 

Empregado t--1-*-----------*--,>~1 Habmdade 

«tabela» <<tabela» «tabela» 
Empregados habilidade-empregados Habilidades 
1D IDdoEmpregado 1D 
IDdaHabilidade 

Figura 3.7 Use um Mapeamento de Tabela de Associação (244) para mapear uma 
associação muitos-para-muitos. 


62 PARTE 1 • As NARRATIVAS 

m alguns casos, a integridade referencial pode tornar as atualizações mais 
complexa . Os i t ma mod rno permitem que ocê protele a v rificação da integridade 
r f rencial para o final da transação. S isso for possível, não há moti o para 
não fazê-lo. De utro modo, o banco d dado irá verificar a cada gra ação. 
ca o, você tem que er cuidado o para realizar ua atualização na ordem corr ta. orno 
fazer is tá fora do copo d te li ro, ma outra t cnica 'r alizar uma ord nação 
topológica de suas atualizações. Outra é codificar explicitamente quais tabelas 

ão escritas em qual ordem. I so pode às vezc reduzir problemas de deadlock dentro 
do banco d dados qu , muito fr qüent ment , faz m com qu a transaçõ s jam 
de feita (rol/ back). 

Campo Identidade (226) é usado para r ferências interobj tos qu viram cha s 
e trangeiras, ma nem todo o relaci nam ntos de um objeto preci am er per i tidos 
de a forma. Pequenos Objetos Valor (453), como inter alos de datas e objeto do 
tipo mo da clarament não d vem r repr entado como ua própria tabela no 
banco de dados. m vez disso, pegue todo os campos do Objeto Valor (453) e coloque-
o dentro do obj to a ociado como um Valor Embutido (261). Já que os Objetos 
Valor (486) t''m s mãntica de alor, voc 4 pod facilm nte criá-los cada vez qu obti


er uma leitura, e não pr ci a e incomodar com um Mapa de Identidade (196). ra álo 
também é fácil -imple mente retire a referência para o objeto e jogue eu campo 
para a tab la propri tária. 

Você pode fazer esse tipo de coisa em uma escala maior pegando um conjunto 
de obj tos e gravando-os em uma única coluna em uma tab la como um LOB Serializado 
(264). L B qu r dizer " arg Bject" (Objeto rand ), qu pode r binário 
(BLOB) ou t xtual (CLOB -Character Larg OBj ct). S rializar um grupo d objet 
como um documento XML ' um caminho óbvio para uma estrutura hi rárquica d 
objeto . Des a forma ocê pode p gar um grupo de pequenos obj to a sociado em 
uma única leitura. Muita vezes os banco de dados têm de empenho pobre com obj 
to pequeno altament interconectado -ond você ga ta muito tempo fazendo 
muitas chamadas pequenas a banco de dados. Estruturas hierárquicas como organogramas 
e contas de materiais ão no que um LOB Seria/izado (264) pode economizar 
muitas idas vindas a um banco d dados. 

lad n gati 'qu a SQL não tá cient d qu tá acont c ndo, d m do 
que ocê não pode fazer con ulta portá eis sobre a e trutura do banco de dados. 
Mais uma vez, XML pode ser sua salvação aqui, permitindo a ocê embutir expres


ões de pesquisa XPath dentro de chamadas SQ , embora embutir não seja de modo 
algum padrão no momento. orno r ultado, LOB Serializndo (264) é m lhor u ado 
quando vo 4 não qui er pesqui ar as part da e trutura ru·mazenada. 

Geralmente um LOB Serializado (264) é melhor para um grupo relativamente 
isolado d obj tos qu faz m part d uma aplicação. S oc 4 usá-lo d mais, acaba 
tran formando eu banco de dado m pouco mai do que um si t ma de arqui 
transacional. 

Herança 

as hierarquias acima, stou falando sobre hierarquias composicionais, como uma 
ár or d part , o que tradicionalm nt não o fort dos i t ma relacionais. Há 
outro tipo d hierarquia que causa dor s d cab ça r !acionais: uma hi rarquia d 
ela a ociada por h rança. Já qu nã há um m do padrão d tratar h rança m 
SQL, novamente temos que e ecutar um mapeamento. Para qualquer estrutura de 


CAPITULO 3 • MAPEANDO PARA BANCOS DE OADOS RELACIONAIS 63 

herança há basicamente três opções. Pode haver uma tabela para todas as classes na 
hierarquia: Herança de Tabeln ÚHicn (269) (veja a Figura 3.8); uma tabela para cada 
classe concreta: Hernnçn de Tabela Concreta (283) (veja Figura 3.9); ou uma tabela por 
classe na hierarquia: Hcrnnça de Tabela de Classes (276) (veja a Figura 3.10). 

Os compromissos são todos entre dupUcaçilo da estrutura de dados e velocidade 
de acesso. A Herança de Tnl,e/n de Classes (276) é o relacionamento mais simples en-

Jogador 

nome 
<etabelan 
Jogadores 
nome 
Jogador de Futebol Jogador de Criquete clube 
média de rebatidas 
clube média de rebatidas média de bollche 
tipo 

Jogador de Boliche 
média de boliche 

Figura 3.8 A Herança de Tabela Única (269) usa uma única tabela para armazenar todas 
as classes em uma hierarquia. 

Jogador «tabela» 
Jogadores de Futebol 

nome 
nome 
clube 

Jogador de Futebol Jogador de Críquete «tabela» 
Jogadores de Críquete 

dube média de rebatidas 
nome 
média de rebatidas 

Jogador de Boliche 1,tabela» 
Jogadores de Boliche 

média de boliche 
nome 
média de rebatidas 
média de boliche 

Figura 3.9 A Herança de Tabela Concreta (283) usa uma única tabela para armazenar 
cada classe concreta em uma hierarquia. 


64 PAR\'f 1 • As NARRATIVAS 

Jogador 

nome 

Jogador de Futebol Jogador de Críquete 
clube média de rebatidas 

Jogador de Boliche 
média de boliche 

((tabela» 
Jogadores de Futebol 

clube 

«ctabela>> 
Jogadores de Crfquete 

média de rebatidas 

((tabela» 
Jogadores de Boliche 

média de boliche 

,,tabelai> 
Jogadores 

nome 

Figura 3.10 A Herança de Tabela de Classes (276) usa uma única tabela para cada classe 
em uma hierarquia. 

tre as classes e as tabelas, mas precisa de junções múltiplas para can-egar um único 
objeto, o que geralmente reduz o desempenho. A Herança de Tabela Concreta (283) evita 
as junções, permitindo que você pegue um único objeto de uma tabela, mas é sensível 
a ai terações. Com qualquer ai te ração em uma superclasse você tem que se lembrar 
de alterar todas as tabelas (e o código de mapeamento). Alterar a própria hierarquia 
pode causar alterações ainda maiores. AJém disso, a falta de uma tabela da superclasse 
pode tornar o gerenciamento das chaves difícil e atrapalhar a integridade 
referencial, embora reduza a disputa de bloqueios na tabela da superclasse. Em alguns 
bancos de dados, o maior problema da Herança de Tabela Única (269) é o desper, 
dício de espaço, já que cada linha precisa ter colunas para todos os subtipos possíveis, 
e isso leva a colunas vazias. No entanto, muitos bancos de dados fazem um bom 
trabalho ao comprimir o espaço desperdiçado em tabelas. Outro problema com a Herança 
de Tabela Unica (269) é seu tamanho, tomando-a um gargalo para os acessos. 
Sua grande vantagem é que el a coloca todas as coisas em um.. único lugar, o que torna 
a modificação mais fácil e evita junções. 

As três opções não são mutuamente exclusivns e, em uma hierarquia, você pode 
misturM padrões. Por exemplo, você poderia ter diversas classes lidas juntas com 
Herança de Tabela Ú11ica (269) e usar Herança de Tabela de Classes (276) para alguns casos 
pouco comuns. Éclaro que misturar padrões acrescenta complexidade. 

Não há um vencedor nítido aqui. Você deve levar em consideração suas próprias 
circunstâncias e preferências, corno com todo o resto desses padrões. Minha 
primeira escolha tende a ser a Hera11ça de Tabela Única (269), já que é fácil de realizar e 
resiliente a muitas refatoraçôes. Tendo a usar as outras duas quando necessário pa1·a 
ajudar a resolver os problemas inevitáveis de colunas irrelevantes e desperdiçadas. 
Muitas vezes, o meil1or é conversar com os DBAs. Eles freqüentemente têm bons 
conselhos sobre o tipo de acesso que faz mais sentido no b,mco de dados. 


CAPITULO 3 • MAPEANDO PARA BANCOS DE DADOS RELACIONAIS 65 

Todos os exemplos recém-descritos, e os padrões, usam herança única. Embora 
herança múltipla esteja ficando menos em uso atualmente e a maioria das linguagens 
esteja cada vez mais evitando-a, a questão ainda apélrece em mapeamentos 0/R 
quando você usa interfaces, como em Java e .NET. Os padrões aqui não entram nesse 
tópico especificamente, mas na essência você lida com herança múltipla usando vnriações 
do trio de padrões de herança. AHernnça de Tabeln Únicn {269) coloca todas as 
superclasses e interfaces em uma grande tabela, a Herança de Tabela de Classes (276) cria 
uma tabela separada para cada interface e superclasse, enquanto que a Hernuça de Tnbela 
Concreta (283) inclui todas as interfaces e superclasses cm cada tabela concreta. 

Construindo o Mapeamento 

Quando mapeia para um banco de dados relacional, você encontra essencialmente 
três situações: 

• Você mesmo escolhe o esquema. 
• Você tem que mapear para um esquema preexistente, o qual não pode ser alterado. 
• Você tem que mapear para um esquema preexistente, porém alterações nele 
são negociáveis. 
O caso mais simples ocorre quando você mesmo está o·jando o esquema e tem 
complexidade de pequena a moderada Ití'I sua lógica de domínio, resultando em nm 
Roteiro de Transação (120) ou em M6dulo Tabela (134). Nesse caso, você pode projetar as 
tabelas em torno dos dados usando técnicas clássicas de projeto de banco de dados. 
Use um Gatewny de Linha de Dados (158} ou um Gnteway de Tabela de Dados (151) para 
retirar toda SQL da lógica do dominio. 

Se você estiver usando um Modelo de Domínio (126), deve tomar cuidado com 

u.m projeto que se pareça com um projeto de banco de dados. Neste caso, construa 
seu Modelo de Domínio (126) sem considerar o banco de dados, de modo que você 
possa simplificar da melhor forma a lógica do domínio. Trate o projeto do banco de 
dr1dos como uma maneira de persistir os dados dos objetos. O Mapendor de Dndos 
(170) lhe dá a maior flexibilidade aqui, porém é mais complexo. Se o projeto de um 
banco de dados isomórfico ao Modelo de Domínio (126) fizer sentido, você pode considerar 
um Registro Ativo (165) em vez d.isso. 
Embora criar primeiramente o modelo seja uma forma razoável de pensar nele, o 
conselho só se aplica dentro de ciclos interativos pequenos. Passar seis meses criando 
um Modelode Domfnio (126) sem bancos de dados e então decidir persisti-lo assim que 
tiver terminado é altamente arriscado. O perigo éque o projeto resultante tenha problemas 
de desempenho fraco que demandem refatoração demais para serem consertados. 
Em vez disso, construa o banco de dados a cada iteração, em não mais de seis semanas 
de duração, preferencialmente menos. Dessa forma, você tei:-á retorno rápido e 
contínuo sobre como suas interações de banco de dados funcionam na prática. Dentro 
desta tnrefa particular, você deve pensar no Mvdelo de Domfnio (126) primeiro, mas integre 
cada parte do Modelo da Domínio (126) no banco de dados à medida que avança. 

Quando o esquemn já está lá, suas escolhas são similares,. mfts o processo éligeiramente 
diferente. Com lógica de domínio simples você cria classes Gatewny de Unltns 


66 PARTE 1 • As NARRATIVAS 

de Dados (158) ou Gnteway de Tabelas de Dado (151) que imitem o banco de dados, eco


1 ca a camada da lógica do domínio br ela . Com lógica de domínio mai comple


xa ocê precisará d um Modelo de Domínio (126), o qual é altament impro á l d 

ca ar com o de enho do banco de dado . Portanto, con trua um Modelo de Domínio 

(126) gradualm nt e inclua Mnpeadore de Dado (170) para p r i tiro dado no banco 
de dados preexistente. 
Mapeamento Duplo 

ca ionalm. nte me deparo com ituaçõ em qu o me mo tipo de dado preci a r 
trazido d mais d uma font . Pod hav r múJtiplo banco d dado com o m mo 
dado , porém com p qu na diferença n e quema de ido a alguma reutilização 
feita com "copiar e colar". ( esta situação, o tamanho do aborrecimento é inversamente 
proporcional ao tamanho da dif r nça.) Outra possibilidade , u ar mecanismos 
diferentes, armazenando os dados, às vezes, em um banco de dados e, às ezes, 

m m n ag n . VocA pod qu r r traz r dado imilar d uma combinaçã d 
mensagens XML, transaçõ s CICS tabelas r !acionais. 

A opção mais simpl s ' ter di ersas camadas d map am nto, uma para cada 
font de dado . Entretanto, e o dad forem muito melhante , i o p d levar a 
muita duplicação. e ca o você poderia con iderar um map am nto em dois pa 


o . O primeiro pa o converte o dado do e quema em memória para um e qu ma 
lógico de armazenamento de dados. O esquema lógico de armazenamento de dados 
é projetado para maximizar as similaridades do formatos das fontes de dado . O egundo 
pa o map ia do squ ma lógico d armaz nam nto d dados para o esqu ma 
de armaz namento d dad fí ico r al. E t gundo pa contém a difer nça . 
pa o extra ó vale a pena quando você t m muita imilaridad , d modo 
qu você som nt dev u á-lo quando ocA tem depó ito fí icos de dados imilar s, 
porém irritantemente diferentes. Trate o mapeamento do depósito lógico para o depósito 
fí ico dos dado como um Gatewny (436) eu e qualquer uma da técnicas de 
map am nto para mapear da lógica da aplicação para o d pósito lógico dos dado . 

Usando Metadados 

e te li ro, a maior part do meu ex mplo u a código e cri to à mão. Com mapeamento 
simples e repeti ti o is o pode le ar a código simples e repetitivo -e código repetiti 
o ' um sinal de algo errado com o projeto. Há muito qu você pode faz r fatorando 
comportamentos comuns com herança e delegação-práticas boas e hone 
ta -mas também há uma abordag m mai fi ticada u ando Mapeamento em 
Metadndo (295). 

O Mapeamento e111 Metadndos (295) 'baseado na condensação do rnap amento em 
um arquivo de metadados qu detalha como a colunas no banco de dado ão mapeada 
em campos nos objetos. objeti o disto é que, as im que tenha os metadado , vocA 
pod evitar c 'digo r p titi usando geração de código ou programação r flexi a. 

Com uma pequ na quantidade de metadado ocê obt 'm uma grande xpr si 
idade. Uma linha de metadados pode dizer algo como 

<nomeCampo =cliente classeA vo = •e iente•, colunaBD ="IOCliente", tabelaA vo =•clientes• 
limitelnfer·or ="l" limiteSuperior ="l" etodoGravacao ="carregarCliente /> 


CAPÍTULO 3 • MAPEANDO PARA BANCOS DE DADOS RELACIONAIS 67 

A partir disso, você pode definir o código de leitw-a e gravação, gerar automaticamente 
junções para t ca o, executar toda SQL, forçar a multiplicidad do relacionamento 
at, fazer coisas como computar ord ns d gravação sob a pr sença da 
int gridade refer ncial. É por i o qu ferramenta de mapearn nto /R tendem a 
u ar m tadad 

Quando u a Mapeamento em Metadndo (295), voeA tem a fundam ntação n ce ária 
para criar consultas baseada em objetos em memória. Um Objeto de Pe quisa 

(304) p rnút -lhe criar ua con ulta bas ada m obj to dado mm mória d 
um modo que os desenvolvedores não precisem conhecer nem SQL nem os detalhes 
do e quema relacional. O Objeto de Pesqui a (304) p de então u ar o Mapeamento em 
Metadado (295) para traduzir expr sõ ba ada em campo d objeto para a SQL 
apr priada. 
e e i so adiante o uficiente e você pode formar um Repa itório (309) que esconda 
amplamente o banco d dado da vi ta. Quai quer con ulta a banco d dados 
podem ser feitas em um Repo itório (309) pelos Objetos de Pesquisa (304), e os de


envolvedores não con eguem perceber e os objetos foram t.razido da memória ou 
do banco d dado . Repo itório (309) funciona b m com i t ma d Modelo de Domínio 
(126) ric . 

Ape ar das muitas antagen do metadado , ne te li ro enfoqu i x mplo e crito 
à mão porque acredito que são mais fáceis de entender. As im qu você donúnar 
os padrões e conseguir escrevê-los à mão para sua aplicação, poderá descobrir 
como usar m tadado para tornar a coi a mai imple . 

Conexões de Bancos de Dados 

A maior parte da int rface d bancos de dado ba eia-m algttm tipo de obj to 

de con xão de banco d dado para atuar como um link ntr o código da aplicação 

e o banco de dados. ormalmente uma conexão deve ser aberta antes de você poder 

executar comando obre o banco de dado . Em geral, ocê precisa de uma conexão 

explícita para criar e e ecutar um comando. Durante todo o tempo em que ocê exe


cuta t comando a c n xão d v tar ab rta. Bu ca r t rnam um Conjunto de Re


gi tro (473). Algumas int rfac s forn c m Conjuntos de Registro (473) d con cta


dos, o quais pod m s r manipulados após a con xão ser fechada. Outras int rfac s 

fornecem apenas Conjuntos de Re istros (473) conectados, o que significa que a cone


xão deve pennanec r ab rta nquanto o Conjunto de Re i tro (47 ) é manipulad . S 

você e tiver e ecutando denh·o de uma transação, normalmente ela está conectada 

a uma conexão e p cífica e ta de p rman cer ab rta nquanto aqu la e ti r 

acontecendo. 

m muitos ambi nte , ' custoso criar uma conexão, o que faz com qu valha 
a pena criar um pool de conexõe . esta situação os desenvol edores solicitam uma 
conexão do pool a Lib rarn quando tiv r m t rnúnado, em v z d criar f char a 
conexão. Atualmente, a maioria das plataformas lhe dá esta po sibilidade de poo1ing, 
de modo que raramente ocê me mo terá que criá-lo. Se tiver, primeiro v rifique 
se o pooling ai realmente ajudar no desempenho. Cada vez mais os ambi ntes 
tornam mai rápido criar uma nova con xão, d modo qu não há n ce idad d 
você usar um pool. 

Ambi nt qu forn c m poo/in muita c locam por trá d uma int r-
face que e parece com a criação de uma no a cone ão. De sa forma, ocê não sabe 


68 PARTE 1 • As NARRATIVAS 

se está obtendo uma cone ão no a ou uma alocada de um pool. Esta é uma coisa boa, 
já que a e colha d u ar um pool ou não está encap ulada. D man ira em lhante, fechar 
uma con xão pod não f chá-la r alment , mas apenas r torná-la ao pool para 
que outra p oa a u e. e ta di cu ão u arei "abrir" e "fechar", qu podem er 

ub tituído por "obter" do pool "lib rar" d olta para pool. 
Custosa de criar ou não, as conexõe precisam de geren iamento. Já que ela 
ão recur o cu to os d g r nciar, devem r f chadas a im qu voe A ti er t rminado 
de usá-las. Além disso, se você estiver usando uma transação, normalmente precisa 
se a gurar de que cada comando dentro de uma tran ação específica u e a 
m ma con xão. 
O cons lho mai comum ' obt r uma con xão xplicitam nt , usando uma chamada 
para um pool ou um g rente de conexão, e ntão fornecê-la para cada coman


do de banco de dados que ocê quiser executar. Assim que você não precisar mais da 
c n xão, f eh -a. E te con elho 1 va a alguma qu t-: a gurar-e d qu vocA tenha 
a conexão e todos os locais onde precisar dela e garantir que não se e quecerá de 
f chá-la ao final. 

Para se assegurar de que ocA t nha urna conexão ond pr cisa, há duas e colhas. 
Urna 'passar a conexão corno um parârn tro explícito. O problema nisso é qu , 
por x mpl , a con xão , adicionada a toda a chamada de m 'todo ond u umco 
propó ito é er pa sada para algum outro método cinco camada abaixo da pilha 
de chamada . É claro que esta é a situação que demanda um Re i tro (448). Já que ocê 
não quer diversas tlzrends usando a mesma conexão, irá querer um Registro (448) 

com copo de tlzrend. 

S você for e qu cido como u, o fechamento e plícito não uma boa id, ia. É 
muito fácil e qu cer d faz A -lo quando de ria. Voe" também não p d f char a con 
xão com cada comando porqu pod star s ndo xecutado d ntro de uma transação, 
o fechamento irá normalmente faz r com que a transação seja de feita. 

Como uma conexão, a memória ' um r cur o que pr cisa r lib rado quando 
você não estiver usando. Ambientes modernos atualmente fornecem gerenciam 
nto automático de m mória coleta de lixo (garbage collection), d modo qu 
uma maneira de e as gurar de que a conexões sejam fechadas é usar um coletor 
d lixo. esta abordagem, a própria conexão ou um objeto que e r fira a ela 
f cha a con xão durant a col ta d lixo. bom dis o , qu usa o m smo sgu ma 
d ger nciam nto u ado para a m mória ndo d a forma con eni nte familiar 
ao mesmo tempo. O problema é que o fechamento da conexão só acontece 
quando o coletor realmente reivindica a memória, e isto pode ocorrer um pouco 
depois do momento em que a conexão tiver perdido sua última referência. Ore


ultado é que conexõ em refer"'ncia pod rn continuar exi tindo por um certo 
t mpo ante d r m f chada . S i o ' um probl ma ou não d p nd muito do 
u ambiente pecífico. 

o geral, não gosto d depender da coleta de lixo. Outros esquemas -at' o f chamento 
explícito -são melhores. Ainda assim, a coleta de lixo é um bom backup no 
caso do e qu ma normal falhar. Afinal,, m lhor ter a conexões f chadas em algum 
momento do que tê-las perdurando para sempre. 
Já que a conexõe são tão atrelada a transações, uma boa maneira de gerenciála 
vinculando-a a uma tran ação. Abra uma con xão quando você começar uma 
transação fech -a quando você confirmá-la ou d sfazA-la. aça com que a transação 

aiba qual con xão tá u ando d m d que voe" po a ignorar a c n xã compl tamente 
e lidar apenas com a transação. Já que a conclusão da transação tem um efei



CAPÍTULO 3 • MAPEANDO PARA BANCOS DE DADOS RELACIONAIS 69 

to visível, é mais fácil lembrar de confirmá-la e localizá-la se você esquecer. Uma Unidade 
de Trabalho (184) e encaixa com perf içã para g r nciar tanto a tran ação quanto 
a cone ão. 

S voe" fiz r coi as fora d uma transação, como uma 1 itura d dado invariáveis, 
u e uma conexão no a para cada comando. Pooling podem lidar com quaisquer 
que tões relacionada à criação de conexões de curta duração. 

Se você esti er usando um Conjunto de Registros (473) desconectado, pode abrir 
uma conexão para colocar o dado no conjunto de registro e fechá-la nquanto manipula 
os dado do Conjunto de Regi tro ( 73). A eguir, quando vo ê já tiver feito o 
que pr ci ava com o dad , p d abrir uma nova c nexã , tran ação, para gravar 
os dados. S oc" fiz r isto, pr cisarás pr ocupar com os dados alt rados durant a 
manipulação do Conjunto de Regi tro (473). E te é um tópico sobre o qual falarei junto 
com o controle de concorrência. 

As especificidades do gerenciamento de conexão são características do seu software 
de int ração com o banco de dado , de modo qu a tratégia qu vocA u a é 
muita ze ditada p lo u ambient . 

Questões Diversas 

Você perceberá que algun do código exemplo u am declaraç~ s select na forma 
se ect * f ro , nquanto que outr u am coluna com nom . U ar se ect * pod ter 

, rios problemas em alguns drivers de bancos de dados, que podem falhar se uma 
nova coluna for acrescentada ou se uma coluna for reordenada. Embora ambientes 
mai moderno não ofram is o, não ' ábio u ar select * ocê sti r u ando índic 
po icionais para obt r informaçõ das coluna , pois o r ord n mento de uma 
c luna irá faz r com qu código falh . ã há probl ma m u ar índic d nom 
de colunas com um select * e de fato estes são mais claros de ler. Entretanto eles podem 
ser mai lentos, embora isso provavelmente não vá fazer muita diferença dado 

o tempo da chamada SQL. Como sempre, meça para se certificar. 
S você usar índic s de números de coluna, preci a se a segurar de que os acessos 
ao conjunto r sultant s jam muito próximos à d finição da d daração SQL d 
mod que nã aiam d incr nia ca a coluna jam r ordenada. C n eqüentemente, 
e ocê e ti er u ando Gateway de Tabela de Dado {151), deve u ar índices de 
nomes d coluna , poi o conjunto resultante é usado por todo código que executa 
uma operação de busca nesse gateway. O resultado d.isso é que geralmente vale a pena 
ter te t de ca o simple de criação/leitura/remoção para cada e trutura de mapeam 
nto d banco de dado qu vocA u ar. I so ajudará a p gar ca o quando ua 
SQL ai de incronia com u código. 

S mpr al a p na o e forç de u ar SQL tática qu po a r pr '-c mpilada, 
em vez d SQL dinâmica que tem que er compilada a cada vez. A maioria da plataformas 
1h dá um mecanismo para pr '-compilar SQL. Urna boa regra é evitar o uso 
de concatenação de strings para formar pesquisas SQ . 

Muitos ambientes lhe dão a habilidade de fazer um lote com diversas pesquisas 
SQL em uma única chamada ao banco de dados. ão fiz is o n st s exemplo , ma ' 
certam nte uma tática qu oc" d v usai· no código d produção. Como oc" faz is


aria com a plataforma. 
Para con x-n t x mplo , ap na o in co com uma chamada a um objeto 
"DB", o qual é um Regi fro (448). Como você obtém uma cone ão dependerá de 


70 PARTE 1 • A5 NARRATIVAS 

seu ambiente, de modo que você irá substituir isto pelo que precisar fazer. Não en


volvi transações em nenhum dos padrões além daqueles sobre concorrência. Mais 

uma vez, você precisará combinar com o que o seu ambiente precisar. 

Leitura Adicional 

O mapeamento objeto-relacional é um fato para a maioria das pessoas, então não é 
surpresa que haja muita coisa escrita sobre isso. A surpresa é que não há um único livro 
coerente, completo e atualizado, motivo pelo qual dedico tanto deste a este assunto 
complicado, porém interessante. 

O bom do mapeamento de banco de dados é que existem por aí mujtas idéias 
para serem roubadas. As fontes intelectuais mais vitimadas são [Brown and Whitenack], 
[Ambler], [Yoder] e [Keller and Coldewey]. Eu certamente o encorajaria a dar 
uma boa olhada nesse material para suplementar os padrões deste livro. 


CAPÍTULO 

4 

Apresentação Web 

U
U
ma das maiores mudanças nas aplicações corporativas nos últimos anos foi o 
surgimento das interfaces com o usuário baseadas em navegadores Web. Elas 
trazem muitas vantagens: nenhum software cliente para instalar, uma abordagem 
comum para a interface com o usuário e um acesso universal fácil. Além disso, 
Ltma série de ambientes tornam fácil criar uma aplicação Web. 

A preparação de uma. aplicação Web começi-l com o próprio software servidor. 
Normalmente ele tem algum tipo de arquivo de configuração que indica quais 
URLs devem ser manipuladas por quais programas. Freqüentemente, um único 
servidor Web pode Lidar com muitos tipos de programas. Estes programas podem 
ser dini\micos e podem ser acrescentados a um servidor colocando-os em um diretório 
apropriado. O trabalho do servidor Web é interpretar é-1 URL de urn pedido e 
passar o controle para um programa servidor. Há duas formas principais de estruturar 
um programa em um servidor Web: como um roteiro ou como uma página 
servidora (server pnge). 

O roteiro é un, programa, geralmente com funções ou métodos para ti·atar a 
chamadn HITP. Exemplos incluem roteiros CGJ e servlets Jnva. O texto do programa 
pode fazer quase tudo o que um programa podefazer, e o roteiro pode ser divido em 
sub-rotinas, além de poder criar e usar oulTos serviços. Ele obtém dados da página 
Web examinando a requisição HTTP, uma string. Em alguns ambientes isso é feito 
por meio de uma busca usando expressões regulares na sll'ing de requisição -a facilidade 
oferecida por Perl para fazer isso a torna uma escolha popular para roteiros 

CCI. Outras plataformas, como servlets Java, fazem essa busca por programa, o que 
permite ao programador acessar as Wormações da requisição por meio de uma interface 
com palavrns-chave. Isso, no mínimo, significa um número menor deexpres,sões 
regulares para criar problemas. A saída do servidor Web é outra string -aresposta 
-né\ qual o roteiro pode escrever usando as operações comuns da linguagem 
de gravação em strenms. 

72 PARTE 1 • As NARRATIVAS 

screver uma resposta HTML por meio de comandos de treams é incômodo 
para o programador e qua impo sí 1 para não-programador qu , no ntanto, 
sentiriam-s confortáveis preparando páginas HTML. Isso levou à id 'ia de página 
ervidora , em que programa é e trutu1·ado em torno da página-t xto de retorno. 
Vi cA cr v a página d r torno em HTML e in er criplet no HTML para 
executar código em determinados pontos. Exemplo desta abordagem incluem 
PHP, ASP e JSP. 

A abordagem da página servidora funciona bem quando há pouco processamento 
dar po ta, como em "Mostre-m os d talhe do álbum# 1234". As coi as ficam 
b m mafa confu a quando ocA tem qu tomar decisõ s ba eadas na entrada, 
e mo dif r nt format d apr ntação para álbun dá ico ou d jazz. 

De ido ao fato do estilo roteiro funcionar melhor para interpretar a requisição 
e o estilo páginas rvidora funcionar melhor para formatar ar sposta, exist a opção 
óbvia de usar um roteiro para interpretar a requisição e uma página ser idora para 
formatar ar po ta. ta paração , uma idéia antiga que apar e u primeiro m int 
rfac com o usuário u ando o padrão Modelo Vi ta Controlador (315). ombin -a 
com a noção s ncial de que lógica não-relacionada à apres ntação dev r dela xtraída, 
e temos uma ótima base para os conceitos de te padrão. 

O Modelo Vi ta Controlador (315) (v ja a Figura 4.1) , um padrão amplamente referenciado, 
mas freqüentemente mal-compreendido. Antes das aplicações Web entrar 
m em cena, a maior parte das demon traçõe do Modelo Vi ta Controlador (315) 
qu examin i o compr ndiam erradamente. Uma das principais razõ s para a confusão 
ra ou o da palavra "controlador." Controlador , u ado em ári context s 
dif r ntes, e g ralmente eu a encontrava u ada d uma man ira dif r nte daquela 
d crita no Modelo Vi ta Controlador ( 15). Por moti o, pr firo u ar t rmo controlador 
de entrada para o controlador no Modelo Vista Controlador (315). 

Urna r quisição eh ga a um controle de ntrada, o qual extrai as informações 
dessa requisição. Ele então encaminha a lógica d negócio para um objeto de domínio 
apropriado. E bj to e nv r a com a f nt d dado r aliza t da a tar fa 
indicadas p lar qui ição, a sim como reún informaçõ para are po ta. Quando tiv 
r terminado, l de olv o control para o controlador d entrada, o qual analisa 
os resultados e decide qual vista é necessária para exibir a resposta. Ele então passa 

o controlador, juntamente com o dado dar posta, para a vi ta. r pas e do controlador 
para a i ta, muitas vezes, não é uma chamada direta e, freqüentemente, envolve 
a colocação do dado m um local pr,-combinado, alguma forma d objeto d 
ssão HTTP compartilhado entr o controlador de entrada e a ista. 

primeira rnai irnportant razão para aplicar o Modelo Vi tn Controlador (315) 
é a egurar que os modelo e tejam completamente eparado da apresentação Web. 
I o torna rnai fácil modificar a apre entação, a im corno acre centar apr entaçõ 
adicionais mais tarde. Colocar o processamento em objetos Roteiro de Transação (120) 
ou Modelo de Domínio (126) também tornará mais fácil te tá-lo . Isto é especialmente 
importante se voe" estiver usando uma página servidora como sua vista. 

t ponto, eh gam a um gund u da palavra "controlador". Muit 
projeto de interface param o objeto da apre enta ão do do domínio com uma 
camada int rmediária d obj to do tipo Controlador de Aplicação (360). O objetivo de 
um Controlador de Aplicação (360) é lidar com o fluxo de uma aplicação, decidindo 
quai telas devem aparecer em qual ordem. Ele pode aparecer como parte da camada 
d apr s ntação ou voe" pode pen ar n le como uma camada parada qu r aliza 
a mediaçã ntr a camada d apr ntaçã d domíni . O Controladore de 


um Servidor Web 

um Controlador solicita ão htt 

ler dados 

solicitação http 

trata solicitação http 

criar com dados do domínio 

ai 

escolher vista 

1 

adicionar dados para a vista (link para o modelo) 

uma Vista 
mandar para a vista 

remeter 

ler dados 

1 
1 
gerar resposta 

resposta http 

Figura 4.1 Uma visão geral de como os papéis do modelo, vista e controle de entrada trabalham juntos em um servidor Web. O controlador trata 
a requisição, faz com que o modelo execute a lógica do domínio e então faz com que a vista crie uma resposta baseada no modelo. 

• 

~ 

::o 

m 

V\ 

m 

,:z 
~. 

o 

~ 

m 

CD 

....a 

w 


74 PARTE 1 • As NARRATIVAS 

Aplicação (360) podem ser escritos para serem jndependentes de qualquer apresentação 
cm particular. Nesse caso, eles podem ser reutilizados entre as aplicações. Isso 
funciona bem se você tiver diferentes apresentações com os mesmos fluxo e navegação 
básicos, e.rnbora, muitas vezes, seja melhor prover um fluxo diferente pMa 
Célda apresentação. 

Nem todos os sistemas precisam de um Controlador de Aplicnçiío (360). Eles são 
úteis se o seu sistema tiver muita lógica relacionada à ordem das telas e à navegação 
entre elas. E1es são úteis também se você não tiver um mapeamento simples entre 
suas páginas e as ações no domínio. No entanto, se as telas puderem ser vistas cm 
praticamente qualquer ordem, você provavelmente terá pouca necessidade de um 
Controlndor de Aplicação (360). Um bom teste é este: se a máquina estiver no controle 
do fluxo de telas, você precisa de um Controlador de Aplicações (360); se o usuário estiver 
no controle, você não precisa. 

Padrões de Vista 

No lado da vjsta há três padrões a se considerar: Vistn de Trnnsformnçiio (343), Vistn 
Modelo (333) e Vista em D11as Etapas (370). Esses, essencialmente, dão origem a duas 
escolhas: usar Vista de Transformnçiio (343) ou Vista Modelo (333) e, em ambos os casos, 
seeles usam um único estágio ou uma Vistn em Duns Etapas (370). Os padrões básicos 
para Vista de Transformnçiio (343) e Vistn Modelo (333) são um único estágio. A Vista em 
Duas Etapas (370) é uma variação que você pode aplicar cm ambos os casos. 

Começarei com a escolha entre a Vista de Transformação (343) e a Vista Modelo 
(333). A Vista Modelo (333) lhe permite escrever a apresentação na estrutura da página 
e em:butir marcadores na página para indicar onde é necessário o conteúdo dinâmico. 
Algumas plataformas populares são baseadas neste padrão, muitas das quais 
são tecnologias de páginas servidoras (ASP, JSP, PHP) que lhe permitem colocar uma 
linguagem de programação completa na página. Isso claramente fornece muito poder 
e flexibilidade, mas, infeliz.mente, também leva a código bastante confuso e difícil 
de manter. Como conseqüência, se você usar tecnologiêl de p~ginas servidoras, deve 
ser muito disciplinado para manter a lógica da programação fora da estrutura da 
página, muitas vezes usando um objeto auxiliar. 

A Vistn de Trnnsformnção (343) usa um estilo de programação de transformação. 
O exemplo habitual é XSLT. Isso pode ser muito eficaz se você estiver traballumdo 
com dados do domínio que estejam no formato XML ou que possam ser facilmente 
convertidos para XML. Um controle de entrada pega a folha de esillo XSLT apropriada 
e a aplica ao XML monté'ldO a partir do modelo. 

Se você usa roteiros procedurais como sua vista, você pode escrever o código 
em ambos os estilos, Vista de Tra11sfon11nção (343) ou Vista Modelo (333), ou mesmo em 
alguma mistura interessante dos dois. Percebi que a maioria dos roteiros segue um 
destes dois padrões como sua forma principal. 

A segunda decisão é sobre usar um estágio único ou usar a Vista em Duas Etapas 
(370). Uma vista de um único estágio, na maioria das vezes, tem um componente de 
vista para cada tela na aplicaçilo. A vista pega dados orientados ao domínio e os representa 
em HTML. Digo ''na maioria das vezes" porque telas lógicas sinúlares podem 
compartilhar visões. Mesmo assim, na maior parte do tempo, você pode pensar 
em uma vista por tela. 


CAPÍTULO 4 • APRESENTAÇÃO WEB 75 

Dados Dados 
do Cliente do Pedido 

Vista Vista 
do Cliente do Pedido 

«criar» «criam 

HTML HTML 

do Cliente do Pedido 

Figura 4.2 Uma vista de estágio único. 

Uma vista em dois estágios (Figura 4.3) divide esse este processo em dois estágios, 
produzindo uma tela lógica a partir dos dados do domínio e então os representando 
em HTML. Há uma vista de primeiro estágio para cada tela mas apenas uma 
vista de segtU1do estágio para a aplicação inteira. 

A vantagem da Vistn em Duns Etnpas (370) é que ela coloca a decisão de qual 
HTML usar em um único local. lsto facilita as alterações globais no código HTML, 
uma vez que só há um objeto para alterar se quisermos alterar todas as telas no site. 
É claro que você só obtém esta vantagem se sua apresentação lógica permanecer a 
mesma, de modo que isto funciona melhor com sites onde telas diferentes usam o 
mesmo lnyo11t básico. Será difícil sugerir uma boa estrutura de tela lógica em sites 
com design elaborado. 

A Vistn em Duns Etnpns (370) funciona ainda melhor se você tiver uma aplicação 
Web em que os serviços estejam sendo usados por múltiplos clientes, com diferentes 
interfaces com o usuário, como diversas companhias aéreas usando o mesmo sistema 
de reservas. Dentro dos limites da tela l6gicr1, cada intcrfocc com o usuário pode ter 
uma aparência d.iierente usando um segtU1do estágio diferente. De modo semelhante 
você pode usar uma Vista em D11ns Etapas (370) para lidar com diferentes dispositivos 
de saída, com segundos estágios separados para um navegador Web normal e para 
um palmtop. Mais uma vez, a limitação é que você tem de fazer os dois compartilharem 
uma mesma tela lógica, o que pode não ser possível se as interfaces de usuário forem 
muito djferentes, como em um navegador e um telefone ceh.tlar. 

Padrões de Controlador de Entrada 

Há dois padrões para o controlador de entrada. O mais comum é existir um objeto 
Controlador de entrada para cada página no seu site. Nocaso mais simples, este Con1rolador 
de Ptíginn (318) pode ser a própria página servidora, combinando os papéis de 
vista e controlador de entrada. Em muitas implementações separar o controlador de 


76 PAATf 1 • As NARRATIVAS 

Dados do Dados do 
Cliente Pedido 

Primeiro Primeiro 

Estágio Estâgio 
do Cliente do Pedido 

1 
«criar» : «criar» 

1 

Segundo 
Estágio 

/ 

/ ', ((criar» 

c,criar» / 

/ 

/ ' ' 

/ 

' 

/ ' 

/

/ 
/ 

,-------, I 
' ' ' ' ' 

HTML do HTML do 
Cliente Pedido 

Figura 4.3 Uma vista em dois estágios. 

entrada em um objeto separado torna as coisas mais fáceis. O controlador deentrada 
pode então criar modelos apropriados para executar o processamento e instanciar 
uma vista para retornar o resultado. Freqüentemente, você perceberá que não há exatamente 
um relacionamento um-para-um entre Co11troladores de Página (318) e vistas. 
Um pensamento mais preciso é que você tem wn Controlador de Página (318) para cada 
ação, em que uma ação é um botão ou link. Na maior parte do tempo as ações correspondem 
a páginas, mas ocasionalmente isso não acontece -tal como um li11k que 
pode levar a diferentes páginas, dependendo de alguma condição. 

Em qualquer controlador de entrada há duas responsabilidades -tratar a requisição 
HTTP e decidir o que fazer com eJa -e muitils vezes faz sentido separá-las. 
Uma página servidora pode tratar a requisição, delegando a um objeto auxiliar separado 
a decisão do que fazer com ela. O Controlador Frontal (328) aprofunda esta separação 
tendo apenas um objeto para lidar com todas as solicitações. Esse objeto único 
interpreta a URLpara descobrir que tipo de requisição ele está tratando e cria um objeto 
separado para processá-la. Dessa forma você pode centralizar todo o tratamento 
HTTP em um único objeto, evitando a necessidade de reconfigurar o servidor Web 
toda vez gue alterar a estrutura de ação do síte. 


CAPITULO 4 • APRESENTAÇÃO WEB 77 

Leitura Adicional 

A maior parte dos livros sobre tecnologias de servidores Web fornece um capítulo 
ou dois sobre bons projetos de servidores, embora estes estejam freqüentemente 
imersos em descrições tecnológicas. Uma discussão excelente de projeto Web em 
Java é o Capítulo 9 de [Brown et nl.J. A melhor fonte para outros padrões é [Alur et 
nl.J; a maior parte destes padrões pode ser usada fora do ambiente em situações 
não Java. Roubei a terminologia de separar controladores de aplicação e de entrada 
de [Knight and Dai]. 


5

CAPÍTULO 

Concorrência 

por Martin owler e David Rice 

A
A
concorrência é um dos aspectos mais traiçoeiros do desen olvimento de software. 
Sempre que você ti er múltiplos processos ou thrends manipulando os 
mesmos dados, depara-e com problemas de concorrência. Pen ar a respeito 
d concorrAncia já é difícil, uma v z qu não ' fácil enum raro po í is c nan 
que podem lhe trazer problemas. Não importa o qu você faça, empre parec ha er 
algo que voc-esquec u. Além disso, a concorrência ' difícil d t star. Somos fãs d 
um grande número de te t automatizado atuando como ba e para o de en ol imento 
de software, mas é difícil obter te tes que no dêem a seguran a de que preciamos 
em relação a problemas de concorrência. 

Uma da grande ironia do de nvolvim nto de aplicaçõ corporativa , que 
poucos ramos do desen rol imento de software estão usando a concorrência, e menos 
ainda se preocupando com ela. O motivo pelo qual desen olvedores deste tipo de 
aplicação podem ter ta i ão ingênua de concorrência são os gerenciador s d tran


açã . A tran aç~ fom m umframework qu ajuda a vitar muito do a p ct 
mai traiçoeiro da concorrência em uma aplicação corporativa. Enquanto ocê executar 
toda ua manipulação de dado dentro de uma transação, nada de muito ruim 
irá lhe acont cer. 

Infelizmente, isso não ignifica que possamos ignorar completamente problemas 
d concorrência, pela razão bá ica de que muitas das interaçõ s com um sist ma 
não podem er colocada dentro de uma única tran ação com banco d dado . Is o 
nos força a gerenciar a concorrência em ituações em que os dados atra essam árias 
transaçõ s. O termo qu usamos , concorrência offliue, ou seja, controle de concorrAncia 
para dados qu s jam manipulados durante múltiplas tran ações com bancos 
d dad . 

A segunda área em que a concorrAncia mo tra eu lado nega ti o para os de envolvedore 
corporativos são os servidores de aplicações -suportar múltiplas threads 
em um servidor de aplicações. astamos muito menos tempo nisso, porque is o é 


CAPÍTULO 5 • CONCORRÊNCIA 7 9 

muito mais simples de lidar. e fato, você pode usar plataformas de ser idores que 
tomem conta de grand part di o para ocê. 
Infelizmente, para nt nd r es as qu stõ , vocA precisa compr nder p lo m nos 
algun do conceito gerai de concorrência. A im, começamo e te capítulo 

xaminando tai gue tõ s. ão temo a pr tensão de qu st capítulo seja um tratamento 
geral da cone rrência no de en ol imento de oftwnre-para tanto pr ci arfamos 
de pelo menos um livro inteiro. O que este capítulo faz é introduzir questões de 
e ncorrência para o d envolvimento d aplicações corporativa . A im qu ti ermos 
feito isso, introduziremos os padrões para lidar com concorrência offline e diremo 
brev pala ra obre concorrência em ervidore de aplicaÇ e . 

m grand parte d st capítulo ilustrar mo as id ' ias com xemplos d uma 
área c ma qual e p ramo que ocA teja familiarizado -i tema de control d 
código fonte u ados por equipes para coordenar alteraçõe em um código base. Fazemo 
isto porqu ele ão relati ament fáceis de ntender também ba tant conhecidos. 
Afinal, se você não esti er familiarizado com sistemas de controle de código 
fonte, você não de e e tar de en ol endo aplicaçõ s corporativas. 

Problemas de Concorrência 

Começaremos e amimmdo o problema bá ico da concorrência. hamamos de bá-
ico porque ão o probl ma fundam ntai que o i temas de controle d concorrência 
devem tentar impedir. les não são os únicos problemas de concorrência, porque 
o mecani mo de controle, muitas vezes, criam um no o conjunto de problema 
nas suas soluçõ s! Toda ia, el s nfocam o ponto básico do control de concorrAncia. 

Atualizações perdidas ão a idéia mai impl s d ent nd r. Suponha qu Martin 
dit um arquivo para faz r alguma alt raçõe no método erificarConcorrê c·a uma 
tarefa qu leva algun minuto . Enquanto le tá fazendo i o, David alt ra o 
método atua izarParâmetroimportante no mesmo arqui o. Da id começa e termina sua alteração 
muito rapidam nte, tão rapidamente que, embora tenha começado depois de 
Martin, termina antes deste. Isso é desastroso. Quando Martin leu o arquivo ele não 
incluía a atual ização d David, d modo qu quand Martin gra ar o arqui o 1 
gravará por cima da ersão que David atualizou s a atualizaçõ s rão p rdidas 
para sempre. 

Uma leitura inconsistente ocorre quando você lê duas informações que são 
corr tas, ma não ao me mo tempo. Suponha qu Martin de eja ab r quantas classes 
estão no pacote de concorrência, o qual contém dois subpacotes para bloqueio e 
multifa . Martin olha o pacote de bloqueio e vê ete da e . t moment l rec 
b uma ligação do Roy a resp ito d alguma que tão confu a. Enquanto Martin está 
falando ao t l fon , David t rmina de consertar aqu la falha ridícula no código d 
bloqueio em quatro fases e adiciona duas classes ao pacote de bloqueio e três classe 
à cinco qu tavam no pac te d multifa pó t 'rmino d eu telefon ma, 
Martin olha o pacote multifase para ver quantas classes há e ê oito, produzindo um 
total g ral d quinze. 

Infelizmente, quinze da ses nunca foi a resposta correta. Ar sposta correta era 
doz ant s da atualização do Da id dez te depois. Cada uma d ta r po tas 
t ria sido corr ta, mesmos não fosse a resposta corr ta corr ntement , mas quinz 
nunca foi corr to. t probl ma é chamado d 1 itura incon i t nt , p rqu o dados 
que Martin leu e tavam incon istentes. 


80 PARTE 1 • As NARRATIVAS 

Ambos os problemas causam uma falha de correção (ou segurança) e resultam 
em comportamento incorreto que não teria ocorrido sem duas pessoas tentando trabalhar 
com os mesmos dados ao mesmo tempo. Entretanto, se a correção fosse a única 
questão, esses problemas não seriam tão sérios. AfinaJ, podemos arranjar as coisas 
de modo que apenas um de nós possa trabalhar nos dados de cada vez. Embora isso 
ajude a correção, reduz a capacidade de fazer coisas concorrentemente. O problema 
essencial de quaJquer progxamação concorrente é que não basta se preocupar com a 
con eção, você também tem que se preocupar com a vivacidade do sistema: quanta 
atividade concorrente pode ser executada. Muitas vezes as pessoas precisam sacrificar 
umpouco de correção para ganhar mais vivacidade, dependendo da seriedade e 
da probabilidade de falhas e da necessidade de as pessoas trabaU,arem nos seus dados 
concorrentemente. 

Estes não são todos os problemas que você tem com concorrência, mas consideramos 
estes como sendo os básicos. Para resolvê-los, usé'lmos diversos mecanismos 
de controle. Infelizmente, não existe com.ida de graça. As soluções introduzem seus 
próprios problemas, emborn estes problemas sejam menos sérios que os originais. 
Ainda assim, isso nos traz uma questão importante: se voe<} puder tolerar os problemas, 
pode evitar qualquer forma de controle de concorrência; é raro, mas ocasionalmente 
você encontrn circunstâncias que o permitam. 

Contextos de Execução 

Toda vez que ocorre processamento em umsistema, ele ocorre em algum contexto e 

normalmente em mais de um. Não há. terminologia padrão para contextos de execu


ção, de modo que é'lqui iremos definir as que estamos pressupondo neste livto. 

Da perspectiva da interação com o mundo externo, dois contextos importantes 
são a solicitação e a sessão. Uma solicitação corresponde a uma única ché'lmada do 
mundo cxtemo sobre a qual o softwnre trabalha e pé'lra a quaJ opcionalmente l'Ctorna 
uma resposta. Dtu·ante uma solicitação, o processamento ocorre amplamente no lado 
do servidor e pressupõe-se que o cliente deva esperar por uma resposta. Alguns 
protocolos permitem que o cliente interrompa uma solicitação antes de obter uma 
resposta, mas isso é bastante raro. Com maior freqüência um cliente pode enviar outra 
solicitação que pode interferir com a que foi recém-enviada. Assim, um cliente 
pode solicitar permissão pMa colocar um pedido e então enviar uma solicitação separada 
para cancelar aquele pedido. Do ponto de visté'I do cliente, ns duas solicitações 
podem estar obviamente conectadas, mas, dependendo do seu protocolo, isso 
pode não ser tão óbvio para o servidor. 

Uma sessão é uma interação longa entre um cliente e umservidor. Pode consistir 
em uma única solicitação, mas, mais comumente, ela consiste em uma série de solicitações 
que o usuário considera como uma seqüência lógica consistente. É comum 
uma sessão começar com um usuário se logando e executando algum trabalho que 
podeenvolver algumas pesquisas e uma ou mais transações de negócio (a serem discutidas 
em breve). No final da sessão, o usuário se desconecta ou pode simplesmente 
ir embora e assumir que o sistema interprete isso como uma desconexão. 

O software servidor em uma aplicação corporativa vê tanto solicitações quanto 
sessões de dois ângulos, como o servidor do cliente e como o cliente para outros sistemas. 
Assim, você muitas vezes verá diversas sessões: sessões HTTP do cliente e 
sessões de banco de dados com diversos bancos de dados. 


CAPÍTULO 5 • CONCORRÊNCIA 81 

Dois termos muito importante de sistemas operacionais são os processos e os 
t/1read .O processo é um cont xto de execução normalmente pe ado qu fornece ba tant 
isolam nto para os dados int mos sobre os quais trabalha. A tlzread • um ag nt 
ativo de menor pe o que é configurado de modo que di er a tl1reads po am 
operar em um uruco proc o. A p oa go tarn de thrend porqu ela up rtarn 
múltiplas olicitações dentro de um único pro esso -o que é uma boa utilização de 
r cur o . A thrend entr tanto normalmente compartilham memória, e tal compartilhamento 
leva a problemas de concorrência. Alguns ambientes permitem que ocê 
control qu dado uma thrend pod ace ar, permitindo qu ocê tenha threads isoladas 
qu não compartilham m mória. 

A dificuldad com contexto de execução m quando ele s não alinham tão 
b m quanto gostaríamos. a teoria, cada essão teria um relacionamento exclusivo 
com um processo por todo seu ciclo de ida. Uma ez que processos são apropriadamente 
i olado entre i, i ajudaria ar <luzir conflito d concorrAncia. Atualmente 
não conhecemos quaisqu r ferramenta de ser idor que lhe p rmitam trabalhar 
a im. Uma alt rnati a próxima , com çar um novo proc o para cada solicitação, 
que era o modo comum nos prim iro sistemas Web Perl. s p ssoas t nd m a itar 
i o agora porqu iniciar proc o r térn muito r cur , ma é muito comum 
que sistemas façam um proces o lidar com apena uma solicitação de cada ez -e is-

pode evitar muita dor de cab ça causadas por concorr"ncia. 

Quando você stiv r lidando com bancos de dado , há outro contexto important 
-uma transação. As transaçõ s juntam di ersas solicitações que o cliente qu r 
qu jam tratada com f m uma única. la pod m oc rr r d uma aplicação 
para o banco de dados (uma tran ação d i t ma) ou do usuário para uma aplicação 
(uma transação de n gócio). Iremos nos aprofundar nes es t rmos mais adiant . 

Isolamento e Imutabilidade 

O probl mas d concorrência têm ocorrido há um c rto tempo, e as pessoa que lidam 
com oftware têm ncontrado di ersa oluçõ . Para aplicaçõ corporati as, 
<lua oluçõ ão particularmente importante : i olamento e imutabilidade. 

Problemas de concorrência ocorrem quando mais de um agente ativo, como um 
processo ou uma thread, tem acesso a uma mesma part dos dados. Urna rnan ira de 
lidar com isso é por meio do isolamento: particionar os dados de modo que qualquer 
part dei ó po a er ac ssada p rum ag nt ativo. proc o trabalham a sim 
na m mória d i t ma op racionais: o i t ma op racional aloca m mória xclu ivam 
nt para um único proce o, ap na e proc o pod l r ou gravar o dados 
ligados a ele. De modo similar, você encontra bloqueios de arquivo em muitas 
aplicaçõ d produti idade popular . S Martin abrir um arquivo, ninguém rnai 
pode abri-lo. Eles podem abrir uma cópia apenas para leitura do arquivo no estado 
em que e te e encontrava no mom nto em que Martin o abriu, ma não podem alterá-
lo e não conseguem v r o arquivo entre uas alteraçõ . 

isolam nto é uma técnica vit l porqu r duz a chanc d rros. Temos visto 
com muita fr qü Ancia p a n lv r m m pr bl ma , porqu u am uma t • enica 
que força todos a se preocuparem com concorrência durante o tempo todo. Com 
i olamento, você deixa as coi as de um modo que os programa entram em uma área 
isolada, dentro da qual ocê não tem que se preocupar com concorrência. Um bom 
projeto d concorrência ·, d ta forma, encontrar modo de criar tai área garantir 
que tanta programação quanto po ív l eja f ita em uma d la . 


82 PARTE 1 • As NARRATIVAS 

Vo ê só terá problemas de concorrência e os dados que estiver compartilhando 
puderem er modificado . D a forma, uma man ira de evitar conflitos d concorrência 
' reconh cer dados imutáveis. Ob iam nte, não podemos tornar todos os 
dado imutá eis, já que o objeti o de rnuHo i tema é a modificação de dado . 
C ntudo, id ntificando algun dado com imutá ei , ou p lo meno imutá i quase 
todo o tempo, podemos relaxar nos as preocupações com concorrência em relação 
a eles e compartilhá-lo amplamente. Outra opção és parar aplicaçõe que apena 
lêem dados e fazê-las usar fontes de dados copiados, nas quais podemos relaxar todos 
o controle de concorrência. 

Controles de Concorrência Otimista e Pessimista 

que acontece quando temo dado mutáveis que não podemos isolar? De um modo 
g ral, há dua formas d controle de concorrência que podemos u ar: otimista e 
pessimista. 

Suponhamos que Martin e Da id queiram editar o arquivo Clientes ao mesmo 
tempo. Com bloqueio otimista, ambo pod m fazer uma cópia do arqui o e ditá-la 
li r m nt . David for o prim ir a t rminar, 1 pod gravar u trabalho m problema. 
O c ntr lede concorrAncia ntra quando Martin t ntar perp trar ua alterações. 
esse momento, o sistema de controle de código fonte detecta um conflito entre 
as alterações de Martin e a de David. A confirmação de Martin é r j itada e é re pon 
abilidade dele de cobrir como lidar com a situação. om bloqueio pessimista, 
qualqu r p oa que pegu o arquivo ant e ita qu outra po a ditá-lo. D a maneira, 
s Martin for o primeiro a p gar o argui o, David não pod rá trabalhar com 
e e arqui o até que Martin t nha terminado e perpetrado ua alteraçõe . 

Uma boa maneira de pen ar obre is é que um bloqueio otimi ta e pr ocupa 
com a detecção de conflito enquanto que um bloqueio pe irnista se preocupa com 
apre enção de conflito . O i t ma d controle de código font p d m u ar ambo 
os tipos, embora atualmente mais desen ol edores de código fonte prefiram trabalhar 
com bloqueio otimistas. (Há um argumento razoável, segundo o qual o bloqu 
io otimista não 'realm nt um bloqueio, mas consid ramo a terminologia bastant 
e n eni nte difundida demai para er ignorada.) 

Amba a abordag n têm pró contra . O pr blema e m bl qu io p uru ta 
é que ele diminui a concorrência. nquanto Martin e tá trabalhando em um arguí


o ele o bloqueia, de modo que as outras pessoas têm de esperar. Se ocê já tiver trabalhado 
com si ternas de controle de código fonte pe simista , sab o quão fru trant 
isso pod ser. om dados corpora ti o , é fr qüentemente, pior porque, e alguém 
ti r ditand dado , ninguém mai p d l A -l , muito m n ditá-lo . 
bloqu io timi ta p nnit m à p a faz r m mai pr gr , porque o 
bloqueio só acont ce durante a confirmação. O probl ma com eles ' o que acontece 
quando você tem um conflito. Ba icarnent , todas a p oa apó a confirmação do 
David têm que erificar a versão do argui o que David gra ou, de cobrir como juntar 
uas alteraçõe com a do David então gravar a nova er ão. om código fonte i o 
não é muito difícil. D fato, em muitos casos o sistema de controle de código font pod 
fazer a junção automaticament para vocA , m smo quando l não pud r fazA-lo, 
f rramenta podem tomar muito mais fácil ver as dif r nça . Contudo, dados d n gócio 
ão n rmalrn nt difíc i d mai d ofr rem junção automaticam nt , d rn do 
que freqüentemente o que você poderá fazer é jogar tudo fora e começar de novo. 


CAPÍTULO 5 • CONCORRÊNCIA 83 

A essência da escolha entre bloqueios otimista e pessimista é a freqüência e severidade 
do conflito . S este for m uficientement raro ou as con quencias 
não for m grav s, ocA deve normalmente scolher bloqu ios otimistas porque l s 
lhe dão maior concorrência ão geralmente mai fácei de implementar. Entr tanto, 
o r ultado d um conflito for m doloro o para u uário , ocA pr ci ará 
usar uma técnica de bloqueio pessimista. 

nhuma dessa abordag n e tá li re d problema . Usando-as, ocê pode facilmente 
introduzir problemas que causem quase tanto prejuizo quanto os problemas 
bá icos de concorrência que você está tentando re olver. D ixaremo uma discu 
ão d talhada d a ramificaÇ para um livro apropriado obr concorrAncia, 
ma aqui e tão algun fato important a r m l mbrado . 

Evitando Leituras Inconsistentes 

Considere esta situação. artin edita a elas e ilentes, a qual efetua chamadas para 
a ela P <lido . Enquanto i o, David dita a da P <lido e alt ra a interfac . David 
compila e grava. Martin então compila e grava. Agora o código compartilhado 
está estragado porque Martin não perceb u que a ela se Pedido foi alterada. Alguns 

i t mas de ontrol de código font irã I calizar e ta leitura inconsi t nt , ma outr 
requ r m algum tipo d di ciplina manual para impor c n i tAncia, com atualizar 
seus arqui os antes de gravá-los. 

a essência, este é o problema da inconsistência de leitura e, muitas, vezes é fácil 
não vê-lo, porqu a maioria da pe oa tende a focar as atualizações perdida como 
o probl ma essencial na cone rrAncia. bloqueios p simistas têm um j ito 
muito u ado d lidar com e t pr bl ma por meio d bl qu io d 1 itura e d gravação. 
Para 1 r dado ocê pr cisa d um bloqu io d 1 itura (ou bloqu io compartilhado). 
Para gra ar dados ocê preci a de um bloqueio de gra ação (ou bloqueio exclusivo). 
uitas pessoas podem ter bloqueios de leitura sobre um mesmo dado ao 
me mo tempo, ma , e alguém ti rum bloqueio de leitura, ninguém pode obter um 
bloqueio de gra ação. ln ersamente, assim que alguém ti er um bloqueio de gra ação, 
ninguém mai poderá ter qualqu r tipo de bloqueio. Com s e istema, você 
consegu vitar leituras inconsistentes com bloqu ios p ssimistas. 

bloqu io otimistas normalm nt ba iam sua d t cção d conflito m algum 
tipo de marcad r d ver ão br o dad . E te pod er um time tnmp ou um 
contador seqüencial. Para detectar atualizações perdidas, o sistema compara o marcador 
de ersão da sua atualização com o marcador de ver ão dos dado compartilhados. 
Se eles forem o mesmo, o sistema permite a atualização e atualiza o marcador 
de ver ão. 

D t ctar uma I itura inc n i t nt m lhant : n t ca o ada part d dados 
qu foi lida precisa ter s u marcador d ver ão comparado com o dados compartilhado 
. Qualquer diferença indica um conflito. 

Controlar o ace soa cada part do dado que , lida, muita vezes, cau a problemas 
desnecessários de ido a conflitos ou esperas dos dados que não importam tanto. 
Você pode r duzir e e fardo eparando dado que u ou do dado que merarn nte 
leu. Em uma lista de escolha de produto , não importa se um no o produto aparecer 
apó ocA com çar ua alteraçõ s. ntr tanto, uma lista d pagam nto qu você e t 
ja r sumindo para uma conta pod s r mais important . A dificuldade ' que isso r qu 
r uma análi cuidad a d motivo p lo qual , u ad . Um código p tal m um 
endereço de um cliente pode parecer inócuo, porém se um cálculo de taxa for basea



84 PARTE 1 • As NARRATIVAS 

do em onde alguém mora, esse endereço tem que ser controlado quanto à concorrência. 
Como ocê pode ver, descobrir o que é e o que não é preciso controlar é um exercício 
intrincado, não importa qual forma de controle d c ncorrAncia voe A us . 

Outra man ira d lidar com probl ma d l itura inconsi t nt ' u ar Leituras 
Temporais. Ela a sina Iam cada 1 irura d dad com algum tip d time ta111p ou rótuJ 
imutáv l, e o banco de dado r toma o dado como le e tavam de acordo 
com aquele tempo ou rótulo. Muito poucos bancos d dados têm algo assim, mas os 
de nvolvedore muita vez e d param com i o em i tema de control d código 
fonte. problema ' que a fonte de dado precisa fornecer urna história temporal 
completa das alterações, o que ga ta tempo e espaço para proc ssar. Is o 'razoáv 
I para código font , p rém , mai difícil cu to para banco d dado . Vi cê p de 
preci ar fornec r a capacidad para área e pecífica da ua lógica de domfrtio: 
v ja m [Snodgra ] [Fowl r TP] id 'ia d como faz ri o. 

Deadlocks 

Um problema particular com técnicas pessirrtista é o dendlock. Suponha qu Martin 

com c a editar o arquivo Li ntes, e David com ce a editar o arquivo Pedido . Da


vid p rc b qu , para completar ua tar fa, pr ci a editar o arquiv Client tam


b 'm, por'm Martin t mo bloqu io d st arqui o, d forma qu 1 t m que sperar. 

Martin ntão p rc b qu t m qu ditar o arquivo P did , qual foi bloqu ado por 

David. El se tão agora em deadlock-nenhum dos dois pode avançar at' que o outro 

t rmin . D cri to a irn, o deadlock parec m fácei d evitar, ma l podem ocor


rer com muita pe oa en olvida em uma cadeia complexa, e is o o toma mai 

traiço iros. 

Há vária técnica u ada para lidar com deadlock . Uma t r oftware que con


iga d tectar um dendlock quando el ocorrer. e se ca o você escolhe uma vítima, 
que tem que jogar fora eu trabalho eu bloqueio de modo que o outro p s am 
avançar. A det cção d deadlock é muito difícil cu to a para a vítima . Uma abordag 
m similar ' dar a cada bloqueio um limite de t mpo. Assim que você chegar ne 


limit , p rd eu bl qu i u trabalho -ba icam nte tomando uma vítima. 
Mecanismo de tempo limite ão mai fáceis de implementar do que um mecanismo 
de det cção d deadlocks, porém, e alguém egurar um bloqueio por certo tempo, alguma 
p oa erão itimada quando não houver realmente deadlock . 

Os tempos limite e detecção de deadlocks lidam com um deadlock quando el 
o orre. Outras abordagen t ntam itar qu o dendlocks ocorram. Deadlock ocorr m 
basicament quando p ssoas qu já têm bloqu ios tentam obt r mais (ou passar d 
bloqueios de leitura para de gravação.) A sim, um modo de preveni-lo é forçar a 
pessoas a obter todos os seus bloqueios de uma ó vez, no início do seu trabalho e, 
então, evitar que elas obtenham mais. 

Você pode forçar uma ordem pela qual todos obtenham seus bloqueios. Um 
exemplo seria ser obter sempre os bloqueios sobre os arqui os em ordem alfabética. 
Desta maneira, já qu David tinha um bloqueio obre o arquivo Pedido , ele não pode 
tentar obter um bloqueio obre o arquivo Cli ntes, porque st 'anterior nas quencia. 
sse momento, le basicam nte s torna uma vítima. 

VocA tamb 'm pod fazer com qu , s Martin t ntar obt rum bloqu io Da id 
já tiver um, Martin automaticamente se torne uma vítima. uma técnica drá tica, 
mas é imples de implementar, e, em muitos casos, tal e quema funciona bem. 


CAPÍTULO 5 • CONCORRÊNCIA 85 

e você for muito conservador, pode usar múltiplos esquemas. Por exemplo, 
voe" força todo a obter todo o eus bloqu io no início, ma acrescenta um tempo 
limite para o caso de algo dar rrado. Isso pode par cer como usar um cinto e suspen 
ório , ma tal con er ad ri mo é muita eze ábio com r lação a deadlock , 
porqu e te ão coi a d agradáv i qu facilm nt dã rrado. 

É muito fácil pensar que você tem um e quema à prova de deadlocks e depois 
de cobrir alguma cadeia de event qu não con iderou. re ultado di o ' que pr ferimos 
esquemas muito simples e conser adores para o desen ol imento de aplicaçõe 
corporativas. Elas podem causar vítima desnec sárias, mas é geralmente muito 
melhor do que as conseqü"'ncias de esqu cer algum cenário d deadlock. 

Transações 

A principal ferramenta para lidar com concorr"'ncia em aplicaçõe corporativa , a 
transação. A palavra "transação" muitas rezes traz à mente uma troca de dinheiro ou 
de ben . Ir at' wn caixa el trônico, digitar eu código r tirar dinheiro , uma tran


ação. Pagar $3 d taxa na Gold n Gat Bridg é uma transação. Comprar uma e rveja 
no bar local ' uma transação. 

Olhar para negócios financeiros típicos como ess s fornece uma boa definição 
para o t rmo. Prim iro, uma transação , uma s qü "'ncia limitada de trabalho, com 
ponto de início e fim bem definidos. ma transação em um caixa eletrônico começa 
quando o cartão é in erido e termina quando o dinheiro é entregue ou uma falta 
de fundos é descoberta. Em segundo lugar, todos os recursos participantes estão 
em stado con i tente tanto quando a tran ação começa como quando ela termina. 
Um hom m comprando uma c rv ja t m algum dinh iro a m nos na sua carteira, 
ma tem uma b la c rv ja na ua frente. O omatório do u ben não mudou. 
mesmo vale para o bar -servir cer eja de graça não seria uma maneira de conduzir 
um n g'cio. 

Além disso, cada transação de e ser completada em uma base de tudo ou nada. 
O banco não pode subtrair do saldo de uma conta a não er que o caixa eletrônico 
realm nt ntr gue o dinheiro. Embora o l m nto humano pud ss tornar esta última 
propriedade opcional durante a tran aç~e acima, não há razão para qu oftware 
não po a criar uma garantia. 

ACID 

As transações de software são freqüentemente descritas em termos de propriedades 
ACID: 

• Atomicidade: Cada pa sona seqüência de ações executadas no cont xto d 
uma tran ação dev er completado com uces o ou então todo o trabalho 
de e ser desfeito. A conclusão parcial não é um conceito transacional. Assim, 
e Martin e ti er tran ferindo algum dinheiro de ua c nta poupança para 
sua conta corrente, o servidor sofrer uma pane após ter retirado o dinheiro 
da conta poupança, o si tema comporta com s nunca tives e x cutado 
essa r tirada. Confirmar (committing) diz que ambas as coi as ocorr ram. 
D faz r (ro/l back) ignifica qu n nhuma acont e u. 1i m qu r a <lua 
coisas ou nenhuma. 


86 PARTE 1 • As NARRATIVAS 

• Consistência: s recursos de um sistema de em estar em um estado consist 
nte e não corrompido tanto no início quanto no final de uma transação. 
• Isolamento: O resultado de uma tran ação individual não d ve r 1s1 el 
para outras transações abertas até que a transação confirme sua execução 
c m uc o. 
• Durabilidade: Qualquer re ultad d uma tran açã confirmada d er 
permanente. Is o é traduzido para "deve obrevi era qualquer tipo de falha". 
Recursos Transacionais 

A maior parte das aplicações corpora ti as se depara com tran ações no uso de banco 
de dado . Por'm há muitas outras coisa que podem er controlada pelo u o de 
tran açõe , como fila de men agens, impre soras ATM . O resultado di o é que 
discussões t ' cnicas sobr transaçõ s usam o termo"recurso transacional" para qualquer 
coi a que eja tran acional -u ja, que u tran aÇ para c ntr le d c ncorrência. 
"Recurso transacional" é um termo um pouco longo, então usamos apenas 
"banco de dad ", já que e é o ca o mai comum. Contudo, quando dizem 
"banco de dados", o mesmo se aplica para qualquer outro recurso transacional. 

Para obter a maior transferência de dados pos ível, si tema transacionais moderno 
são projetados para manter as transaçõe tão curtas quanto pos í el. orno 
con qüência dfaso, o conselho geral é nunca faz ruma transação durar por múltipla 
olicitaçõe . Uma tran ação que dura por múltipla olicitaçõe é geralment conh 
cida como uma transação longa. 

Por ssa razão, uma abordag m comum é começar uma transação no início de 
uma olicitação e compl tá-la ao final. Esta transação de solicitação ' um ótimo modelo 
imple , e ário ambient tornam fácil fazê-la declara ti ament , impl mente 
identificando métodos como transacionais. 

Uma variação , abrir uma tran ação o mai tard po ível. Com uma transação 
tardia, você pode executar todas as leituras fora dela e apenas abri-la quando executar 
a atualizaç~es. I o tem a antag m de minimizar o tempo ga to em uma transação. 
Se houver um tempo longo entr a abertura da tran ação e a primeira escrita, is-

o pode melhorar a vi acidade. ntretanto, significa que você não tem nenhum control 
d concorrAncia até qu com c a tran ação, o qu 1h d ixa uj ito a l itura incon 
i t nt . Como con qüAncia, normalm nte não val a p na faz ri o, a m no 
que ocê tenha uma di puta muito grand ou o steja fazendo de ido a tran ações 
de negócio que atrave am múltipla olicitações (o qu é o próximo tópico). 
Quando voe A usa transaçõ s, pr ci a de alguma forma tar ciente do que xatamente 
está bloqueado. Para muitas ações do banco de dados, o sistema de transaç 
bloqueia a linha envolvida , o qu permit qu múltipla tran açõ ace m 
a mesma tabela. Entretanto, se uma transação bloquear muitas linhas de uma tabela, 

o banco de dado tem mai bloqueio do que con egue lidar e amplia o bloqu io para 
a tab la inteira -bloqueando outras transações. Esta ampliação de bloqueio pod 
t r ef itos érios obr a concorrência, ' xatam nt por i o qu ocA não dev ter 
alguma tabela "obj to" para dado no nív 1Camada Supertipo (444) do domínio. Tal 
tab la é uma forte candidata à ampliação do bloqueio, bloqu ar sta tabela imped 
o ac de todos o outro ao banco de dado . 

CAPÍTULO 5 • CONCORRÊNCIA 87 

Reduzindo o Isolamento Transacional para Aumentar a Vivacidade 

É comum re tringir a proteção completa da tran ações, de modo que você po a ob


ter mai vivacidade. I o é particularment oca o ao lidar comi olam nto. S voe 

ti er isolamento integral, obtém transações serializáveis. As transações são serializá


veis e puderem ser executadas concorrentemente e ocê obti er um resultado igual 

ao qu obt ria da x cução s rial d ssas transaçõ s. Assim, s p garmos nosso xem


plo ant rior do Martin contand u arquivo , a capacidad d rializar garant 

que ele obtenha um re ultado que corre ponde a concluir ua tran ação compl ta


mente antes que a tran ação do David com c (doze) ou compl tament apó ela t r


minar (dezessete). Capacidade de serializar não pode garantir o resultado, como nes


t ca o, mas pelo meno garante um re ultado correto. 

A maior parte dos ist mas tran acionais u a o padrão SQL, o qual define quatro 
nívei dei olam nto. O rializável é o nível mai fort , cada nív 1 abaixo permit 
qu um tipo particular d l itura inconsist nt ntr me na. Nós os xploraremo 
com o exemplo do Martin contando arqui o nquanto Da ido modifica. Há 
dois pacotes: bloqueio e multifase. Antes do David atualizá-lo há ete arqui os no 
pacote de bloqueio e cinco no de multifa e. Após sua atualização, há nove no d bloqueio 
e oito no multifase. Martin olha o pacote de bloqueio e Da id então atualiza 
ambo . A eguir, Martin olha o pacote multifase. 

S o nív l d i olam nt f r erializáv 1, o i t ma garant qu a r po ta do 
Martin eja doz ou dezesset , ambas corr tas. A capacidad de s rializar não pod 
garantir que toda xecução d t cenário dê o me mor suJtado, mas e t ernpre obtém 
o número antes da atualização do Da id ou o número depois. 

O primeiro nível dei olam nto abaixo da erialização é a leitura repetível, que 
permite fantasmas. Os fantasmas ocorrem quando você adiciona alguns elementos a 
uma coleção, e o leitor vê apena algun deles. O caso aqui é que Martin ê os arquivo 
no pacote d bloqu io nx rga t . David ntão confirma ua transação, apó 

o que, Martin ~ o pacot multifa nx rga oit . C n qü nt m nt , Martin obt' m 
um resultado incorreto. Os fantasmas ocorrem porque eles são vál idos para uma part 
da transação de Martin, mas não para toda la, e eles são sempre coisas que foram 
inseridas. 
A seguir, na lista, está o ní el dei olam nto leitura confirmada, que permite 
leituras não repetíveis. Imagin que Martin olh um total em v z do arqui os reai . 
Uma l itura não-r p tív l p rmit a le ler um total de te para bloqu io. s guir, 
David confirma a gra ação e 1 ntão l A um total d oito para multifa . É chamada 
leitura não-repetível porque, se Martin fosse reler o total do pacote de bloqueio após 
David t r confirmado a gravação, ele obteria o no o número nove. Sua leitura original 
do número sete não pode ser repetida após a atualização de Da id. É mais fácil 
para banco de dado localizar leituras não-repetíveis do que fantasmas, de modo 
que a 1 itura r petí l lh dá mai corr ção do que 1 ituras confirmada , ma m no 
c ncorrência. 

m nor nív l d i olamento , a leitura não-confirmada, qu p rmite leituras 
sujas. a leitura não-confirmada, ocê pode ler dados que outra transação 
ainda não e nfirmou. I o cau a doí tipo de erro . Martin poderia ver o pacote 
d bloqu io enquanto Da id adicionava o primeiro dos seus arqui os, ma antes 
qu l acr c ntas os gundo. O r ultado di o ' que l A oito arqui o no 
pacote d bloqueio. s gundo tipo d erro ocorr s David adiciona seus arquivo 
, ma d faz ua tran ação -n teca o Martin vA arquiv qu nunca ti ram 
realmente lá. 


88 PARTE 1 • As NARRATIVAS 

A Tabela 5.1 lista os erros de leitura causados por cada ní el de isolamento. 

Para e tar guro da corr ção, você de e empre u ar o ní el de i olam nto rializáv 
1. O problema , qu scolh r os rializá el atrapalha a ivacidad d um sistema, 
tanto qu muita veze ocê tem qu reduzir a capacidade de erializar para 
aum ntar a quantidad d dad tran f rido . Voc A tem qu d cidir qu ri co quer 
tomar e fazer seu próprio balanço entre erros e desempenho. 

Você não tem que u ar o me mo nív l de i olamento para toda a tran açõe , 
de modo que deve ver cada transação e decidir como balancear vivacidade versus 
correção. 

Transações de Negócio e de Sistema 

O que nós falamos até agora, e a maior parte do que as pessoas falam, é o que chamamo 
de tran aç~ de i tema, ou tran ações uportada por i tema de gerenciamento 
d bancos de dados relacionai (RDBMS) e monitore de tran açõe . Uma 
tran ação d banco d dados ' um grupo d comando SQL d limitado por in truçõ 
s para com çar e terminá-lo. Se a quarta decla1·ação na transação r sultai· m uma 
violação der trição d int gridad , o banco de dado d d faz r o efeitos da 
primeira trê declarações e notificar o solicitante de que a transação falhou. Se todas 
a quatro d claraç-e tive em ido completada com uc o, toda teriam ido tornadas 
visí eis para os outros usuários ao mesmo tempo, e não uma de cada vez. Gerenciador 
s d transaçõ sem sist mas RDBMS em r idor s de aplicações são tão 
comuns qu podem não r c b r tanta at nção. les funcionam b m ão bem compr 
enclido pel de nvol dore d aplicaÇ . 

Todavia, uma tran ação de istema não tem ignificado para o usuário de um 

istema de negócio . Para o usuário de um istema de banco online uma tran ação 
consiste em se logar, selecionar uma conta, configurar alguns pagamentos e finalmente 
clicar no botão OK para pagar a conta . I so é o que chamamo de uma transação 
de negócio, par c uma xp ctativa razoáv 1 qu la apr nt a m ma 
pr priedade ACID c mo uma tran açã d i t ma. S u uário cai-\C la1· ante d 
pagar as contas, quaisquer alt rações feita nas telas anteriore devem ser canc ladas. 
Fazer pagamentos não dever sultar em uma alt ração de saldo i í el para o 
sistema até que o botão OK seja pressionado. 

Ar po ta óbvia para uportar a propri dad ACID de uma tran ação d negócios 
, xecutar e a transação inteira d ntro de uma única transação d ist ma. 
Infelizment as tran açõe de negócio muita veze precisam de cli, ersas olicitaçõ 
para r m compl tada , de modo que u ar uma única tran ação d i tema para 
implementá-lar ulta em uma tran ação de i tema longa. A maioria do i tema 
de transação não funciona muito eficientemente com transações longas. 

Tabela 5.1 Níveis de Isolamento e os Erros de Leitura Inconsistente que Permitem 

Nível de Isolamento Leitura Suja Leitura Não-Repetível Fantasmas 
Leitura Não-Confirmada Sim Sim Sim 
Leitura Confirmada Não Sim Sim 

Leitura Repetível Não Não Sim 
Serializável Não Não Não 


CAPÍTULO 5 • CONCORRÊNCIA 89 

Isso não ignifica que você nw1ca deva usar transações longas. e o eu banco 
de dado tiver omente nece idad mod rada d concorrência, la podem funcionar 
para vocA. E, se las funcionar m para ocA, sugerimos usá-las. Enti·etanto, a 
aplicação não rá e calá 1, porque tran ações longa tran formam banco de dados 
em um gargalo importante. Al 'm di o, a refatoração de tran aÇe longa para 
curta é compl xa mal compreendida. 

Por este moti o muitas aplicações corporativas não podem arriscar transações 

longa . es e caso, você tem que dividir a tran ação de negócio em uma s 'rie d 
tran aç~ curta . I o ignilica que você terá qu dar u jeito para up rtar a propriedad 
ACID de transaçõ s de negócio ntre transaçõ de sistema um 
probl -

ma que chamamo de concorrência offline. A transaçõe de i tema ainda fazem 
part da c na. S mpr que tran ações d negócio interagem com um recur o tran acional, 
corno um banco de dado , a interação irá ex cutar dentro d uma tran ação 
de sistema para que se mantenha a integridade desse recurso. ontudo, como 
você lerá a eguir, não ' suficiente conectar uma érie de transações de isterna para 
suportar apropriadam nte uma tran ação de negócio. A aplicação de negócio dev 
con ctar a tran açõ d i tema. 

A atomicidad e a durabilidad ão a propriedade ACID mai facilmente suportadas 
em transaçõe d negócios. Ambas são suportadas x cutando-s a fas d 
confirmação da tran ação de negócio, quando ou uário pr iona " ravar", d ntro 
de uma transação de sistema. Antes que a sessão tente gra ar todas as alterações para 
o conjunto der gistro , la primeiro abre urna tran ação de si tema. A tran ação 
de sistema garante que as alterações sejam gra adas como uma unidade e as torna 
p rmanent s. A única part pot ncialm nt traiço ira aqui ' a manut nção d um 
c njunt pr ci d alt raçõ durant a vida da tran açã de neg ' cio. S a aplicação 
u ar um Modelo de Domínio (126), uma Unidade de Trabalho (187) pode rastr ar a alteraçõ 
s com preci ão. Colocar lógica de n gócio em um Roteiro de Tran açifo (120) requer 
um rastreamento manual das alterações, mas isso pro a elmente não é um probl 
ma já que o u d roteiro de tran ação ugere tran açõe imple de n gócio . 

A propriedade ACID mais traiçoeira de garantir em transações de negócios é o 
i olarn nto. Falha d isolam nto 1 am a falhas d con istAncia. A consistAnci, determina 
que urna transação de negócio não deixe o conjunto de regi tro em um e tado 
inválido. D ntro d uma única tran ação, a r pon abilidade da aplicação no 

up rt à con i tência é forçar o r p ito a toda a regra de n gócio di ponív i . Ao 
longo de múltiplas transações, a responsabilidade da aplicação é assegurar que uma 
e ão não atropele as alteraçõe d outra se ão, deixando o conjunto d regi tro no 

stado inválido de ter p rdido o trabalho d um usuário. 

A im como o probl ma óbvio da coli ão de atualizaçõe , há problema mais 
sutis de leituras inconsistentes. Quando dados são lidos por di ersas transações de 

istema, não há garantia de qu e tarão consistentes. As dif r nt l itura pod m 
até introduzir dado na m mória que t jam uficientem nt inc n i t nte para 
causar falhas na aplicação. 

As tran ações de negócios estão intimamente ligadas a se sões. Na isão do 
usuário, cada essão é uma seqüência de transações de negócios (a não ser que eles 
e tejarn apena lendo dado ), d modo que normalmente pr supomo qu toda a 
transaçõ s de n gócio ex cutam m uma única sessão cliente. Embora c rtament 
ja po í 1 proj tar um si t ma qu t nha múltipla ssõ para uma transação d 
n gócio, est é um modo muito bom de confundir -de maneira qu pre upomos 
que ocê não irá faz ris o. 


90 PARTE 1 • As NARRATIVAS 

Padrões para o Controle de Concorrência Offline 

Tanto quanto possí el, você deve deixar o seu sistema de tran açõ lidar com problemas 
d concorrência. Tratar controle de concorrência que atra essa várias transaçõ 
d i t ma faz com qu vocA mergulh na água turva d t r vocA m m qu 
lidar com a concorr"ncia. Es as água tão eh ias d tubarõ virtuais, águas-vi a , 
piranha outras criaturas m nos amigáv is. Inf lizm nt , o d sacordo ntre tran ações 
de negócios e de sistema significa que às vezes ocê tem que suar a camisa. s 
padrõ s que fornecemos são algumas técnicas que achamos úteis para lidar com controle 
d concorrência que atra a tran aç-de i t ma. 

L mbre-se d que essa sao técnicas que vocA ó deve usar se tiver que faz A -lo. 
Se puder fazer com que todas a suas tran açõ s de negócio s ajust rn em uma 
transação d si t ma, a s gurando-de qu la aibam d ntro d uma única solicitaçã 
, ntão faça i o. S cê pud r irar c m tran açõe longa r nunciando à e calabilidade, 
então faça i so. Dei ando o controle de concorrência nas mão do seu 
software de transações, você vitará uma grande quantidade de problemas. E tas técnicas 
são o que ocê tem que usar quando não puder fazer isso. Devido à natureza 
traiço ira da concorrência, temo que enfatizar novamente que o padrõ ão um 
ponto d partida, não um d tino. D cobrimo que l ão úteis, ma não al gamos 
ter encontrado uma cura para todo os male da concorrAncia. 

os a prim ira colha para lidar com probl mas de concorr"ncia offline 'o Bloqueio 
Offline Otimi ta (392), que ba icament u a control de concorrência otimista ao 
longo das transações de negócios. Gostamos desta como primeira escolha porque é 
uma abordagem mai fácil de programar e fomec a melhor ivacidade. A limitação 
do Bloqueio Offline Otimista (392) é que ocê só de cobre que uma transação de negócio 
irá falhar quand t nta confirmá-la , m alguma circun tância , o cu t d ta 
d cob rta tardia ' muito alto. U uário pod rn t r p retido uma hora d trabalho entrando 
com detalhe sobr um empré timo e voe" ti r muita falha 1 s p rd rão 
sua confiança no sistema. Sua alternativa é o Bloqueio Offline Pessimista {401), com 

o qual você de cobre cedo se tem problemas, mas sai perdendo porque é mais difícil 
de programar e reduz a vivacidad . 
Com qualquer de a abordagens, você pode diminuir con ideravelmente a 
complexidade se não tentar gerenciar os bloqueios em todos os objetos. Um Bloqueio 
de Granularidade Alta (412) permite qu voe A g r nci simultan am nt a concorrAncia 
d um grupo d bjet . Outra man ira d voe A tornar a vida d d n ol dores 
de aplicaçõe mais fácil é u ar Bloqueio Implícito (449), o qual o poupa de ter que 
g renciar os bloqueios dir tamente. Isso não apenas poupa trabalho como também 
evita falhas quando as pessoas esquecem -e essas falhas são difíceis de serem encontrada 
. 

Uma d claração comum sobr concorrência é qu ela ' uma decisão purament 
técnica que pode er tomada apó o requisito e tarem completo . Nó di cordamos. 
A escolha d control s otimista ou pessimista af ta toda a xperi"ncia do usuário 
com o i tema. Um proj to int lig nt do Bloqueio Offl.ine Pe imi ta (401) pr ci a 
de muita informação a respeito do domínio pro eniente dos usuário do sistema. De 
modos melhante, conhecimento do domínio é neces ário para escolher bons Bloqueio 
de Granularidade Alta (412). 

Brincar com concorrência é uma da tar fa d programação mai difícei . 
muito difícil t tar código concorr nt com confiança. Falha d concorr"ncia ão difíc 
i d r m r produzida muito difíc i d ra tr ar. O padrõ qu de cr 


CAPÍTULO 5 • CONCORRÊNCIA 91 

mos funcionaram para nós até agora, ma este é um território particularmente difícil. 
S voe" preci ar ir por caminho, val a p na obt r um pouco de ajuda exp rien


t . P lo m nos consulte os livros m ncionados no final d ste capítulo. 
Concorrência em Servidores de Aplicação 

Até agora falamo obre concorrência, principalment em termo d múltipla e õe 
rodando sobre uma fonte de dados compartilhada. Outra forma de concorrência é a 
do proce o do próprio er idor d aplicações: como e e ervidor lida com di er a 
olicitaçõ s concorr ntement e como jsso afeta o proj to da aplicação nos rvidor? A 
grand dif rença da outra que t-de concorrência bre a quai falamo ' que a 
concorrência d ervidor d aplicaÇ nã nvolve tran açõe , de m do qu trabalhar 
com elas ignifica um afastamento do relativamente controlado mundo transacional. 

A programação multithrend explícita, com bloqueios e blocos de sincronização, 
é complicada de er bem feita. É fácil introduzir defeito que ão muito difíc i d 
d obrir-falha d concorr"ncia ão qua impo í i d r produzir-r ultando 
em um i tema qu funciona e rr tament 99% do t mpo, ma falha aleatoriam nte. 
Tal oftware é incrivelmente frustrante de usar e depurar, de modo que nossa poUtica 
é evitar tanto quanto possí el a necessidade d manipulação xplícita de incronização 
e bloqueios. Os desenvolvedores de aplicações não de em quase nunca ter que 
lidar com esses mecanismos explícito de concorrência. 

A man ira mai simple d lidar comi o é u ar processo-por-sessão, em qu 
cada es ão roda no eu próprio proce o. Sua grande antagem ' qu o e tado de 
cada proc s o ' compl tament i olado do outro proc o , d modo qu o programador 
de aplicaçõ não têm qu preocupar com multithrending. Até onde o 
isolamento de memória abranger, é quase que igualmente eficaz fazer cada solicitação 
iniciar um novo proc o ou ter um prece o a ociado à s ão que e ti er ciosa 
entre as solicitaçõ s. Muitos dos primeiros sistemas Web iniciavam um novo prece 
so Perl para cada solicitação. 

probl ma do pro o-por-e ao qu l u a muito r cur o , uma v z qu 

o prece ã cu to . Para er mai fiei nt , oc" pod fazer um poo/ de prece os, 
de modo que cada um lide apenas com uma única olicitação de cada vez mas 
po sa lidar com múltiplas olicitaçõ s d diferentes sessões em uma seqüência. Essa 
abordagem de um pool de processos-por-solicitação usará muito menos processos 
para up rtar um dado númer d e õe . u i olamento é qua e tão bom: você 
não t m muitas da complicada qu stõ d nwltitl1rendin . O probl ma principal do 
proce o por olicitação em relação ao pr ce o-por-e ão é que ocê t m que a egurar 
que quaisquer recursos u ado para manipular urna olicitação sejam liberado 
ao final da olicitação. A ver ão atual do Apach mod-perl usa este squema, a sim 
como fazem muitos dos sistemas de processamento de transação de larga escala. 
Até me mo o proce o-por-olicitação irá pr cisar de muitos prece o rodando 
para lidar com uma carga razoável. Voe" pode melhorar ainda mais a quantidad 
de dado tran ferido fazendo um único proce ex cutar múltipla thrends. Com 
e ta abordagem thread-por-solicitação, ada olicitação é manipulada por uma única 
thread dentro d um proce o. Já qu a tlzread u am muito m no recurso do ervidor 
do que um processo, ocê pode lidar com mais solicitações com menos hardware, 
de modo que eu servidor fica mais eficiente. O problema com ou o de tlzread-por


olicitação é qu não há isolam nto ntr as thread , qualqu r tl,rend pod p gar alguma 
parte d dado a qual ti r ac 


92 PARTE 1 • As NARRATIVAS 

Na nossa visão, há muito a ser dito sobre o uso de processo-por-solicitação. Embora 
seja meno eficiente do qu thread-por-olicitação, usar proce so-por-olicitação 
é igualmente escalável. Você também obtém m lhor robustez -s uma das threads 
sair de controle, ela pode trazer abaixo o proces o inteiro, de forma que usar proce 


o-por-olicitação limita o e trago. Esp cialm nte com uma quip m no experi nte, 
a redução dos problemas causados por tlzreads (e o tempo e custo de consertar falhas) 
justifica os custos extra de hardware. Acreditamos que poucas pessoas realmente 
executam algum teste de desempenho para estimar os custos relativos de t/1readpor-
solicitação e processo-por-solicitação para suas aplicaçõ s. 

Alguns ambientes forn cem um meio-termo p rmitindo qu áreas isoladas d 
dado jam d ignada a uma única thread. COM faz i o com apartam nto d uma 
única thread, e J2EE faz isso com Enterprise Ja a Beans (e no futuro fará com isolamentos). 
S sua plataforma tiver disponível algo parecido com isso, ela pode permitir 
que você faça e coma seu próprio bolo -seja lá o que isso signifique. 

Se você usar t/irend-por-olicitação, o mais importante é criar e nb·ar em uma 
zona isolada onde os desenvolv dor s de aplicaçõe podem na maior parte das vez 
s, ignorar questões relati as a multithreadíng. O modo usual d fazer isso é 1 vara 
thread a cliar novos objetos quando ela inicia o tratamento da solicitação e assegurar 
que e e objeto não ejam colocado em algum lugar (como em uma variável estática) 
onde outras threads possam vê-los. Dessa maneira, os objetos ficam isolados porque 
outras thread não têm como referenciá-los. 

Muitos desenvolvedores estão preocupados com a c1·iação de novos objetos 
porqu lhes foi dito qu a criação de obj tos é um proc sso custoso. Ore ultado dis


o é que ele muita vezes criam um pool de objeto . problema com a criação de 
pool é que você tem que sincronizar o ace o ao objetos do pool de alguma maneira. 
Contudo o custo da criação de objetos depende muito da máquina virtual e das estratégias 
de gerenciamento de memória. Em ambientes modernos, a criação de objetos 
é realmente bastante rápida [Peckish]. (Quantos objetos Java para datas você acha 
qu podemo criar em um egundo no P3 600 Mhz do Martin comJav, 1.3? Nó 1h 
diremo mais adiante.) Criar objeto novos para cada sessão vita muita falha de 
concorrência e pod reahnente aum ntar a escalabilidade. 
Embora essa tática funcione em muitos casos, ainda há algumas áreas que os de-

envolvedores preci am evitar. Uma são as variáveis estáticas baseadas em ela e ou 
variáveis globais, porque qualquer uso delas precisa ser sincronizado. Isso também é 
v rdad para ingleton . Se voe~ pre i ar de algum tipo d memória global, u. um Registro 
(448), o qual você pode implementar de tal modo qu el s par ça com uma variáv 
I tática, ma que na verdade us armazenam nto esp cífico para tlzread. 

Me mo se ocê puder criar objetos para a sessão, e assim criar uma zona comparativamente 
egura, alguns objeto são cu toso de criar e, portanto, preci am er 
manipulados diferentemente -o exemplo mais comum é uma conexão de banco de 
dados. Para lidar com isso, você pode colocar esses objetos m um pool explicito em 
que possa obter uma con xão enquanto precisar de uma e reto1ná-la quando t rminar. 
E ta op raçõ pr ci arão er incronizada . 

Leitura Adicional 

De muitas formas, este capítulo apenas arranha a superfície de um tópico muito mais 
complexo. Para maior investigação, sugerimos começar com [Bernstein and ewcomer], 
[Lea] [Schmidt et al.]. 


CAPÍTULO 

Estado da Sessão 

Q
Q
uando falamos sobre concorrência, levantamos a questão da diferença entre 
transações de sistema e transações de negócio (Capítulo 5). Além de afetar a 
concorrência, essa diferença afeta também a forma de armazenar os dados 
usados em uma transação de negócio, mas que ainda não estão prontos para serem 
gravados de forma definitiva (commit) no banco de dados. 

As diferenças entre transações de negócio e transações de sistema sustentam 
muito do debate sobre sessões sem estado contra sessões com estado. Muito tem sido 
escrito sobre esta questão, mas o problema básico muitas vezes está disfarçado 
atrás das questões técnicas de sistemas servidores com e sem estado. A questão fundamental 
é perceber que algumas sessões são inerentemente com estado e então decidir 
o que fazer a respeito do estado. 

O Valor de Não Possuir Estado 

O que as pessoas querem dizer com um servidor sem estado? O ponto principal a 
respeito de objetos, é óbvio, é que eles combinam estado (dados) com comportamento. 
Um objeto verdadeiramente sem estado é um objeto sem atributos. Tais "animais" 
aparecem de tempos em tempos, mas, francamente, eles são bastante raros. Na verdade, 
você pode argumentar, com razão, que um objeto sem estado caracteriza um 
projeto ruim. 

Verifica-se, entretanto, que isso não é o que a maioria das pessoas quer dizer 
quando fala sobre ausência de estado em uma aplicação corporativa distribuída. 
Quando as pessoas se referem a um servidor sem estado, querem dizer um objeto 
que não retém estado entre solicitações. Tal objeto pode muito bem ter atributos, mas 
quando você invoca um método em um servidor sem estado os valores dos atributos 
são indefinidos. 


94 PARTE 1 • As NARRATIVAS 

Um e emplo de um objeto servidor sem estado pode er um servidor que retorn 
uma página Web cont ndo informaçõe are peito de um livro. Você faz uma 
chamada a st servidor acessando uma URL-o obj to pod ser um docum nto 
ASP ou um er let. a URL ocA fornec um núm ro ISB que o er idor u a para 
g rara re po ta HTTP. Durant a int raçã , o objeto rvidor, ant d g rara página 
HTML, pode armazenar o ISB , o título e o pre o do li roem atributo do objeto, 
quando ele o obtém do banco de dado . Talvez ele ex cute alguma lógica de negócio 
para determinar quais informações complementares mostrar para o usuário. 
A sim qu tiv r termin do u trabalho, entr tanto, te alor s tornam inútei . 

próximo ISB ' outra história compl tam nt dif r nt , o objeto rvidor erá 
prova 1m nt r inicializado para limpar quai qu r valor antigo itando a 1m 
a ocorrência de erros. 

Agora imagin qu oc" queira guardar todos os ISB s visitados por um d terminado 
endereço IP cliente. Você pode guardá-los em uma lista mantida pelo objeto 

rvid r. ontudo, ta li ta pr ci a persi tir ntre a olicitaç-e e a sim você tem 
um obj to s rvidor com tado. s a mudança d em stado para com tado muito 
mais do que uma mudança d pala ra . Para muitas p s oas, ervidor s comestado 
são nada menos do que de astrosos. Por que isso? 

que tão bá ica diz re p ito a recur s do ervidor. Qualquer obj to rvidor 
com estado precisa manter todo o seu e tado enquanto e pera que o usuário medite 

obre a página Web enviada. Um obj to ervidor em e tado, contudo, pode proce sar 
outras solicitações de outras sessões. Considere um exemplo completament irreal, 
por 'rn ilu trativo. Suponha qu t nhamo uma cent na d p oas qu qu iram 
obt r informaçõ a re peito de Jj • ro e qu proce ar uma requi ição obr um li ro 
1 ve um gundo. Cada p a faz uma olicitação a cada dez gund , toda a 
solicitações são perfeitamente balanceadas. Se quisermos guardar as solicitações de 
um u uário m um obj to servidor com estado, temos que ter um obj to ser idor por 
usuário: cem objetos. Entr tanto, durante 90% do tempo, est s objetos ficam parados 

m nada para faz r. S d i tirm d ra tr ar o ISBN ap na u armo obj t r-
vidor em e tado parar pond r à olicitaçõ s, pod mo no air b m com ap nas 
dez obj tos ervidor , integralm nte utilizado , durant todo o t mpo. 

A questão é que, se não tivermos estados entre chamadas de métodos, não importa 
que objetor sponde à olicitação, ma , s armazenarmo o e tado, então preci


amos sempre pegar o me mo objeto. A au ência de e tado no permite fazer um pool 
c m no obj t de modo qu preci emo de m no objeto para lidar com mai 
usuários. Quanto mais usuários inativo tiv rmos, mais valiosos s rão os servidor s 

em e tado. Como vocA pod imaginar, s r idor m tado ·ão muüo út is m 
Web site com muito tráfego. A au ência de estado também é apropriada para a Web, 
já qu o HTTP ' um protocolo em tado. 

Então, tudo de eria ser em estado, certo? Bem, deveria, se isso fosse possí el. 
O probl ma é que muitas interaçõe d clientes ão in rent mente com stado. 
Consider a m táfora do carrinho de compras pr sente em milhares de aplicaçõ s 
d comércio 1 trônico. A int ração dou uário c n i te m na gar p la página 
de diver o livro e e colher o que de eja comprar. conteúdo do carrinho de 
compra preci a er lembrad durant toda a essão do cliente. Basicamente, temo 
uma transação de negócio com estado, o que significa que a sessão tem que terestado. 
Se eu apenas procuro livros e não compro nada, minha e são não tem e tado, 
ma u comprar, ela t m. ão podemo vitar o tado a não r qu qu iramo 
p rmanec r na pobreza. Em vez di o, t m qu d cidir o qu faz r c mel . 


CAPÍTULO 6 • ESTADO DA SESSÃO 95 

A boa notícia é que podemos usar um ser idor sem estado para implementar uma 
ão com tado. A novidade int r s ant é que, ainda que i o seja po ívcl, podemos 
não qu rA-lo. 

Estado da Sessão 

Os itens no carrinho de compras ão o estado da sessão, o que quer dizer que os dados 
no carrinho ão relevante apenas para aquela e ão em particular. E te e tado e tá 
dentro de uma transação d negócio, o que significa que está s parado d outras ses


-ua transaç-s de n gócio. (Continuar i a pr supor, n ta discu ão, que cada 
transação de negócio roda em umas ão ap na e que cada e são x cuta apenas 
uma tran ação de negócio de cada vez). O tado d ão ' dií r nt d que chamo 
de registro de dados, que são os dado persistentes, de longo alcance, armazenados no 
banco de dado e visíveis para todas as sessõ s. Para se tomar um r gistro de dados, o 
estado da sessão precisa ser armazenado de forma p rsist nte (commited). 

Uma v z qu o tado da ão tá d ntro d uma tran ação d n gócio, 1 
pos ui muita da propriedad qu a pe oa normalm nt as ociam a tran açõ , 
tais como a propri dades ACID (atomicidad , con i tência, i olam nto e durabilidade). 
As conseqüências disso nem sempre são compreendidas. 

Urna con eqüência inter ante é o feito obre a con istência. nquanto o cliente 
está editando uma apólice de seguros, o estado corrente da apólice pode não ser 
válido. O cli nt alt ra um ator, u a uma olicitação para nviá-lo para o i t ma 

o sist ma responde indicando valor inválidos. Esses alor s são part d um stado 
d se ão, mas não são válidos. E t fato muitas vez s ocorr com o tado da e ão 
-ele não satisfaz a regra de validação enquanto está sendo trabalhado. I so irá 
correr ap na quando a tran ação de negócio for armazenada de maneira per i tente 
no banco (commited). 
A questão maior no que diz r sp ito ao estado da essão é lidar com o isolamento. 
Devido ao grande número de aspectos en olvidos, div rsas coisas pod m ocorr r 

nquant cli nt dita uma apólic . mai ób ia con i t m dua p a ditando 
a me ma apólice ao me mo tempo. o entanto, o problema não ão apena a alteraçõ 
. Considere a xistência de doi registro , a própria apólic e o regi tro do cliente. 
A apólice tem um alor de risco que depende parcialmente do código postal no registro 
do cliente. cliente com ça a editar a apólice e, após dez minuto , faz algo que abr 

o r gi tro do cli nt d modo qu le pos a v r o código po tal. Entr tanto, durant 
perí d , outra pe oa alt r u c dig po tal alor d ri c -1 ando a uma leitura 
incon i tente. Veja, na página 9-90, uma estratégia para lidar com i o. 
em todos o dados armazenados pela sessão contam como estado da essão. 
A sessão pode armazenar em cache alguns dados que, em erdade, não precisariam 
er per i tido entre olicitações, ma que ão armazenado para aum ntar o d empenho. 
Uma. ez que ocê pode perd r o cach m p rd r o comportamento corr to, 
i to é diíerente do esta.do da ão, que de er armazenado entr olicitaçõ 
para que o comportamento seja o corr to. 

Modos de Armazenar o Estado da Sessão 

Como ocê pode armazenar o e tado da se são uma vez que descobriu que preci ará 
d l ? Divido as opçõ s m tr"s scolhas não muito distinta , por'm básicas. 


96 PARTE 1 • As NARRATIVAS 

Estado da Se ão no Cliente (427) armazena o dados no cliente. Há di ersos 
modos d fazer i o: codificando o dado em uma URL para uma apr s ntação Web, 
usando cookíes, serializando os dados m algum campo escondido em um formulário 
Web ou ai·mazenando o dado em objeto em um cliente rico. 

E tado da Se ão no Servidor (429) pode er tão irnpl quant armaz nar 
dados na memória entre olicitações. ormalmente, entretanto, há um mecanismo 
para armazenar o estado da e são em algum lugar mai durá el, corno um objeto 

erializado. O objeto pode ser armazenado no si tema de argui os local do servidor 
de aplicaçõ ou colocado em urna font de dados compartilhada. sta pod ria ser 
uma imples tab la m um banco d dados com um ID da s ão como cha um 
obj t rializado como alor. 

O Estado dn Sessão no Banco de Dado (432) também é armazenamento no lado 

rvidor, por'm envolv a paração do dados em tabelas campo e o armaz namento 
deles no banco de dados, de modo semelhante ao que ocê faria com dados 
mai duráv is. 

Há alguma qu tõ en ol ida na colha da opção. Prim iro falar i obre a 
n ce idade de largura da banda ntr o cliente o ervidor. U ar E tado da Se ão no 
Cliente (427) significa que os dados da essão precisam ser transferidos pela rede em 
cada olicitação. S tivermo falando de apena algun campo , i o não é grand 
coisa, mas quantidades maiores de dados resultam em transferências maiores. Em 
uma aplicação, est dado eh garam a quase um megabyte ou, como um do membros 
da nossa equipe colocou, o tamailho de trê p ça de Shak speare. É v rdad 
que tá amo u ando XML entr o dois, o qu não é a forma mais compacta d 
tran mi ão de dado , porém me mo a im havia muito dado para trabalhai·. 

É claro que algun dad pr ci arão er tran ferido porqu ele têm qu er 
vistos na apresentação, porém, usar Estado da Se são no Cliente (427) significa que, em 
cada solicitação, você tem que transferir todos os dados qu o servidor usa, mesmo 
que o client não pr cise deles para fins de xibição. Tudo isso ignifica que ocê não 
irá qu r r u ar E tado da Se ão no Cliente (427) a não r qu a quantidade d tado 
d s ão qu voe" pr ci a armazenar eja pequena. Você também tem qu pr ocupar 
com s gurança int gridade. Ameno qu você criptografe os dados, dev t r 
em mente que qualquer usuário mal-intencionado pode editar seus dados de sessão, 

o que poderia levá-lo a uma ver ão inteiramente nova do cone ito de "diga o eu 
próprio preço." 
O dado da ão t~m qu ri olado . a maior part do ca o o qu tá 
acontecendo em uma sessão não d v afetar o qu está acont c ndo m outra. S 
r r armo um itin rário d vôo, i o não de t r n nhum f ito obre n nhum 
outro usuário até que o ôo seja confirmado. De fato, parte do significado de dado 
de e ão é que ele ão in i ívei fora da e ão. I o e toma uma que tã complicada 
se ocê usar Estado da Sessão no Banco de Dados (432), porque ocê tem que 
trabalhar duro para isolar os dados da ão dos registros de dados armaz nados 
no banco de dados. 

S v cê tiv r muito u uário , d con id rara utilização d c/u ter param lhorar 
a taxa de tran ferência de dados (throughput). ste ca o, você de e con iderar 
e você preci a d migração d essão. A migração de sessão permite que uma 
sessão se mova de um servidor a outro quando um servidor trata uma solicitação da 

essão e outro ser idore tratam as demais. Seu oposto é a afinidade de servidor, 
que força um rvidor a tratar toda as olicitaçõ s para uma e são m particulru·. A 
migração d r idor 1 va a um m 1h r balanc am nto do rvid r , p cial



CAPÍTULO 6 • ESTADO DA SESSÃO 97 

mente se suas sessões forem longas. Entretanto, is o pode ser complicado se você esti 
er u ando E tndo da Se ão no Servidor (429), porqu , muita ez s, apena a máquina 
que lida com a s ssão pod encontrar ess estado facilrn nte. Há man iras d contornar 
i o, ma e ta maneira ob curecem a cU tinção entre o E fado da Se ão no 
Banco de Dado (432) o E tndo da S ão no Servidor (429). 

A afinidade com o ervidor pode levar a problemas maiores do que você poderia 
inicialmente imaginar. a tenta ti a de garantir a afinidade com o ervidor, o clu ter 
de máquinas não pode a todo momento inspecionar as chamadas para ver de qual 

s ão la faz m part . Como r ultado, el irá aumentar a afinidad d modo qu 
toda s chamadas d um cli nte jam encaminhada para o m smo rvidor d 
aplicaçõ . Muita v z , i o ' feito pelo nd r ç IP do cli nt . S o cli nte ti r 
atrás de um proxy, isso poderia significar que muitos clientes estejam usando o mesmo 
endereço IP as ím as ociados a um r idor em particular. I so pod s r muito 
ruim se você chegar a uma situação em que a maior parte do seu tráfego é manipulado 
por um único rvidor r pon ável pelo nder ç IP da A L! 

S o ervidor for usar o tado da são, preci a obtA-lo m um formato qu 
pos a ser usado rapidament . S ocê u ar o E fado da Se ão no Servidor (429), o stado 
da sessão já está lá. Se você usar o Estado da Sessão no Cliente (427), ele está lá, mas 
freqüentemente preci a ante r colocado na forma apropriada. Se você u ar o E tado 
da Ses ão no Banco de Dados (432), precisa ir ao banco de dados para obtê-lo (e, talvez, 
também ex cutar alguma tran formação). Is o ignifica qu cada abordagem pode 
t r d.iler nt s feito sobr a resposta do ist ma. O tamanho e a complexidad 
do dado terão f ito n ta hora. 

e você tiver um i tema público de v nda a arejo, provav lment não t rá 
tanto dado em cada ão, ma t rá rnuHo u uário na maior parte do t mpo 
inativos. Por este motivo, o Estado da Ses ão no Banco de Dados (432) pode funcionar 
b m em termo d d semp nho. Em um sist ma d lea in , você corre o risco de arrastar 
uma grand quantidade de dados de para o banco de dados em cada solicitação. 
' n a ituação qu o E tado da Se ão no Servidor (429) p d 1h dar um d 


mpenho m lhor. 

Um do grand s bichos-pap-s, m muitos sistema , é quando ou uário canc la 
uma sessão e diz "pode deixar, esqueça". Isso é especialmente complicado com 
aplicaçõe B2C, porqu o usuário normalm nte não diz "pode deixar, e queça", le 

implesment desaparece e não olta mai . O Estado da Se ão no Cliente (427) certam 
nte ganha aqui, porqu v cê pod facilm nt e qu cer e u uano. a outra 
abordagens, ocê pr cisa limpar o stado das ssão quando perc b que ela foi canc 
lada, as im como configurar um ist ma qu Ih p rmita canc lar a se ão apó a 
pas agem de um certo período de tempo (timeout). Boas implementaçõe do E tado 
da S ão no Servidor (429) permit m um timeout automático. 

Assim como o cancelamento pelo usuário, considere o que acontece quando um 

i t ma cancela: um cliente pod falhar, ums rvidor pode ter problemas uma conexão 
der de pode desapar cer. O E tado da Sessão no Banco d Dados (432) normalm 
nt lida muito b m com a trA ituaÇ . O tado da Se ão no Servidor (429) p d 
ou não obreviver, dependendo de o objeto da se são ter backup em armazenamento 
não-volátil e ond es e armazenamento é mantido. O E tndo da Ses ão no Cliente (427) 
não irá sobre iver a uma falha no cliente, mas deve sobreviver à queda dos demais. 

ão e e qu ça do esforço de de envol imento envolvido nestes padrões. ess 
ntido, o E tado da Se ão no Servidor (429) ', normalm nt , o mai fácil d impl mentar, 
e p cialment cê não tiver que p r i tir tado da ã entr r qui



98 PARTE 1 • A5 NARRATIVAS 

sições. O Estado da Sessão no Banco de Dados (432) e o Estado da Sessão no Cliente (427) 
normalmente demandarão código para transformar o formato interno de um banco 
de dados ou um formato de transporte em um formato apropriado para os objetos de 
sessão. Esse tempo extra significa que você não conseguirá efetuar o mesmo trabalho 
tão rapidamente quanto o faria com o Estado da Sessão no Servidor (429), especialmente 
se os dados forem complexos. À primeira vista, o Estado da Sessão no Banco de Dados 
(432) poderia não parecer tão complexo se você já estiver efetuando o mapeamento 
para tabelas no banco de dados, porém o esforço extra de desenvolvimento vem 
da necessidade de manter os dados da sessão isolados de todas as outras utilizações 
do banco de dados. 

As três abordagens não são mutuamente excludentes. Você pode usar uma mistura 
de duas ou três delas para armazenar diferentes partes do estado da sessão. 
Contudo, isso normalmente torna as coisas mais complicadas, já que você nunca tem 
certeza de que parte do estado vai em que parte do sistema. Se, apesar disso, você usar 
algo em conjunto com o Estado da Sessão no Cliente (427), terá que manter pelo menos 
um identificador de sessão no Estado da Sessão no Cliente (427) mesmo se o resto 
do estado for mantido usando os outros padrões. 

Minha preferência é pelo Estado da Sessão no Servidor (429), especialmente se o 
estado da sessão for armazenado remotamente, de modo que possa sobreviver a 
uma falha no servidor. Também gosto do Estado da Sessão 110 Cliente (427) para IDs e 
dados de sessões que sejam muito pequenos. Não gosto do Estado da Sessão no Banco 
de Dados (432), a menos que você precise defnilover e clusters e você não possa armazenar 
mementos remotos ou se o isolamento entre sessões não for um problema 
para você. 


CAPÍTULO 

Estratégias de Distribuição 

O
O
s objetos têm sido usados já há um certo tempo e às vezes parece que, desde 
sua criaçãoÍ as pessoas têm querido distribuí-los. Entretanto, a distribuição 
de objetos tem muito mais armadilhas do que muitas pessoas percebem 
[Waldo et ai.], especialmente quando elas estão sob a influência dos livretos dos vendedores. 
Este capítulo é sobre algumas dessas duras lições -lições que tenho visto 
muitos dos meus clientes aprenderem de modo difícil. 

O Fascínio dos Objetos Distribuídos 

Há uma apresentação recorrente que eu costumava ver duas ou três vezes por ano 
durante revisões de projetos. Orgulhosamente, o arquiteto de sistemas de um novo 
sistema 00 mostra seu plano para um novo sistema de objetos distribtúdos -vamos 
fazer de contél que é algum sistema de pedidos. Ele me mostra um projeto que se parece 
com a Figura 7.1, com objetos remotos separados para clientes, pedidos, produtos 
e entregas. Cada um deles é um componente separado que pode ser colocado em 
um nó de processamento separado. 

Pergunto "Por que você faz isso?" 

"Desempenho, é claro'', o arqtliteto retruca, olhando para mim de um modo um 
pouco estranho. "Podemos rodar cada componente em uma caixa separada. Se um componente 
ficar ocupado demais, acrescentamos caixas extras para ele, de modo que possamos 
balancear a carga da nossa aplicação". O olhar agora é curioso como se ele estivesse 
tentando imaginar se eu realmente conheço alguma coisa sobre objetos dist:i:ibtúdos. 

Enqtrnnto isso, deparo-me com um dilema interessante. Será que eu digo que 
este projeto é ruim e me mostram a porta de saída imediatamente? Ou tento aos poucos 
esclarecer o meu cliente? Essa última opção é mais lucrativa, mas bem mais difícil, 
já que o cliente geralmente está bastante satisfeito com sua arquitetura, e é duro 
desistir de um sonho do qual se gosta muito. 


100 PARTE 1 • As NARRAllVAS 

/ 

Fatura Cliente 

1 1

* * 

/ 

/ 

Pedido Entrega 

1 1 

,I 

* * 

Figura 7 .1 Distribuindo uma aplicação, colocando diferentes componentes em 
diferentes nós (não recomendado!). 

Assim, pressupondo que você não tenha mostrado a porta de saída para este Livro, 
acho que irá querer saber por que esta arquitetura distribuída é ruim. Afinal de 
contas, muitos vendedores de ferramentas lhe dirão que o motivo prjncipal do uso 
de objetos distribuídos é que você pode pegar um monte de objetos e posicioná-los 
como quiser em nós de processamento. Além djsso, seu midrllewnre poderoso fornece 
transparência. A transparência permite que os objetos chamem uns aos outros dentro 
de um processo ou entre processos sem ter que saber se o objeto chamado est~ no 
mesmo processo, em outro processo ou em outra máquina. 

A transparência é valiosa, no entanto, ajnda que muitas coisas possam ser tornadas 
transparentes em objetos distribuídos, o desempenho normalmente não é uma 
delas. Embora nosso arquiteto idealizado estivesse cListribuindo objetos do modo 
que vinha fazendo por motivos de desempenho, na verdade seu projeto irá prejudicar 
o desempenho ou tornar o sistema muito mais difícil de construir e distribuir ou 
ainda, o que é mais freqüente, terá ambos os defeitos. 

Interfaces Locais e Remotas 

A principal razão pela qual a distribuição por modelo de classe não funciona tem a 
ver com um fato fundamental a respeHo de computadores. Uma chamada de procedimento 
dentro de um mesmo processo é muito, muito rápida. Uma chamada de um 
procedimento entre dois processos separados ordens de magnitude mais devagar. 
Rode esse processo em uma outra máquina e você pode acrescentar mais uma ou 
duas ordens de magnitude, dependendo da topografia de rede envolvida. 

O resultado disso 6 que a interface de um objeto a ser usado remotamente deve 

ser diferente daquela de um objeto usado dentro do mesmo processo. 
Uma interface local fica melhor como uma interface de granularidade baixa. As


sim, se eu tiver uma classe endereço, uma boa interface terá métodos separados pa



CAPÍTULO 7 • ESTRATÉGIAS DE DISTRIBUIÇÃO 101 

ra l r a cidade, o estado, gravar a cidade, gravar o estado, e a sim por diante. Uma 
int rface de granularidade baixa é boa porque segue o princípio 00, que pr coniza 
muitos p daços pequenos de software que podem er combinado e sobrescrito de 
vária man iras para stend r o proj to no futuro. 

Uma interface de granularidade baixa não funciona bem quando é remota. 
Quando as chamadas de métodos são lentas, você quer obter ou atualizar a cidade, 
e tado código po tal em uma chamada, em vez de em trê . A interface re ultante 
tem granularidade alta, projetada não para maior flexibilidade e extensibilidad mas 
para minimizar as chamadas. qui ocê erá uma interface lidar com todo os detalh 
d uma l itura ou atualização d nd r ço . É muito mai complicado de programar, 
mas por motivos de des mpenho, oc" pr cisará d st tipo d int rfac . 

claro, que o vend dore irão lh dizer é qu não há overhend no u o do eu 
middlewnre para chamada locai e r mota . S for uma chamada 1 cal, ela ' f ita com 
a elocidad d uma chamada local. S for uma chamada remota, ela é f ita mai devagar. 
As im, você ó paga o pr ço de uma chamada r mota quando pr cisar de uma. 
Isso ', at' certo ponto, verdadeiro, porém não ita a que tão e sencial d que qualquer 
objeto que possa s r u ado r motamente d va ter uma int rface d granularidad 
alta nquanto que cada obj to qu não for u ado r motam nt deve t r uma interfac 
d granularidad baixa. S mpr que doi bj to c municam, voe" d v c lher 
qual dela u ar. Se o objeto puder, alguma vez, estar em um pr ce o s parado, 
você tem que usar a interface de granularidade alta e pagar o preço do modelo de programação 
mais difícil. bviamente, só faz sentido pagar esse preço quando ocê precisar, 
então você deve minimizar a quantidade de colaborações interprocessos. 

Por s motivo voe" não pod imple m nt pegar um grupo d ela qu 
proj t u para um ambi nt d um único pr c , atirar CORBA ou algo emelhant 
nela di to re ultar um model di tribuído. Um projeto distribuído mai do 
que isso. Se ocê basear sua estratégia de distribuição em classes, acabará com um 

isterna que , ecuta muita chamadas remotas e, desta forma, precisa de interfaces 
deselegante , com granularidade alta. o final, mesmo com interfaces de granularidad 
alta em toda da r mota, voe" ainda t rá como bônus, d ma iada chamada 
r m ta e um • t ma complicado para modificar. 

Assim, chegamos à minha Primeira Lei do Projeto de Objetos Distribuídos: 
não distribua seu objetos! 

Como, então, u ar efetivamente múltiplo proce adore ? a maior parte do 
ca os, o caminho apropriado é a dusterização (v ja a Figura 7.2). Coloque toda a 
classes em um único processo e então ex cute múltipla cópias des e processo nos diver 
nó de pr ce amento. D ta forma, cada proc o u a chamada locais para 
ex cutar o trabalho assim o faz mais rápido. Além disso, oc" pod usar interfaces 
d granularidad baixa m todas as class s d ntro do proc sso e assim obt r maior 
facilidade de manut nção com um modelo de programação ma i imples. 

Onde Você Tem que Distribuir 

Voe" quer minimizar a fronteiras da distribuição utilizar a clu t rização de us 
nó d pr e amento tanto quanto po í l. O ob táculo • qu há limi t n a 
abordag m -i to é, ituaç~ onde ocê preci ará parar os proce o . S oc" for 

en ato, lutará como um rato encurralado para liminar tanta fronteira d di tribuição 
quanto puder, mas não as eliminará por completo. 


102 PARTE 1 • As NARRATIVAS 

oa4: Aplicação 
Pedido 

Figura 7.2 A utilização de clusters envolve a colocação de diversas cópias da mesma 
aplicação em diferentes nós. 

• Uma separação óbvia é entre o lado cliente e o lado servidor nas aplicações 
de negócio. O PCs nas mesa dos usuários são nó d proce amento diferentes 
daqueles onde residem os repositórios de dados compartilhados. Já 
que les ão máquina clifer nt , ocê pr ci a de preces o s parados que s 
comuniqu m. A clivi ã cli nt -vidor é uma típica clivi ão int rproce o . 
• Umas gunda di isão freqü ntem nt ocorre entr o lado servidor da aplicação 
(o rvidor de aplicaÇe ) e o banco d dad . É claro qu você não , 
obrigado a fazer is o. Você pode rodar todo o lado ervidor da aplica ão no 
próprio processo do banco de dados usando coisas tais como procedimentos 
armaz nado . Ma , na maioria da v z , i o não ' tão prático, de modo qu 
oc" tem qu t r proce o eparado . le at pod m rodar na m sma máquina 
ma , ap na por trabalhar com proc o parados, oc" t rá qu pagar 
amai r part do cu to d chamada r mota . F lizm nt , a linguagem 
SQL é projetada como uma interface remota, de modo que ocê normalmente 
pode arranjar as coisas de modo a minimizar esse custo. 

• Outra eparação em proce os pode ocorrer em um sistema Web entre o ser idor 
Web e o servidor de aplicação. Se tudo for igual, é melhor rodar os servidores 
Web e de aplicações em um único proc so, ma nem tudo é mpr igual. 
• Voe" p de ter que parar d vido a difer nça entr end dore . S v cê e tiver 
u ando um pacot de oftware, ele muitas eze rodará no eu próprio 
proc sso, de modo que mais uma vez você stará distribuindo. Um bom pacot 
ter', no mínimo, uma int rfac de granularidad alta. 
• E, finalm nte, pod hav r alguma razão g nuína para ocê ter que dividir 
u oftware rvidor d aplicaç~ . Voe" d atém mo v nd r u próprio 
a ó para itar i o, ma alguma vez há certos ca os em que não ' 
possí el evitá-lo. esses casos, ocê tem de tampar o nariz e dividir seu software 
em componentes r motos com granularidad alta. 


CAPÍTULO 7 • ESTRATÉGIAS DE DISTRIBUIÇÃO 103 

tema recorrente, segundo a memorável frase de olleen Roe, é ser "parcimonioso 
com a distribuição de objetos". Venda primeiro sua a ó favorita, se for possí el. 

Trabalhando com as Fronteiras da Distribuição 

Durante o projeto d eu istema, você preci a limitar a di tribuição tanto quanto 
possível, ma ond ela fornece ária, voe" tem d levar em conta as fronteiras de distribuição. 
Toda chamada remota é o equivalente cibernético de uma viagem em uma 
carruagem puxada a ca alo . Todos os locais no si tema mudarão de formato para 
minimizar chamada r mota . t , o pr ço p rado. 

Entr tanto, dentro de um único proces o, ocê ainda pod projetar u ando obj 
to d granularidad baixa. Acha , u ar obj to int rnarn nt col car objetos 
de granulal"idade alta nas fronteiras de distribtúção, cujo único papel é fornecer 
uma interface rem ta para o objeto de granularidade baixa. O objeto de granularidade 
alta agem simplesmente como uma fachada para os objetos de granularidade 
baixa. A xi tência d ta fachada , motivada ap na por qu tõe de distribtúção daí 
o nom de Fachnda Remota (368). 

O u o de uma Fachada Remota (368) ajuda a minimizar as dificuldades que as interface 
de granularidade alta introduzem. De a forma, apena o obj to que r alrnent 
precisam de um serviço remoto in ocarn o método d granularidad alta fica 
'bvio para o d envolvedor s qu ele tão pagando e pr ço. A tran par"ncia 
tem suas virtudes, mas ocê não quer r transparent em relação a urna potencial 
chamada remota. 

Mantendo as interfaces de granuJaridad alta como meras fachadas, ocê permite 
que as pessoas usem os objetos de granularidade baixa sempre que elas souberem 
que estão rodando no m smo processo. Isso torna toda a política de distribuição 
rnuH mai xplícita. D mão dada com a Facl1nda Remota (368) tá o Objeto de 
Trnn if. rência de Dado (3 O). Você pr ci a não ap na de m ' todo d grnnularidad alta, 
ma também tran ferir objeto de granularidade alta. Quando ocê olicita um endereço, 
preci a nviar e sa informação em um bloco. ormalmente você não pod 
en iar o próprio objeto do domínio, porque ele está preso a uma rede de referências 
1 cai entre bjeto de granularidade baixa. A im, você deve pegar todo o dado 
que o cliente precisa e os empacotar em um objeto específico para a transferência daí 
o termo Objeto de Tran iferência de Dado (380). (Muita p s oa na c munidad enterpri 
e Java u am o termo objeto valor para i so, ma cau a um conflito com outros 

ignificado do t rmo Objeto Valor (453)). O Objeto de Tran iferência de Dndo (380) aparece 
no doi lado da con xão, de modo que é importante que ele não faça nenhuma 
referência a nada que não seja compartilhado através da conexão. Isto re ulta no fato 
d que um Objeto de Transferência de Dado (380) normalment apena referencia 
outros Objeto de Trnn iferência de Dado (380) e obj tos fundamentais tai como tring . 

utro caminho para a distribuição é ter um intermediário que migre objetos entre 
o proce o . A idéia aqtú é u ar um e quema de Car a Tardia (200) em que, em 

z de ef tuar uma 1 itura tardia de um banco d dado , ocA mov obj to atra 's 
da conexão. A parte complicada é ass gurar que você não acabe com d masiadas 
chamada r mota . Ainda não vi ningu 'm t ntar i o m uma aplicação, ma algumas 
ferramentas de mapeamento /R (p. ex., T PLink) têm e ta facilidade e tenho 
ouvido alguns relato intere ante a e e r speito. 


104 PARTE 1 • A5 NARRATIVAS 

Interfaces para Distribuição 

Tradici nalmente, as interface de componente di tribuído têm sido baseada em 
chamadas a procedim ntos remotos, seja por m iode procedimentos globais ou como 
m 'todo n obj to . o último ano , ntr tanto, t m c m çado a r int rfac 
ba ada m XML obr HTTP. A forma ma.i comum de a interfac rá provavelm 
nt o SOAP, mas muita p soas ef tuararn experimento na área durant 
muitos anos. 

A comunicação HTTP baseada em XML • útil por diver o motivo . Ela p rmit 
facilmente que uma grande quantidad d dados seja en iada de forma estruturada, 
m uma única iag m d ida e olta. I o bom, uma v z qu o núm r d chamadas 
remotas pr cisa er minimizado. O fato d XML s rum formato comum, com 
par er di poniv is em muitas plataformas, permit qu sistemas construídos m plataformas 
inteiramente diferentes se comuniquem, acrescido ao fato do protocolo 
HTTP r uni r al. fato do XML r textual torna fácil v r o qu e tá acont c ndo 
atra és da conexão. E ainda é fácil passar HTTP através de firewall quando que tões 
políticas de s gurança tornam difícil uma alt mativa. 

Ainda assim, uma int rface orientada a obj tos d classes métodos também 
t m alor. Mov r todo dado tran f rido para trutura XML e tring p d 
adicionar uma obrecarga considerável à chamada remota. As aplicaçõe certamente 
tAm i to uma igniôcativa melhora d de empenho ubstituindo uma interface 
baseada em XML por uma chamada remota. Se ambos os lados da conexão usarem o 
mesmo mecanismo binário, uma interfac XML não traz muito ma.is do que um conjunto 
vistoso d acrônimos. S ocê ti r dois sist mas construído com a m sma 
plataf rma, tará melhor r id u ar o m cani m d chamada r m ta n a 
plataforma. Ser iço Web e tornam útei quando você qu r que plataformas diferent 
s con ersem. Minha posição é u ar erviço W b ba eado em XML ap nas 
quando uma abordagem mais direta não for possível. 

É claro que você pode ter o melhor do do.i mundo colocando uma camada 
HITP obr uma interfac orientada a obj to . Ti da a chamadas para o rvidor 
W b ã traduz.ida por ta camada m chamada para uma int rfac orientada a 
obj tos correspondent . Até certo ponto, isso 1h dá o melhor dos dois mundos, mas 
aumenta a complexidade, já qu irá precisar tanto do ervidor Web quanto dom canismo 
para uma interface remota . Portanto, você só deve fazer isso se preci ar de 
uma API HTTP, b m como d uma API r mota 00, ou a facilidade da API 00 
remota para segurança e gerenciamento de transações tornar mais fácil lidar comes-

a qu stõe do que usando objetos não-remotos. 

as minhas discu sões aqui, parti do pr ssuposto d uma interfac síncrona 
ba ada m RPC. Entretanto, embora i o eja o qu d cr vi, realmente não con idero 
que eja sempr a melhor maneira de lidar com um sistema distribuído. Cada 
vez mai , minha preferência é por uma abordagem inerentemente assíncrona, baseada 
em mensagens. A exploração de padrões para trabalhos baseados em mensagens 
é um tópico relati amente grande por i ó, por i soa evitei n t livro. E pero 
qu um li ro obr is o apar ça m um futuro próximo, ma , por nquanto, tudo 
o que p o fazer é ncorajá-lo a con id rar abordagen a íncr na , ba eada 
em mensagens. Particularmente, acho que ela ão o mell1or uso dos serviços Web, 
ainda qu a maior part dos xemplos publicados até agora jam síncronos. 


CAPÍTULO 

8 

Juntando Tudo 

A
A
té agora estas narrativas olharam um aspecto de umsistema e exploraram as 
diversas opções para tratá-lo. Agora é hora de reunir tudo e começar aresponder 
às questões traiçoeiras de quais padrões usar ao projetar uma aplicação 
corporativa. 

O conselho, neste capítulo, é de muitas maneiras uma repetição do conselho dado 
em capítulos anteriores. Devo admitir que fiquei na dúvida se este capítulo seria 
necessário. Contudo, pensei que seria bom contextualizar toda a discussão agora 
que, espero eu, você tem pelo menos as linhas gerais do escopo completo dos padrões 
deste livro. 

Enquanto escrevo isso, estou inteiramente dente das limitações do meu conselho. 
Frodo disse em O Senhor dos Anéis: "Não peça conselhos aos Elfos, porque eles 
dirão não e sim." Embora eu não esteja reivindicando qualquer conhecimento imortal, 
certamente entendo sua resposta de que conselhos são muitas vezes um presente 
perigoso. Se estiver lendo isto para tornar decisões referentes à arquitetura do seu 
projeto, pense que você sabe muito mais sobre seu projeto do que eu. Uma das maiores 
frustrações em ter bastante conhecimento sobre algo é que as pessoas mujtas vezes 
vêm a mim em uma conferência ou enviam uma mensagem pelo correio eletrônico 
pedindo conselhos sobre suas decisões de processo ou arquitetura. Não há como 
você dar conselhos específicos baseado em uma descrição de cinco minutos. Escrevo 
este capítulo com ainda menos conhecimento do seu problema. 

Assim, leia com o espírito com o qual ele é apresentado. Não conheço todas as 
respostas e certamente não conheço suas questões. Use este conselho para estimular 
sua reflexão, mas não o use em substituição à sua reflexão. No final, você tem que tornar 
suas próprias decisões e viver com elas. 

Uma coisa boa é que suas decisões não têm de ficar para sempre gravadas em 
pedra. A refatoração arquitetura] é difícil, e ainda não conhecemos todos os seus custos, 
mas ela não é impossível. Aqui o melhor conselho que posso dar é que, mesmo 
se você não gostar de nada da programação extrema [Beck XP], ainda assim deveria 


106 PARTE 1 • A5 NARRATIVAS 

considerar seriamente três práticas técnicas: integração contínua [Fowler I], desenvolvimento 
conduzido por t st s [Beck TDD] refatoração [Fowler Refactoring]. E 


as técnica não ão uma panacéia, ma tornarão muito mai fácil mudar de idéia, 
quando oc~ d cobrir qu pr ci a faz" -lo. ocê irá pr ci ar, a m no qu t nha 
mai sorte ou mai habilidade do que qualquer pessoa que eu já tenha conhecido. 

Começando com a Camada de Domínio 

O com ço do proce o d cidir qual abordag m d lógica de domínio usar. trê 
principais competidores são o Roteiro de Trnn ação (120), o Módulo Tabela (134) e o Modelo 
de Domínio (126). 

Conform r alt i no Capítulo 2 (página 45-46), a maior força que conduz 
por este trio é a complexidade da lógica do domínio, algo totalmente impossí el de 
quantificar, ou até mesmo de qualificar, com algum grau de precisão. ontudo outros 
fatores também influem na decisão, em particular a dificuldade de conexão com um 
banco de dados. 

mais imple do três padr-' o Roteiro de Tran ação (120). El e aju ta ao 
mod lo pr c durai com o qual a maioria da p oa ainda nt confortá 1. 
Eficientemente encapsula a lógica d cada tran ação do i tema m um rot iro facilmente 
compreensí el. Além disso, ele é fácil para construir um Roteiro de Transação 
sobre um banco de dados relacional. Sua maior falha é não tratar adequadamente 
a lógica de negócio complexa, sendo especialmente suscetível a código duplicado. 
Se você ti er apena uma aplicação simple d catálogo, com pouco mais 
do que um carrinh de c mpra r dando obr uma e trutura bá ica d preço , ntão 
o Roteiro de Transação (120) será perfeitam nt sufici nt . Entretanto, à medida 
que ua lógica ficar mai complicada, sua dificuldades multiplicam. 

o outro lado da escala e tá o Modelo de Domínio (126). anáticos radicais por 
objeto , a sim corno eu, não enxergam urna aplicação de outra forma. Afinal, se urna 
aplicação ' impl o ufici nt para qu po a r crita com o Roteiro de Tran ação 
(120), por que n o imen o intel cto d veriam incomodar com um probl ma 
tão sem valor? Al 'm disso, minha xperiência me 1 a a não ter dúvidas d qu nada 
pod lidar m lhor com o inf mo da lógica d domínio r almente cornpl xa do 
que um rico Modelo de Domínio (126). Uma vez que ocê t nha e aco tumado a trabalhar 
com um Modelo de Domínio (126), até mesmo problemas simples podem ser 
tratados com facilidade. 

Ainda a im, o Modelo de Domínio (126) tem ua falha . o primeiro lugar 
da lista está a dificuldade de aprender a como usar um modelo de domínio. Fanático 
por objetos muitas z s tore m s u nariz para p s oas que simpl sm nte não 
c n gu m nt nd r bj t , ma a v rdad , qu , for para r b m f it , um Modelo 
de Domínio (126) requ r habilidad -ma] f ito l é um d sastr . gunda grande 
dificuldade d um Modelo de Domínio (126) a sua conexão a um banco de dado 
relacional. É claro que um verdadeiro fanático por objeto usa de artimanhas para re


olver este problema com um empurrãozinho de um banco de dados orientado a obj 
to . Mas, por muitas razões, a maioria delas n;o-t, cnicas, um banco de dados 

ri ntado a obj to não é uma colha po sív Ipara aplicaçõ orporati a . O r ultad 
' uma conexão confu a com um banco de dados r laci nal. Vam falar a verdad 
: mod lo de obj to modelo relacionai não e encaixam. Ore ultado ' a 
complexidade de muitos dos padrõe de mapeamento 0/R que descrevo. 


CAPÍTULO 8 • JUNTANDO TUDO 107 

Módulo Tabela (134) r presenta um meio-termo interessante entre esses dois 
pólo . Ele pode tratar melhor a lógica de domínio do que os Roteiro de Tran ação 
(120). Além di so, embora não po sa e comparar a um erdadeiro Modelo de Domínio 
(126) para tratar lógica d domínio complexa, el s ncaixa rdad iram nt 
bem com um banco de dado relacional -e muitas outra coi as também. Se você tiver 
um ambiente como o . T, onde mwta ferramentas orbitam em torno do todo 
podero o Conjunto de Re • tro (473), ntão Módulo Tabela (134) funciona muito b m, 
apro eitando o pontos fortes dos banco de dado relacionais e ainda repre entando 
uma razoá el fatoração da lógica do domínio. 

Anali ando ar~um nto, v mo qu a f rramenta qu oc" tem tamb 'm 
af tam sua arquit tura. s z s voe" pod scolh r as f rramentas bas ado na arquitetura 
, em t oria, é isso o qu ocê tem de faz r. a prática, entr tanto, muitas 
vez voe" t rn qu adaptar ua arquit tura à ua f rrarn nta . Do trA padrõ , o 
Módulo Tabela (134) é aqu le cuja trela mai brilha quando você tem ferramentas 
que s adaptam a ele. E urna scolha particularment apropriada para ambientes 
.NET, já que tanto da plataforma é centrado ao r dor do Conjunto de Regi tro (473). 

S ocê l u a discussão sobre a lógica do domínio no Capítulo 2, muito disso par 
e rá familiar. Ainda a sim, val a p na repetir s a di cu ão aqui, porqu r alrnent 
p n o qu ta , a d ci ão e ntral. Daqui, pro guimo para a camada do banco 
de dado , mas agora as decis~e são moldada pelo contexto da sua scolha da lógica 
do domínio. 

Descendo para a Camada de Dados 

Uma vez que você tenha e colhido ua camada de domínio, tem que de cobrir como 
conectá-la à sua fonte de dad . Sua deci õe são baseadas na sua e colha da camada 
de domínio. Por esse moti o, abordarei essa questão em seções separadas, dirigidas 
por essa escolha. 

Camada de Dados para o Roteiro de Transação (120) 

O Roteiro de Tran ação (120) mais sim.pi contêm sua própria lógica d banco d dado 
, ma u vito i o m mo no ca o rnaj impl . S parar bane d dado d limita 
duas parte que fazem sentido separadas, de modo qu faço a separação mesmo 
nas aplicações mais imples. O padrõe d banco de dados a serem escolhidos 
aqui são o Gateway de Linha de Dados (158), e o Gateway de Tabela de Dados (151). 

A escolha ntr os dois depende muito dos r cw·sos da sua plataforma de implementação 
para onde voe p ra qu a aplicação vá no futuro. Com um Gateway de 

A 

Linhn de Dado (1 8), cada r gi tr ~ lido para um bj to c m uma int rfac clara xplicita. 
Com um Gateway de Tabela de Dados (151), você pode ter menos código para e cr 
ver, uma vez que ocê não pr cisa de todo o código de ac o para chegar ao dados, 
mas você acaba com uma interface muito mais implícita que se baseia no acesso 
a urna estrutura do tipo conjunto de registros que é pouco mais que um mapa. 

A d ci ão-chave, ntretanto, r cai obre o r sto da sua plataforma. Se ocê t m 
uma plataforma qu forn c vária f rram nta qu trabalham b m com um Conjunto 
de Regi tro (473), e pecialrn nte ferramenta de int rfac com ou uário ou e njuntos 
de registro transacionais de conectados, faz com que você se incline decididamente 
na direção de um Gateway de Tabela de Dado (151). 


108 PARTE 1 • As NARRATIVAS 

Você normalmente não precisa de nenhum dos outros padrões de mapeamento 
O/R ne te c nt to. A que tõ ref rente ao mapeamento e trutural e tão praticamente 
aus nt s aqui uma z que a estrutura em memória mapeia tão bem para 
a e trutura do banco d dados. VocApod ria con id rara utilização d uma Unidade 
de Trabalho (1 7), ma normalmente é fácil ra trear o que mudou no roteiro. Voe 
na pr ci a pr ocupar c ma maior part da qu t-r !acionada à concorrência, 
porque o roteiro freqüentemente corresponde quase que exatamente a uma 
tran ação d i tema.Você pod , portanto, imple ment encap ular todo o roteiro 
em uma única tran ação. A xceção u ual é quando uma requi ição xtrai dado 
para dit; -lo , a próxima r qui ição t nta gra ar a alt raçõ . t ca o, o Bloqu 
io Offline Otimi ta (392) , qua empr a melhor escolha. Ele não apena é mai 
fácil d impl m ntar, como tamb 'm g ralmente ati faz a xpectati a do u uários 
e e ita o problema de uma sessão pendurada deixar todo tipo de recurso bloqueado. 


Camada de Dados para o Módulo Tabela (134) 

A principal razão para e olh r um Módulo Tabela (134) é a pre ença de um bom 
framework ba ad em Conjuntos de Regi tro (473). teca o, ocA irá querer um padrão 
de mapeamento de banco de dados que funcione bem com um Conjunto de Re-

istro (473), e isso o leva inexoravelmente na direção de um Gateway de Tabela de Dado 
(151). Ess s dois padrõ s se ajustam tão bem que par c m ter sido feitos um para 
o outr . 

D fato, com e t padrão, não há mais nada qu v c" preci acre c ntar no lado 
da font de dados. o m lhores cas , o Conjunto de Re istros (473) t m algum tipo 
de mecanismo de controle de concorrência embutido, o que efetivamente o torna 
uma Unidade de Trabalho (187), reduzindo ainda mais a perda de cabelo . 

Camada de Dados para o Modelo de Domínio (126) 

Agora a coi a ficam int r ant . Por muito m tivo , a grand fraqu za do Modelo 
de Domínio (126) é que a conexão ao banco de dados é complicada. O grau de complicação 
depende da complexidade de te padrão. 

Se o seu Modelo de Domínio (126) for simples, digamos uma ou duas dúzias de 
classes que jam ba tante emelhantes às tab la no banco de dado , ntão um Re


i tro Ativo (165) faz entido. S vocA qtú er d sacoplar um pouco as coisas, você pod 
u ar para i tanto um Gatewny de Tabeln de Dndo (151) quanto um Gateway de Linha 
de Dados (158). Quer ocê separe, quer não, qualquer das alternativa não é muito 
complicada. 

Como as coisas se tornam mais complicadas, você precisará considerar a utilização 
d um Mapendor de Dado (170). ta ' a abordag m que promet manter s u 
Modelo de Do111[11io (126) tão ind pend nt quanto po í l d toda a outras camadas. 
Ma o Mapeador d' Dado (170) , tamb 'mo mais complicado padrão para impl mentar. 
A menos que oc.. tenha uma equip forte ou con iga encontrar algumas 

implificaçõ s qu tornem o mapeam nto mai fácil, u r comendaria fortement o 
uso de uma ferramenta de mapeamento. 

Uma ez qu voe.. tenha colhido o Map ndor de Dndo (170), a maioria dos padrõ 
s na eção de mapeamento O/R e aplicam. Em particular, recomendo de todo o 
coração a Unidade de Trabalho (187), que funciona como um ponto central para o control 
da concorrência. 


CAPÍTULO 8 • JUNTANDO TUDO 109 

A Camada de Apresentação 

Por diversos moti os, a apresentação é relati amente independente da escolha 
das camadas mais baixas. Sua primeira questão é entre forn cer uma interfac rica 
d cli nt ou uma interfac HTML m um brow er. Um cli nt rico 1h dará uma 
int rfac com u uário mai bonita, ma , n t ca , vocA pr ci a d um c rto 
controle obre a di tribuição de eu cliente . Minha preferência é u ar um na gador 
HTML e for possível, e um cliente rico em caso contrário. Clientes ricos 
normalmente demandarã um e forço mai r de programação, ma i o ocorr 
porqu el tend ma r mai ofi ticado , n m tanto devido à complexidade 
inerent s à t enologia. 

ão xpl r i n nhum padrã d cli nt ric n t li r , d m do qu vocA 
e c Ih r um, nã t nho r alm nte nada mai a diz r. 

Se você escolher o caminho HTM , tem que decidir como estruturar sua aplicação. 
C rtarn nt , recomendo o padrão Modelo Vista Controlador (315) como a fundação 
do seu projeto. Feito isso, rocê ainda tem duas deci ões a tomai~ uma para o controlador 
e outra para a vista. 

Sua f rram ntas podem muito b m faz r a e colha para ocê. S vocA usar o 
Visual Studio, a maneira mais fácil é o Controlador de Página (318) e a Vista Padrão 
(333). você u ar Java, tem uma variedade de fram work W b a con iderar. o momento, 
o Strut é uma scolha popular, o que o levará a um Controlador Frontal (328) 
e a uma Vista Padrão (333). 

e for possível uma maior liberdade na e colha, eu recomendaria um Controlador 
de Página (318) o u ite for mais orientado a d umento , e pecialrnent vocA 
tiv ruma mistura de página estáticas dinâmica . A na gação interface com 

o usuário mai compl xa levam à dü ção d um Controlador Frontal (328). 
o lado da i ta, a e colha ntr a Vi ta Padrão (333) a Vi ta de Trnn ;formação 
(343) depende de se sua equipe usa páginas ser idoras ou XSLT na programação. As 
Vista Padrão (333) têm no momento a dianteira, embora eu goste da facilidade de teste 
da Vista de Transformação (343). Se você ti er n c sidade de mo trar um mesmo 
site com múltiplas aparência funcionalidad s, dev consid rara utilização d uma 
Vi ta em D11a Etapa (347). 

O modo como você e comunica com a camada inf riore dep nde do tipo de 
camada e se ela e tarão empre no mesmo proce o. Minha preferência é fazer com 
que tudo rode em um único proc o, e po ív 1-d ta maneira, você não t m qu 

preocupar com a 1 ntas chamada interproc s os. Se ocê não puder fazer is o, 
de e encapsulai· sua camada de donúnio com uma Fachada Remota (368) e usar um 
Objeto de Trnn iferência de Dado (380) para comunicar com o rvidor W b. 

Alguns Conselhos Específicos para Determinadas Tecnologias 

a maior parte deste livro, tenho tentado trazer a experiência comum de criar projetos 
em várias plataformas diferentes. A e periência com orte, O BA e Smalltalk se 
traduz muito efetivament no d envolvimento com Java . T. A única razão pela 
qual t nho me cone ntrado em ambient s Ja a . ET é qu ele parec m eras plataformas 
majs comuns para o d senvolvim nto d aplicaçõ s corporativas no futuro. 
(Ainda qu u fo go tar a linguag n d cript dinamicam nt tipada , m 
especial Python e Ruby, tives em uma chance.) 


110 PARTE 1 • As NARRATIVAS 

esta seção, quero aplicar os conselho acima nestas duas plataformas. Tão logo 
tenha feito is o, contudo, corr o ri co d atribuir a mim me mo um prazo de alidad 
. As tecnologias mudam muito mais rapidam nte do que estes padrões, d 
modo que nquanto ocê lê lembre-e de que e tou e crevendo no inicio de 2002, 
quando tod tão cliz ndo qu ar cuperação econômica chegará l go. 

Java e J2EE 

Atualm nte o grand d bat no mundo Ja a ' xatamente o quão alioso são o 

nt rpri Ja a B an . D p i d tanta "v r õ pr liminar " finai quanto c ncerto 
de despedida do The Who, a especificação EJB 2.0 finalment apar ceu. Ma 
você não precisa d EJB para criar uma boa aplicação J2EE, ap sar do qu os forn cedores 
EJB lhe dizem. Você pode fazer bastante com os elhos e bons objetos Java 
(P J )* JDB . 

A alternativas de proj to para J2EE variam em função dos padrõ s qu voe" 
ti r u ando , mai uma v z, com çam p la lógica do domínio. 

S voe" usar um Roteiro de Transação (120) sobre alguma das formas d um Gatewny 
(436), a abordagem u uai com EJBs, atualm nte, 'u ar e ion benn como um Roteiro 
de Transação (120) e entity beans como um Gateway de Linha de Dado (158). Esta é 
uma arquitetura bastante razoável s a ua lógica de domínio for uficientement 
modesta. Entretanto, um problema com tal abordagem usando beans é que é difícil se 
li rar do rvidor JB s ocê d scobrir que não pr cisa d !e e não quis r gastar com 
taxas de lic nças. A abordag m não-EJB consi t d um P JO para o Roteiro de Tran


ação (120) br um Gntewny de Linha de Dado (158) u um Gateway de Tabela de Dado 
(151). Se os conjuntos de linhas do JDBC 2.0 obtiverem maior aceitação, esta erá 
uma razão para u á-lo como um Conjunto de Dados (473) is o le a a um Gnteway de 
Tabela de Dados (151). Se ocê não estiver seguro sobre a utilização de EJBs, pode usar 
a abordagem não-EJB e encap ular o entity bea,1 com o e ion bean atuando como 
fachada r mota (368). 

S v cê e tiv r u ando um Modelo de Domínio (126), a ort doxia e rr nte é u ar 
entity beans. Se o seu Modelo de Do111(11io (126) for bastante simpl e tiver uma boa correspondência 
com as tabelas no banco d dados, isso faz bastante sentido seus entihJ 
bean serão então Re i tros Ativos (165). Ainda é uma boa prática encapsular seus 
entity benn com e ion benn agindo como Fachada Remota (368) ( mbora voe~ tamb 
• m possa pen ar na Per i tência Gerenciada pelo Conteiner (CMP**) como um Mapeador 
de Dados (170)). Entretanto, e o eu Modelo de Domínio (126) formai compl xo, 
voe~ irá quer r que el ja inteiram nt ind p ndente da strutura do JB d modo 
qu ocê po a gra ai~ xecutar t tar ua lógica d domínio m ter qu lidar com 
os caprichos do contâiner JB. esse contexto, eu usaria POJOs para o Modelo do Domínio 
(126) os encap ularia com e ion beans agindo como Fachadas Remotas (368). 
Se você escolher não usar EJBs, u executaria toda a aplicação no ser idor Web e itai
·ia chamada remota entre a apr entação e o domínio. você e ti er u ando um 
Modelo de Domínio (126) P J , u tamb • m u aria POJO para o Mnpeador d Dado 

(170) -eja u ando uma f rramenta para o mapeamento 0/R, eja faz ndo eu me mo, 
se eu achas e que conseguiria. 
,. . d R.T.: Plai11 and O/d ]a aObje t·. 

.. . de R.T.: Conlainer Managed Persi tence. 


CAPÍTULO 8 • JUNTANDO TUDO 11 1 

e você usar entity benns em qualquer contexto, evite dar a eles uma interface remota. 
unca ent ndi o motivo de dar a um entity benn uma interface remota. O entíty 
bcnn ão normalm nt u ado como Modelo de Domínio (126) ou como Gatewny 
de Unha de Dndo (158). Em mb ca , ele preci am d uma interface d granularidade 
baixa para executar bem e se pap 'is. No entanto, como e pero ter introduzido 
em ua mente, uma interface remota de e empre ter urna granularidad alta. 
Por e se moti o, mantenha seus entihJ beans apenas como locais. (A e ceção a isso 
é o padrão EntihJ Composto de [Alur et ai.], o qual é uma forma diferente de usar entíty 
bean e que, ainda a sim, não m par c muito útil.) 

o pres nte mom nto, o Módulo Tabela (134) não é muito comum no mundo Java. 
Será inter ssant v r s mais ferramentas sw-girão m tomo do conjunto d linhas 
(row et) JDBC -i o ac nt e r, e te padrão p d tornar uma abordag m viá l. 
Neste ca o, a abordagem POJO se adapta melhor, mbora voe tamb 'm possa ncap-
A 

ular o Módulo Tnbela (134) com se sion beans atuando como Fachndas Remotas (368) e 
r tornando Conjunto de Regi tro (473). 

.NET 

Ob ervando o . T, o Visual Studio e a história do d n olvim nto d aplicaçõ s 
no mundo Micro oft, o padrão dominant ' o Módulo Tabela (134). Ainda qu os fanático 
por obj to costumem dizer que i o ignifica ap na qu o guidor da Microsoft 
não conhecem orientação a objetos, o fato é que o Módulo Tabela (134) oferece 
um meio-termo alioso ntre um Roteiro de Tran ação (120) e um Modelo de Domínio 
(126), com um impr sionante conjunto d f rrarn ntas qu tiram proveito do onipres 
nte conjunto d dados atuando como um Conjunto de Regi tros (473). 

A con qüencia di o 'que o Módulo Tabela (134) tem qu r a colha padrão 
para esta plataforma. m verdade, não vejo entido algum em usar Roteiro de Trnnação 
(120), exc to nos ca o mais simple e, m smo a im, les dev riam er bem


comportado e retomar conjunto de dado . 

Is o não ignilica que ocê não po a u ar um Modelo de Domínio (126) . Com certeza, 
você pode con truir um Modelo de Domínio (126) tão facilmente em .NET quanto 
em qualquer outr ambi nte 00. Ti da ia, a ferram nta não lh dã a ajuda xtra 
qu elas dão em M6d11/o Tabeln (134), de modo que eu tol raria uma complexidade 
maior antes de entir a ne e idade de mudar para um Modelo de Domínio (126). 

xiste atualmente uma publicidade excessiva referente ao uso de erviços Web 
em . T. o entanto, eu não usaria serviços Web dentro de uma aplicação. u os 
usaria, as im como em Java, na camada de apresentação para permitir a integração 
de aplicaçõ . ão exi te n nhuma boa razão em uma aplicação .NET para separar o 

r idor Web e a lógica do domínio m proc s o di tint . D s modo, a Fachada 
Remotn (368) 'meno útil aqui. 

Procedimentos Armazenados 

Ocorrem normalmente uma quantidad razoável de di cus õ s a respeito de procedimentos 
armazenados. Freqüentemente, les são o modo mais rápido de faz r as 
coi a , uma v z qu le rodam no m mo pr c o do u bane d dado e, de ta 
forma, reduz ma preguiço a chamada rem ta . Entretanto, a maioria do ambientes 
de procedimento armazenados não lhe fornece bon mecani mo para a estruturação 
de eus procedimentos armazenados. Além disso, os procedimentos ar



112 PARTE 1 • As NARRATIVAS 

mazenados o manterão preso a um vendedor de banco de dados específico. (Uma 
boa maneira d evitar e te problemas é a abordagem Orade de permitir que você rode 
aplicações Java dentro do proce so do seu banco de dados. Is o é o equi alente a 
colocar toda sua camada d lógica do domínio dentro do banco de dado . Por nquanto, 
isso ainda o deixa um pouco amarrado a um vendedor, mas pelo menos r duz 
os custo de portar o banco de dados para um outro gerenciador.) 

Por que t-e de m dularidade e portabilidade, muita pe oa evitam u ar pro


cedimentos armazenados para a lógica d negócio. Tendo a m alinhar com esta ião 
a menos que haja um grande ganho de de empenho a er obtido, o qu , para ser 
inc ro, fr qü nt m nt ocorr . ca o, p go um m t do da camada do domínio 

e, alegr m nt , o transformo m um proc dim nto armaz nado. Faço isso apenas m 
área com claro problema d d s mp nho, tratando-o como um pa o da otinúzação, 
não como um princípio arquiteh.ual. ([Nil on] apr enta um bom argurn nto 
a favor dou o de procedimento armazenado mai exten amente.) 

Um modo comum d u ar procedimentos armazenado é para controlar o aces


a um banco de dados, egundo a diretriz de um Gnteway de Tabelas de Dados 
(151). ão tenho n nhuma opinião fechada quanto a fazer is o ou não, , p lo que t nho 
i to, não há forte argum nto d n nhum do lado . D todo mod , pr firo u ar 
o m mo padrõ para i olar o ac ao banco d dado , qu r t ja controlado 
por procedim nto armazenado ou por SQL normal. 

Serviços Web 

Quando e cre o isso, o con n o enh·e os especialista é o de que o erviços Web 

farã dar utização uma r alidade e tirarã integradore de i tema dom rea


do, mas não e tou a sim tão entusiasmado. Os erviço Web não desempenham um 

papel muito importante na util ização destes padrões, porque sua finalidade é a in


tegração de aplicações, e não a construção das mesmas. Você não de eria tentar se


parar uma aplicação única em serviços Web que conver em entre i, a menos que 

vocA r almente precise fazê-lo. Em ez disso, construa sua aplicação e exponha a 

di r a partes d la como s r iço Web, tratando e s r iço como nchndn Re


mota (368). Acima d tudo, não deixe que todo o burburinho sobre o quão fácil 

criar erviço Web faça ocê esquecer a Primeira Lei do Projeto de Objetos Distri


buído (página 100-101). 

Embora a maforia do exemplos publicados que u tenha visto u e erviço 
Web de forma síncrona, em vez de usá-lo como uma chamada RPC XML, prefiro 
u á-lo d f01·ma assíncrona e ba ado em m n agen . Embora não apre ente aqui 
nenhum padrão para is o ( st li ro já é grande o suficiente do jeito qu tá), espero 
que possamos v r nos próximos anos alguns padrõ s para a troca assíncrona d 
rn n agen . 

Outros Esquemas de Camadas 

Construí minha di cus ão m torno de tr As camada principai , ma a minha abordag 
m para a riaçã d camada não é a única qu faz ntido. Outro bon livr obre 
arquit nua tAm quema d camada , e todo le tAm alor. Vale a pena olhar 
e e outro e qu ma e compará-lo àquele que apre nt aqui. Você pod achar 
que eles fazem mais entido para a sua aplicação. 


CAPÍTULO 8 • JUNTANDO TUDO 113 

primeiro dest s padrões é o que chamarei de modelo de Brown, di cu tido em 
[Brown et ai.] (veja a Tabela 8.1). Ess modelo t m cinco camada : apr entação, controlador/ 
mediador, domínio, map am nto de dados font d dados. Basicam nt 
ele coloca camada adicionai de mediação entre a três camada bá ica . O controlador/
m diador realiza a mediação ntr a camada d apre ntação e domínio, enquanto 
que a camada de mapeamento de dados realiza a mediação entre a camada 
de domínio e a camada da fonte de dado . 

Acho que as camadas de mediação são úteis durante parte do tempo mas não 
durante todo o tempo, d forma que a descr voem t rmos de padrõ . Controlador 
de Aplicação (360) 'o m diador entr a apr entação e o domínio, o Mapeador de 
Dado (170) ' o m diador entr a camada d dado d mínio. Para organizar t 
livro, descre i o Controlador de Aplicação (360) na eção da apresentação (Capítulo 14) 
e o Mapeador de Dados (170) na s ção da camada de dados (Capítulo 10). 

Para mim então, a adição das freqüentemente (mas nem sempre) úteis camadas 
de mediação, r pr enta um upl mento opcional no proj to. Minha abordagem ' 

mpr p n ar nas tr" camada bá icas, v rificar alguma d las stá e tornando 
muito compl xa , m ca o afirma ti o, acr se ntar a camada d m diação para parar 
a funcionalidade. 

Outro bom quema d camadas para J2EE apar ce no padr-e CoreJ2EE 
[Alur et al.] (veja a Tabela 8.2). Aqui as camadas são: cliente, apre entação, negócio, 
int gração r curso . Corre pond"ncia imple xi tem para a camada d n gócio 
e integração. A camada der cursos compr end os s r iços externos aos quais a 
camada d int graçã con cta. A principal dif r nça ' qu el s param a camada 

de apr ntação entr a parte qu roda no cliente (cliente) a parte que roda m um 
rvidor (apre ntação). E a paração 'muita vez útil, ma , n vam nt , la não 
é necessária durante todo o tempo. 

A arquüetura Mia·osoft D A [Kirtland] define tr"s camadas: apresentação, 
n gócio e acesso a dados, que corr spondem quase que diretamente às três camada 
qu u o aqui ( ja a Tab la 8.3). A maior mudança orr no m do p lo qual 
dados são pas ado da camada de ac s o a dado . o Micro oft D A, toda a 
camadas op ram sobre conjuntos de registros que re ultam d con ultas SQL x cutadas 
pela camada de acesso a dados. Isso inh·oduz um aparente acoplamento, 
uma vez que, tanto a camada de negócio quanto a d apresentação conhecem o 
banco d dado . 

O modo como vejo i o é qu no DNA c njunto d r gi tro e g como um 
Objeto de Transferência de Dados (380) entr as camadas. A camada d negócio pod 
modificar o conjunto d r gi tro durante o trajeto d st para a camada d apre ntação 
ou mesmo ela própria criar um conjunto de regi tros (o que é raro). Embora 

Tabela 8.1 As Camadas de Brown 

Brown Fowler 

Apresentação Apresentação 

Controlador/mediador Apresentação (Controlador de Aplicação (360)) 

Domínio Domínio 

Mapeamento de dados Fonte de dados (Mapeador de Dados (170)) 

Fonte de dados Fonte de dados 


114 PARTE 1 • As NARRATIVAS 

Tabela 8.2 Camadas CoreJ2EE 

CoreJ2EE Fowler 

Cliente Apresentação que roda no cliente (p.ex., sistemas de clientes ricos) 

Apresentação Apresentação que roda no servidor (p.ex., processos que tratam 
requisições HTTP. páginas servidoras) 

Negócio Dominio 

Integração Fonte de Dados 

Recursos Recursos externos com os quais a fonte de dados se comunica 

Tabela 8.3 Camadas Microsoft DNA 

Microsoft DNA Fowler 

Apresentação Apresentação 

Negócio Domínio 

Acesso a dados Fonte de Dados 

esta forma de comunicação seja, por muitos motivos, incômoda, ela tem a grande 
vantagem d permitir qu a apre entação use controles ligados ao dados (data 
aware) na interface com o usuário, mesmo com dados que tenham sido modificados 
pela camada de negócio. 

t ca o, a camada d domínio é struturada na forma d Módulo Tabela 
(134), a camada d dado u a Gateway de Tabela de Dado (151}. 

[Marinescu] tem cinco camadas (veja a Tabela 8.4). A apresentação é di idida 
em duas camadas, r fletindo a separação de um Controlador de Aplicação (380). O domínio 
, também di idido, com uma Camada de Serviço (1 1) construída sobre um Modelo 
de Domínio (126), r fl tindo n comum d dividir uma camada d domínio 

m duas part . Esta uma abordagem comum, r forçada p las limitaçõ s d JB como 
um Modelo d Domínio (126) ( eja a página 127-128). 
A idéia de separar uma camada de ser iço de uma camada de dorrúnio é ba


eada na eparação da lógica do fluxo de trabalho da lógica d domínio pura. A camada 
de ser iços tipicamente inclLú lógica específica de um único caso de uso e tamb,
m alguma comwucação com outra infra-e trutura , como a de men agen . 1i r ou 
não camadas s paradas d ser iço e de domínio é moti o de algum debat . Tendo a 
encai-ar i o como algo oca ionalment útil, em ez de obrigatório, ma vário proj ti 
ta que re peito não concordam omigo. 

[Nil n] u a um do e qu mas de camada mai complexo (v ja a Tab la 8.5). 
O mapeamento para este esquema de camadas se torna um pouco mais complexo 
pelo fato de ilsson usar xtensi amente procedimento armazenados e encorajar, 
por motivos d d mpenho, a inclusão d lógica de domínio nel . ão me into 
c nfortável m c locar lógica d domínio m proc dimento armaz nado , porqu 
isso pod tornar uma aplicação muito mais difícil d manter. Ocasionalmente, ntr tanto, 
sa é uma t,cnica d otimização valio a. As camada de procedimento armazenados 
de ilsson contêm tanto a fonte de dados quanto a lógica do domínio. 


CAPITULO 8 • JUNl'ANOO Tuoo 11 5 

Tabela 8 .4 Camadas de Marinescu 

Marinescu Fowler 
Apresentação Apresentação 
Aplicação Apresentação (Controlador de Aplicação (360)) 
Serviços Domlnio (Camada de Serviço (141)) 
Domínio Domínio (Modelo de Domínio (126)) 
Persistência Fonte de Dados 

Tabela 8.5 Camadas de Nilsson 
Nilsson Fowler 
Consumidor Apresentação 
Auxiliar do Consumidor Apresentação (Controlador de Aplicação (360)) 
Aplicação Domínio (Camada de Serviço (141)) 
Domínio Domínio (Modelo de Domínio (126)) 
Acesso Persistente Fonte de Dados 
Procedimentos Fonte de Dados (pode incluir algum domínio) 
Armazenados Públicos 
Procedimentos Fonte de Dados (pode Incluir algum domínio) 
Armazenados Privados 

Assim como [Marinescu], Nilsson usa camadas de aplicação e de domínio separadas 
para a lógica de domínjo. Ele sugere que você pode pular êl camada de domínio 
em um sistema pequeno, o que é semelhante à minha visão de que um Modelo de 
Domínio (126) tem menos valor para sistemas pequenos. 


PARTE 

11 • 

Os PADRÕES 


CAPÍTULO 9 

Padrões de Lógica de Domínio 


120 PARTE li • Os PADRÕES 

Roteiro de Transação (Transaction Script} 

Orgnnizn n lógicn de negócio e111 procedimentos ondecndn procedimento lida 
com umn IÍ11ica solicitnçiio dn nprese11taçiio. 

Serviço de Lançamento ~ 

receitaLançada (númeroDoContrato: long, aPartirDe: Date) : Dinheiro -----~ 
calcularlançamentoDeReceitas (númeroDoContrato: long) : void 

A maioria das aplicações podem ser percebidas como uma série de transações. Uma 
transação pode enxergar alguma informação organizada de alguma forma particular, 
outra transação pode fazer alterações nesta informação. Cada interação entre um 
sistema cliente e um sistema servidor contém uma certa quantidade de lógica. Em alguns 
casos isso pode ser tão simples quMto mostrar informações armazenadas no 
b,mco de dados. Em outros, pode envolver muitos passos de validações e cálculos. 

Um Roteiro de Transação organiza toda esta lógica primariamente como um único 
procedimento, fazendo chamadas diretas ao banco de dados ou usando um fino envoltório 
para acesso ao banco de dados. Cada transação terá seu própt'io Roteiro de 
Transnç.ão, embora subtarefas comuns possam ser separadas em procedimentos. 

Como Funciona 

Com o l{oteiro de Trnnsnção1 a lógica do domínio é org,mizada primariamente pelas 
transações que você executa usando o sistema. Se a sua necessidade for reservar o 
quarto de um hotel, a lógica para verificar a djsponibfüdade de quartos, calcular taxas 
e atualizar o banco de dados é encontrada dentro do procedimento Reservar 
Quarto de Hotel. 

Parn casos simples não há muito a dizer sobre como organizar isso. É claro que, 
assim como com qualquer outro programa, você deve estruturar o código em módulos 
de uma maneira que faça sentido. A menos que a transação seja especialmente 
complicada, isso não será um grande desafio. Um dos benefícios desta abordagem é 
que você não precisa se preocupar com o que outras transações estão fazendo. Sua tarefa 
é ler a entrada de dados, inquirir o banco de dados, trabalhar sobre os dados e 
gravar seus resultados no banco de dados. 

Onde você deve colocar o Roteiro de Trnnsaçiio dependerá de como você organiza 
suas camadas. Pode ser em uma página servidora, um script CGI ou umobjeto de sessão 
distribuído. Minha preferência é separar os Roteiros de Transação o máximo que você 
puder. Coloque-os no mínimo em sub-rotinas distintas; melhor ainda, coloque-os 
em classes separadas daquelas que lidamcom a apresentação e a fonte de dados. Além 
disso, não permita chamadas dos Roteiros de Transação para qualquer lógica de apresentação. 
Isso facilitará a modificação do cócligo e os testes dos Roteiros de Trnnsnç.ão. 

Você pode organizar seus Roteiros de Trn11snçiío entclasses de duas maneiras dis6ntas. 
A mais comum é ter diversos Rotefros de Tnmsação em uma única classe, onde 
cada classe define um assunto comum para Roteiros de Tm11snçiío relacionados. Isso 
é simples e direto e é a melhor aposta para a maior parte dos cc1sos. A outra maneira 
é ter cada Roteiro de Trnnsnçiio em sua própria classe (Figura 9.1), usando o padrão 


(APiYULO 9 • PAC>RÕE5 DE LÓGICA OE DOMINIO 121 

Comando [Gang of Fourj. Neste caso você define um supertipo para seus comandos 
que define algwn método para execução no qual a lógica dos Roteiros de Trmisnçno se 
encaixa. A vantagem desta abordagem éque ela permite manipular instâncias de roteiros 
como objetos cm tempo de execução, embora cu raramente tenha visto necessidade 
de fazer isso com os tipos de sistemRs que usam Roteiros de Transação para organizar 
a lógica de domínio. É claro que, em muitas linguagens, você pode ignorar 
as classes completamente e usar apenas funções globais. Contudo, você descobrirá 
mtútas vezes que instanciar tLm novo objeto ajuda em questões relacionadas a 
tlmmds, pois torna mais fácil isolar os dados. 

Eu uso o termo Roteiro de Transnção, porque na maior parte do tempo você terá 
un1 Roteiro de Transação para cada trnnsação no banco de dados. Isso não é uma regra 
para 100% dos casos, mas é verdade em uma primeira aproximação. 

Roteiro de Transação 

run O 

4' 

1 1 

RT Receita Lançada RT Calcular Lançamento de Receitas 

new (númeroDoContrato:long, aPartirDe: Date) new (númeroDoContrato: long) 
run () run O 

Figura 9.1 Usando comandos para Roteiro de Transação. 

Quando Usá-lo 

A beleza do Roteiro de Trnnsnção é sua simplicidade. Organizar El lógica desta maneira 
é natural para aplicações com apenas uma pequena quantidade de lógica, e envolve 
muito pouco overltead, seja no desempenho, seja na compreensão. 

No entanto, à medida que a lógica de negócio fica mais complicada, toma-secada 
vez mais difícil mante-la em um estado que possa ser caracterizado como um bom 
projeto. Um problema específico a observar é a duplicação de código entre transações. 
Já que o ponto central é lidar com uma transação por roteiro, qualquer código 
em comum tende a ser duplicado. 

Uma fatoração cuidadosa pode minorar muitos destes problemas, no entanto 
domínios de negócio mais complexos precisam construir um Modelo de DomÍllio 
(126). Um Modelo de Domínio (126) U\e dará muito mais opções na estruturaçl-lo do código, 
aumentando a legibilidade e diminuindo a duplicação. 

É difícil quantificar o ponto de corte entre as duas estratégias, especialmente 
quando você está mais familiarizado com lLm padrão do que com outro. Você pode 
refatornr o projeto de um Roteiro de Trnnsação para o de um Modelo de Domínio (126), 
mas é uma alteração mais difícil do que de outra forma precisaria ser. Uma escolha 
inicial acertada é, portanto, a melhor ma1,eira de seguir adiante. 


122 PARTE li • Os PAORÕES 

Entretanto, cünda que você se tome um fanático por objetos, não descarte os Roteiros 
de Transação. Há muitos problemas simples poraí1 e uma solução simples lhe levará 
adiante mais rápido. 

O Problema do Lançamento de Receitas 

Para este padrão, e outros que falam de lógica do domínio, usarei o mesmo proble


ma como ilustração. Para não ler de descrever o problema diversas vezes, eu o farei 

apenas uma vez aqui. 

O lançamento de receitas é um problema comum em sistemas de negócios. O 
problema central é quando você pode realmente contabilizar em seus livros o dinheiro 
que você recebe. Se eu lhe vender uma xícara de café, esta é uma questão 
simples: eu lhe dou o café, pego seu dinheiro e contabilizo o dinheiro nos livros no 
mesmo nanossegundo. Entretanto, para muitas coisas isso fica complicado. Digamos 
que você me dê um adiantamento para que eu fique disponível durante esse 
ano. Ainda que você me pague uma remuneração ridícula hoje, posso não poder 
lançá-la imediatamente em meus livros, porque o serviço será executado no decorrer 
de um ano. Uma solução poderia ser contabilizar apenas uma duodécima parte 
dessa remuneração para cada mês do ano, desde que você pudesse rescindir o 
contrato após um mês, quando percebesse que escrever atrofiou minhas habilidades 
de program.ação. 

As regras para lançamento de receitas são muitas, variadas e voláteis. Algumas 
são estabelecidas por regulamentos, algumas por padrões profissionais e outras 
por políticas da companhia. R<tstrear receitas acaba sendo um problema bastante 
complexo. 

Não quero me aprohrndar nesta complexidade neste momento, assim, em vez 
disso, vamos imaginar umél companhia que venda três tipos de produtos: processadores 
de texto, bancos de dados e planilhas. De acordo com as regras, quando você 
assina um contrato de um processador de te.xto, pode lançar as receitas nos livros 
imediatamente. Se for uma planilha, pode colocar um terço hoje, um terço em sessenta 
dias e um terço em noventa dias. Se for um banco de dados, pode colocar um terço 
hoje, um terço em trinta d.ias e um terço em sessenta dias. Não há base para estas 
regras além dc1 minha própria imaginação febril. Disseram-me que as regras reais são 
tão racionais quanto essas. 

Exemplo: Lançamento de Receitas (Java) 

Este exemplo usa dois roteiros de transação: um para calculc1r o lançamento de receitas 
para um contrato e outro para dizer quanto da receita de um contrato foi lançado 
até uma determinada data. A estruturí\ do banco de dados tem três tabelas: uma para 
os produtos, uma para os contratos e un1a para os lançamentos de receitas. 

CREATE TABLE produtos IIO inl: prim~ry key, nome varchar, tipo vc1rchar) 
CR2ATE TABLE contratos (!D int primary key, produto int, receita decimal, dataAssinatura date) 
CREATE TABLE lança~entosDeReceitas (contrato int, quantia decir.al, lançadaEln date, 

PRH-IAR'i KEi' (contrato, lançadaEm)l 

O primeiro roteiro calcula o total de lançamentos até uma determinada data. 
Posso fazer isso em duas etapas: na primeira seleciono as linhas apropriadas na tabela 
de lançamentos de receitas; na segunda, somo as quantias. 


CAPiTtJLO 9 • PAORÕES DE LÓGICA OE DOMÍNIO 123 

Lançamento de 

Contrato 

Produto Receita 

-data assinatura

tipo 

1 * -receita 1 * -quantia 
-data 

se um contrato tiver quaisquer 
lançamentos de receitas, a receita do 
contrato deve ser igual à soma dos 
valores de seus lan amentos de receitas 

Figura 9.2 Um modelo conceituai para o lançamento simplificado de receitas. Cada 
contrato tem múltiplos lançamentos de receitas que indicam quando as várias parcelas da 
receita devem ser lançadas. 

Muitos projetos de Roteiros dt! Trausnçiio têm roteiros qlte operam diretamente no 
banco de dados, inserindo código SQL no procedimento. Aqui estou usando um simples 
Gntewny de Tabela de Dados (151) para encapsular as consultas SQL. Já que este 
exempJo é tão simples, usarei um único gntewny para todas as tabelas. Posso definir 
um método de busca apropriado no gntewny. 

class Gateway ... 

public ResultSet buscaLançamentoPor (long JDdOContrato, MfDate aParci~De) thr<r~s SQLException { 
PreparedStatement dec = dh.prepareStatement (declaraçãoBuscatançamentos); 
dec.setLong (l, IDàoContrato); 
dec.setDate(2, aPartirDe.toSqlDace() I; 
?.esultSet resultado= àec.executeQueryl )); 
return resultado; 

private static final String ôeclaraçãoBuscaLança~entos = 
,SELECT quantia" t 

• PRc.M lançamentosDeReceitas • i 
• WHERB contrato=? ANO lançadoEm <= ?•; 
private Connection db; 
Eu então uso o roteiro para somM baseado no conjunto de resultados devolvido 
pelo gafewny. 

class ServiçoDeLançamento... 

publ!c Dinheiro receitaLançada (long nOceroDoContrato. MfDate aPartirDel l 
Dinheiro resultado~ Dinheiro.dollars(O); 
try { 

Resu:tset rs = db.buscat.ança~entoPor(n6meroDoContrato, aPartirDe); 
while (rs.nextl)) ! 
resultado=-resultado.add(Dinheiro.dollars(rs.getBigDecirnal(~quantia•))) i 

retum resultado; 
) catch {SQLException e) (throw new AplicationException (e) ; 

) 


124 PARTE li • Os PAORôES 

Quando o cálculo for simples como este, você pode substituir o roteiro em memória 
por uma chamada a uma declaração SQL que use uma função de agregação 
para somar as quantias. 

Para calcular as lançamentos de receitas em um contrato existente, uso uma separação 
similar. O roteiro no serviço se encarrega da lógica de negócio. 

class ServiçoDeLançamento ... 

publíc void calcularLançair:entoDeReceitas(long núneroDoContraco) 
try { 
ResultSet oontratos = db.encontrarContrato(númeroDoContrato); 

contratos.next(); 

Dinheiro receitaTotal = Dinheiro.dollars(contratos.getBigDecimal("rece1ta•) 1; 
MfDate dataLançamento = new MfDate(contratos.getDate(•dataAssinatura•)); 
String tipo= contratos.getString("tipo"); 
if(tipo.equals(•p•)l // planilha { 

Dinheiro alocaçàoll = receitaTotal.alocar(31 i 
db.inserirLançamento 
(núe.eroDoContrato,alocação(O],dacaLançatMnto); 
ôb.inserirLançamento 
(núr.eroDoContrato,alocação(l],dataLançamento.ad1cionaDias(60)); 
db.inserirLançamento 
(núr.eroDoContrato,alocaçào(2],dataLançamento.aâicionaDias(90)) ; 
} else iE (tipo.eguals('T")I // processador de textos ( 
db.inserirLançamento(númeroDoContrato, receitaTotal, dataLança~entol; 

} else if (cipo.equals ('B")I // banco de dados { 
Dinheiro alocaçaoll = receitaTotal.alocar(3); 
db.inserirLançamento 

(nú~ercDoContrato,alocaçao[OJ,dataLançamento); 

db.inserirLançamento 
{nú~eroDoContrato,alocaçao(l],dacaLançameoto.ad.icionaOias{30)1; 
db.in&erirLançamento 
(núkeroDoC-0ntrato,alocaçao(2],dataLançamento.ad.icionaDias(60l); 

} 
) cacch (SQLException e> 1throw new Aplicationfxception(e); 
) 

Perceba que estou usando Dinlteil'o (455) para executar a alocação. Ao dividir 
uma quantia em três é fácil perder alguns centavos. 
O Gatewny de Tnbe/n de Dndos (151) fornece suporte ao SQL. Primeiro há um método 
de busca para um contré'\to. 

class Gate~ay... 

public ResultSet encontrarContrato(long rDdOContrato) throws SOLException ( 
Prepare.dStatement dec = db.prepareStatement ídeclaraçãoBuscaCOntrato) ; 
dec. setLong (l, IDdOContrato) ; 
ResultSet resultado= dec.e.xecuteQueryl I); 
return resultado; 

private static final String declaraçãoBuscaContrato = 

nsBLECT • • • 

• FROM contratos e, produtos p •. 
~ WHERE c.?D = 7 AI/D e.produto= p.ID"; 

CAPÍTULO 9 • PAOAÕES OE LÓGICA OE DOMÍNIO 125 

Em segundo lugar, há um encapsubimento para a inserção. 

cla$s Gat!~ay. . . 

public void inserirLançamento(long IDdoContrato, Dinheiro quan:ia, MfDate aPartirDe) 
thro~s SQLBxception { 
PreparedState:nent dec = db.prepareStatement(declaraçãolnserírLançarnento); 
dec.setLong(l, IDdoContrato); 
dec.setBigOecir.ial(2, quantia.quantia()); 
dec.setDate(J, aPartirDe.toSqlDate()); 
dec.executeUpdate ll ; 

private sLatic final String de<:laracàoinserirtancamenco : 
~rnsERT rnro lanca111entosDeReceitas VAtJJes (?, ? , ?) •; 

Ern um sistema Java, o serviço de lançamento poderia ser uma classe regular ou 

umsessio11 benn. 

Quando você comparar este padrão ao exemplo no Modelo do Domínio (126), a 
menos que sua mente seja tão torcida quanto a minha, provavelmente pensará que 
este é muito mais simples. O pior cenário a se considerar é quando as regras ficam 
mais complicadas. As regras típicas de lançamento de receitas são muito complexas, 
variando não somente com o produto, mas também com a data (se o contrato foi assinado 
antes de 15 de abril, esta regra se aplica ...). É difícil manter um projeto coerente 
com o Roteiro de Trnnsnção, quando as coisas ficam tão complicadas, e este é o motivo 
pelo qual fanáticos por objetos, como eu, preferem usar o Modelo de Domínio 

(126) nestas circunstâncias. 

126 PARTE li • Os PADRÕES 

M odelo de Dominio (Domain Model) 

Um modelo de objetos do domínio tJlfC! incorpora tanto o comporfn111e11fo 
q11a11to os dados. 

Contrato 

receitalançada (data) 
calcufarlançamentos --


,,,

• ,,,,,,, 
,,,,,, 

,,,,,,,,,,

1 1 ' 

,,,,,, 

,,,,,,

Produto /

,,,, 

cafcularl ançamentos (contrato) 

1 ' / 

Estratégia 

Estratégia de 

..... -Completa de 

Lançamento 

Lançamento 

No pior caso, a lógica de negócios pode ser muito <..'Omplexa. As regras e a lógica de 
negócio descrevem muitos casos diferentes e muitas variações de comportamento. 
Os objetos foram projetados justamente para lidar com essa complexidade. Um Modelo 
de Domínio cria uma rede de objetos interconectados em que cada um representa 
algumconceito significativo, que pode ser tão grande quanto uma corporação, ou tão 
pequeno quanto uma linha em um formulário de pedidos. 

Como Funciona 

Colocar um Modelo de Domf11io em uma aplicação envolve a inserção de uma camada 
inteira de objetos que modelam a área de negócios com a qual você está trabalhando. 
Você encontrará objetos que representam os dados do negócio e objetos que capturam 
as regras usadas pelo negócio. Em sua maior parte, dados e processos são com~ 
binados para ju.ntar os processos aos dados com os quais eles trabalham. 

Um modelo de domínio 00 freqüentemente se parece com um modelo de bancode 
dados, embora muitas diferenças persistam. Um Modelo de Domínio mistura dados 
e processos, tem atributos multivalorados, urna complexa rede de associações e 
usa herança. 

Em conseqüência, consigo enxergar dois estilos de Modelo de Domínio. Um Modelo 
de Domínio simp1es se parece muito com o projeto de um banco de dados, tendo, 
na maior parte das vezes, um objeto de domínio para cada tabela do banco de dados. 
Um Modelo de Domínio rico pode parecer diferente do projeto de um banco de dados, 


CAPiYULO 9 • PAORÕES DE LÓGICA OE DOMÍNIO 127 

com herança, estratégias e outros padrões [Gang of Fow-J, e complexas redes de pequenos 
objetos interconectados. Um Modelo de Domínio rico é melhor para a lógica 
mais complexa, mas é mais difícil de mapcc1r para o banco de dados. Um Modelo de 
Domínio simples pode usar o Registro Ativo (165), enquanto que um Modelo de Domínio 
rico requer o Mnpeador de Dados (170). 

Uma vez que o comportamento do negócio é sujeito a muitas alterações, é importru1te 
poder modificar, criar e testar esta camada facilmente. Em conseqüência, 
quanto menor o acoplamento do Modelo de D0111í11io a outras camadas no sistema, mell1or. 
Você perceberá que uma linha mestra de muitos pAdrões de CAmadas é manter 
tão poucas dependências entre o modelo de domínio e outras partes do sistemél 
quanto for possível. 

Existem vários escopos diferentes que você pode usar com um Modelo de Domínio. 
O caso mais simples é uma aplicação monousuário na qual todo o conjunto de 
objetos é lido de um arquivo e trazido para a memória. Uma aplicação desktop pode 
funcionar desta maneira, porém isso é menos comum para um sistema de informações 
multicamadas, simplesmente porque há objetos demais. Trazer todos os objetos 
para a memória demora muito e consome memória demais. A beJeza dos bancos de 
dados orientados a objetos é que eles dão a impressão de fazer isso enqwmto movem 
objetos entre a memória e o disco. 

Sem um banco de dados 00, você mesmo tem que fazer isso. Normalmente, 
uma sessão envolve trazer para a memória todos os objetos nela envolvidos. Isso certamente 
não significa trazer todos os objetos e, na maior parte das vezes, nem mesmo 
todas as classes. Assim, se você estiver olhando um grupo de contratos, poderia 
trazer apenas os produtos referendados pelos contratos dentro do seu conjunto de 
trabalho. Se você estiver apenas efetuando cálculos nos contratos e em objetos de lançamento 
de receitas, não precisa trazer para a memória nenhum objeto produto. O 
que exatamente você trará para a memórill é controlado pelos seus objetos de mapeamento 
de banco de dados. 

Se você precisar do mesmo conjunto de objetos entre chamadas ao servidor, você 
tem de salvar o estado do servidor em algum lugar, o que é o assunto da seção sobre 
gravação do estado do servidor (página 93-94). 

Uma preocupação comum com a lógica de domínio são os objetos de domínio 
inchados. Quando você criar uma tela para manipular pedidos perceberá que uma 
parte do comportamento do pedido só é necessário para esta tela. Se você colocaressa 
responsabilidades no pedido, o risco é que a classe Pedido se torne grande demais 
porque está cheia de responsabilidades que s6 são usadas em um único caso de 
uso. Essa preocupação leva as pessoas a considernrem se uma parte da responsabilidade 
é geral, em cujo caso ela deve ficar na classe Pedido ou especifica, em cujo caso 
ela deve ficar cmalguma classe de uso especifico, que poderia ser um Roteiro de Transação 
(120) ou talvez a própria apresentação. 

O problema em separar comportamento específico de uma situação de uso é 
que isso pode levar a duplicação. O comportamento separado do pedido é difícil de 
achar, de modo que as pessoas tendem a não encontrá-lo e o duplicam. A duplicação 
pode levar rapidamente a mais complexidade e inconsistência, ma descobri que inchaços 
ocorrem com muito menor freqüª nda do que esperado. Se realmente eles 
ocorrerem, são relativamente fáceis de ver e não são difíceis de consertar. Meu conselho 
é não separar comportamento especifico de uma situação de uso. Coloque tudo 
no objeto que parece ser o mais adequado. Conserte o inchaço quélndo, e se, ele se 
tornar um problema. 


128 PARTE li • Os PADRÕES 

Implementação Java 

As discussões sobre o desenv()lvimento d~ um Modelo de D0111í11io em J2EE são 
sempre acaloradas. Muitos dos materiais de ensino e dos livros introdutõrios de 
J2EE sugerem que você use ettfily beans para desenvolver um modelo de domínio, 
mas há s~ric.>s problemas com esta abordagem, pelo menos com a especificação 
corrente (2.0). 

Os ettlity bea11s são mais úteis quando você usa CMP (Container Managcd 
Persistence). a verdade, eu diria que não há muito sentido em usar c11/ily bf'a11s 
sem CMP. Entretanto, CPM é uma fonna limitada de mapeamento objeto-relacional, 
e não consegue suportar muitos dos padrões que você precisa em um Modelo 
dt1 D0111f11io rico. 

Os e11fily /Jeans não devem ser reentrantes. Isso quer dizer que, se você fizer 
uma chamada de um e11tity bea11 para outro objeto, esse outro objeto {ou qualquer 
objeto que ele chamar) não pode chamar o primeiro e11tily /Jrmr. Um Modelo tl1• Do• 
mf11io rico freqüentemente usa reentrância, de modo que esta é uma limitação importante. 
Ela fica pior pelo fato de que é difícil localizar comportamento rl!cmtrante. 
Em conseqüência, algumas pessoas dizem que um e11lity bem, nuncêl deve chamar 
outro. Embora isso evite reentrância, diminui significativamente as vantagens 
de usar um Modelo de D0111i11io. 

Um Modelo d1• Domínio deve usl'lr objetos de granularidade baixa, com interfaces 
de granularidade baixa. Os enlily llf'ans podem ser remotos (antes da versão 

2.0 eles tinham que ser). Se você tiver objetos remotos com interfaces de granularidade 
baixa, obterá desempenhos péssimos. Você pode evitar facilmente esse 
problema, usando apenas interfaces locais para eus e11tity bemts em um Modelo 
de D0111f11io. 
Para rodar oscmlily bea11s você precisa de urn contâiner e um banco de dados 
conectado. l so irá aumentar o tempo de criação e também o de teste, jâ que estes 
têm que ser executados sobre um banco d~ dados. Os e11tlty bea11s são também complicado::. 
para depurar. 

A íllternativíl é usar objetos Java nonnais, embora isso muitas vezes cause 
uma reação de surpresa-éincrível como muitas pessoas pensam que você não pode 
rodar objetos Java normajs emum contâiner EJB. Cheguei à conclusão de que as 
pessoas se esquecem dos objetos Java normais porque eles não tem um nome bonito. 
~ por isso que, durante a preparação para uma palestra em 2000, Rebeca\ Parsons, 
John Mackenzie e eu lhes demos um: POJO (Plain Old Java Objects-velhos 
e bons objetos Java). Um modelo de domínio POJO é fácil de ser reunido e construído, 
pode rodar e ser testado fora de um contâiner EJB e é independente do EJB 
(talvez seja por isso que os vendedores de EJt; nílo lhe encornjem a usá-los). 

Minha visão global é qu(? usar e11tíly l1ea11s como um Modelo de Domfllio funcic)
na se você tiver uma lógica de domínio bastante $imples. Neste caso, você pode 
constwir um Modelo de IJ0111i11io que tenha lU'Tl relacionamento simples com o banco 
de dados: na sua maior parte apenas um e11tity bea11 por tabela do banco de dados. 
Se você tiver uma lógica de domínio mais rica, com herança, estr.itégias e outros 
padrões mais sofisticados, você estará melhor servido com um modelo de domínío 
POJO e um Mapradorde Dados (170), usando uma ferramenta comercial ou 
uma cnmada desenvolvida em casa. 

A maior frustração para mim no uso de EJB é que considero 1.1m Modelo de 
Doml11io complicado o suficiente para lidar, equero ficar tão independente quanto 
possível d(,s detalhes do ambiente de implementação. O EJB faz com que você tenha 
de pensar nele quando pensa no Modelo d1i Domi11io, o que signüica que tellho 
que rne preocupar tanto com o domínio quanto com o ambiente EJB. 


CAPiTULO 9 • PAC>RÕE.S DE LÓGICA C>E DOMÍNIO 129 

Quando usá-lo 

Se o como para um Modelo de Domínio é difícil porque é um assunto extenso, o q11a11do 
édifícil devido tanto à falta de clareza quanto à simplicidade do conselho. Tudo 
se resume à complexidade do comportamento do seu sistema. Se você tiver regras 
de negócio complicadas e em constante mudança, envolvendo validação, cálculos 
e derivações, é bastante possível que você queira um modelo de objetos que lide 
com elas. Por outro lado, se você tiver verificações simples para fazer (nof 1111ll) e 
apenas algumas somas para calcular, um Roteiro de Tra11sação (120) é uma aposta 
melhor. 

Um fator importante aqui é o quão confortável a equipe de desenvolvimento se 
sente com objetos de domínio. Aprender como projetar e usar um Modelo de Domínio 
é um exercício signilíca tivo -que já proporcionou vários artigos sobrea '' mudança de 
paradigma" representado pelo uso de objetos. Certamente é necessário prática e 
orientação para que alguém se acostume a um Modelo de Domínio, mas descobri que, 
uma vez acostumadas, muito poucas pessoas querem voltar a um Roteiro de Trmzsnçâo 
(120), a não ser para problemas muito simples. 

Se você estiver usando um Modelo de Domínio, minha primeira escolha para a interação 
com o banco de dados é o Mapendor de Dados (170). Isso manterá seu Modl!fo 
de Domínio independente e é a melhor abordagem para lidar com casos em que o Moe/
e/o de Domfnio e o esquema do banco de dados divergem. 

Quando você usa o Modelo de Domínio, talvez possa considerar a Cnmada de Serviço 
(141) pará dar ao seu Modelo de Domínio uma API mais separada. 

Leitura Adicional 

Qualquer livro sobre projelo 00 falará sobre Modelos de Domtnio, já que a maior parte 
do que as pessoas chamam de desenvolvimento 00é centrado sobre seu uso. 

Se você estiver procurando por um livro introdutório sobre projeto 00, atualmente 
meu favorito é [Larmc1nl Para exemplos de Modelo de Domí11io, veja [fowler 
AP]. [HayJtambém dá bons exemplos em um contexto relacional. Para construir um 
bomModelo de Domínio, você deve ter uma boa compreensão sobre os conceitos relacionados 
ao uso de objetos. Para isso sempre gostei de [Martin eOdell]. Para compreender 
os padrões que você verá em um Modelo de Domtnio rico, ou em qualquer 
outro sistemél 00, você deve ler [Gang of Four]. 

Eric Evans está escrevendo atualmente wn Livro [Evans] sobre a criação de Modelos 
de Domfoio. Enquanto escrevo isto, vi apenas um manuscrito inicial, mas ele parece 
bastante promissor. 

Exemplo: Lançamento de Receita (Java) 

Uma das maiores .frustrações em descrever um Modelo de D0111f11io é o fato de que qualquer 
exemplo que eu mostre tem de ser necessarjamente simples para que você possa 
entendê-lo. Contudo, esta simplicidade esconde a força do Modelo de Domínio. Você só 
aprecia essa força quando tem um domínio realmente complicado. 

Mas ainda que o exemplo possa não fazer justiça ao porquê de você querer um 
Modelo de Domínio, pelo menos lhe dará uma boa idéia de como ele se parece. Poresta 
razão, estou usando o mesmo exemplo que usei para o Roteiro de Tra11sação (120), 
umc1 pequena questão de lançamento de receitas. 


130 PARTE li • Os PAORÕES 

Uma coisa a ser percebida imediatamente é que cada clé\sse, neste pequeno 
exemplo (Fig~ua 9.3) contém tanto comportamento quanto dados. Mesmo a modesta 
dasse Lançamento de Receitas contém um método simples para descobrir se ovalor 
do objeto pode ser lançado cm determinada data. 

public class Lançarr~ntoDeReceicas. . . 

private Dinheiro quantia; 
privace MfDate dau; 
public LançamentoDeReceicas(Oinheiro quantia, MfDate data) 

this.quantia = quantia: 
this.data ~ data; 

public Dinheiro lerQuantia(J 
return quantia; 

boolean éLançávelElll(MfDate aPartirDel 
recuro aPartirDe.after(daca) li aParcirDe.equals(data); 

Cakular o quanto de uma receita já foi lançada em determinada data, ~nvolve 
tanto a classe Contrato quanto o lançamentoDeReceitas. 

Contrato 

Produto 

-receita * 1 

-dataAssinatura 


-

+ cakularl ançamentos(Contrato) 
+ receitalançada(data): Dinheiro 
+ calcularLanç.amentosO 
* 

1 

"1 

Estratégia de Lançamento 

*1 / 

+ calcularlançamentoDeReceitas(Contrato) 
Lançamento de Receitas 

~ 

-quantia: Dinheiro 
-data: 1 

Estratégia Completa de Lançamento

+ élançavelEm(data) 
+ calcularl ançamentoDeReceitas(Contrato) 
Estratégia de Lançamento em Três E1apas 

-primeiraEtapadelançamento 
-segundaEtapadelançamento 

+ calcularLançamentosDeReceitas(Contrato) 
Figura 9.3 Diagrama de classes para as classes do exemplo de um Modelo de Domlnio. 


CAPiTULO 9 • PAORôES DE LÓGICA DE DOMINIO 131 

class Contrato_ 

priva~e List lançarcentoDeReceitas = new ArrayLisc()r 

public Dinheiro receitaLançada(MfDate aPartirDe) ( 

Dinheiro resultado= Dinheiro.dollars(O); 

Iterator it : lança:nentoDeReceitas. iteratorO; 

while (it.hasNext(>) { 

t.ançamencoDeReceitas r: ltançar.encoDeReceicas) ic.next(): 

if lr.éLançávelfh(aPartirDe)l 

resultado ~ resultado.add(r.lerQuant ia{)); 

return resultado; 

Uma coisa comum que você descobre em modelos de domínio é como múltiplas 
classes têm de interagir para executar até as tarefas mais simples. Isso é o que leva 
à redamação freqüente de que em programas 00 perde-se muito tempo passeando 
pelas classes, tentando encontrá-las. Esta reclamação tern bastante fundamento. O 
benefício surge quando a decisão sobre se algo é lançável ou não em uma certa data 
fica mais complexa, e outros objetos precisam saber. Manter o comportamento no objeto 
que precisa saber evita a duplicação de código e reduz o acoplamento entre os diferentes 
objetos. 

Olhar para o cálculo e a criação destes objetos de lançamento de receitas reforça 
o conceito de sjstemas constituídos de muitos objetos pequenos. Neste caso, o cálculo 
e a criação começam com o cliente e são encaminhados através do produto para 
uma hierarquia de estratégias. O padrão hierarquia [Gang of Four] é um padrão 00 
conhecido que permite combinar um grupo de operações em uma pequena hierarquia 
de classes. Cada instância de um produto é conectada a uma única instâncicl de 
estratégia que determina o algoritmo usado para calcular o lançamento de receitas. 
Neste caso, temos duas subclasses de estratégia de lançamento parn os dois diferentes 
casos. A estrutura do código tem esta aparência: 

class Contrato .. . 

private Produto produto; 

private Dinheiro receita; 

private MfDate data~ssinatura; 

private Long id; 

public Contrato(Produto produto, Dinheiro receita1 MfOate dataAssinatura} 

this.produto = produto; 

this.receita: receita; 

this.dataAssinatura: dataAssinatura; 

class Produto. . . 

private String nome; 

private EstratégiaLançamento estratégiaLançamento; 

public Produto{String nome, estratégiaLançamento estratégiaLançarcentol 

this.non:e = non:ei 

this.estratégiaLançamento = escratégiaLançamento; 

public static Produto novoProC€ssadorDeTexto(Strin9 nome) 
return new Produto(nOll'.e, new EstratégiaLancar.entoTotal ()) 1 


132 PARTE li • Os PADRÕES 

publie static Produto novaPlanilha(String nOi!le) 
return new Produto(norte, new EstracégiaLançamentoEr:fi'tésBtapas{60, 90)) ; 

) 

publie stacie Produto novoBancoDeDados lString nome) { 
return new Produto(n01te, new EstracégiaLançamentoEmTrésEtapas(30, 60)1 ; 

abstract class EstracégiaLançamento { 

abstract void calcularLançamentoOeReceitas(Contrato contrato); 

class EstratégiaLançamencoTotal excends EstratégiaLançamento { 
void calcularLançamentoDeReceitas(Contrato contrato) ( 
contrato.adicionarLançair.entoDeReceitaslnew Lança~entoDeReceitas(contrato.lerReceita(), 
contrato.lerOataAssinatural) )); 

class EstratégiaLançamentoEinTrêsBtapas extenàs EstratégiaLançamento { 

private int priffieiraEtapaDeLançacento; 

private int segundaBtapaDeLançarr~nto; 

public BstratégiaLança~~ntoEmTrêsBtapas(int prúneiraEtapaDeLançar.iento, 

int segundaEtapaDeLançaoenco) 

this.pri~eiraBtapaDeLança~ento: primeiraEtapaDeLançaffiento; 

this.segundaEtapaDeLançamento = segundaEtapaDeLançamento; 

) 

void calcularLançamentoDeReceitas(Contrato contrato> { 

Dinheiro!} alocação~ contrato.lerReceita() .alocar{3); 

contrato.adicionarLançamentoDeReceitas(new LançamentoDeReceitas 

ialocação[O), contrato.lerDataAssinatural)l); 

contrato.adicionarLançamentoDeReceitas(ru:w LançamentoDeReceitas 

(elocaçào(l], contrato.lerDataAssinatura().adicionaOias(primeiraEtapaDet.ançamentol)J; 

contrato.adicionarLançamentoDeReceitas(ne~ Lança=entoDeReceitas 

(alocação(2), contrato.lerOataAssinatura() .adícionaDias(segundaEtapaDeLançamento))) ; 

O grnnde VAior das estrRtégias é que elas fornecem pontos de conexão bem limitados 
para estender a aplicação. Adicionar um novo algoritmo de lançamento de 
receita exige apenas a criação de uma nova subclasse que sobrescreva o método calculnrla11ça111e11toDeRcceifas. 
Isso toma fácil estender o comportamento algorítmico da 
aplicação. 

Quando você cria produtos, os conecta com os objetos de estratégia pertinentes. 
Parei isto em meu código de teste. 

class Teste... 

private Produto processador= Produto.novo?rocessadorOeTexto(•Thinking Word•); 

private Produto planilha= Produto.novaPlanilha("Thinking Cale'); 

private Produto db = Produto.novoBancoOeDados(1Thinking DB•) ; 

Quando tudo estiver pronto, não é necessário conhecer as subclasses de estratégias 
para calcular os lançamentos. 


CAPiTULO 9 • PAORôB DE LÓGICA DE DOMINIO 133 

class Contrac:o... 

public void calcularLançamentos ll 
produto.calcularLança~entoOeReceitas lthis); 

class Produto... 

void calcularLançamentoDeReceitas (Contrato contrato) { 
estratégi~t.ançamento.calcularLançair.entoDeReceitas (contrato); 

A prática 00 de mandru· mensagens de um objeto para outro não só move o 
comportamento para o objeto mais qualificado a lidar com ele, mas também resolve 
muito do comportamento condicional. Você perceberá que não há instruções condicionais 
neste cálculo. Você estabelece o caminho da decisão quando cria os produtos 
com a estratégia apropl'iada. Uma vez que tudo esteja no lugar, os algoritmos simplesmente 
seguem o trilho. Modelos de domínio funcionam muito bem quando você 
tem expressões condicionais parecidas, porque estas expressões podem ser fatora~ 
das para a própria estrutura do objeto. Isso tira a complexidade dos algoritmos e a 
coloca nos relacionamentos entre objetos. Quanto mais parecida for a lógica, mais vezes 
você encontrará a mesma rede de relacionamentos usada em diferentes partes do 
sistema. Qualquer algoritmo que seja dependente do tipo de cálculo de lctnçamento 
pode seguir esta rede especifica de objetos. 

Perceba neste exemplo que não mostrei nada sobre como os objetos são traz idos 
do banco de dados ou nele armazenados. Há algumas razões para isso. Em primeiro 
lugar, mapear um Modelo de Domíllio em um banco de dados é sempre um pouco difícil, 
de modo que me acovardei e não forneci um exemplo. Em segundo lugar, sobre 
muitos aspectos, a questão central a respeito de um Modelo de Domínio é esconder o 
banco de dados, tanto das camadas superiores quanto das pessoas trabalhando no 
próprio Modelo de Domínio. Assim, escondê-lo aqui reflete a realidade do que é programar 
neste ambiente. 


134 PARTE li • Os PADRÕES 

Módulo Tabela (Table Module) 

Uma 1í11ica i11sta11cia que traia n lógica de negócio para todasas Iiultns de 11111n 
tabela ou visiio de 11111 banco de dados. 

Contrato 

Calcularlançamentos (10) ---__

----------:;ô 

_..-~---------
/

Produto --/

~~~ / 

-----------------// 

LerTipoDoProduto (10) ,/
/ 
/

/

/

/
/

/

/

/ 

lançamento de Receitas //

/ 

-------------,,✓ 

Inserir (1D, quantia, data) 

Receitalançada (IDdoContrato, data) 

Um dos conceitos-chave dft orientação a objetos é empacotar os dados com o comportamento 
que os usam. A abordagem orientada a objetos tradicional é baseada em 
objetos identificados, junto com as diretrizes de Modelo de Domínio {126). Assim, se tivermos 
uma classe Empregado, qualquer instância dela corresponde a um empregado 
em particular. Este esquema funciona bem porque, uma vez que tenhamos uma 
referência para um empregado, podemos executar operações neste empregado, seguir 
relacionamentos e obter informações sobre ele. 

Um dos problemas com o Modelo de Domínio (126) é a interface com bancos de 
dados relacionais. Sob vários aspectos, esta abordagem trnta o banco de dados relacional 
como uma tia louca trancada no sótão sobre a qual ninguém quer falar. Em 
conseqüência, muitas vezes você precisa de uma considerável ginástica de programação 
para extrair e gravar dados no banco de dados, realizando a transformação 
entre as duas diferentes representações dos dados. 

Um M6d11/o Tabela organiza a lógica do domínio com w11a classe por tabela do 
banco de dados, e uma única instância de uma classe contém os vários procedimentos 
que atuarão sobre os dados. A distinção primária do Modelo de Domínio (126) é que, se 
você tiver muitos pecLidos, um Modelo rle Domínio (126) terá um objeto Pedido por pedido, 
enquanto que um Módulo Tabela tcu-á um objeto para tratar todos os pccLidos. 

Como Funciona 

A força do Mód11/o Tabela é que ele permite empacotarjuntos os dados e o comportamento 
e, ao mesmo tempo, tira proveito do poder de um banco de dados relacional. 
Na superfície, o M6d11lo Tabela se parece muito com um objeto regular. Aprincipal cti



CAPirULO 9 • PAORÕES DE LÓGICA DE DOMÍNIO 13 5 

ferença é que ele não temo conceito de identidade dos objetos com os quais está trabail1ando. 
Assim, se você quiser obter o endereço de um empregado, deve usar um 
método como uw,MõduloEmpregado. lerEndereço(long IDdoEmpregado). Cada vez que você 
quiser fazer algo com umempregado espccffico, tem que passar algum tipo de identificação 
deste empregado. Freqüentemente, esta será a chave primária usada no 
banco de dados. 

Normalmente, você usa o Mód11lo Tabela com uma estrutura de suporte orientada 
a tabelas. Os dados tabulares são geral.mente o resultado de uma chamada SQL e 
são armazenados em um Conjunto de Registros (473) que imita uma tabela SQL. O Mód11Jo 
Taba/a dá a você uma interface explicitamente baseada em métodos que age sobre 
esses dados. Juntar o comportamento à tabela dá a você muitos dos benefícios do 
encapsulamento, na medida emque o comportamento está próximo aos dados sobre 
os quais ele atua. 

Com freqüência, você precisará do comportamento de múltiplos Módulos Tabela 
de modo a executar algum trabalho útil. Muitas vezes você encontrará múltiplos 
Módulos Tabela operando sobre o mesmo Co11j11nto de Registros (473) (Figura 9.4). 

O caso mais simples é a utilização de um Módulo TnlJeln para cada tabela no banco 
de dados. No entanto, se você tiver consultas e visões interessantes no banco de 
dados, pode ter também Módulos Tabelns para elas. 

O Módulo Tnbeln pode ser uma instância ou uma coleção demétodos estáticos. A 
vantagem de uma instância é que ela permite a você inicializar o Módulo Tabela com 
um conjunto de dados existente, talvez o resultado de uma consulta ao banco. Você 
pode então usar a instância para m.anipular as linhas no conjunto de registros. As instâncias 
também tomam possível ~, utiJjzação de herança, de modo que podemosescrever 
um módulo de um contrato urgente que contenha comportamento adicional 
ao do contrato normal. 

O Módulo Tabela pode incluir consultas ao banco como métodos fábrica. A alternativa 
é um Gntewny pnrn Tnbelns de Dados (151), mas uma desvantagem disso é ter 

new (oConjuntoDeDados)

-umContrato 

1 
calcularl.1nçamentos (IOdoContrato) 1 new 
-----~,.-,(oConjuntoDeDados) 
umProduto 
new 
(oConjuntoDeOados) 

umlançamento 
DeRece,ta

lerTipoDoProduto (IDdoProduto)1 

._ inserir 

Figura 9.4 Diversos Módulos Tabela podem colaborar com um único Conjunto de 
Registros (473). 


136 PARTE li • Os PADRÕES 

uma classe e mecanismo Gnteway pnrn Tabelns de Dados (151) extra no projeto. A vantagem 
é que você pode usar um único Módulo Tabela nos dados de diferentes fontes 
de dados, uma vez que você estará usando Gnll!fvays pnm Tnbelns de Dados (151) diferentes 
para cada fonte de dados. 

Quando você usa um Gatewny para Tabelas de Dados (151), a aplicação primeiro 
usa o Gatewny para Tnbelns de Dados (151} para inserir dados em um Conjunto de Registros 
(473). Você então cria um M6d11/o Tabela com o Conjunto de Registros (473) como 
um argumento. Se você precisar do comportamento de múltiplos Módulos Tabela, 
pode criá-los com o mesmo Conjunto de Registros (473). O Módulo Tabela pode então 
executar a lógica do negócio no Conj1111to de Registros (473) e passar esse Conj,mto 
de Registros (473) modific.ado para a apresentação para que seja exibido e editado 
usando componentes que trabalham com tabelas. Esses componentes não sabem dizer 
se os co11juntos de registros vieram diretamente do banco de dados relacional ou 
se um M6d11/o Tabela manipulou os dados no caminho. Após as modificações na interface 
com o usuário, o conjunto de dados volta para o Módulo Tabela para validação 
antes de ser gravado no banco de dados. Um dos benefícios deste estilo é que 
você pode testar o Módulo Tabela criando um Conjunto de Regis ft'os (473) em memória, 
sem ir ao banco de dados. 

A palavra "tabela" no nome do padrão sugere que você tenha um Módulo Tabela 
por tabela no banco de dados. Embora isso seja verdadeiro em uma primeira aproximação, 
não é completamente verdadeiro. Também éútil ter um Módulo Tabela parn 
visões ou outras pesqwsas comum.ente usadas. Na verdade, a estrutura do Módulo 
Tabeln não depende da estrutura real das tabelas no banco de dados, e sim das tabelas 
virtuais percebidas pela aplicação, incluindo visões e pesquisas. 

um gateway de um Banco

uma apresentaç,ão um Módulo Tabela

Tabela De Dados de Dados 

solicitar dados 
encontrar 
selecionar 

um conjunto 
de registros 

1 

-----------1 • 

aplicar lógica d<;> domínio (um conjunto de registros} 
um conjunto 
de registros 

j

< ----------1J 

atualizar (conjunto de 1 
registros modificado) 1 1 
1 
validar (conjunto de registros modificado) 

atualizar : 
(conjunto de registro~ modificado) 

atualizar 

Figura 9.5 Interações típicas das camadas em torno de um Módulo Tabela. 


CAPiYULO 9 • PAORÔES DE LÓGICA OE DOMÍNIO 13 7 

Quando Usá-lo 

O Módulo Tabela é fortemente baseado em dados orientados a tabelas, de modo que, 
obviamente, o seu uso faz sentido quando você está acessando dados tabulares usando 
um Conjunto de Registros (473). Além disso, o Módulo Tnbeln coloca essa estrutura 
de dados bem no centro do código, então é desejável ainda que o modo de acesso à 
estrutura de dados seja razoavelmente direta. 

No entanto, o Mód11lo Tabcln não dá a você todo o podet dos objetos na organização 
de lógica complexa. Você não pode ter relacionamentos diretos de instância 
cotn instância, e o polimorfismo não funciona muito bem. Assim, para lidar com lógica 
de domínio complexa, um Modelo de Domínio (126) é uma escolha melhor. Essencialmente, 
a escolha entre um e outro padrão é u_m compromisso entre a habHidade 
do Modelo de D0111í11io (126) cm lidar com lógica complexa e a facilidade de integração 
do Módulo Tabela com suas estruturas de suporte orientadas a tabelas. 

Se os objetos em um Modelo de D0111i11io (126) e as tab~las no banco de dndos fo~ 
rem relativamente semelhantes, pode ser melhor usar um Modelo de Domí11ío (126) 
que use Registros Ativos (165). O Módulo Tabela fonciona melhor do que a combinação 
Modelo de Domínio (126) e Registros AIivos (165) quando outras pMtes da aplicação forem 
baseadas em uma estrutura comum, baseada em tabelas. É por esse motivo que 
você não vê muito o Módulo Tabela em um ambiente Java, embora isso possa mudar 
na medida em que conjuntos de linhas se tornem mais largamente usados. 

A situação mais conhecida em que me deparei com este padrão foi nos projetos 
utilizando o Microsoft COM. Em COM (e .NET) o Conjunto de Registros (473) é orepositório 
primário de dados em uma aplicação. Conjuntos de registros podem ser 
passados para a interface com o usuário, onde componentes data aware mostram as 
informações. As bibliotecas ADO da Microsoft fornecem um bom mecanismo para 
acessar os dados relacionais como conjw-\tos de registros. Nesta situação, o Mód11lo 
Tabela permite a você introduzir a lógica do negócio na aplicação de uma maneira 
bastante organizada, sem perder o modo como os diversos elementos atuam sobre os 
dados tab1.1fares. 

Exemplo: Lançamento de Receitas com um Módulo Tabela (C#) 

É hora de revisitar o exemplo do lançamento de receitas que usei nos outros padrões 
para modelagem de domínio, desta vez com um Mód11lo Tnbeln. Apenas para recapitular, 
nossa missão é lançar receitas referentes a pedidos em que as regras de lançamento 
variam de acordo com o tipo do produto. Neste exemplo, temos regras diferentes 
para processadores de texto, planilhas e banco de dados. 

O Módulo Tabeln é baseado em um esquema de dados de algum tipo, normalmente 
um modelo de dados relacional (embora no futuro possamos ver um modelo 
XML usado de forma semelhante). Neste caso, usarei o esquema relacional da Figura 
9.6. 

As classes que manipulam estes dados têm quase que a mesma forma; há uma 
classe Módulo Tabela para cada tabela. Na arqu.itehu-a .NET, um objeto conjunto de 
dados (data sei) fornece uma representação em memória de uma estrutura do banco 
de dados. Assim, faz sentido criar classes que operem sobre estes data seis. Cada 
classe Módulo Tabela tem um atributo do tipo tabela de dados (data table), que é a 
classe .NET correspondente a uma tabela dentro do data sei. A capacidade de ler 
uma tabela é comum a todos os Módulos Tabela e por isso pode aparecer em um 511pertipo 
de Camada (444). 


138 PARTE li • Os PAORôES 

<11abela1> ((tabela» 
<<tabela» Contratos lançamento 
Produtos 1 1 de Receitas -10: Number 
ID: Number -dataAssinatura; Date -~ 

10: Number
Nome: String Quantia: Numbef

* * quantia: Number

Tipo: String 

data: Date 

Figura 9.6 Esquema do banco de dados para o lançamento de receitas. 

class M6duloTabela... 

protected OataTable tabela; 
protected MóduloTabela (l>ataSet ôs, String noo.eDaTabelal 
tabela: às.tables(norneDaTabelaJ; 

O construtor da subclasse du1ma o construtor da superclasse com o nome correto 
da tabela. 

class Contrato... 

public contrato (DataSet os): base (ds, "COntratos"I {) 

lsso permite a você criar um novo Módulo Tabela simplesmente passando o conju.
nto de dados (data set) para o construtor do Módulo Tabela 

contrato= ne~ Contrato ldatasetl; 

o qual mantémo código que cria o datn set separado dos M6d11lô$ Tnbeln, seguindo as 
diretrizes do ADO.NET. 
Uma característica útil é o indexador C#, que localiza Utrul linha específicc1 no 
dnla Lnblc, dada a chave primária. 

class Contrato.. . 

public DataRow this [long chave) 

get ( 
String filtro= String.formac(•Io • jo}•, chave); 
retorn tabela,sele~t ffiltro) IOl; 

l 

A primeira parte da função calcula o lançamento da receita de um contrato, 
atualizando a tabela de lançamento de receitas de acordo. A quantia lançada depende 
do tipo de produto que temos. Já que este comportamento usa principalmente dados 
da tabela Contrato, decidi adicionar o método na classe Contrato. 

class Cont~ato... 

pul:>lic void CalcularLançamentos (long IDdoContrato) { 
DataRow linhaOoContrato this(!DdoContrato); 

2 

Oecir.ial quantia= IOecimal)linhaOoContrato[•quantia•); 


CAPiTULO 9 • PAORÕES OE LÓGICA OE DOMINIO 139 

Lança:nentoDeReceitas lr = new LançamentoDeReceitas (tabela.DataSet); 

Produto proãuto = new Produto (tabela.DataSet); 

long lOdoProduto: ler!DdoProduto(!DdoContrato); 

if (produto.Ler'TipoDoProduto(IDdoProduto) =-= TipoDoProcluto. PT) 

lr.Inserir (IDdoContrato, quantia, (DateTime) LerDataAssinatura{IDdOCôntrato)); 

1e!se if (produto.LerTipoDoProcluto(lOdoProdutol == TipoDoProduto.PI ( 

Decimal ()alocação= alocar(quantia, 3); 

lt.Inserír(IDdoContrato, alocaçâo(O), {DateTime) LerOataAssinaturalIDdoContrato)); 

lr.Inserir(IDdoContrato, alocação[II, (DateTime) 

LerDataAssioatura(IDdoContraco). adicionaDias(60)); 

lr.lnserir (IDdoContrato, alocaçãol21, (DateTime) 

LerDataAssinatura (rDdocont rato) . adicionaDias 190)) ; 

} else iÍ !produto.LerTipoDoProduto(IDdoProduto) == TipoDoProduto.BDI 

Decimal (] alocação= alocar(quantia, 3); 

lr.lnserir(IOdoContrato, a!ocaçâolO!, (DateTiffie) LerDataAssinatura(IDdoContratoll; 

lr.Inserir(IDdoContrato, alocação(ll, (DateTimel 

LerDataAssinatura(rDdOContrato). adicionaDias (30)); 

lr.Inserir(IOdOContrato, alocação(2I, (DateTime) 

LerDataAssioatura(lDdOContraco). adiciona.Dias (60)): 

) else thr® new Exception (•iõentifícaçào inválida de produtO"li 

) 

private DeciDJal[l alocar (Decimal quantia, int quantos) ( 

Decimal resultado!nferior = quantia / quantos; 

resu!tado inferior= Decimal.Round(resultadolnferior, 2) ; 

Decir.ial resultadoSuperior = resultadolnferior ~ O.Olm; 

Decir..al{I resultados= new Decimal [quantos]; 

int resto= (int) quantia\ quantos; 

for (iot : =O; i < resto; í~+) resul tados(il = resultadoSUperior; 

for (int i = resto; i < quantos; i+tl resultados[!) = resultadoinferiori 

recuro resultados; 

Normalmente cu usada a classe Dinheiro (455) aqui, mas para variar um pouco 
usarei dessa vez um decimal. Uso aqui um método de alocação similar ao que uso 
em Dinheiro (455). 

Para isso funcionar1 precisamos de parte do comportamento definido em outras 
classes. O produto precisa ser capaz de nos dizer de que tipo ele é. Podemos fazer isso 
com uma enumeração pru·a o tipo do produto e um método de busca. 

publ ic enum TipoDoProcluto {PT, P, BD); 

class Produto... 

public TipoDoProduto LerTipoDoProduto llong id) 
String enumeração= (String) thts[id] !•tipo"); 
return lTipoDoProduto) Enum.Parse (typeoflTi poDoProduto), enumeração); 

Ler'l'ipoDoProduto encapsuJa os dados no dnta table. Há um bom argumento para fazer 
isso para todas as colunas de dados, em oposição a acessã-los diretamente como 
fiz com a quantia no contrato. Embora o encapsulamento geralmente seja uma boa 
coisa, não o uso aqui porque ele não combina com a suposição de um ambiente em 
que diferentes partes do sistema acessem o conjunto de dados diretamente. Não há 
encapsulamento quando o conjunto de dados se move para a interface com o usuário, 


140 PARTE li • Os PADRÕES 

de modo que funções de acesso a colunas só fazem sentido quando há funcionalidade 
adicional a ser executada, tal como converter uma string em um tipo do produto. 

Esta também é urnR boa horn para mencionar que, embora eu esteja usando aqui 
um dntn set não tipado, porque estes são mais comuns em diferentes plataformas, há 
um argumento forte (página 473-474) para o uso de data set .NET fortemente tipados. 

O outro comportamento adicional consiste em inserir um novo registro de lançamento 
de receitas. 

class LançamentoDeR~ceitas... 

public long Inserir llong IDdoContrato, Decimal quantia. D3te,iree datal 
oataRow novaLinha =tabela.»ewRow( Ir 
long id = GetNextID (); 
nova~inha{•10•) =id; 
novaLinha('IDdoContrato • 1 =IOdoContrato; 
novaLínha(•quantia~l ~ quantia; 
novaLinha [•data•J = String.Format(•{o:s}~. datal; 
tabela.Rows.Add{novaLínha); 
return id; 

Uma vez m,üs, o ponto central deste método é menos encapstúar os dntmvws e 
mais ter um método, em vez de diversas linhas de código repetidas. 

A segunda parte da funcionalidade é somar todas as receitas lançadas em um 
contrato até uma determinada data. Uma vez que esta funcionalidade usa a tabela de 
lançamento de receitas, faz sentido definir o método lá. 

class LançamentoDeReceitas... 

public Decimal ReceitaLançada (long IDdoContrato, DateTime a?art irDe) { 
String filtro= String.Forn-~t ("IDdOContrato: {O} AND data<= ~(1:d}~~. IOdOContrato, 

aPartirDe); 
DataRow (1 1inhas =tabela.Select(filtrol; 
Decimal resultado = Do; 
foreach !DataRO'h linha in linhas} 1 

resultado+= (Decimal) linha(•quantia•J; 

retum resultado; 

Este fragmento tira proveito da ótima característica do J\DO.NET que lhe permite 
definir uma cláusula wltere e então selecionar um subconjunto da tabela de dados 
para manipular. De fato, você pode ir além e usar uma função agregada. 

class LançamentoDeReceitas... 

public Decimal ReceitaLançada2 (long IDdoContrato, DateTicte aPartirDe) { 
String filtro= String.Fermat (•lOdoContrato = {o} ANO data e= ã{l:d}fi•, IDdOContrato, 

aPartirDe); 
String expressãoAComputar = •sua(quantia)~; 
Object soma~ tabela.Coo.pute(expressãoACoo.putar, filtro); 
return lso.w is Syste~.DBnulll ? O: (DeciQal) SO.'llal; 


CAPiTULO 9 • PAORÕES DE LÓGICA DE DOMINIO 141 

Camada de Serviço (Service Layer) 

por Rnndy Stnffard 

Define os limites de u111a aplicnçiio com 11mn camndn de serviços que 
estnbelece 11111 co11j1mto de operações d;spo11íveis ecoordena n 
resposta da nplicnção em cada operação. 

As aplicações corporatjvas normalmente requerem diferentes tipos de interfaces para 
os dados armazenados e para a lógica implementada: carregadores de dados, interfaces 
com usuário , gateways de integração e outros. Apesar de seus objetivos diferentes, 
estas interfaces freqüentemente requerem interações comuns com a aplicação 
para acessar e manipular os déldos e invocar é\ lógica de negócio. As interações 
podem ser complexas, envolvendo transações por meio de múltiplos recursos e a 
coordenação de diversas respostas a uma ação. Codificar a lógica das interações separadamente 
em cada interface acarreta em mtúta duplicação de código. 

Uma Ca111adn de Serviço define a fronteira de uma aplicação [Cockburn PloPJ e 
seu conjunto de operações disponíveis, a partir da perspectiva das camadas de interface 
dos clientes. Ela encé'lpsula a lógica de negócio da aplicação, controlando as transações 
e coordenando as respostas na implementação de suas operações. 

Como Funciona 

Uma Camada de Serviço pode ser implementada de algumas formas diferentes, sem 
violar as características de definição expressas acima. As diferenças aparecem na alocação 
de responsabilidades por trás dé\ interface da Cnmndn de Serviço. Antes que eu 
me aprofunde nas diversas possibilidades de implementação, deixe-me apresentar 
algm1s princípios básicos. 


142 PARlE li • Os PAORÔES 

Tipos de "Lógica de Negócio" Assim como no Roteiro de Transação (120) e no Modelo 
de Domínio (126), a Cnmadn de Seroíço é umpadrão para organizar a lógica do negócio. 
Mtútos projetistas, incluindo a mim, gostam de divicUr a "lógica de negócio" em 
dois Lipos: "lógicn do domínio", relacionada estritamente ao domínio do problema 
(tais como as estratégias para calcular o lançamento de receitas de um contrato) e "lógica 
da aplicação'', relacionada às responsabilidades da aplicação [Cockbmn uq 
(tais como notificar os administradores de contratos e as aplicações integradas dos 
cálculos de lançamento de receitas). A lógica da aplicação é algumas vezes chamada 
de ''lógica de fluxo de trabalho" (workjlow logic), embora pessoas diferentes tenham 
interpretações diferentes pt1ra "fluxo de trabalho". 

Os Modelos de Domf11io (126) são preferíveis aos Roteiros de Transação (120) para 
evitar a duplicação da lógica de domirúo e para gerenciar a complexidade usando 
padrões clássicos de projeto. Contudo, colocar lógica da aplicação em objetos de domínio 
puros traz algumas conseqüências indesejáveis. Primeiro, os objetos de donúruo 
tornam-se menos reutilizáveis em outras aplicações se eles implementarem lógica 
especifica da aplicação e dependerem de pacotes específicos da aplicação. Em segundo 
lugar, misturar ambos os tipos de lógica nas mesmas classes torna mais difícil 
reimplementar a lógica da aplicação, digamos, em uma ferramenta de fluxo de trabalho 
(workflow) se isso se tomar desejável. Por estas razões, a Camada de Seroiço fatora 
cada tipo de lógica de negócio em uma camada separada, produzindo os benefícios 
costumeiros da disposição em camadas e tornando os objetos de domínjo puros, 
mais reutilizáveis de ttma aplicação para outra. 

Variações de lmplementação As duas variantes básicas de implementação são é'\S 
abordagens da fachada de domínio e a do roteiro de operação. Na abordagem da fachada 
de domínio uma Cnmadn de Serviço é implementada como um conjunto de faclladas 
finas sobre umModelo de D0111ínio (126). As classes que implementam as fucl1adas 
não implementam nenhuma lógicõ de negócio. Em vez disso, o Modelo de Domfnio 

(126) implementa toda a lógica de negócio. As fad,adas finas estabelecem uma fronteira 
e um conjunto de operações por meio do qual as camadas clientes interagem com a 
aplicação, exibindo as características que definem uma Cnmada de Serviço. 
Na abordagem roteiro de operação, uma Camada de Seroiço é implementada como 
um conjunto de classes maiores que implementam diretamente a lógica da aplicação, 
mas que delegam a lógica de domínio para as classes de objetos de donúnio 
encapsulados. As operações disponíveis para clientes de uma Cnmndn de Serviço são 
implementadas como roteiros, vários deles organizados cm cada classe definindo 
uma área relacionada de lógica. Cada uma dessas classes, constitui um "serviço" da 
aplicação, e é comum haver nomes de tipos de serviços que começam com "Serviço". 
Uma Cnmnda de Serviço é composta destas classes de serviços da aplicação, que devem 
estender um $11pcrtipo de Cnmndn (444), abstraindo suas responsabilidades e 
comportamentos comuns. 

Ser ou Não Ser Remoto?Ainterface de umi'I classe Cnmndn de Serviço tem granulc1ridade 
aJta quase que por definição, uma vez que ela declara um conjunto de operações 
de apjjcaç~o destinado à interface com as camadas clientes. As classes Camada de 
Serviço são, portanto, apropriadas para invocação remota, da perspectiva da granularidade 
da interface. 

No entanto, a invocação remota tl'az embutido o custo de lidar com a distribuição 
de objetos. Isso provavelmente impõe muito trabalho adicional para fazer as as



CAPiYULO 9 • PAORÕES DE LÓGICA OE D0MINI0 143 

sinaturas dos métodos da sua Camada de Serviços lidaI com Objetos de Tra11sferê11cin de 
Dados (380). Não subestime o custo deste trabalho, especialmente se você tiver um 
Modelo de Domínio (126) complexo e interfaces de usuário sofisticadas para complexos 
casos de uso de ntunlização! É significativo e trabalhoso -taJvcz ele perca apenas 
para o custo e trabalho necessários para o mapeamento objeto-relacional. Lembre-se 
da Primeira Lei do Projeto de Objetos DistribLúdos (página 100-101). 

Meu conselho é começar com uma Cnmndn de Serviço invocada localmente, cujas 
assinaturas dos métodos lidem com objetos do domínio. Acrescente d1amadas remotas 
quando precisar (se precisar) colocaJ1do Fnclzndns Remotas (368) na sua Cnmnda 
de Sarviço ou fazendo os objetos da sua Omrndn da Serviço implementarem interfaces 
remotas. Se a sua aplicação tiver uma interface com o usuário baseada na Web ou um 
gntcwny de integração baseado em serviços Web, não há lei que diga que a sualógica 
de negócio tenha que rodar em um processo separado das páginas no servidor e serviços 
Web. De fato, você pode economizar algum esforço de desenvolvimento e tempo 
de resposta durante a execução, sem sacrificar escalabilidade, começando com 
uma abordagem que as coloque lado a lado. 

Identificando Servjços e Operações Identificar as operações necessárias na fronteira 
de uma Camada de Serviço é bastante claro. Elas são determinadas pelas necessidades 
dos djentes da Cnmndn de Serviço, a mais significativa (e primejra) das quajs é 
geralmente uma interface com o usuário. Uma vez que uma interface com o usuário 
é projetada para suportar os casos de uso que os atores querem realizar com uma 
aplicação, o ponto de partida para identificar as operações da Camndn de Serviço é o 
modelo de caso de uso e o projeto da interface com o usuário da aplicação. 

Por mais desapontador que seja, muitos dos casos de uso em uma aplicação corporativa 
são simples e maçantes casos de uso "CRUD" (iniciais em inglês para criar, ler, 
atualizar e excluir) sobre objetos do donúnio-criar um destes, ler um conjunto daqueles, 
atualizar este outro. Minha experiência é de qu.e quase sempre existe uma correspondência 
um-para-um entre casos de uso CRUD e operações da Cnmndn de Serviço. 

As responsabilidades da aplicação em Jevar a cabo esses casos de uso, todavia, 
podem ser tudo, menos maçantes. Validações à parte, criação, atualização 01.1 exclusão 
de um objeto do domínio em uma aplicação, cada vez mais requerem notificações 
a outras pessoas e aplicações integradas. Essas respostas devem ser coordenadas 
em transações atônúcas por operações da Cnmnda de Serviço. 

Seria bom se fosse assim tão fácil identificar as abstrações da Cnmndn de Serviço 
para agrupnr operações relacionadas. Não há uma lei obrigatória nesta área, apenas 
heurísticas vagas. Para uma aplicação suficientemente pequena, pode ser o bastante 
ter apenas uma abstração, com o mesmo nome da aplicação. Segundo minha experiência, 
aplicações maiores são particionadas em diversos ''subsistemas", cada 
um dos quais inclui uma fatia vertical completa da pilha de camadas da arquitetura. 
Neste caso, prefiro uma abstração por subsistema, cujo nome provém desse subsistema. 
Outras possibilidades incluem abstrações refletindo parti\ões importantes 
em um modelo de domínio, caso estas sejam diferentes das partições do subsistema 

(p. ex., Serviç.oDeContracos, ServiçoDeProduc.os) e abstrações cujo nome deriva de comportamentos 
temáticos da aplicação (p. ex., ServiçoDeLançamento). 
Implementação Java 

Tanto na abordagem fachada dt! dumínio quélnto na abordagt.!m roteiro dt.: operação, 
uma classe da Camada de Serviço pode ser implementada como um POJO 


144 PARTE li • Os PAORÕES 

ou um sessio11 bea11 sem estado. O compromisso é entre a facilidade de teste e a 
facilidade d~ controle de h·ansação. Os POJOs poderiam ser mais fáceis de tcsté\
r, já que não têm que ser cr\rregados em um contãiner EJB para rodar, mas é 
mais difícil para uma Camada de St1rviço baseada em POJOs se adaptar a um ambiente 
de servíços de transações distribuídas gerenciados por contâineres, especialmente 
em chamadas inter-serviços. Os EJBs, por outro lado, já vêm com o 
pr,tencial pMa transações distribuídas gerenciadas por contâineres, mas têm 
que ser carregados em um contâiner antes que possam ser executados e testados. 
Escolha seu veneno. 

Minha maneira preferida de aplicar uma Camada de Serviço em J2EE é com 
sl'.ssio11 bea11s EJB 2.0 sem estado, usnndo interfaces locais, e a abordagem do roteiro 
de operação, delegando a objetos POJO de classes do domínio. Émuito corweniente 
implementar umc1 C amada de Serviço usando sessio11 lmms sem estado, por 
causa das transações distribuídas gerenciadas pelo contâiner fornecidas pelo EJB. 
Além disso, com as interfaces locais intrnduzidas no EJ B 2.0, uma Camada de Serviço 
pode explorar os valiosos serviços de transação ao mesmo tempo ~i'n que evita 
as espinhosas questões envolvendo distribuição de objetos. 

Em uma observação específica paraJava, deixe-me diferenciar a Cmnada de 
St>rviço do padrão Facliadn dr Sessão (Session Facade) documentado na litera lura de 
padrões J2EE [Alur l'f ai. ] e [Marinescu). A Facltndtl de Sessão foi motivada pelo desejo 
de evitar a perda de desempenho causadt) pelo excesso de chamadas remotas 
em enlity be1111s. Nesse sentido, ela recomenda o uso de sessio11 beans atuando 
como fachada para entlty /Jea11s. Em vez disso, a motivação da Cam ada de Serviço é 
fatorar responsabilidade para evitar duplicação e promover· a reutilização. É um 
padrão arquitetural que transcende a tecnologia. De fato, o padrão fro11teirí1 da 
aplicação [C(,ckburn PloP] que inspirou a Camada de ServiÇ()S precede o EJB em 
três anos. AFaclwft1 de Serviço pode estar no l'spfrHo da Camarln de Serviço, mas, 
como correntemente chamada, definida em seu escopo e apresentada, os padrões 
não são <b mesmos. 

Quando Usá-la 

O benefício da Cnmnda de Serviço éque ela define um conjunto comum de operações 
da aplicação disponível para muitos tipos de clientes e coordena uma resposta da 
aplicação cm cada operação. A resposta pode envolver lógica de aplicação que precise 
ser executada atomicamente por diversos recursos transacionais. Assim, em uma 
aplicação com mais de um tipo de cliente da sua lógica de negócio e respostas complexas 
aos casos de uso, envolvendo múltiplos recursos transacionais, faz basbmte 
sentido incluir uma Camada de Serviço com transações gerenciadas por contâiners, 
mesmo em uma arquitetura não-distribuída. 

A questão mais fácil de responder é provavelmente quando não usá-la. Você 
provavelmente não precisa de uma Camada de Serviço se a lógica de negócío da sua 
aplicação só tiver um tipo de cliente -digamos, uma interface com o usuário -e as 
respostas aos seus casos de uso não envolverem mt'iltip1os recursos transacionais. 
Neste caso, seus Controladores de Página podem controlar manualmente as transações 
e coordenar qualquer resposta que seja requerida, talvez delegando diretamente 
à camada da Fonte de Dados (Data So11rce). 

No entanto1 se você prever um segundo tipo de cliente ou um segundo recurso 
transacional em resposté'ls de casos de usos, vale a pena projetar uma Cnmndn de Serviço 
desde o início. 


(APiYULO 9 • PA!>RÔES DE LÓGICA DE DOMINIO 145 

Leitura Adicional 

Não há muita coisa anterior sobre a Camada de Serviços cuja inspiração é o padrão 
fronteira da aplicação de AJistair Cockburn [Cockburn PloPj. Na área de serviços remotos 
[Alpert et nl.j discutem o papel das fachadas em sistemas distribuidos. Compare 
este trabalho com as várias apresentações de Facl,ndas de Seção fAlur et nl. Je [Marinescu]. 
No tópico sobre responsabilidades da aplicação que devem ser coordenadas 
dentro de operações da Camada de Serviço, é muito útil a descrição de Cockburn 
de casos de uso como um contrato de comportamento [Cockbum UC). Uma referência 
anterior sobre fundamentos é a metodologia F11sion para a identificação de "operações 
do sistema" {Coleman et ai.]. 

Exemplo: Lançamento de Receitas (Java} 

Este exemplo continua o exemplo de lançamento de receitas dos padrões Roteiro de 
Tm11snção (120) e Modelo de Do111í11io (126), demonstrando como a Camada de Serviçosé 
usada para fazer um roteiro da lógica de aplicação e delegar a lógica do domínio em 
uma operação da Camndn de Serviço. file usa a abordagem do roteiro da operação para 
implementar uma Cnmnda de Serviço, primeiro com POJOs e depois com EJBs. 

Para realizar a demonstração, expandimos o cenário para incluir um pouco de 
lógica de aplicação. Suponha que os casos de uso da aplicação requeiram que, quando 
o lançamento de receitas de um contrato for calculado, a aplicação deva responder 
enviando um e-mnil, notificando este evento a um administrador de contrato designado 
e publicando uma mensagem, usando um middlewarc orientado a mensagens, 
para notificar outras aplicações integradas. 

Começamos alterando a classe ServiçoDeLançamento do exemplo do Roteiro de 
Transação (120) para estender uma Camada Supertipo (444) e para usar algtms Galeways 

(436) na execução da lógica de aplicação. Isso produz o diagrama de classes da Figura 
9.7. ServiçoDeLançamento se torna uma implementação POJO de um serviço de 
aplicação Cnmndn de Serviço, e seus métodos representam duas das operações disponíveis 
na fronteira da aplicação. 
Os métodos da classe ServiçoDelançamento constroem o roteiro da lógica de 
aplkação das operações, delegõndo a lógica do domínio para os objetos pertencentes 
às classes do domínio (do exemplo do Modelo de Domínio (126)). 

public class ServiçoDeAplicação ( 
protected GatewayDeE:t:iail obterGatewayDeEmail{) 
//retorna uma instancia de GatewayOeEmail 

protected GatewayDelntegracao obterGac.ewayDeintegracao(l 
//retorna urna instancia de GatewayDe:ntegracao 

) 

public :nterface GatewayDeEmail ( 

void enviarEtnail(String endereoo, String assunto, String corpoDall.ensagem); 
} 
public interface GatewayDeintegracao { 

void public3rCálculoD:LançaeientoDe?.eceita{Contrato contrato); 

public class ServiçoDeLançamento 
extends ServiçoDeAplicaçào { 


Camada de Service 

.... 

.i::,. 
O'I 

= 

• 

«interface»

ServiçoDeAplicação 
GatewayDeEmail 

+enviarEmail(in end ereço: String, in assunto: String, in corpo: String): void

+obterGatewayDeEmail(): GatewayDeEmail 

/1\.

+ObterGatewayDelntegração: GatewayDelntegração 1 

1 
1 
((usa» 

,---------



1 
1 
1 

1 «interface» 

1 GatewayDelntegração

1 

1 
1 + publicarCálculoDelançamentoDeReceita (in contrato: Contrato): void 

1 
1 
1 

ServiçoDelançamento «usa» 

+calcularlançamentoDeReceitas (in númeroDoContrato: long): void 
+receitaslançadas (in númeroDoContrato: long, in aPartirDe: Date): Dinheiro 

Figura 9.7 Diagrama de Classes POJO ServiçoDelançamento. 


(APiYULO 9 • PAC>AOES DE LÓGICA DE DOMÍNIO 147 

public ,•oid calcularLançamentoDeReceit4s(long núrneroDoCon:.raro} ( 

Contrato contrato= Contrato.ler?araAtualização(oúmeroDoCOiltrato); 

cont!'ato.calcularLançamentos(); 

obterGatewayDeEmail().enviarEmaíl l 

contrato.lerEmailDoAdcínistrador() , 

ºRE: Contrato#" númeroDoConcrato,

T 

contrato• • teve o lançamento de receitas ca.l~lado.•): 
obterGatewayDe!ntegracao!) .publicarCálculoDeLançai:.entoDeR~eíta(contratol ; 

public Dinheiro receitasLançadas (long número.DoConrn1to, Date aPartírDe) 
Nturn Contrato.ler(númeroDoContrato}.receitaLançada(aPartirDe); 

Os detalhes de persistência são novamente deixados fom do exemplo. É stúiciente 
dizer que a classe Contrato implementa métodos estáticos para ler contratos 
da camada de dados, identificados pelos seus números. Um desses métodos tem um 
nome que revela uma intenção de atualizar o contrato lido, o que permite a um Mnpenrlor 
de Dados (170) relacionado registrar o(s) objeto(s) lido(s) com uma Unidada de 
Trnbalho (187), por exemplo. 

Detalhes de controle de transação são também deixados de fora do exemplo. O 
método calcularLançamentoDeReceitas() é inerentemente transacional porque, durante 
sua execução, objetos persistentes referentes a conh-é'ltos são modificados por meio dn 
adição de lançamentos de receitas, mensagens são enfileiradas em um middleware 
orientado a mensagens e e-mails são enviados. Todas essas respostas devem ser executadas 
atomicamente, no contexto de uma transação, porque não queremos enviar 
e-mails e publicar mensagens para outras aplicações se as alterações do contrato não 
puderem ser gravadas. 

Na p lataforma J2EE podemos deixar o contêiner EJB gerenciar as transações 
distribuídas implementando serviços de aplicação (e Gall!wnys (436)) como sessio11 
benns sem estado que usam contextos de transação. A Figura 9.8 mostra o diagrama 
de classes de uma implementação do ServiçoOeLançamento que usa interfaces locais EJ B 

2.0 e o idioma "interface de negócio''. Nesta implementação uma Camada Supertipo 
(444) é ainda usada, fornecendo implementações padrão dos métodos de beaus requeridos 
pelo EJB, além dos métodos específicos da aplicação. Se partirmos do principio 
de que as interfaces GatewayDeEmail e GatewayOeintegração também são "interfaces 
de negócio'' para seus respectivos scssion beans semestado, então o controle da transação 
rustribuída é obtido declarando-se os métodos calcularLançamentoOeReceitas, enviarEmail 
e puhlicarCálculoDeLançamentoDeReceita como sendo transacionais. Os métodos 
do ServiçoOelançamento do exemplo POJO são movidos sem alterações para a 
classe ImplementaçâoDoBeanServiçoDeLançamento. 
O ponto importante sobre o exemplo é que a Camada de Seroiço usa conjuntamente 
um roteiro de operação e objetos de classes do domínio na coordenação da .resposta 
transacional d;:i operação. O método calcularLançamentosOeReceitas contrói o 
roteiro da lógica de aplicação da resposta requerida pelos casos de uso da aplicação, 
mas delega a lógica do domínio para os objetos das classes do domínio. Ele também 
apresenta algumas técnicas para combater a lógica duplicada dentro dos roteiros de 
operação de uma Camada de Sen,iço. As responsabilidades são fatoradas em diferentes 
objetos, (p. ex., Gafewnys (436)) que podem ser reutilizados por meio de delegação. 
Uma Camadn S11pertipo (444) fornece acesso adequado a esses outros objetos. 


«interface» 

ServiçoDelançamento 

+calcularlançamentoDeReceitas (in númeroDoContrato: long): void 
+receitaslançadas (ín númeroDoContrato: long, in aPartirDe: Date): Dinheiro 

A Lê_ 

«interface» 

BeanServiçoDelançamento 

lmplementaçãoDoBeanServiçoDelançamento 

+calcularLançamentoDeReceitas (in númeroDoContrato: long): void 
+receitaslançadas (in númeroDoContrato: long, in aPartirDe: Date): Dinheiro 

Figura 9.8 Diagrama de classe EJB para o ServiçoDelançamento. 

Camada de Service 

.... 

.i:. 

= 

• 

«interface» «interface» 

javax.ejb.EJBLocalObject javax.ejb.SessionBean 

1 A 

1 ---
1 
1 

lmplementaçãoDoBeanServiçoDeAplicação 

+obterServiçoDeEmail( ): ServiçoDeEmail 
+obterServiçoDelntegr ação: ServiçoDelntegração 


CAPÍTULO 9 • PAOAÔES DE LÓGICA DE DOMINIO 149 

Alguns podem argumentar que uma implementação mais elegante do roteiro 
de operação usaria o padrão Observcr [Gang of Four ], mas o Observer é difícil de implementar 
em uma Cnmadn de Serviço sem estado e com múltiplas thrends. Na minha 
opinião, o código aberto do roteiro de operação é mais claro e mais simples. 

Alguns poderiam ainda argumentar que as responsabilidades da lógica de aplicação 
poderiam ser implementadas em métodos de objetos do domínio, tais como 
Concrato.calcularLançamentoDeReceitas O, ou até mesmo na camada de dados, elimjnando 
com isso a necessidade de uma Camada de Serviço separada. Acredito no entanto, 
essas atribuições de responsabilidades indesejáveis por uma série de motivos. Primeiro, 
as classes de domínio são menos reutilizáveis em outras aplicações se implementarem 
lógica especifica da aplicação (e dependerem de Gnlewnys (436) específicos 
da aplicação, e assim por diante). Elas deveriam modelar as partes do domínio do 
problema que são de interesse da aplicação, o que não significa todas as responsabilidades 
dos casos de uso da aplicação. Segundo, encapsular lógica de aplicação em 
uma camada "mais alta" dedicada a esse propósito (o que a camada de dados não é) 
facilita a alteração da implementação dessa camadA -para usar talvez um mecanismo 
de fluxo de trabalho (workflow). 

Como um padrão para a organização da camada de lógica de uma aplicação 
corporativa, a Cnmadn de Seroiço combina roteiros e classes de objetos do domú1io, 
alavancando os melhores aspectos de ambos. Diversas variações são possíveis na implementação 
de uma Camnda de Serviço-porexemplo, fachadas de domínio ou roteiros 
de operação, POJOs ou sessio11 ben11s, ou uma combinação de ambos. A Camnda de 
Serviço pode ser projetada para chamadas locais, chamadas remotas ou amhas. Mais 
importante de tudo, independentemente dessas va riações, este padrão estabelece a 
fundação para a implementação encapsulada da lógica de negócio de uma aplicação 
e para a chamada consistente dessa lógica por seus diversos clientes. 


CAPÍTULO 

1o 

Padrões Arquiteturais de Fontes 

•de Dados (Data Source) 

CAPilULO 10 • PAORÓES ARQUITETURAIS DE FONTES DE DADOS (DATA SOURCE) 151 

Gateway de Tabela de Dados (Table Data Gateway) 

Um objeto que at11n como 11111 Galewny (436) pnm 11111a tabela do banco de dados. 
Umn i11stn11cin lida com todas ns linhns na tabela. 

Gateway Pessoa 

encontrar (id): ConjuntoDeDados 

encontrarPeloSobrenome (String): ConjuntoDeOados 

atuallzar (id, sobrenome. prenome. númeroDeDependentes) 

inserir (sobrenome, prenome. númeroDeDependentes) 

apagar (id) 

Misturar SQL com a lógica da aplicação pode causar vários problemas. Muitos desenvolvedores 
não se sentem confortáveis com SQL, e muitos dos que se sentem, podem 
não escrevê-lo bem. Osadministradores de bancos de dados precisam poder encontrar 
facilmente as instruções SQL de modo que eles possam descobriJ como ajustai
· e aprimorar o banco de dados. 

Urn Gateway de Tabela de Dados armazena todo o SQL utilizado para é'lcessar umn 
única tabela ou visão: seleções, inserções, atualizações e exclusões. Os outros códigos 
chamam os métodos do Gatewny para toda a interação necessária com o banco de dados. 

Como Funciona 

Um Gntewny de Tabeln de Dados tem uma interface simples, consistindo normalmente 
de diversos métodos de busca para obter dados do banco de dados e métodos para 
atualizar, inserir e excluir dados. Cada método mapeia os parâmetros de entrada em 
uma chamada SQL e executa o SQL sobre a conexão com o banco de dados. O Gntewny 
de Tabela de Dados normalmente não retém estado, já que seu papel é simplesmente 
enviar dados do banco e trazer dados para o banco. 

O mais complicado cm um Gntewny de Tabela de Dados é como ele deve retomar 
informações de uma consulta. Mesmo uma consulta simples, do tipo recuperar um 
registro dada a chave primárja, retornará diversos itens de dados. Em ambientes onde 
você pode retornar múltiplos itens, você pode usar esta característica para retornar 
uma única linha da tabela, mas muitas linguagens permitem apenas um único 
valor de retomo, e muitas buscas retornam múltiplas linhas. 

Uma alternativa é retornar alguma estrututa de déldos simples, tal como um 
mapa. Um mapa.funciona, mas força a cópia dos dados do conjunto de registros que 
retorna da consulta ao banto de dados para o mapa. Penso que o uso de mapas para 
passar dados é uma prática rnim, porque ele frustra a verificação em tempo de compilação 
e não é uma interface muito explícita, levando a fa lhas quando c1s pessoas 
não entendem o que está no mapa. Uma alternativa melhor é usa1· um Objeto de Transferência 
de Dados (380). Émafa um objeto que tem de ser criado, mas é um objeto que 
pode muito bem ser usado cm todo lugar. 

Para evitar tudo isso, você pode retornar o Conjunto de Registros (473) resultante 
da consulta SQL. Conceitualmente, isso é confuso, uma vez que, idealmente, o ob~ 
jeto na memória não tem que saber nada a respeito da interf<\ce SQL. Isso também 
pode tornar difícil substituir o banco de dados por um arquivo, se você não puder 


152 PARTE li • Os PAORÔES 

criar conjuntos de regjstros com facilidade no seu próprio código. Apesar djsso, em 
muitos ambientes que fazem uso extensivo de Conjuntos de Registros (473), tal como o 
.NET, esta é uma abordagem muito efetiva. Desta forma, um Gntewnyrle Tabeln rle Dndos, 
combina muito bem com o Módulo Tnbe/a (134). Se todas as suas atualizações fo. 
rem feitas por meio do Gateway de Tnbela de Dados, os dados retomados podem ser baseados 
em visões, em vez de nas tabelas reais, o que reduz o acoplamento entre o seu 
código e o banco de dados. 

Se você estiver usando um Modelo de Domínio (126), pode fazer o Gafl'1uay de Tabela 
de Dados retomar o objeto de domínio apropriado. O problemn dfaso é que você 
passa a ter dependências bidirecionais entre os objetos do domúúo e o gateway. Os 
dois são intimamente conectados, de modo que isso não é necessariamente algo terrível, 
mas é algo que sempre reluto em fazer. 

Na maioria das vezes em que você usar um Cateway de Tabela de Dados, terá um 
para cada tabela no banco de dados. Para casos mtúto simples, entretanto, você pode 
tet· um único Galcway de Tabela de Dados que lide com todos os métodos para todas 
as tabelas. Você também pode ter um gntewny para visões ou até mesmo para pesquisas 
interessantes que não são mantidí'ls no banco de dados como visões. Obviamente, 
muitas vezes, os Gnteway de Tabela de Dados baseados em visões não são atualizáveis 
e, assim, não terão o comportamento de atualização. Contudo, se você puder fazer 
atualizações nas tabelas associadas, então encapsular essas atualizações por b·ás 
de operações de <1tualizaçâ() no Gnteway de Tabela de Dados é uma excelente técnica. 

Quando Usá-lo 

Assim como com o Calewny de Linhade Dados (158), a decisão relativa ao Gatewny de Tabela 
de Dados é, em primeiro lugar, usar ou não um Gnteway (436) e, depois, qual deles. 

Acho que o GatewmJ de Tabela de Dados é provavelmente o padrão de interface de 
banco de dados mais simples de usar, na medida em que ele mapeia tão bem tanto para 
uma tabela de em banco de dados quanto para um tipo registro. Ele também consiste 
cm um lugar natural para encapsular a exata lógica de acesso da fonte de dados. Eu 

o uso menos com o Modelo de Domínio (126) porque acredito que o Mapcador de Dados 
(170) provê um isolamento melhor entre o Modelo de Domínio (126) e o banco de dados. 
O Gateiony de Tabeln de Dados funciona especialmente bem com o Módulo Tabela 
(134), no qual ele gera um conjunto de registros para ser usado pelo Mód11/o Tabela 
(134). Em verdade, não consigo imaginar qualquer outra abordagem de mapeamento 
de banco de dados para o Mâdulo Tabela (134). 

Assim como o Gateway de Linha de Dados, o Gnteway de Tabela de Dados é muito 
apropriado para Roteiros de Transação (120). A escolha entre os dois se reduz a como 
eles lidam com múltiplas linhas de dados. Muitas pessoas gostam de usar um Objeto 
de Transferência de Dados (380), mas isso me parece não compensar o trabalho, a menos 
que o mesmo Objeto de Tra11sferê11cia de Dados (380) seja usado emalgum outro lugar. 
Prefiro o Cntewny de Tnbcla de Dados quando a representação do conjunto resultante 
for conveniente para ser manipulado pelo Roteiro da Trn11saçiío (120). 

É interessante observar como muitas vezes faz. sentido fazer os Mnpendores de 
Dados (170) se comunicarem com o banco de dados por meio de Gateways de Tabela de 
Dados. Embora isso não seja útil quando tudo écodificado à mão, pode ser muito efetivo 
se você quiser usar metadados para os Gateways de Tabela de Dados, mas preferir 
codificar à mão o mapeamento real para os objetos do domínio. 

Um dos benefícios na utilização de um Gatcway de Tabela de Dados é que a 
mesma interface pode funcionar tanto na utilização de SQL para manipufar o ban



CAJ>ilUL0 1 O • PA0RÕES ARQUITffiJRAIS oe FONTES OE OA00S (DATA SOURCE) 153 

co de dados quanto na utiliwção de procedimentos armazenados. De fato, os próprios 
procedimentos armazenados são muitas vezes organizados como Gateways 
de Tnbeln de Dados. Dessa forma, os procedimentos armazenados para inserção e 
atualização encapsulam a estrutura real da tabela. Neste caso, os procedimentos 
de pesquisa podem retornar visões, o que ajuda a esconder a estrutura das tabelas 
correspondentes. 

leitura Adicional 

[Alur et nl.Jdiscutem o padrão Objeto de Acesso a Dados, que é um Gnteway de Tabela de 
Dados. Eles mostram como retornar uma coleção de Objetos de Transferência de Dados 

(401) nos métodos de consulta. Não fica claro se eles vêem este padrão como sendo 
sempre baseado em tabelas. A intenção e a discussão parecem sugerir ou um Gatewny 
de Tabela de Dndos ou um Gntetvny de Linha de Dados (158). 
Usei um nome diferente, em parte porque vejo este padrão como um uso particul<
1r do conceito mais genérico de Gntewnys (436) e quero que o nome do padrão reflita 
isso. Além do mais, o termo Objeto de Acesso n Dndos (Dntn Access Object) e sua 
abreviação DAO tem seu próprio significado especifico dentro do mundo Microsoft. 

Exemplo: O Gateway Pessoa (C#) 

Um Gntewny de Tnbeln de Dados é a forma usual de acesso a banco de dados no mundo 
Windows, então foz sentido ilush ar seu uso com C#. Tenho que enfatizar, no entanto, 
que esta forma clássica de Gntewny de Tnbeln de Dados não se ajusta perfeitamente 
ao ambiente .NET, já que ela não tira. proveito do conjunto de dados (dntn set) 
AOO.NET. Em vez disso, ela us<1 o leitor de dados (data render), que é uma interface 
do tipo cursor para registros de bancos de dados. O leitor de dados é a escolha certa 
para mélnipular quantidades m<1iores de informação quando você não quiser trazer 
ludo para a memória de uma só vez. 

Para o exemplo, estou usando uma classe Gateway Pessoa que conecta a uma 
tabela pessoa em um banco de dados. O Gateway Pessoa contém o código de busca, 
retornando um leitor de dados ADO.· F.T para acessar os dados retornados. 

cl3ss GatFewayPessoa ... 

public IDataReaàer EncontrarTodos ( t { 
String sql 2 'SBLBC'I' • FROM pessoa"i 
return ne·~ OleObCon:mand (sql, DB. Connection) . ExecuteReader ( ) ; 

public roataReader EncontrarPeloSobrenome !String sobrenome) 
String sql :, -sELECT • ?ROM pessoa '"'HERE sobrenome : ?•; 
IDbCo.-:r:nand coo:.~= new OleDbCommand(sql, DB.Connection): 
comm.Parameters.Add(new OleDbParameter('sobrenome•, sobrenome)) ; 
return coom.Ex.ecuteReader{ ); 

public IDataReaãer EncontrarComCondição !String cláusulaCondicional) ( 
String sql = String.Fonnac(ªSSLECT • PRC~ pessoa WHBRE joj•, cl!usulaCondiciona!}; 
return new OleDbc:ooJitand(sql, DS.Connection).EXecuteReader( ); 

Na maioria das vezes, você desejará enviar de volta u.m conjunto de linhas com 
um leitor. Em raras ocasiões, você pode desejar pegar uma linha de dados inctividual: 


154 PARTE li • Os PADRÕES 

class GatewayPessoa... 

public Object( 1 EncontrarLinha llong chave) { 
String sql = •ssLBCT • FROM pessoa ~1l6RB id : ?•; 
IObCommand comm = new OleDbCoffl!lland(sql, DB.Connection) 1 
comm.Para:neters.Add (new OleDbParameter ("chave•, chave}) ; 
IOataReader leitor= comm.ExecuteReader( >; 
leitor. Re<1d C ) ; 
Object{) resultado= new Objectlleitor.FieldCount), 
leitor.GetValues(resultado); 
leitor.Closel l ; 
return resultado; 

Os métodos de atualização e inserção recebem os dados necessários em parâmetros 
e chamam as rotinas SQL apropriadas. 

class GatewayPessoa ... 

public void atualizar llong chave, String sobrenome. String prenorre, long nútr.eroDeDependentesJ { 
String sql = •• 

UPOATE pessoa 
SET sobren1Xr~ = ?. preno:ne =?, n1'.ímeroDeDependentee =? 
l\liERE id = ? " i 

IDbCoounanà canm = new OleDbCorn.'l\and(sql, DB.Connection); 
cornm.Par.uieters. Md (new 0leDbParameter (•sobrenome•, sobrenome)) ; 
comm.Parareters.Add (new OleDbParameter (•prenome•, prenor.e)I ; 
COill1l.Parameters.Add (new OleDbParameter (•numDep•, númeroDeOependentes)) i 
comm.Paramecers.Add (new OleDbParameter (•chave•, chave) ): 
com.ExecutetionQuery( }; 

class GatewayPessoa... 

public long inserir (String sobrenome, String prenooe, long númeroDeDependentes} 
String sql: "!NSBRT INTO pessoa VALUES (?, ?, ?, ? I ; 
long chave= GetNextID( ); 
IObCoovnand cocnm = new OleDbCommand (sql, DB.Connectíon); 
co.m.Parareters.Add{new OleDbPararr~cer('chave•, chave); 
COOIIII.P~rameters.Add (new OleDbParameter (•sobrenome•, sobrenome)) i 
CO!Mi.Para:neters.Add (new OleDbParaílleter (•prenoo;e•, preno~e)}; 
ccxnm.Parameters.Add (new OleDbParameter (•numDep•, númeroDeOependentes)) ; 
cOOllll. Execute!/onQuery ( l ; 
return key; 

O método de exclusão precisa apenas de uma chave. 

class GatewayPessoa... 

public void excluir (long chave) { 
String sql = "DELETE FROM pessoa w'liERB id: ?•; 
lDbCoaimand com.~= new OleDbCommand (sql. DB.Connection); 
cOO'll'II.Parameters.Addinew OleDbParameter(~chave•, chave); 
cooun.ExecutenonQuery(); 


CAPilULO 1 O • PAORÔES ARQUITHl.JRAIS OE FONTES DE DAOOS (DATA SouRCE) 155 

Exemplo: Usando Conjuntos de Dados ADO.NET (C#) 

O Gateway de Tabela de Dados genérico trabalha com quase todo tipo de plataforma1 já 
que ele não é nada além de um envoltório para declarações SQL. Com o .NET você 
usa mais freqüentemente conjuntos de dados (data sets), mas o Gatewny de Tnbeln de 
Dados ainda é (1til1 embora ele assuma uma forma diferente. 

Um conjunto de dados precisa de adaptadores de dados para nele cai-regar 
os dados e para atualizar esses dados. Considero útil definir um repositório para 

o conjunto de dados e os adaptadores. Um gnteway usa então o repositório para 
armazená-los. Muito deste comportamento é genérico e pode ser feito em uma 
superclasse. 
O repositório indexa. os conjuntos de dados e os adaptadores pelo nome da 
tabela. 

class RepositórioDeConjuntosDeDados... 

public OataSet dados= new DataSetl 1~ 
private Hashtable adaptadoresDeDados = new Hashtable( ); 

O gntewny armazena o repositório e expõe o conjunto de dados para os seus 
clientes. 

class GatewayDeoados. .. 

public Reposit6rioDeConjuntosDeDados repositório; 
public DataSet dados { 
get { return repositório.dados;) 

O gntewny pode atuar sobre um repositório existente ou pode criar um novo repositório. 


1 Armazenador 1 

Gateway ..... --Conjunto

de Conjuntos

de Dados ---de Dados 

de Dados 

6 * 

nome da 1 
1 tabela 

o 

1 , / 

Adaptador 
Gateway de Dados 
Pessoa 

Figura 10.1 Diagrama de classes de um gateway orientado a conjunto de dados e o 
repositório de dados de apoio. 


156 PARTE li • Os PADRÕES 

class GatewayDeDados ... 

protecteà GatewayDeDados () { 
repositório= new RepositórioOeConjuntosDeDados ( ); 

protected GatewayDeDados (RepositõrioDeConJuntosDeDados repositório) 
this.repositório = repositório; 

O código de busca pode ter un1 comportamento um pouco diferente aqui. Um 
conjunto de dados é um contâiner de dados orientados a tabelas e pode armazenar 
dados provenientes de diversas tabelas. Por esse motivo, é melhor carregar os dados 
em um conjunto de dados. 

class GatewayDeDados... 

public void CarregarTudo( ) { 
String oornando = String.Foniat( •select • froot {Oj•, NomeDaTabelal; 
repositório.PreencherDados (cOl!lando, Non:eOaTabela); 

public void carregarCondicional {String cláusulaCondicional) 
String cooiando = 
String.Fort:1at(•select ~ from {o) where {1}", Nor.eDaTabela, cláusulaCondicionall; 

repositório.PreencherDados{comando, No4eDaTabela); 
} 
abstract public String NoceDaTabela {get;} 

class GatewayPessoa.. . 

public override String No.~eDaTabela f 
get (recuro •Pessoa•;! 

class RepositõrioDeConjuntosDeDados... 

public void PreencherDados (String consulta, String noreeDaTabelal { 
íf (adaptadoresDeDados.Contains(no.ieDaTabelal) throw new Nult1pléLOadException( l; 
OleDbDataAdapter ade new OleDbDataAdapter(consulta, OB.connection); 
OleDbCOll'.::ianàBuilder construtor= new OleObCoor..and3uilder(ad); 
ad.Fill(dados, nomeDaTabela); 
adapcadoresDeDados.Add(nocneOaTabela, aó}; 

Para atualizar os dados, você manipula o conjunto de dados d iretamente no código 
cliente. 

pessoa.Carrega?Tudol I; 
pessoa(chavel [•sobrenOl:le") = •Odell•; 
pessoa.repositõrio.Atualitarl 1; 

O gnteway pode ter um indexador para tornar mais fácil obter linhas especificas. 

class GatewayDeDados ... 

public DataRo,, this (long chave] { 
get{ 
String filtro= Strin9.format fsid • {o)•, chave); 


CAPiTULO 10 • PAORÕE5 ARQUITETURAIS DE FONTES DE DADOS (DATA SOURCE) 15 7 

return Table.Select(Eiltro) (OJ ; 

} 
public override DataTable Table 1 
get{ retum Dados.Tables(!lomeDaTabela); ) 

A atualização djspara o código de atualização no repositório. 

class RepositórioDecoojuntosDeDados... 

public void Atualizar( ) 1 
foreach {String tabela in adaptadoresteDados.Keys) 
(IOleDbDacaAdapter)adaptadoresDeDados(tabelal) .AtualitarlDados, tabela); 

public DataTable this (String nomeDaTabelal \ 
get {retum Dados.Tables (nomeDaTabela] ;j 

A inserção pode ser feita essencialmente da mesma forma: obtenha um conjunto 
de dados, insira uma nova linha na tabela de dados e preencha cada coluna. No 
entanto, um método de atualização pode fazer a inserção em uma única chamada. 

class G3teway1leDados... 

public long Inserir (String sobrenome, String prenome, int númeroDeDependentes) 1 
long chave = new PersonGatei.•ayDS() .Gettlext IDI ) ; 
DataRow r.ovaLinh.l = Table.NewRow( )1 
novaLinba (•id•I : chave; 
novaLinha (•sobreno::e•I : sobrenon:e; 
novaLinha(•μrenome•I : prenome; 
novaLinha("númeroDeDependentes~I = númeroDeDependentes; 
Table.Rells.Add (novaiinha); 
rernm chave; 


158 PARTE li • Os PADRÕES 

Gateway de Linha de Dados (Row Data Gateway) 

Um objeto que age como um Gnteway (4..36) pnrn um tínico registro em uma 
fonte de dados. Haverá 11111n instância por linha. 

Busca Pessoa 

encontrar (id) 
encontrarPeloSobrenome 
(String) 

t 
1 

w 

Gateway Pessoa 

sobrenome 
prenome 
númeroDeDependentes 

inserir 
atualizar 
excluir 

Embutir código de acesso ao banco de dados em objetos na memória pode lhe trazer 
algumas desvantagens. Para começai~ se os seus objetos na memória tiverem sua própria 
lógica de negócio, rtcrescentar o código de manipulação do banco de dados aumenta 
a complexidade. Os testes também ficam complicados uma vez que, se os seus 
objetos na memória estiverem ligados a um banco de dados, a execução dos testes fica 
mais lenta devido à sobrecarga do acesso ao banco de dados. Você pode ter de acessar 
múltiplos bancos de dados com todas aquelas pequenc1s e irritantes variações de SQL. 

Um Gateway de Un!ta de Dados fornece objetos que parecem exatamente com o 
registro na sua estrutura de registros, mas que podem ser acessados com os mecanismos 
normais da sua linguagem de programação. Todos os detalhes do acesso à fonte 
de dados ficam escondidos atrás desta interface. 

Como Funciona 

Um Gateway de Unha de Dados age como um objeto que encapsula exatamente um 
único registro, tal como uma linha de um banco de dados. Nesta estruturn, cada coluna 
no banco de dados toma-se um campo. Normalmente, o Gnteway de Li1tlta de Dados 
faz qualquer conversão de tipo necessária dos tipos da fonte de dados para os tipos 
na memória, porém esta conversão é mwto simples. Este padrão armazena os 
dados de umn linha de modo que um cliente possa então acessar diretamente o Gateway 
de Li11/ia de Dados. O gntewny age como uma boa interface para cada linha de dados. 
Essa abordagem funciona especittlmente bem ~m Roteiros de TransaçcJcs (120). 

Com o Gatewny de Linha de Dados, você se depara com as questões relativas a 
onde colocar as operações de busca que geram este padrão. Você pode usar métodos 
estáticos de busca, mas eles impedem o polimorfismo, se você quiser substituir diferentes 
métodos de busca para diferentes fontes de dados. Neste caso, muitas vezes, 
faz sentido ter objetos de busca separados de modo que cada tabela em um banco 
de dados relacional tenha uma classe de busca e umél classegateway para os resultados 
(Figura 10.2). 


CAPilUL0 10 • PAORÕE5 ARQUITETURAIS OE f0NTES OE OAO0S (DATA SOURCE) 159 

Muitas vezes é difícil perceber a diferença entre um Gatcway de Linha de Dados 
e um Registro Ativo (165). O ponto crucia) da questão é se há alguma lógica de domínio 
presente. Se houver, você tem um Registro Ativo (165). Um Gatewny de Linha 
de Dados deve conter apenas a lógica de acesso ao banco de dados e nenhuma lógica 
de domínio. 

Do mesmo modo que com qualquer outra forma de encapsulamento tabular, 
você pode usar um Gateway de Linha de Dados com uma visão ou pesquisa assim como 
com uma tabelõ. Neste padrão, muitas vezes, as atualizações acabam por ser 
mais complicadas, uma vezque você tem que atualizar as tabelas correspondentes. 
Além disso, se você tiver dois Gateways de Linha de Dados que operam sobre as mesmas 
tabelas, você pode descobrir que o segunda Gateioay de Li11l1a de Dados que você 
atualiza desfaz as alterações do primeiro. Não há um modo genérico de evitar isso. 
Simplesmente, os desenvolvedores precisam estar conscientes de como os Gatewnys 
de Li11'1a de Dndos virtuais são formados. Afinal, a mesma coisa pode acontecer 
com visões atualizáveis. É claro que você pode decidir não fornecer operações de 
atualização. 

Os Gnfeways de Linlta de Dados tendem a ser um pouco tediosos para codificar, 
mé'ls são bons candidatos p<lra a geração de código basec'lda em um Mapeamento 
em Metadados (295). Desta forma, todo o código de acesso ao banco de dados 
pode ser automaticamente criado para você durante o seu processo automatizado 
de construção. 

Quando Usá-lo 

A escolha do Gnteway de Lin!,n de Dados muitas vezes exige dois passos: primeiro, usar 

ou não urngnteway e, segundo, usar um Gnteway de Linlta de Dados ou um Galewny de Ta


bela de Dados (151). 

Uso o Gateway de Linha de Dndos com maior freqüência quando estou usando 
um Roteiro de Trnnsnçiio (120). Neste caso, ela decompõe eficientemente o código de 
acesso ao banco de dados e permite que este seja reutilizado facilmente em diferentes 
Roteiros de Transação (120). 

Não uso um Gntewny de Linha de Dndos quando estou usando um Modelo de Oo111/
nio (126). Se o mapeamento for simples, o Regist1·0 Ativo (165) faz o mesmo trabalho 
sem uma camada adicional de código. Se o mapeamento for complexo, o Mapendor 
de Dados (170) funciona melhor, na medida em que ele é melhor para desacoplar 
a estruht.ra de dados dos objetos do donúnio uma vez que estes objetos não precisam 
conhecer o lnyout do banco de dados. É claro que você pode usar o Gatl'Wi1}J rle Li11J,a 
de Dados para isolar os objetos do domínio da estrutura do banco de dados. Isso é 
uma boa coisa se, quando você estiver usandoo Gatewny de Li11ha de Dndos, estiver alterando 
a estrutura do banco de dados e não quiser alterar a lógica do domínio. Todavia, 
fazer isso em larga escala Jhe leva a três representações de dados: uma na lógica 
do domínio, uma no Gnteway de Linha de Dados e uma no banco de dados -e isso 
é demais. Por essa razão, normalmente, faço o Gatewny de Linl,n de Dados espelhar 
a estrutura do banco de dados. 

Tenho visto com interesse Gatewnys de Li11/tn de Ondas usados muito eficientemente 
com Mnpeadores de Dados (170). Embora isso pareça demandar um trabalho 
adicional, pode ser eficaz se os Gntewny de Linlrn de Ondos forem gerados automaticamente 
a partir de metadados enquanto que os Mnpeadores de Dados (170) são feitos 
à mão. 


Gateway de Linha 
de Dados 

umCliente 

novo 

-.... 

umPesquisadorDePessoas 

-

1 

encontrar(1) 1 

..... 1 

ô 

Banco de Dados 

1 
1 
1 
1 
1 
1 

select from pessoas where id = 1 1 

-
-
1

..... 

<------um conjunto dedados____ ~ 

*(para cada registro] novo 

1 
1 
1 -1 

Figura 10.2 Interações para uma busca com uma Gateway de Linhas de Dados baseada em linhas. 

... 

°'o 

= 

• 

..... 

umaPessoa

-

1 


CAPiTULO 10 • PAORÕES ARQUITETURAIS DE FONTES DE DADOS (DATA SOURCE) 161 

Se você usar o [foleiro de Transação (120) com o Gatewny de Linha de Dados, você 
pode perceber que existe lógica de negócio repetida cm multiplos roteiros, lógica esta 
que faria sentido no Gntewny de Unha de Dados. Mover esta lógica irá gradualmente 
transformar seu Gatcway de Linha de Dados cm um Registro Ativo {165), o que freqüentemente 
é bom, uma vez que reduz a duplicação na lógica de negócio. 

Exemplo: Um Registro Pessoa (Java) 

Aqui está um exemplo de um Gnteway de Linha de Dados. É uma tabela simples, Pessoa. 

create table pessoas (ID int primary key, soorenome varchar. 
prenome varchar, númeroDeDependentes intl 

GatewayPessoa é um gateway para a tabela. Ele começa com atributos e métodos de 
acesso. 

class CatewayPessoa... 

priva~ String sobrenooe; 
private String prenome; 
private int nGmeroDeDependentes; 
public String lerSobrenome () { 

return sobrenome; 

public void gravarSobrenome (String sobrenome) 
this.sobrenooe = sobrenome; 

public String lerPrenoc:e 1) { 
return prenome; 

public void gravarPrenome {String preno.11e} 
this.prenome =prenome; 

public int lerNúmeroDeDependentes ( ) 
return númeroDeDependentes; 

public void gravarllúmeroDeDepenàentes (int nú::ieroDeDependentes) 
this.nú~eroDeDependentes = númeroDeDependentes; 

A classe gnfeway pode, ela própria, lidar com atualizações e inserções. 

claas Gate~ayPessoa... 

private static final String stringDaDeclaraçàoDeAtualhação = 
"UPDATR ~essoas .½ 
fl set sobrenane = ?, prenoae = ?, nú~eroOeDependentes =? • • 

• where id = ?"; 
public void atualizar 1 1 ( 
PreparedStatement declaraçãoDeAtualização = null; 
try { 

declaraçãoDeAtualizaçào = DR.prepare(stringDaDeclaraçàoDeAtualizaçàoJ i 
declaracàoDeAtualização.setString ll, sobrenoc:e); 


162 PARTE li • Os PAORÕES 

declaraçãoDeAtual1zaçào.setString(2, prenome!; 
declacaçãoDeAtualizaçào.setlot(3, númeroOeOependentesl; 
declaraçàoDo-Atualização.setlnt(4, ler!O( l .intValue( )1 ; 
declaraçàoDeAtualízaçào.e.xecute( ): 

} catch (Exception e) ( 
throw new Applicationixception (e); 
} finally {PB.cleanUp(declaraçãoDeAtualização); 
J 

private static final String stringDaDeclaraçâoDelnserção = 
·rnSERT nrro pessoas VALOESI?, ? , ? , n•; 

public Long inserir () l 
PreparedStatement declaraçãoDeinserçào =null; 
try l 

declaraçàoDeinserção = OB.prepare (stringoaDeclaraçãoDe!nserçào); 
setID(descobreProximoIDBancoDeOados( ll; 
declaraçàoDe!nserção.setint (l, lerIO.intValue ( /); 
declaraçãoDeinserção.setString(2, sobrenome); 
declaraçãoDeinserção.setScring(J, prenome); 
declaraçãoDe!nserção.setlnt(4, númeroDeOependentes); 
declaraçàoDeinserção.execute( 1; 
Registro.adicionarPessoa(this); 
retum lerlD() ; 

) cacch (SQLBxception e) 1 

throw new Application~oeption le): 
) finally lDB.cleanOp{declaraçãoDelnserçãol; 
) 

Para buscar pessoas no banco de dados, temos uma classe separada PesquisadorDePessoas. 
Esta trabalha junto com portão gnt<:wny para criar novos objetos gatewny. 

class FesquisadorDePessoas... 

privace stacic final String stringDaDeclaraçàoDeBusca = 
"SELECT id, sobre.nooie, prenome, nú.'lleroDeDepenàentes • , 

• FROM pessoas • 1 
• WHERE id =? "; 
public GatewayPessoa procurar(Long id) 
GatewayPessoa resultado = (GatewayPessoa) Registro. ler-Pessoa (idl; 
if (resultaào != nulll return resultaóo; 
PreparedStatement ãeclaraçãoDeBusca = null; 
ResultSet rs =null; 
try ( 

declaraçâoDeBusca =DB.prepare(stringDaDeclaraçãoDeBusca); 
declaraçâoDeBusca.setLong(l, id.longValue( I) ; 
rs = declaraçãoDeBusca.executeQuery( ); 
rs.next ( ); 
resultado= GatewayPessoa.carregar{rs); 
return resultado; 

} catch {SQLException e) { 

throw oew ApplicationE'xception (e}; 
} finally jDB.cleanOp(de<:laraçãoDeBusca, rs); 
) 


CAPiTULO 10 • PAORÓES ARQUITETURAIS DE FONTES DE DADOS (DATA SOURCE) 16 3 

public GatewayPessoa procurar {lon9 idl { 
return procurar(new Long{id)); 

class GatewayPessoa... 

public static GatewayPessoa carregar (ResultSet rs) throws SOLException { 
Long íd = new Long(rs.getLong(ll}; 
GatewayPessoa resultado = (Gate·.:ayPessoa) Registro. lerPessoalídl; 
if (resultado!= null) return resultado; 
String parâmetrOSobrenome = rs.getString(2); 
String parâmetroPrenor.e =rs.getStringl3l ; 
int parâ~ecroMúmeroDeDependentes = rs.getlnt (4); 
resultado= new GacewayPessoa (id, parãmetroSobrenome, parámetroPrenome, parárnetroNú 

meroDeOependentes); 
Registro.adicionarPessoalresultado); 
return resultado; 

Para pesquisar mais de uma pessoa de acordo com algum critério, podemos 
fornecer um método de busca apropriado. 

class PesquisadorDePessoas... 

private static final String declaraçàoDeBuscaDeResponsáveis = 

•SELECT id, sobrenome, prenome, nú~eroDeDependentes •fl 


FROM pessoas • • 

• ~l!ER& númeroDeDependentes > o•, 
public List enco~trarResponsáveis () 1 
List resultado= new ArrayList( ); 
PreparedStatement dec = null; 
ResultSet rs ~ null; 
tr/ { 

dec: DB.prepare (declaraçàoDeBuscaDeResponsáveis) r 
rs • dec.execuceQuery( 1; 
while (rs.next ( )) { 

resultado.adõ(GatewayPessoa.carre9arlrs) >1 

} 

retum resultado; 
) catch (SQLException e) 

throw new A,pplícationException (e): 
} t1nally IDB.cleanOp(dec, rs); 
) 

O pesquisador de pessoas usa um Registro (448) para armazenar Mnpns de Identidade 
(196). 
Podemos agora usar os gnt<!ways a partir de um Roteiro de Transação {120). 

PesquisadorOePessoas pesquisador= new PesquisadorDePessoas t 1 
lterator pessoas: pesquisador.enconcrarResponsáveis() .iterator( ); 
StringBuffer result.ado = new StringBuffer(); 
while (pessoas.has?lext.( ) ) { 

Gate~-ayPessoa cada= (GatewayPessoal pessoas.next( ); 


164 PARTE li • Os PAORÕES 

resultado.append (caàa.lerSobrenome( J); 
resultado.append (• ~1; 
resultaào.append (caàa.lerPreno:ne( )); 
resultaào.append (• "I: 
resultado.append (String.valueOf (eada.lerNúmeroDeDependentes( I); 
resultado.append ,•\n")1 

} 

retum resultado.toString( ): 

Exemplo: Um Armazenador de Dados 
para um Objeto de Domínio (Java) 

Na maior parte das vezes, uso o Gateway de Unha de Dados com l{otefros de Trn11saçào 
(120). Se quisermos usar o Gateway de Linha de Dados a partir de um Modelo de Domí11io 
(126), os objetos do domínio precisam chegar aos dados a partir do gntl'toay. Em 
vez de copiarmos os dados para o objeto do domínio, podemos usar o Gateway de Li11/
10 de Dados como um armazenador de dados pRra o objeto do domínio. 

class Pessoa... 

p~ivate GacewayPessoa dadosi 
public Pessoa (Gatei,ayPessoa ôadosl ( 
this.dados = dados; 

Métodos de acesso na lógica de domínio podem então delegar os dados p <1ra o 

Knfeway. 

class Pessoa... 

public int lerNfüneroDeDependences ( ) { 
return dados,lerMúmeroDeDependentes( l; 

A lógica de domínio usa os métodos de leitura (gefters) para trazer os dados do 
gateway. 

class Pessoa... 

public Dinheiro lerlsenção() 
Dinheiro baseDeisenção = Dinheiro.dollars(lS00); 
Dinheiro isençãoPorDepenàente = Dinheiro.dollars(750); 
retum baseDeisenção.adlcionarUsençãoPorDependente.multiplicar(thls.lerllúmeroDeDependent~sl 11); 


CAPilUL0 10 • PA0RÕES ARQUITH\JRAIS OE f0NlES DE OA00S (DATA SOURCE) 165 

Registro Ativo (Active Record) 

Um objeto que e11cnps11ln umn linhn de 11mn tnbela ou visão de wu bnnco de 
dados, oncesso no bnnco de dados eadiciona lógica de domínio n esses dados. 

Pessoa 

sobrenome 

prenome 

númeroDeDependentes 

inserir 

atualiza( 

excluir 

lerlsençao 
estáMarcadoParaAuditoria 
lerRendimentosTaxáveis 

Um objeto carrega tanto dados quanto comportamento. Muitos desses dados são 
persistentes e precisam ser armazenados em um banco de dados. O Registro Atívo usa 
a abordagem mais óbvia, colocando a lógica de acesso aos dados no objeto do domínio. 
Dessa maneira todos os objetos pessoa sabem como ler e gravar seus dados do 
banco de dados e no banco de dados. 

Como Funciona 

A essência de um Registro Ativo é um Modelo de Domínio (126) no qual as classes são 
muito semelhantes à estrutura das tabelas correspondentes. Cada Registro Ativo é 
responsável por salvar e buscar seus dados no banco de dados e também por qualquer 
lógica de domínio que atue sobre os dados. Esta pode ser toda a lógica de domínio 
na aplicação, ou você pode descobrir que alguma lógica de domínio é mantida 
em Roteiros de Tm11snçiio (120) com o código compartilhado e orientado a dados 
no Registro Ativo. 

A estrutura de dados do Registro Ativo deve corresponder exatamente ilquela do 
banco de dados: um atributo na classe para cada coluna na tabela. O tipo dos atributos 
deve ser o mesmo dos dados entregues a você pela interface SQL -não faça nenhuma 
conversão neste estágio. Você pode considerar o uso do Mnpenme11to de Gtnve 
Estrnllgcirn (233), mas télmbém pode deixar as chaves estrangeiras como estiverem. 
Você pode usar o Rc(~istro AIivo com visões ou tabelas, ainda que as atualizações por 
meio de visões sejam obviamente mais difíceis. Visões são particularmente úteis para 
a geração de relatórios. 

A classe Registro Ativo tem, tipicamente., métodos que realizam as seguintes 
funções: 

• Constroem uma instância do Registro Ativo a partir de uma linha de um conjunto 
de dados resultantes de uma consulta SQL. 
• Constroem uma .nova instância para posterior inserção na tabela. 

166 PARlE li • Os PAORÕES 

• Encapsulam consultas SQL, comumente usadas, e retomam objetos do tipo 
Registro Ativo, pelos métodos de busca estáticos. 
• Atualizam o banco de dados e nele inserem os dados do Registro Ativo. 
• Lêem e gravam os atributos. 
• Implementam alguns fragmentos de lógica de negócio. 
Os métodos de leitura e gravação podem fazer algumas outras coisas inteligentes, 
tais como converter os tipos orientados a SQL para tipos mais apropriados 
para armazenamento em memória. Além disso, se você solicitar uma tabela relacionada, 
o método de leitura pode retornar o Registro Ativo apropriado, mesmo se você 
não estiver usando o Cnmpo lde11lidnde (215) na estrutura de dados (executando 

um lookup). 

Nesse padrão as classes são convenientes, mas não escondem o fato de que tm1 
banco de dados relacional está presente. Como conseqüência, você normalmente encontrará 
uma quantidade menor dos outros padrões de mapeamento objeto-relacional 
presentes quando estiver usando o Registro Ativo. 

O Registro Ativo é muito semelhante ao Gnteway de Linha de Dados (158). A principal 
diferença é que o Gateway de Li11hn de Dados (158) contém apenas métodos de 
acesso ao banco de dados, enquanto que um Registro Ativo contém tanto lógica de domínio 
quanto acesso aos dados. Como a maioria das fronteiras em software, a linha 
divisória enh·e os dois padrões não é muito precisa, mas é útil. 

Devido ao gri'lnde acoplamento entre o Registro AIivo e o banco de dados, encontro 
com maior freqüência métodos de busca estáticos neste padrão. Entretanto, 
nada existe que o impeça de separar os métodos de busca em uma classe separada, 
corno dfacuti em Gateway de Li11ha de Dados (158), e isso facilita os testes. 

Assim como com os outros padrões tabulares, você pode usar o Registro Ativo 
com uma visão ou pesquisa, bem como com uma tabela. 

Quando Usá-lo 

O Regist-ro Ativo é uma boa escofüa para a lógica de domínio que não seja muito complexa, 
como criações, leituras, atualizações e exclusões. Derivações e validações baseadas 
em um único registro funcionam bem nesta estrutura. 

Em um projeto inicial para um Modelo de Domínio (126), a escolha principal recai 
entre o Registro Ativo e o Mnpcador de Dados (170). O Registro Ativo tem a vantagem 
prim.<fria da simplicidade. É fácil construir Regislros Ali-vos, e eles são fáceis de entender. 
O principal problemé\ relacionado ao seu uso é que eles trabalham bem somente 
se os objetos do tipo Registro Ativo corresponderem diretamente às tabelas no banco 
de dados em um esquema isomórfico. Se a sua lógica de negócio for complexa, você 
logo irá desejar usar relacionamentos di retos entre seus objetos, coleções, herança e 
assim por diante. Estas técnicas não são facilmente mapeadas em Registros Ativos, e 
adicioná-las uma a uma torna-se muito confuso. Jsso é o que lhe levará ao uso alternativo 
dos Mnpeadores de Dados (170). 

Outro argumento contra o Registro Ativo é o fato de que ele acopla o projeto dos 

objetos ao projeto do banco de dados. Isso torna mais difícil refatorar esses projetos 

à medida que o projeto prossegue. 

O Registro Ativo é um bom padrão a considerar se você estiver usando o Rotefro 
de Trnnsnção (120) e estiver começando a sentir os problemas da duplicação de códi



CAPiTULO 1O • PAORÓES ARQUITET\JRAIS DE FONTES DE DAOOS (DATA SouRCE) 167 

go e a dificuldade, muitas vezes, presente nos Roteiros de Transação (120) para atualizar 
roteiros e tabelas. Neste caso, você pode começar gradualmente a criar Registros 
Ativos e então lentamente neles refatorar o comportamento. Muitas vezes, é útil primeiro 
encapsular as tabelas como um Cateway (436) e só depois começM a mover o 
comportamento de modo que as tabelas evoluam pRra um Registro Ativo. 

Exemplo: Uma Pessoa Simples (Java} 

Este é umexemplo simples, até mesmo simplista, para mostrar como o âmago do Registro 
Ativo funciona. Começamos com uma classe Pessoa básica. 

class Pessoa ... 

private String sobrencx:e; 
private String prenome; 
pri,ate int númeroDeDependentes; 

Também hÃ um campo ID na superclasse. 
O banco de dados tem exatamente a mesma estrutura. 

create table pessoas (TO inc primary key, sobrenocne v-archar, 
prenom-e varchar. númeroDeDependences incl 

Para carregar um objeto, a classe Pessoa localiza o objeto e efetua a carga. Para 
isso são usados métodos estáticos na classe Pessoa. 

class Pessoa . .. 

private static final String stringDaDeclaraçàoDeBusca = 
"SELECT id, sobrenome, prenome, nÕJ:leroOeDependentes ~ + 
~ raOM pessoas •+ 

• ¾1iERE id =? "; 
public static Pessoa procurar ILong id ) 
Pessoa resultado= (Pessoa) Registro.lerPessoa(id) i 
if (resultado!: null) return resultado; 
PreparedStatement declaraçàoDeBusca = null; 
ResultSet rs = null; 
try f 

declaraçãoDeBusca = OB.preparelstringDaDeclaraçãoPeSuscal; 
declaraçàoDeBusca.setLong(l, id.longValue( )); 
rs: declaraçãoDeBusca.executeQuery( ) ; 
rs.next ( l; 
resultado= carregar{rs); 
recurn resultado; 

} catch (SQLException e) 1 
throw new Appl1cat1onException Ce}; 
) finally { 
DB.cleanUp(declaracãooeEusca, rs); 

public static Pessoa procurar (long id) 
return procurar{new Long (id)) ; 


168 PARTE li • Os PAORÕES 

public static Pessoa carregar (ResuLtSet rs) r.hrows SOLBxception { 
Long id = ne·,; wng(rs.9etLonq(l l); 
Pessoa resultado= (Pessoa} Registro.lerPessoa(idl; 
if (resultado l= null) return resultado; 
String parâmetroSobrenoo.e =rs.getString(2); 
String parâmetroPren~ = rs.getString(3); 
int parâtetroNúmeroDeDependentes = re.get!nt (4); 
resultado = ne-., Pessoa lid, parâmetroSobrencu, parâretroPrenane, parà!uetrol:Úil:eroDeDependentes>; 
Registro.adicionarPessoa (reeultado); 
recuro resultado; 

Para atualizar um objeto basta um simples método de instância. 

class Pessoa ... 

private static final String stringOaDeclaraçâoDeAtualização = 
ªUPDATE pessoas •t 

• S5'!' sobrenome=?, preno.~e = ?, númerooeoependentes : ? • 1 
~ WHERE id =?•; 
public void atualizar 1 1 { 
PreparedStaternent declaraçâoDeAcual ização = null; 
try{ 

declaraçãoDeAtualização = OB.prepare (stringDaOeclaraçãoDeAtualização)i 
declaraçàoDeAtualizaçào.setString U, sobrenome); 
declaraçãoDeAtualizaçâo.setString(2, prenome); 
declaraçãoDeAtualização.setStringl3, númeroDeOependentes); 
declaraçàoDeAtualizaçào.setStringt~. lerID( 1 .1lltValue( )J; 
declaraçãoDeAtualização.execute( ); 

) catch (Exception e) { 
throw ne~ ApplicationException [e}: 
) ttnally l 
DB.cleanlJp(declaraçãoDeAtualizaçào); 

Inserções são, na sua maioria, também muito simples. 

class Pessoa... 

private static final String stringDaDeclaraçâoDeinserção = 
"fNS8RT lNTO pessoas VALUES (?, ?, ?, ?)•; 

public Long inserir ( ) { 
PreparedStatement declaraçàoDeinserçào = null: 
try ( 

declaraçàoDeinserção = DB.prepare(stringDaDeclaraçãoDelnserção): 
setID(encontrarProximoIOdaBaseDeOados C)1 ; 
declaraçãoDeinserção.setlnt (l. lerID,intValue( l); 
declaraçãoDeinserção.setString(2, sobreno:ne}; 
declaraçàoDeInserção.setString(3, prenome) ; 
declaraçâoDeinserção.setlnt (4, númeroOeDependentes); 
declaraçàoDelnserção.execute( ); 
Registro.adicionarPessoa( this); 
return lerID( l; 


CAPiTULO 10 • PAORÕES ARQUITETURAIS OE FONTES DE DADOS (DATA SOURCE) 169 

) catch (SQL!lxcepcion e) ( 
throw ne~ ApplicationException (e); 
) Einally { 
DB.cleanOp(declaraçàoDelnserçào) , 

Qualquer lógica de negócio, tal como o cálculo de uma isenção, vai djretamente 
para a classe Pessoa. 

class Pessoa... 

public Dinheiro lerlsenção() 
Dinheiro baseDelsenção =Dinheiro.dollars(lSOO) ; 
Dinheiro isençâoPorOependente: Dinheiro.dollars(750); 
return baseOeisençào.adicionarlisençàoPorDependente.multiplicar(this.ler!.úmeroDeDependentes( l ll; 


170 PARlE li • Os PADRÕES 

Mapeador de Dados (Data Mapper) 

Uma camada de Mnpeadores (442) que move dados entre os objetos e11m banco 
de dados 111n11tendo-os i11depe11de11tes um do outro e do pr6prio mapendor. 

Pessoa 

sobrenome 

Mapeador Pessoa --------ô

prenome 
númeroDeOependentes <f-----inserir ~ 

atualizar 
lerlsenção excluir 
estáMarcadoParaAuditoria 

lerRendimentosTaxáveis 

Objetos e bancos de dados relacionais usl\m mecanismos diferentes para estruturar 
os dados. Muitas partes integrantes de um objeto, tais como coleções e herança, não 
estão presentes em bancos de dados relacionais. Quando você cria ummodelo de objetos 
com muita lógica de negócio, o uso destes mecanismos é valioso para melhor 
organizar os dados e o comportamento associado. Isso leva a esquemas diversos, isto 
é, o esquema dos objetos e o esquemél relacional não combinêlm. 

Aindél assim, você precisa transferir dados entre os dois esquemas, e esta 
transferência se torna, por sj só, complexa. Se os objetos na memória conhecem a 
estrutura do banco de dados relacional, alterações em um tendem a se propagar 
para o outro. 

O Mnpeador de Dados é uma camada de software que separa osobjetos na memória 
do banco de dados. Sua responsabilidade é tnmsferir dados entre os dois e também 
isolá-los um do outro. Com o Mnpeador de Dados, osobjetos na memória não precisam 
nem mesmo saber que há um banco de dados presente. Eles não precisam conter 
comandos SQL e certamente não precisam ter nenhum conhecimento do esquema 
do banco de dados. (O esquemél do biloco de dados sempre ignora osobjetos que 

o usam.) Uma vez que o Mnpeador de Dados é uma forma de Mnpearlor (442), ele próprio 
não é conhecido pela camada de donúnio. 
Como Funciona 

A separaçào entre o domínio e a fonte de dados é a principal função de umMnpendor 
de Dados, mas existe uma grande quantidélde de detalhes que tªm que ser tratados 
para que isso aconteça. Existe ainda uma diversidade grande de formas pelas quais 
camadas de mapeamento são criadas. Muitas das observações aqui são bastante gerais, 
porque estou tentando lhe dar uma visão geral do que você ptecisa para separar 

o joio do h·igo. 
Começaremos com umexemplo bastante básico de umMapeador de Dados. Este 
é o estilo mais simples que você pode ter para esta camada e pode parecer não valer 
a pena usá-lo. Quando usamos exemplos simples de mapeamento de banco de dados, 
outros padrões são normalmente mais simples e, portanto, melhores. Você normalmente 
usará o Mapaador de Dados em casos mais complicados. No entanto, é mais 
fácil explicar as idéias se começamos de modo simples em um nível bastante básico. 

Um ca.so simples envolveria, por exemplo, uina classe Pessoa e uma classe Mapendor 
de Pessoa. Para carregar uma pessoa do banco de dados, um cliente chama



CAPi1ULO 10 • PAORÔES ARQUITETURAIS OE FONTES DE DAOOS (DATA SOURCE) 171 

ria um método de busca no mapec1dor (Figura 10.3). O mapeador usa um Mapa de 
ldcntidndc (196) para verificar se a pessoa já está carregada; em caso contrário, ele a 
carrega. 

As atualizações são mostradas na Figw-a 10.4. Um cliente solicita que o mapeador 
grave um objeto do domínio. O mapeador extrai os dados do objeto de domínio 
e os e.nvia para o banco de dados. 

Toda a camada do Mapeador de Dados pode ser substituída, para efetuar testes, 
ou para permitir que uma llni.ca camada de donúnio traballle com diferentes bimcos 
dedados. 

Um Mnpendor de Dados imples apenas mapearia, campo a campo, uma tabel<1 
do banco de dados em uma classe equivalente em memória. É claro que as coisas 
normalmente não são simples. Os Mapcndores precisam de uma série de estratégias 
para lidar com. classes que se transformam em campos múltiplos, classes que têm 
m(1ltiplas tabelas, classes com herança, além de ter de conectar os objetos uns aos outros 
assim que eles tiverem sido extraídos do banco. Os vários padrões para o mapeamento 
objeto-relacional apresentados neste livro lidam todos com essas estratégias. 
É normalmente mais fáciJ desenvolver esses padrões com um Mnpendor de Dados do 
que com ns outras alternntivas de organização. 

Quando se trata de inserções e ahmlizações, a camada de mapeamento do banco 
de dados precisa saber que objetos mudaram, quais novos objetos foram criados e 
quais foram destruídos. Ela também tem que encaixar toda essa catga de trabalho em 

u.m contexto transacional. O padrão Unidade de Trnba/110 (184) é uma boa maneira de 
organizarisso. 
A Figura 10.3 sugere que uma única requisição a um método de busca resulta 
em um;, única consulta SQL. Isso não é sempre verdade. Cttrregar um pedido típico, 
com múltiplas linhas de pedido pode envolver a carga das linhas também. A requisição 
do cliente normalmente leva a um conjunto de objetos sendo carregados: o projetista 
do mapeador decide exatamente quanto pegar de cada vez. A essência aqui é 
mi.nim.izar as consultas ao banco de dados, assim, tipicamente, os métodos de pesquisa 
precisam conhecer um pouco sobre a forma como os clientes usam os objetos 
de modo a poder tomar as melhores decisões na carga dos dados. 

O exemplo apresentado leva a casos em que é necessário carregar diversas classes 
de objetos de domínio é\ partir de uma única consulta. Se você quiser carregar pedjdos 
e linhas de pedidos, normalmente será mais rápido executar uma única consulta 
que junte as tabelas dos pedidos e das linhas dos pedidos. Você então usa o conjunto 
resultante para carregar as instâncias do pedido e das linhas (página 239-240). 

Uma vez que os objetos são bastante interconectados, você, cm algum ponto, 
tem de parar de trazer osdados. De outra forma, você possivelmente irá trazer todo 

o banco de dados como resultado de uma única consulta. Mais uma vez, as camadas 
de mapeamento têm uma série de técnicas para lidar com este problema ao mesmo 
tempo em que, usando a Carga Tardia (200), minimizam o impacto sobre os objetos na 
memória. Por esse motivo, os objetos na memória não podem desconhecer completamente 
a camada de mapeamento. Eles podem precisar conhece-1· os métodos de 
pesquisa e alguns outros mecanismos. 
Uma aplicação pode ter um ou vários Mapeadores de Dados. Se você estiver codificando 
explicitamente seus mapeadores, é melhor usar um para cada classe do domínio 
O\t raiz de uma hierarquia de domínio. Se você estiver usando um Mapenmente> 
de Metadnrlos (295), você pode ter êxito com apenas uma única classe de mapeamento. 
Neste último caso, o problema limitante são os métodos de pesquisa. Em uma 


Mapeador de Dados 

... 

-..i 
IV 

um ma eador = 

um ma a o banco de dados 

de essoa • 

o 

1 "' 

encontrar(1) 1 
1 o;,;, 
~ 
ler(1) 1 o 

m

1 

V' 

1 
1 
1 
1 

nulo 1 

select * from pessoas where id = 1 

1 
1

--------------r-------------



um conjunto de resultados 

ler muitos dados 

novo 

martin : pessoa 

< -----------



martin 

Figura 10.3 Trazendo dados de um banco de dados. 


CAJ>ilULO 10 • PAORÓES ARQUtTET\JRAIS OE fONTES DE DAOOS (DArA SOURCE) 173 

martin: Pessoa

um mapeador 

o banco de dados
de pessoa 

id = 1 

:

atualizar (martin) : 1 

1 1 
1 l 

ler muitos dados 1 • 
t-------~....., : 

1 
1 

' 1

update pessoa .set... where id =-1 1 
1 > 1 

! u 

1 
1 

1

' 

Figura 10.4 Atualizando dados. 

aplicação grande, pode ser excessivo ter um único mapeador com muitos métodos 
de busca, de modo que faz sentido dividir estes métodos por classe de donúnio ou 
raiz de hierarquia de domínio. Desse modo, você obtém um número grande de pequenas 
classes de busca, mas é mais fácil para u0"'1 desenvolvedor localizar o método 
de busca de que ele precisa. 

Assim como com qualquer procedimento de busca em um banco de dados, os 
métodos de busca precisam usar um Mapa de Identidade (196) a fim de persistir a 
identidttde dos objetos lidos do banco de dados. Você pode usar um Registro (448) 
ou Mnpns de Identidade (196), ou você pode fazer cada método de busca armazenar 
um Mapa de Identidade (196) (supondo que exista apenas um método de busca por 
classe por sessão). 

Manipulando Métodos de Pesquisa Para lrnbanu,r com um objeto, você tem que 
carregá-lo do banco de dados. Normalmente a camada de apresentação dá início ao 
processo carregando alguns objetos iniciais. O controle passa então parn a camadé\ de 
domínio, momento em que o fluxo de controle do código passa a se mover de objeto 
em objeto usando as associações entre eles. Este mecanismo funciona efetivamente 
desde que a camada de donúnio tenha todos os objetos de que precisa carregados na 
memória, ou então que você use a Carga Tardia (200) para carregar objetos adicionais 
quMdo necessário. 

Ocasionalmente, você pode precisar que os objetos do domínio invoquem métodos 
de busca no Mapcador de Dados. No entanto, descobri que, com uma boa Carga 
Tardia (200), você pode completamente evitar isso. Para aplicações mais simples, no 
entanto, pode não valer a pena tentar gerenciar tudo com associações e Carga Tardia 
(200). Ainda assim, não é desejável introduzir umc1 dependência dos seus objetos de 
donúnio com o seu Mapeador de Dados. 

Você pode resolver esse dilema usando uma Interface Separada (445). Ponha todos 
os métodos de busca necessários para o código do domínio em uma classe de interface 
que você pode colocar no pacote do domínio. 


174 PARlE li • Os PAORÔES 

Mapeando Dados em Atributos do Domínio Os mape<ldores precisam ter acesso 
aos atributos nos objetos do domínio. Isso, freqüentemente pode ser um problema, 
porque você precisé\ de métodos públicos para dar suporte aos mapeadores que não 
são 11eccssários para a lógica do domínio. (Estou pressupondo que voe~ não irá cometer 
o pecado capital de tornar os atributos púbJkos.) Não existe uma resposta fácil 
para este problema. Você poderia usar um nível mais baixo devisibilidade empacotando 
os mapeadores próximo aos objetos do domínio (o que corresponderia em 
Java a colocá-los no mesmo pacote), mas isso confunde o cenário dependências, porque 
você não quer que outras partes do sistema que conheçam os objetos do domínio 
conheçam também os mapeadores. Você pode usar reflexão, que freqüentemente 
pode contornar as regras de visibilidade da linguagem. Jsso é mais lento, mas a 
velocidade menor pode ser tão insignificante quanto um erro de arredondamento, 
comparada ao tempo gasto pela chamada SQL. Você pode ainda usar métodos públicos, 
mas protegê-los com umcampo de status de modo que eles gerem uma exceção 
se forem usados fora do contexto de uma carga do banco de dados. Neste caso, 
nomeie•os de modo que não sejam confundidos com métodos de acesso regulares 

(gctters e setters). 

Associada a esta questão, está a da cliaçilo do objeto. Em essência, você tem 
duas opções. Uma é criar o objeto com um construtor rico de modo que ele seja criado, 
ao menos, com todos os dados obrigatórios. A outra opção é criar um objeto vazio 
e então povoá-lo com os dados obrigatórios. Normalmente prefiro a primeira 
opção, uma vez que é bom ter um objeto bem formado desde o início. Isso também 
significa que, se você tiver um campo imutável, você pode garantir que ele não será 
alterado, simplesmente não fornecendo nenhum método para alterar seu valor. 

O problema com um construtor rico é que você tem de estar ciente das referências 
ádicas. Se você tiver dois objetos que referenciam um ao outro, cada vez que você 
tentar carregar um deles, ele tentará carregar o outro, que por sua vez tentará carregar 
o primeiro, e assim por diante, até que você fique sem espaço na pilha. Para 
evitar esse problema, é necessário um código condicional especial, freqüentemente 
usando a Cargn Tardia (200). A codificação deste código condicional especial é coniusa, 
de modo que vale a pena tentar passar sem isso. Você pode fazê-lo criando um 
objeto vazio. Use um construtor sem parâmetros para criar um objeto em branco e 
insira esse objeto vazio imediatamente no Mnpn de Identidade ( 196). Desta forrnr1, se 
você tiver um ciclo, o Mapa de Identidade (196) retornará um objeto de modo a interromper 
a cMga recursiva. 

Usar um objeto vazio como esse significa que você pode precisar de alguns métodos 
de escrité, para os valores que forem verdadeirnmente imutáveis quando o objeto 
for can egado. Uma combinação de uma convenção de nomes apropriada e, tal~ 
vez, algumas sentinelas para verificação de slaflis pode resolver isso. Você também 
pode usar reflexão para a carga de dados. 

Mapeamentos Baseados em Metadados Uma das decisões que você precisa tomM 
com respeito ao armazenamento da informação é como os atributos nos objetos do 
domínio são mapeados para colunas no banco de dados. A maneira mais simples, e 
muitas vezes a melhor, de fazer isso é com código explícito, o que requer uma classe 
de mapeamento para cada objeto do domínio. O mapeador realiza o mapeamento 
por meio de atribuições e tem campos (usualmente stri11gs constantes) para armazenar 
a consulta SQL para acesso ao banco de dados. Uma alternativa é usar o Mapeamento 
de Metadndos (295), que armazena os metadados como dados, em urna classe 


CAPilULO 10 • PAORÓES ARQUITETURAIS DE FONTES DE DADOS (DATA SOURCE) 175 

ou em um arquivo separado. A grande vantagem dos metadados é a de que todas as 
variações nos mapeadorcs podem ser tratadas por meio de dados sem a necessidade 
de código fonte adicional, seja pela geração de código ou por meio de progrnmação 
reflexiva. 

Quando Usá-to 

A principaJ ocasião para usar o Mapcador de Dados é quando você quiser que o esquema 
do banco de dados e o modelo de objetos evoluam independentemente. A situação 
m,\is comum para isso é com um Modelo de Domí11io (126). O principal benefício 
do Mnpcndor de Dados é que, quando você estiver trabalhando no modelo do domínio, 
você pode ignorar o banco de dados, tanto na fose de projeto quanto na de constrnção 
e teste. Os objetos do domínio não têm qualquer conhecimento da estrutura 
do banco de dados porque toda a correspondência é feita pelos mapeadores. 

1sso lhe ajuda no códígo porque você pode entender e trabalhar com os objetos 
do domínio sem ter que entender como eles estão armazenados no banco de dados. 
Você pode moctiJicar o Modelo do Domínio (126) ou o banco de dados sem ter que alterar 
o outro. Em mapeamentos complicados, especialmente aqueles envolvendo 
bancos de dados já existentes, isso é muito valioso. 

O preço, é claro, é a camada adicional não-existente se você usa o Registl'() Ativo 
(165), de modo que a chave para o uso ou não deste padrão é a complexidade da lógica 
de negócio. Se sua lógica de negócio for razoavelmente simples, você provavelmente 
não precisa de um Modelo de Domínio (126) ou de um Mapendor de Dados. Lógica 
mais complicada leva-o a um Modelode Domfnio (126) e, conseqüentemente, a um 
Mnpendor de Dados. 

Eu não escolheria um Mnpendor de Dados sem um Modelo de Domínio (126), mas 
posso usar o Modelo de Domínio (126) sem um Mnpendor de Dados? Se o modelo do domínio 
for bastante simples e o banco de dados estiver sob o controle do desenvolvedor 
do modelo do domínio, então é razoável que os objetos do domínio Acessem diretamente 
o banco de dados com o Registro Ativo (165). Efetivamente, isso coloca a lógica 
de mapeamento descrita aqui nos próprios objetos do domínio. À medida que 
as coisas se tornam mais complicadas, é melhor refatorar o código de acesso ao bimco 
de dados em uma crunada separada. 

Lembre-se de que você não tem que ci·iar uma camada completa de mapeamento 
de dados. Esta é uma tarefa bastante complicada, e existem produtos disponívejs 
que fazem isso para você. Na maioria dos casos, recomendo comprru· uma camada 
para o mapeamento no banco de dados em vez de criar uma você mesmo. 

Exemplo: Um Mapeador Simples de Banco de Dados (Java) 

Este exemplo mostra um uso absurdamente simples de um Mnpeador de Dados para 
lhe dar uma idéia da sua estrutura básica. Nosso exemplo consiste em uma classe 
pessoa e uma tabela isomórfica pessoa. 

cl~ss Pessoa ... 

private String sobreooc:1e; 
private String prenome; 
private int nõmeroDeDependentes; 


176 PARTE li • Os PAORÕES 

O esquema do banco de dados se parece com: 

create table pessoas (lD int prioary key, sobrenom.e varchar. 
prenome varchar, númeroOeDependentes intl 

Usaremos o caso simples aqui onde a classe Mapeador de Pessoa também implementa 
o método de busca e o Mnpa de Identidade (196). Entretanto, acrescentei um mapeador 
abstrato Camada Supertipo (444) para indicar para onde posso extrair algum 
comportamento comum. A carga envolve a verificação de que o objeto já não esteja 
no Mnpa de fdentidnde (196) e, então, a busca dos dados a partir do banco de dados. 

O comportamento de busca começa no Mnpendor de Pessoa, o qual encapsula as 
chamadas para um método abstrato de busca pelo ID. 

class MapeadorDePessoa ... 

protecteà String declaraçãoDeBusca 1 ) 
return "SELECT • 1 COLUN~.S i 
~ FRO(,I pessoas• • 

• WHERB íd ~ ?•; 
public static final String COLUll).S .. • id, sobrenO(lle, prenome. númeroDeDepenàentes •: 
public Pessoa buscar (Long íd) 
return (Pessoal buscaAbstata (id); 

public Pessoa buscar (long id) 1 
return buscar(new Long{id) ); 

class MapeadorAbstrato... 

protecteà Map mapaCarregado = new Hash!,!ap( 11 
abstract protecteà String declaraçãoOeBusca ( ); 
protected ObjetoDoOominio buscaAbstrata(LOng idl 

ObjetoDoDomínio resultado= (ObjetoDoDominio) mapacarregado.ler(idl; 
ii (resultado!: nulll return resultado; 
PreparedStatement declaraçãoDeBusca = null; 
try( 

declaraçãoOeBusca .. OB.prepare(declaraçãoDeBusca( 1); 
declaraçàoOeBusca.setLong(l, id.longValue( )); 
ResultSet rs = declaraçãoDeBusca.executeQueryl l1 
rs.next( ); 
resultado; carregar(rsl; 
return resultado; 

) catch (SQLException e) { 
throw ne~ ApplicationException le); 
) Einally l 
DB.cleanUp(declaraçãoDeBuscal: 

O método de busca chama o método de carga, o qual é dividido entre o mapeador 
abstrato e o mapcador de pessoa. O mapeador abstrato verifica o 10, extraindo-o 
dos dados e registrando o novo objeto no Mapa de lde11tidnde (196). 


CAPilUL0 10 • PA0RÔES ARQUITETI.JRAIS DE FONTES DE OA00S (DATA SOURCE) 177 

class MapeadorAbstrato... 

protected ObjetoDoDomínio carregar (ResultSet ts) thro~s SQLException 1 
Long ld = new Long(rs.getLong(l}}; 
if (mapacarregaôo.containsKey(id)) return (ObjetoDoDominio) mapacarregado.ler(id); 
ObjetoDoOomínio resultado= fazerCarga lid, rs); 
mapacarregado.put (id, resultado); 
recurn resultado; 

abstract protected ObjetoDoDominio fazerCarga (Long id, ResultSet rs) 
throws SQLExcepcion; 

class ~apeadorDePessoa .. . 

proLected ObjetoDoDom1nio fazercarga (Long id, ResulcSet rs) throws SQIJ:xcepL1on ( 
String parâmetroSobrenome = rs.getString(2); 
String parâmetroPreno..,e = rs.getStringl3); 
int parâmetroNúmeroDeDependences = rs.getlnt (4); 
return new Pessoa (id, parãmetrosobrencme, par&metroPrenooe, 
parâmetroNGr.eroDeDependentes); 

Perceba que o Mnpn de Identidade (196) é verificado duas vezes, uma pelo método 
buscaAbstrata e outra método carregar. Há uma razão para esta loucura. 

Preciso verificar o mapt\ no método de busca porque, se o objeto já estiver lá, 
posso evitar uma ida ao br1nco de dados -sempre quero evitr1r essa ida ao banco 
de dados, se puder. Contudo, também preciso verificar na carga porque é possível 
que eu tenha consultas que não posso ter certeza de resolver no Mnpn de Identidade 
(196). Suponha que eu queira encontrar todas as pessoas cujo sobrenome satisfaça 
algurn padrão de busca. Não posso ter certeza de que eu já tenha todas essas 
pessoas carregadas, de modo que tenho que ir ao banco de dados e executar uma 
consulta. 

class l~apeadorDePessoa... 

pri'late static String declaraçàoBncontrarSobren01te = 

'SELBCT • t COLUNAS t 

• FROM pessoas • , 
• WHERE UPPERlsobrenome) like UPPERl?I" • 
• ORDER BY sobrenome• ; 
public List encontrarl?elosobrenome (String noo.e) { 
PreparedStatement dec = null; 
ResultSet rs % nul l; 
try { 

dec = DB.prepare(declaraçàoEncontrarSobrenocne); 
dec.setString 11, nome~; 
rs = dec.executeOuery( ); 
return cauegarToàos{rs); 

) catch (SQLException e) 1 
throw new ApplicationExoeption (e}; 
} finally { 
DB.cleanOp (dec, rs); 


178 PARTE li • Os PADRÕES 

class MapeadorAbstato... 

protected List carregar'l'odos (ResultSet rsl thro~s SQLException ( 
List resultado= ne~ ArrayList ( 1 i 
while (rs.next ( )} 

resultado.add (carregar(rs)); 
return resultado; 

Quando faço isso posso extrair algumas linhas do conjunto resultante que correspondam 
a pessoas que eu já tenha carregado. Tenho que me assegurar de que eu 
não faça uma duplicata, então tenho que verificar o Mnpa de identidade (196) novamente. 


Escrever um método de busca dessa forma em cada subclasse que precise dele 
implica em uma codificação básica, porém repetitiva, o que posso eliminar fornecendo 
um método genérico. 

class HapeadorAbstrato... 

public List encontrat'l{Uitos (Ori9er.DaDeclaração origem) 
PreparedStatement dec = null; 
ResultSet rs = null; 
try { 

dec = DB.prepare(ori9em.sqll )); 
for(int i :O; i< origem.parâmetros( ) .length; ii+I 

dec.setObject(i+l, origem.parâoetros( ) lil); 
rs = dec.executeQueryt ); 
return carregarTodos (ra); 

) catch (SQLBxception e} ( 
thro~ ne~ ApplicationExcepcion te}; 
) finally l 
DB.cleanUp (dec, rs); 

Para isto funcionar, preciso de uma interface que encapsule tanto a string SQL 
quanto a carga dos parâmetros na declaração preparada. 

interface OrigemDaDeclaração.. , 

String sql; 
Object 11 parâmetros ( ); 

Posso, então, usar esse recurso fornecendo uma implementação apropriada como 
uma classe interna. 

class MapeadorOePessoa .. . 

public List encontrarPeloSobrenome2 (String padrão) { 
return encontrarMuitos (new BnccntrarFeloSobrenooe (padrão)); 

} 

static class EncontrarPeloSobrenome i~plen:ents Orige:nDa.Declaração{ 
private String sobrenome; 
public EncontrarPeloSobren~~e {String sobrencme} 

this.sobrenome = sobrenOl".e; 


CAPiTULO 1 O • PAORÓES ARQUITE'T\JRAIS DE FONTES DE DADOS (DATA SouRCE) 179 

public String sql 1 ) ( 
return 

"SELECT • ¼ COLUNAS + 

• FROM pessoas~ 1 
1 

WHERE OPPBR (Sobrenon:e) like UPPBR(?)• 1 

• ORDER BY sobrenome•; 
public Object() parâi;etros 1 ) { 
Object( 1 resultado= {sobrenome}; 
return resultado; 

Esse tipo de trabalho pode ser executado em outros lugares onde houver código 
repetitivo de chamada de declarações. De modo geral, fiz os exemplos aqui mais 
diretos para torná-los mais fáceis de seguir. Se você perceber que está escrevendo 
uma grande quantidade de código di1·eto repetitivo, deve considerar fazer algo semelhante. 


Com a atualização, o código JDBC é específico para o subtipo. 

class MapeadorDePessoa ... 

private static final String stringl>aDeclaraçâoDeAtualiz~çào = 
"UPDATE pessoas •♦ 

• SET sobrenc.~e =?, pren~ = ?, núceroDeDependentes ~? • • 
" WHBRE id =?" i 
public void atualizar (Pessoa sujeito) { 
PreparedStatement declaraçãoDeAtual1zaçâo = null; 
try{ 

declaraçàoDeAtualização = DB.prepare(stringDaDeclaraçãoOeAtualizaçãol ; 
declaraçãoDeAtualizaçào.setString(l, sujeito.lerSobrencxne()); 
declaraçàoDeAtualizaçào.setString(2, sujeico.lerPrenome()); 
declaraçâoDeAtualizaçào.set1nt(3, sujeito.lerNúmeroDeDependentes{)); 
declaraçàoDeAtualizaçào.setint(4, sujeito.lerID() .intValue( l}; 
declaraçàoDeAtualizaçào.execute( I; 

} cacch (Exception e) { 
throw nei; Application2xoeption (e); 
} finally { 
DB.cleanUp(declaraçãoDeAtualizaçào)1 

Para a inserção, algum código pode ser fatorado para a Cnmndn S11pertipo (444). 

class ~.apeadorAbstrato ... 

public Long inserir (ObjetoDoDomínio sujeicol 
PreparedStatement dec araçãoDelnserçào = null; 
try { 

declaraçãoDeinserção = DB.preparetdeclaraçãoDelnserção( li; 
sujeito. gravarID (enconcrarPrõximoidlioBancoDeDados( li; 
declaraçàoDe!nserção.setJnt (1, sujeito.lerIO( ) .intValue( ))1 
fazerrnseryão (sujeito, declaraçâoDe!nserção); 


180 PARTE li • Os PADRÕES 

declaraçãoDelnserção.executel 1; 
mapaCarregado.put tsuje1to.lerl.D( 1, sujeito); 
return sujeito.lerIO( li 

} catch {SQLBxception e) I 
throw new ApplicationException te}; 
} finally l 
DB.cleanOp(declaraçãoDelnserçãoJ; 

abstract procected String declaraçãoOe:nserçào( ): 
abstract protecteó void faierinserção (ObjetoDoOO.~íoio sujeito, PreparedStatement declaração• 
DeInserção) 
throws SQLExcept1on; 

class HapeadorOePessoa ... 

protected String declaraçãoDernserção 1) 
recurn 'INSERT rnro pessoas V~LUBS (?. ? , ? , ?) ": 

protecteó void fazertnserção ( 
ObjetoDoDo~ínio sujeitoAbstrato, 
PreparedStatement decl 
throws SQLException 

Pessoa sujeito= l?essoa) sujeitol\bstrato; 
dec.setString (2, sujeito.lerSobrenomel l); 
dec.setString (3, suje1to.lerPrenomel li; 
dec.setlnt C4, sujeito.lerNút:eroDeDependeotesl I); 

Exemplo: Separando os Métodos de Busca (Java) 

Para permitir que os objetos do dommfo invoquem o comportamento de busca, posso 
usar uma Intetface Separada (445) para separar as interfaces de busca dos mapeadores 
(Figura 10.5). Posso colocar estas interfaces de busca em umpacote separado que 
seja visível à camada de domínio ou, como neste caso, posso colocá-las na própria camada 
do domínio. 

Uma das pesquisas mais comuns é aquela que busca um objeto pelo 10 que o 
identifica. A maior parte deste processamento é bastante genérico, de modo que ele 
pode ser tratado por uma Camada S11pertipo (444) apropriada. Tudo que é preciso é 
uma Camada S11pertipo (444) para objetos do domínio que conheça os IDs. 

A interface para pesquisas reside na interface para buscas. Normalmente, é melhor 
não torná-la genérica porque você precisa conhecer o tipo de retorno. 

interface buscadorDeArtisca... 

Artista buscar (Long id): 
Artista buscar llong id>; 

É melhor declarar a interface para buscas no pacote do domínio com os métodos 
de busca anm1zenados em um Registro (448). Neste caso, fiz com que a classe mapeadora 
implementasse a interface para buscas. 


CAJ>ilULO 10 • PADRÕES ARQUITHIJRAIS DE FONTES DE DADOS (DATA SOURCE) 181 

domlnio mapeador 1 

Objeto do Domínio 

id: long 

Mapeador Abstrato 

+ inserir
Artista 

+ atualizar 
# buscaAbstrata 
# carregar 
# fazerCarga 
Álbum 

I 

I 
I 

I 
I 

I 

Mapeador 
ccinterface» de Artista 
Buscador de Artista 
buscar (id) 
buscar {id) # fazerCarga 

Figura 10.5 Definindo uma interface de busca no pacote do domínio. 

class l~apeadorOeArtista in:ple~ents buscadorOeArtista... 

public Artista buscar (Long id) i 
return (Anistl buscaAbstrata (id)i 

l 

public Artista buscar llong id) ( 
return buscar(new 1ong(id}); 

A parte principal do método de busca é executada pela Camada Supertipo {444) 
do mapeador, que verifica o Mapa de Identidade (196) para ver se o objeto já está na 
memória. Se não estiver, ele completa um prcpared statement (carregado pelo mapeador 
de artista) e o executa. 

class NapeadorAbstrato... 

abstract protected Str1ng declaraçãoDeBusca I J; 
protected Map mapacarregado = ne~ HashMapl ); 
pr-0tecteõ ObjetoDoDonúnio buscaAbstrata (Long idl 

ObjetoOoDomino resultado= (ObjetoDoDoc!ínio) mapaCarregado.get{id); 
if (resultado l= null ) return resultado; 
PreparedState:r.ent dec: null; 
ResultSet rs: nul!; 


182 PARTE li • Os PAORÕES 

try ( 
dec = DB.prepare(declaraçàoDeBuscaf )); 
dec.setwng(l, id.longValue( li; 
rs = dec.executeQuery( ); 
rs.next (); 
resultado: carregar(rs); 
return resultado; 

) catch (SQLException e) 1 

thrcw new ApplicationExoeption (e); 
) finally {cleanOpldec, rs); 
) 

class HapeadorDeArcista.. . 

protecteà String declaraçàoDeBusca 1 ) ( 
return "select '" 
➔ LISTA_DE_COL011AS • • from artistas art where ID = ?9 
; 

public static String LISTA_OE_COLONAS = •art.10, art.noee' ; 

A parte do comportamento referente à busca diz respeito à obtenção de um objeto 
existente ou de um novo. A parte referente à carga diz respeito a colocar os dados 
do banco de dados em um novo objeto. 

class Hapeadori\bstrato ... 

protected ObjetoDoDofllínio carregar (Resulcset rsl throws SQLException { 
Long id = new Long (rs.getLong tid")) ; 
if (mapaCarregado.containsKey (id)I return (ObjecoDoOo~inio) mapaCarregado.get lidl; 
ObjetoOoOcninio resultado= fazerCarga lid, rs) : 
mapaCarregado.put (id, resultado); 
return resul tado; 

abstract protected ObjetoDoDomínio fazercarga (Long id, ResultSet t&) 
throws SQLException; 

class MapeadorDeAttista.. . 

protecteà ObjetoOODom!nio fazerCarga (Long id, ResulcSet rs) thro~s SQLException { 
String nomes rs.getString(•nome•I ; 
Artista resultado= new Artista (id, nOille); 
return resultado; 

Observe que o método de carga também verifica o Mnpn de lde11tidnde (196). Embora, 
neste caso, isso seja redundante, a carga pode ser chamada por outros métodos 
de busca que ainda não fizeramesta verificação. Neste esquema, tudo que uma subclasse 
tem que fazer é desenvolver um método fazerCarga para carregar os dados 
reais necessários, além de retornar uma declaração aproprjada a partir do método declaraçãoDeBusca. 


Você também pode fazer uma busca baseada em uma consulta. Suponha que tenhamos 
um banco de dados de faixas e álbuns e queiramos um método de busca que 
encontre todas as faixas em um álbum específico. Novamente, a interface declara os 
métodos de busca. 


CAPilULO 1 O • PADRÕES ARQUITHURAIS OE FONTES DE DAOOS (DATA SouRCE) 183 

interface buscadorDeFaixas. ,. 

Faixa buscar (Long id); 
Faixa buscar (long id); 
List buscarDoAlbum (Long idOoÁlbum); 

Uma vez que este é um método de busca específico para esta classe, ele é implementado 
em uma classe espeáfica, tal como a classe mapeadora de faixas, em vez de 
em uma Camada S11pertipo (444). Assim como com qualquer método de busca, existem 
dois métodos para a implementação. Um deles estabelece a expressão preparada 
(prepnred stale111e11t) e o outro encapsuJa a chamada para a expressi\o preparada e 
interpreta os resultados. 

class MapeadorDeFalx.a... 

public static final String declaraçãoBuscaDoÃlbu~; 

•SBLBCT ID, seq, idOo~lbum, titulo "t 
"FROM faixas•~ 
"WHERE IDdoÁlburn =? ORDER BY seq"; 
public List buscarPorÁ1bum ([.()ng iõDoÁlbuml 
PreparedStatement dec = null; 
ResultSet rs = null; 
try ( 

dec = DB.pr~pare (declaraçãoBuscaDoÁlbum ); 
dec. setLong n, idDoÁlbum. longVaJue ( ll; 
rs = dec.execuceQuery( ); 
List resultado= ne~ ArrayList( ); 
while (rs.next l )> 

resultado.add(carregar(rs)) ; 
return resultado; 
} eatch (SQLE:xception e) 1 

throw new ll.pplicationExoeption (e); 
} finally lcleanUp(dec, rs); 
} 

O método de busca chama um método de carga para cada linha no conjunto resultante. 
Este método tem a responsabilidê-\de de criar o obj~to na memória e carregálo 
com os dados. Como no exemplo anterior, parte disso pode ser tratada em uma Camada 
S11pcrlipo (444), incluindo a verificação do Mapa de Identidade (196) para ver se 
algo já está carregado. 

Exemplo: Criando um Objeto Vazio (Java) 

Há duas abordagens básicas para carregar um objeto. Uma é criar um objeto completamente 
válido com um construtor, que é o que fiz nos exemplos acima. Isso resulta 
no seguinte código construtor: 

class MapeadorAbstrato.. . 

protected ObjetoDoDomínio carregar !ResultSet rs) throws SOLí::xception ( 
Long id: new Long(rs.getLong(lJ); 
i[ (mapacarregado.containsKey(íd)l retum (ObjetoDoDominio) ~4pacarregado.get,id); 
ObjetoDoOomínio resultado: fazer<:arga(id, rs); 


184 PARTE li • Os PAORÕES 

mapaCarregado.put (id, resultado); 
return resultado; 

abstract protected ObjetoDoDominio fazercarga (Long id, ResultSet rs) thro~s SQLException; 

class MapeadorDePessoa ... 

protected ObjetoDoDomínio fa2e?:Carga (Long id, ResultSet rs) r.hrows SQLEXception ( 
String parâmetroSobrenorne = rs.getString l2); 
String parâmetroPrenonie = rs.getStríngl3t ; 
int parâ~etroNúmeroDeDependentes = rs.getint (4); 
return ne~ Pessoa (id, parâmetroSobrencme, paràmetroPrenome, parâroetroNfu:leroDeDependentes); 

Aai terna tiva é criar um objeto vazio e, mais tarde, carregá-lo com os métodos 
de gravação. 

class NapeadorAbstrato... 

procected ObjetoDoDonúnioEL carregar (Resu!tSet rs) thro-.is SQLException ( 
Long id = new Long(rs.getLor.g(l l); 
if (mapacarregado.containsKey(idl) return (ObjetoDoDominioEL) mapacarregado.get (id); 
ObjetoDoDolllinioEL resultado= criarObjetoDoDomínio( ); 
resultado.gravarID(idl ; 
mapaCarregado.put(id, resultado): 
fazercarga (resultado, rsl; 
return resultado; 

abstract protected ObjetoüoOomínioEL criarObjeto!loDomínio() 1 
abstract protected void fazerCarga (ObjetoDoDomínioBL obj, Resu1tSet rs} thr0t-·s SQLException; 

class MapeadorDePessoa ... 

protected Obje~oDoDominioEL criarObjetoDoDomfnio() 
return new Pessoa( >i 

protected void fazercar9a (ObjetoDoDomin10BL obJ, ResultSet rs) thro~s SQLBxception ( 
Pessoa pessoa= (Pessoa) obj; 
pessoa.carregarSobrenomeBO (rs.getString(2)); 
pessoa.gravarPrenOCle(rs.getString \31); 
pessoa.gravarNúmeroDeDependentes(rs.getint (4l ); 

Perceba que estou usando um tipo diferente de objeto de domínio, Camada Supcrtipo 
(444) aqui, porque quero controlar o uso de métodos de gravação. Digamos 
que eu queira que o sobrenome de uma pessoa seja um campo imutável. Neste caso, 
não quero alterar o valor do campo, uma vez que este tenha sido gravado, então 
acrescento um campo status no objeto do domínio. 

class ObjetoDoDominioEL.. . 

privace int estado = CA.~l!GAllOO; 
private static final int CARREGA?IOO = ~; 
private static final ínt ATIVO= l; 
public void fiqueAtivo ( > { 

estado : ATIVOi 


CAPilULO 10 • PAORÕES ARQUITH1JRAIS DE FONTES DE DADOS (DATA SOURCE) 185 

Posso, então, verificar o valor deste durante uma carga. 

class Pessoa .. . 

public void carre<JarSobrenomeBO (String sobrenome) 
assertEstadoÉCarregando ( ); 
this.sobrenOC1e = sobrenome; 

class ObjetoDoDQaúnioEI.... 

void assertEstadoÊCarregando ( ) 

Assert. isTrue (estado == CARREGANDO) ; 

O que me desagrada nisso é termos agora um método na interface que a 
maioria dos clientes da classe Pessoa não pode usar. Este é um argumento para o mapeador 
usando reflexão gravar o campo, ignorando assim completamente os mecanismos 
de proteção Java. 

A condição guarda baseada no stnt11s compensa o problema? Não estou inteiramente 
certo. Por um lado isso irá pegar falhas causadas por pessoas chamando métodos 
de "tualização na hora errada. Por outro lado, estas falhas são tão severas que 
compensam o custo do mecanismo? No momento não tenho uma opinião sólida a favor 
de qualquer das opções. 


CAPÍTULO 11 

Padrões Comportamentais 
Objeto-Relacionais 


CAPirUL0 11 • PADRÕES COMPORTAMENTAIS OaJET0-RELACI0NAIS 187 

Unidade de Trabalho (Unit of Work) 

Mantém uma lista de objclos afetados por 11111a 
lrnnsaÇt1o de 11eg6cio e coordena n grnvoçno dns alterações 
e n resolução de problemas de co11corrêncin. 

Unidade de Trabalho 

reg1strarNovo(objeto} 
reg1strarSujo(objeto) 
registrarlimpo(objeto) 
registrarExcluido{objeto) 
confirmar() 

Quando você está enviando d<1dos de e p<1ra um banco de dados, é importante manter 
registro do que você alterou, senão esses dados não serão gravados de volta no 
banco de dados. De maneira similar, você tem que inserir novos objetos que criou e 
remover quaisquer objetos que apagou. 

Você pode alterar o banco de dados a cada mudança no seu modelo de objetos, 
mas isso pode levar a muitas chamadas pequenas ao banco de dados, o que acaba 
sendo muito lento. Além disso, requer que você tenha uma transação aberta para a 
interação inteira, o que não é prático se você tiver uma transação que envia diversé'ls 
solicitações. A situação é até pior se você precisar manter registro dos objetos que leu 
para que possa evitar leituras inconsistentes. 

Uma Unidadede Trnbnl/10 mantém registro de tudo o que você faz durante uma 
transação de negócio que possa afetar seu banco de dados. Quando você tiver terminado, 
ela descobre tudo o que precisa ser feito para alternr o banco de dados como resultado 
do seu trabalho. 

Como Funciona 

As coisas óbvias que fuzem você lidar com o banco de dados são alterações: novos 
objetos criados e objetos já existentes atualizados ou excluídos. A Unidade de Trabalho 
é um objeto que mantém registro dessas coisas. Assim que você começa a fazer algo 
que possa afetar um banco de dados, você cria uma Unidade de Trabalho para manter 
registro das alterações. Cada vez que você cria, aJtera ou exclui um objeto, informa a 
Unidade de Trabalho. Você também pode informá-la sobre objetos que leu para que ela 
possa verificor leituras inconsistentes checando se nenhum dos objetos foi alterado 
no banco de dados durante a transação de negócio. 

A chave da Unidade de Trabalho é que, na hora de confirmar o trabalho, ela decide 
o que fazer. Abre umé'I transação, executa quaJquer verificação de concorrência 
(usando Bloqueio Offline Pessimista (401) ou Bloqueio Offline Otimista (392)) e grava as 
alterações no banco de dados. Os programadores de aplicações nunca chamam explicitamente 
métodos para atualização do banco de dados. Dessa forma, eles não têm 
que manter registro do que foi alterado ouse preocupar a respeito de como a integridade 
referencial afeta a ordem na qual precisam fazer as coisas. 

É claro que para isso funcionar a Unidade de Trabnllto precisa saber de quais objetos 
deve manter registro. Você pode obter isso com o solicitante do objeto realizando 
esse trabalho ou fazendo o objeto informar à U11idndede Trnbnl/10. 


188 PARTE li • Os PADRÕES 

Com o registro do solicitante (Figtu-a 11.1), o usuário de um objeto tem que se 
lembrar de registrar esse objeto na U11idnde de Trnbnlho para atualizações. Quaisquer 
objetos que não estiverem registrados não serão gravados na hora da confirmação. 
Embora isso permita que o esquecimento cause problemas, dá flexibilidade permi• 
tindo que as pessoas façam alterações na memória que elas não queiram que sejam 
gravadas. Não obstante, eu argumentaria que causará muito mais confusão do que 
valeria a pena. É melhor fazer uma cópia explícita para esse propósito. 

Com o registro do objeto (Figura 11.2), o ônus é removido do solicitante. O truque 
comum aquj é colocar métodos de regislTo cm métodos de objetos. Carregar um 
objeto do banco de dados t-egistra o objeto como limpo; os métodos de gravação registram 
o objeto como sujo. Para este esquema funcional', a Unidadede Trnbal/10 precisa 
ser passada para o objeto ou estar em um lugar bem conhecido. Passai-a U11idnde 
de Trnbnl/10 é tedioso, mas normalmente não há problemas em tê-la presente em algum 
tipo de objeto de sessão. 

Mesmo o registro do objeto deixa algo a ser lembrado, ou seja, o desenvolvedor 
do objeto tem que se lembrar de acrescentar uma chamada de registro no lugar certo. 
A consistência se torna habitual, mas ainda é uma falha complicada quando perdida. 

Este é um lugar natural para a geração de código gerar chamadas apropriadas, 
mas só funciona quando você puder separar claramente código gerado de código 
não-gerado. Este problema é especialmente apropriado para a programação orienta-

uma unidade

banco de dados 

de trabalho 

novo(ID) 

um usuário 

select 

gravar limite , 
de crédito 1 
1 
f 
registra, sujo (um usuário) 

confirmar 
gravar 
update 

Figura 11.1 Fazendo o solicitante registrar um objeto alterado. 


CAPilUL0 11 • PADRÕES COMPORTAMENTAIS OSJETO-RElACIONAIS 189 

uma unidade 

banco de dados 

de trabalho 

novo 
um usuário 

select 

registrar limpo 

gravar limite 1 
de crédito 1 
registrar su10 

confirmar 

gravar 

update 

Figura 11 .2 Fazer com que o objeto receptor registre a si próprio. 

da a aspectos. Também me deparei com pós-processamento dos arquivos objeto para 
resolver isso. Neste exemplo, um pós-processador examinou todos os arqtúvos Java 
.clnss, procurou pelos métodos apropriados e inseriu chamadas de registro no byte 
code. Todo esse procedimento parece deselegante, mas ele separa o código do banco 
de dados do código comum. A programação orientada a aspectos fará isso de modo 
mais limpo com o código fonte e, quando suas ferrn.mentas se tornarem mais comuns, 
espero ver esta estratégia sendo usada. 

Outra técnica que vi é o controlador de unidade de trabalho (Figura 11.3), que o 
produto TOPLink usa. Aqui a Unidade de Trnbn/110 lida com todas as leituras do bl'lnco 
de dados e registra objetos limpos toda vez que eles são lidos. Em vez de marcar objetos 
como sujos, a Unidade de Trnbn/110 faz uma cópia na hora da leitura e então compara 
o objeto na hora da confirmação do trabalho. Embora isso acrescente overltend ao 
processo de conJirmação, permite uma atualização seletiva de apenas aqueles campos 
que foram realmente modificados. Também evita chamadas de registro nos objetos 
do domínio. Uma abordagem luôrida é fazer cópias apenas dos objetos mocüfica• 
dos. Isso requer registro, mas suporta atualização seletiva e reduz grandemente o 
ovcrlwnd da cópia se houver muito mais leituras do que atualizações. 


190 PARTE li • Os PADRÕES 

um cliente banco de dados 
uma unidade 
de trabalho 
novo 
um usuário 
carregar 
• 1 
1 carregar (um usuário) 1 
1 
select 

novo

--------~--------


clone do usuário 
gravar limite 
de crédito 

confirmar 
diferenças do (clone do usuário} 

1 (usuário alterado) 
update 

X

1 

Figura 11 .3 Usando a Unidade de Trabalho como controlador do acesso ao banco de dados. 

Acrié\ção de objetos é freqüentemente um momento especial para considerar o 
registro do solicit,inte. Não é incomum as pessoas criarem objetos que apenas supostamente 
são transitórios. Um bom exemplo disso ocorre nos testes de objetos de domínio, 
que rodam muito mais rapidamente sem as gravações no banco de dados. O 
registro do solicitante pode tornar isso perceptível. Entretanto, há outras soluções, 
como fornecer um construtor transitório que não registre n<t Unidade de Trnbnl/,o ou, 
melhor ainda, fornecer um Caso Especial (462) de Unidade da Trnbnl/10 que não faça nada 
na hora da confirmação. Outra área onde uma U11idnde de Trnbnlho pode ser útil é 
na atualização quando um banco de dados usa integridade referencial. Na maior 
parte do tempo, você pode evitar essa questão assegw·ando que o banco de dados 
apenas verifique a integridade referencial quando a transação é confirmada, em vez 
de em cada chamada SQL. A maioria dos bancos de dados permite isso, e se estiver 
disponível não há um bom motivo para não fazê-lo. Se não estiver, a Unidade de Trnba/
110 é o lugar natural para lidar com a atualização. Em sistemas menores isso pode 
ser feito com código explícito que contenhêl detalhes sobre quais tabelas gravar primeiro 
baseado nas dependências das chaves estrangeiras. Em uma aplicação maior é 


CAPiTUL0 1 1 • PADRÕES COMPORTAMENTAIS OSJET0-RELACI0NAIS 191 

melhor usar metadados para descobrir em qual ordem gravar no banco de dados. 
Como você faz isso está além do escopo deste livro e é uma razão comum para usar 
uma ferramenta comerdal. Se você mesmo tiver que fazê-lo, fui informado de que a 
chave do enigma é um arranjo topológico. 

Você pode usar uma técnica semelhante para minimizar os dendlocks. Se cada 
transação usar a mesma seqüência de tabelas para editar, você reduz grandemente o 
risco de dendlocks. A Unidade de Trabnlho é um lugar ideal para armazenar uma seqüência 
fixa de gravações em tabelas para que você sempre acesse as tabelas na mesma 
ordem. 

Os objetos precisam ser capazes de encontrar sua Unidade de Trnhnlho corrente. 
Uma boa maneira de fazer isso é com um Registro com o escopo de umn t/,rcnd. Outra 
maneira é passar a Unidade de Trabalho para os objetos que necessitem dela, seja 
em uma chamada de método ou quando você cria um objeto. Em ambos os casos, assegure-
se de que apenas uma tlirend possa acessar uma Unidadede Trnbn/110 -aí reside 

o caminho para a loucura. 
A U11idnde de Trabnlllo torna óbvia a questão de lidar com atualizações em lotes. 
A idéia por trás de uma atualização em lote é enviar diversos comandos SQL como 
uma única unidade de modo que eles possam ser processados em uma única chamada 
remota. Isso é especialmente importante quando muitas atualizações, inserções e 
Qxclusões são enviadas em uma rápida sucessão. Diferentes ambientes fornecem diferentes 
graus de suporte a atualizações em lote. JDBC tem um recurso que permite 
«você colocar em lote dedarações individuais. Se você não tjver este recurso, pode 
simulá-lo criando uma string que tenha diversas declarações SQLe, então, submetendo-
as como uma única declaração. [Nilsson] descreve um exemplo disso para plataformas 
Nlicrosoft. Entretanto, se você fizer isso verifique se interfere com a pré-compi1ação 
das declarações. 

A Unidade de Traba/1,o funciona com qualquer recurso transacional, não apenas 
bancos de dados, de modo que você também pode usá-la para coordenar filas de 
mensagens e monitores transacionais. 

Implementação .NET 

Em .NET a Unidade dt• Traba/1,o é feita pelo conjunto de dados descnnectadô. bso a 
toma um padrão levemente diferente da variedade! clássica. A maioria das Unidades 
tft> Trabalho com as quais me deparei registram e rastreiam as altérações nos objetos 
. . NET lê dados do banco de dados para un-1 conjunto de dados, o qual ~ uma 
série de objétos dispostos como tabelas de um banco de dc1dos, linhas e colunas. O 
conjunto de dndos é basicamente uma imagem na memória do resultado de uma 
ou mais consultas SQL. Cada linha de dados tem o conceito de uma versão (corrente, 
original, proposta) e um estado (inalterado, acrescentado, excluído, modificado), 
o que, junto com o fato de que o conjunto de dados simuJa a estrutura do 
banco de dados, torna direta a gravação de alterações no banco de dados. 

Quando Usá-la 

O problema fundamental com o qual a Unidade de Traba//ro lida é manter registro dos 
vários objetos que você manipulou, de modo que você saiba quais precisa considerar 
para sincronizar seus dados na memória com o banco de dados. Se você for capaz de 
fazer todo seu trnbalho dentro de uma transação de sistema, os (micos objetos com os 
quais precisa se preocupar são aqueles que você altera. Embora a U11idnde de Tl·abalho 
seja geralmente a melhor maneira de fazer isso, há alternativas. 


192 PARTE li • Os PADRÕES 

Talvez a alternativa mais simples seja grnvar explicitamente qualquer objeto toda 
vez que o alterar. O problema aqui é que você pode ter muito mais chamadas ao 
banco de dados do que quer já que, se você alterar um objeto em três momentos diferentes 
no seu trabaJho, tem três chamadas em vez de uma no seu estado final. 

Para evitar cliversas chamadas ao banco de dados, você pode deixar todas as 
suas atualizações para o final. Para tanto, você precisa manter registro de todos os 
objetos que alterou. Você pode usar variáveis, no seu código, para isso, mas logo elas 
se tornam não-gerenciáveis, já que você tem mais do que apenas algumas. As variáveis 
muitas vezes trnbafüam bem com um Roteiro de Transação (U0), mas elas podem 
fic<1r muito difíceis com um Modelo de Domínio (126). 

Em vez de guardar objetos em variáveis, você pode dar a cada objeto umajlng, 
indicando-o como sujo, que é configurada quando o objeto é alterado. Então, você 
precisa encontrar todos os objetos sujos no final da sua transação e gravá-los. Ovalor 
desta técnica depende de quão fácil é encontrar os objetos sujos. Se todos eles estiverem 
em uma única hierarquia, então você pode percorrer a hierarquia e gravar 
qualquer um que tenha sido alterado. Entretanto, uma rede de objetos mais geral, tal 
como um Modelo de Domf11io (126), é mais difícil de percorrer. 

A grande força da Unidade de Trnbn/1,o é que ela mantém toda esta informação 
em um único lugar. Assim que você a tiver trabalhando para si, não terá mais que se 
lembrar de fazer mtúta coisa para manter o registro das suas alterações. Além disso, 
a Unidade de Trabalho é uma phttaforma sólida para situações mais complicadas, como 
lidar com transações de negócio que se estendem por diversas transações de sistema 
usando lJl<>queio Ofjline Otimista (392) e 13/oq11eio Offli11e Pessimista (401). 

Exemplo: Unidade de Trabalho com Registro de Objeto (Java) 

por David Rice 

Aqui está uma Unidade de Trnbnllro que pode manter registro de todas as alterações 
em uma dada transação de negócio e então perpeh·á-las (co111mit) no banco de dados 
quando instruída a fazê-lo. Nossa camada de domínio tem uma Cnmadn Supertipo 
(444), ObjetoDoDominio, com a qual a Uuidnde de Trnbn/110 irá interagir. Para armazenar 
o conjunto de alterações usamos três listas: objetos do domínio novos, sujos 
e excluídos. 

class UnidadeDeTrabalho... 

private tist objecosNovos ~ new Array1istl I; 
private List objetosS\ljos: new ArrayList ( I; 
private tist objetosExcluidos ~ new Arraytist( ): 

Os métodos de registro mantêm o estado destas listas. Eles devem executar asserções 
básicas tais como assegurar que um ID não seja nulo ou que um objeto sujo 
não esteja sendo registrado como um novo. 

class UnidadeDeTrabalho. .. 

public void registrarNovo (ObjetoDoDomínio obj) 
Assert.notNU.ll (•id não nulo~, obj.lerld( )l ; 
Assert.isTrue("objeto não sujo•, lobjetosSujos.contains(objl); 
Assert.isTrue(•objeto não excluído~, !objetosExcluídos.contains(obj)l ; 
Assert.isTrue("objeto ainda não ~egistrado co:no novo•, !objetosNovos.contains(obj)J ; 


CAPilULO 11 • PADRÕES COMPORTAMENTAIS OSJET0-RElACI0NAIS 193 

objetosNovos.add(obj); 

public void registrarSujo {ObjetoDoDomínio obj} 
Assert.notNull(•id não nulo•, obj,lerld{ )) ; 
Assert.isTrue(•objeto não excluído•, !objetosExcluídos.concains(obj>)1 
if (!objetosSujos.contains (objl && !objetosNovos.contains(objl) j 

objetosSujos.add(obj); 

public void registrarRemovido (ObjetoDoDomínio obj) 
Assert.notNull(•id não nulo•, obj.lerld( )l: 
if (objetosNovos.remove (obj)I return; 
objetossujos.reoove(obj); 
ií (lobjetosRe:novidos.contains(obj) 

objetosRemovídos.add(objl i 

public void registrarLimpo (ObjetoDoDotúnio obj) 
Assert.notNull(•id não nulo•, obj.lerld( )l; 

Perceba que regiscrarLimpo( ) não faz nada aqui. Uma prática comum é colocar 
um Mapa de ldentidade (196) dentro de uma Uuidnde de T,,abnfho. Um Mapa de lde11tidade 
(196) é necessário quase sempre que você armazenar o estado de objetos do domínio 
na memória porque .múltiplas cópias do mesmo objeto resultaria.m em comportamento 
indefinido. Estivesse um Map(l de lrlcntidadc (196) no lugar, registrarUmpo( ) 
colocat·ia o objeto registrado nele. Da mesma forma, registrarNovo( ) colocaria o novo 
objeto no mapa e regístrarB.xcluído( 1 removeria um objeto excluído do mapa. Sem o 
Mapa de Identidade (196), você tem a opção de não incluir registrarLimpo( ) na sua Unidade 
de Trabnl/10. Já vi implementações deste método que remove.m objetos alterados 
da lista de sujos, mas desfazer parcialmente alterações é sempre complicado. Tenha 
cuidado ao reverter qualquer estado no conjunto de alterações. 

commit 1 ) localizará o Mapendor de Dados (170) para cada objeto e chamará o método 
de mapeamento apropriado. Os métodos atudizarSujos( ) e apagarRemovidos( ) 
não são mostrados, mas eles se comportariam como inserirNovos( l, o que é esperado. 

class UnidadeDeTrabalho.. 


public void COIT.mltl 1 { 
inserirNovo{ ) ; 
atualizarsujos(); 
apagarReC10vidos( ); 

private void inserírNovos() 

for (lterator objetos= objetost:ovos.iterator( 1; objetos.has?lext( ):) 
ObjetoOoDonlínio obj = (ObjetoOoDom!nio) objetos.next( ); 
RegistroDoMapeador.lerMapeador(obj.9etClassl )) .i.nsert(obj); 

Não está incluído nesta U11idndede Trabnf/10 o rastreamento de quaisquer objetos 
que tenhamos lido e queiramos verificar erros de leihtrn inconsistente na hora da 
confirmação. Isso é abordado pelo Bfoq1teio Offline Otimista (392). 


194 PARTE li • Os PADRÕES 

A seguir, precisamos facilitar o registro de objetos. Primeiro c«da objeto do domínio 
precisa encontrar a Unidade de Trnbalho servindo a transação de negócio corrente. 
Já que essa Unidade de Tmballto será necessária parn todo o modelo de domínio passá-
la como um parâmetro, é provavelmente pouco razoável. Já que cada transação de 
negócio é executada dentro de uma única t/,rend, podemos associar a Unidade de Trabalho 
com a tl,read correntemente em execução usando a classe java.lang.ThreadLocal. 
Mantendo as coisas simples, acücionarernos esta funcionalidade usando métodos estáticos 
na nossa classe Unidade de Trn/Jn/110. Se já tivermos algum tipo de objeto de sessão 
associado à tl1read da execução da trnnsação de negócio, devemos colocar a Unidade 
de Trabal/10 corrente nesse objeto de sessão, em vez de adicionar o ovcrltend de gerenciamento 
do mapeamento de outra tl1read. Além disso, a Unidade de Trnbnlflo pertence 
logicamente à sessão. 

class UnidadeDeTrabalho... 

private static ThreadLocal corrente a new ThreadLoca: { ); 
public stacic void novoCorrence ( ) { 
gravarcorrence(new UnidaôeDeTrabalho( )); 

public static void gravarcorrente tUnidadeDeTrabalho udt) 
corrente.set{udtl; 

public static unidadeoerrabalho lercorrente 1 1 
return (UnidadeDeTrabalho) corrente.get( ); 

Agora podemos dar ao nosso objeto de dommio abstrato os métodos de marcação 
para registrar a si próprio na UnidnrleDeTrabn/110 corrente. 

class ObjetoDoOaJinio... 

protected void marcarHovo( ) 
UnidadeDeTrabalho.lerCorrente () .registrarNovo(this); 

protecteó void marcarLimpo() { 
UnidadeDeTrabalho.lerCorrente( ) .registrarLii.po(this); 

protected void marcarSujo() { 

UnidadeDeTrabalho.lercorren~e( 1 .registrarS\ljo{this); 
) 
protected void marcarExclufdo () { 

UnidadeDeTrabalbo.lerCorrente () .registrarExcluído(this); 

Os objetos de domínio concretos precisam se lembrar de marcar a si mesmos como 
novos e sujos quando apropriado. 

class ÁlbU!l. . . 

public static Ãlhum criar (String nome) { 
ÁlbU!ll obj = ne~ Álbum(geradorlD.novolD( ), no.11e); 
obj.marcarNovo(); 
return obj; 


CAPITULO 1 1 • PADRÕES COMPORTAMENTAIS OBJETO-RElACI0NAtS 195 

public void gravarTímlo {String título) 
this.título = titulo; 
ruarca.rSujo 1 1 ; 

Não está mostrado que o registro de objetos removidos pode ser feito por um 
método remover ( ) no objeto de domínio abstrato. Além disso, se você tiver implementado 
registrarLimpo( ), seus Mapendores de Dados (170) precisarão registrar qualquer 
objeto recém-carregado como limpo. 

A paJ'te final é registrar e perpetrar (commit) a Unidade de Trnbn/lio onde for apropriado. 
Isso pode ser feito expJídta ou implicitamente. Aqui está como o gerenciamen 
to explícito da Unidade de Traballlo se parece: 

class RoteiroDeEdiçãoDeÁlbum... 

public static void atuali2arTítulo (Long IdDoÁlbum, String título) 
UnidadeDetrabalho.novoCorrente{); 
Mapeador mapeador = RegistroDoMapeador.lerMapeador (Álbum.class); 
Álbum álbum= (Álbum) mapeador.buscar(IdDoÃlbum); 
álbum.gravar'l'ítulo(titulol ; 
UnidadeDeTrabalho.lerCorrente( 1.co:llmit( t; 

Excetuando-se as aplicações muito simples, o gerenciamento implícito da Unidade 
de Trnbnlflo é mais apropriado, pois evita a codificação repetitiva e ted.iosa. Aqui 
está um servlet Camndn Supertipo (444) que registra e grava (commif) a Unidade de Trabal/
10 para os seus subtipos concretos. Os subtipos implementarão tratarLeitura( } em 
vez de sobrescreverem executarLeitura( }. Qualquer código em execução dentro de 
tratarLeitura ( l terá uma Unidade de Trabalho com a qual trabalhar. 

elass Serv letUnidadeDeTrabalbo ... 

final procecced void executarLeitura (HtcpServlecRequest solicitação, HttpServletResponse resposta) 

throws servletException, IOEx<:eption 1 

try{ 

OnidadeDeTrabalho.novOCorrente( ); 

tratarLeitura (solicitação, resposta) ; 

OilidadeDeTrabalho.ler.Corrente ( 1 .commit 1 ) ; 

) finally ( 

UnidadeDeTrabalho.gravarCorrente(null); 

abscract void tratarLeitura (HttpServletRequest solicitação, HttpServletResponse resposta\ 
throws Servlet:lxception, IOBxception; 

O exemplo de sen.1/ef acima é obviamente um pouco simplista, pois omite o controle 
de transação de sistema. Se você estivesse usando um Controlador Frontal (328), 
você mais provavelmente encapsularia a gerência da Unidade de Trabalho nos seus comandos1 
em vez de executarLeitura ( ) . Um encapsulamento similar pode ser feito 
com quase qualquer contexto de execução. 


196 PARlE li • Os PADRÕES 

Mapa de Identidade {ldentity Map) 

Assegura que cndn ôbjeto sejn cnrregndo npenns 11111n vez, 111nnte11do cada 
objeto carl'egndo em 11111 mapa. Procura objetos usando o mnpn q11andose 
refcl'indo n eles. 

procurador ~ m22ª~! banco de dados

identidade 

procurar (1) 1 
encontrado =ler (1) 1 
1 

<------1 

(encontrado não-nulo) [encontrado ê nulo! encontrado= select where id = 11 
encontrado 

Um provérbio antigo diz que um homem com dois rclógios nunca sabe que horas 
são. Se dois relógios são confusos, você pode entrar em uma confusão ainda maior ao 
carregar objetos de um banco de dados. Se você não for cuidadoso poderá carregar 
os dados do mesmo registro do banco de dados em dois objetos d.ife1·entes. Enti\o, 
quando você atualizar ambos os objetos, passará por momentos interessantes gravando 
as alterações no banco de dados corretamente. 

Relacionado a isso está um problema óbvio de desempenho. Se você carregar os 
mesmos dados mais de uma vez, estará incorrendo em um custo alto em chamadas 
remotas. Assim, não carregar os mesmos dados duas vezes não apenas ajuda na consistência, 
mas pode também aumentar a velocidade da sua aplicação. 

Um Mapn de Identidademantém um registro de todos os objetos que foram lidos 
do banco de dados em uma única transação de negócio. Sempre que quiser um objeto, 
você verifica o Mnpa de Identidade primeiro para ver se já o tem. 

Como Funciona 

A idéia básica por trás do Mapa de Jrlentidnde é ter uma série de mapas contendo objetos 
q_uc foram trazidos do banco de dados. Em um caso simples, com um esquema 
isomórfico, você terá um mapa por tabela do banco de dados. Quando você carregar 
um objeto do banco de dados, primeiro verifica o mapa. Se houver um objeto 
nele que corresponda ao que você estiver carregando, retorne-o. Caso contrário, você 
vai ao banco de dados, colocando os objetos no mapa para referência futurn 
quando carregá-los. 

Há um número de escolhas na implementação com as quais se preocupar. Além 
disso, já que Mapas de Identidade interagem com gerenciamento de concorrência, você 
deveria considerar também o Bloq11eio Offline Otimista (392). 

Escolha das Chaves A primeira coisa a considerar é a chave do mapa. A escolha óbvia 
é a chave primária da tabela correspondente do banco de dados. Isso funciona 


CAPiTUL0 1 1 • PADRÕES COMPORTAMENTAIS Oaiero-RElACI0NAlS 197 

bem se a chave for uma coJuna única e imutável. Uma chave primária substituta se 
adapta bem nesta abordagem porque você pode usá-la como a chave no mapa. A 
chave será normalmente um tipo de dados simples de modo que o comportamento 
de compatação funcionará bem. 

Explícito ou Genérico Você tem que escolher entre tornar um Mnpn de Jdentidadc explícito 
ou genérico. Um Mapa de Identidade explícito é acessado com métodos distintos 
para cada tipo de objeto que você precisar: tal como encontrarPessoa (1). Um mapa 
genérico usa um único método para todos os tipos de objetos, com talvez um parâmetro 
para indicar qual o tipo doobjeto que você precisa, tal como em encontrar( ~Pessoa", 
1). A vantagem óbvia é que você pode suportar um mapa genérico com um objeto 
genérico e reutilizável. É fácil criar um Registro (4.48) reutilizável que funcione 
para todos os tipos de objetos e não precise de atualização quando você adicionar um 
novo mapa. 

Conhtdo, prefiro um Mapa de ldc11tidndeexplícito. Para começai·, isso lhe dá verificação 
em tempo de compilação cm uma linguagem fortemente tipada, mas, mais 
do que isso, tem todas as outras vantagens de uma interface explicita: é mais fácil ver 
quais mapas estão disponíveis e como eles se chamam. Isso significa acrescentar um 
método cada vez que você acrescentar um novo mapa, mas é um overllead pequeno 
em razão da clareza. 

O tipo da sua chave afeta a escolha. Você só pode usar ummapa genérico se todos 
os seus objetos tiverem o mesmo tjpo de chave. Este é um bom argumento para 
encapsular diferentes tipos de chaves de bancos de dados por trás de um único objeto 
d,ave. (Veja mais detalhes em Campo ldcntidndc (215).) 

Quantos Aqui a decisão varia entre um mapa por classe e um mapa para a sessão inteira. 
Um único mapa para a sessão funciona apenas se você tiver drnves únkas de 
banco de dados (veja a discussão em Campo lde11tídndc (215) sobre os compromissos 
envolvidos.) Uma vez que você tenha um Mnpn de Jdentitfnde, o benefício é que você 
tem apenas um lugar para ir e nenhuma decisão complicada sobre herança. 

Se você tiver diversos mapas, o caminho óbvio é um mapa por classe ou por tabela, 
o que funciona bem se o esquema do seu banco de dados e modelos de objetos 
forem o mesmo. Se eles forem dHerentes, é geralmente mais fácil basear os mapas 
nos seus objetos emvez de nas suas tabelas, já que os objetos não devem conhecer as 
complexidades do mapeamento. 

A herança aparece aqui como um sério complicador. Se você tiver carros como 
subtipo de veículos, você tem um mapa ou mapas separados? Mantê-los separados 
pode tornar referências polimórficas muito mais complicadas, já que qualque.r busca 
precisa saber procurar em todos os mapas. Como conseqüência, prefiro usar um único 
mapa para cada árvore de herança, mas isso significa que você também deve tornar 
suas chaves únicas pelas árvores de herança, o que pode ser difícil se você usar 

Herança de Tabela Concreta (283). 

Uma vantagem de um único mapa é que você não tem que acrescentar novos 
quando adiciona tabelas de banco de dados. Todavia, vincular seus mapas aos seus 
Mnpendores de Dados (170) (veja a seguir) nãoserá nenhum fardo extra. 

Onde Colocá-los Os Mapas de fdentidnde precisam estar em algum lugar onde sejam 
fácejs de encontrar. Eles também estão vinculados ao contexto do processo no qual 
você está trabalhando. Você precisa assegw·ar que cada sessão tenha sua própria instância 
que seja isolada de qualquer outra instância de sessão. Assim, você precisa co



198 PARTE li • Os PAORÔES 

locar o Mnpa de identidade em um objeto específico de sessão. Se você estiver usando 
Unidade de Trnbnl/10 {187), este é de longe o melhor local para os Mnpns de Identidade já 
que R Unidade de Trnbnll10 (187) é o principal lugar para manter registro dos dados vindos 
do banco de dados ou indo para o banco de dados. Se você não tiver tuna Unidade 
de Trabalho (187), a melhor aposta é um Registro (448) que seja vinculado à sessão. 

Como sugeri aqui, você normalmente vê um único Mapa de Identidade para uma 
sessão, caso contrário precisará fornecer proteção transacional para o seu mapa, o 
que dá mais trabalho do que qualquer desenvolvedor sensato quer executar. Todavia, 
há algumas exceções. A mé\ior de todas é usar um bé\nco de dados orientado a 
objetos como um cache transacional, mesmo se você usar um banco de dados relacional 
parn armazennr os dados. Embora eu não tenha visto qualquer estudo independente 
sobre performance, as chances são de que vale a pena dar uma olhada. Muitas 
pessoas que respeito são grandes fãs de cache transacional como uma forma de melhorar 
o desempenho. 

A outra exceção são objetos que sejam apenas de leitura em todas as situações. 
Se um objeto não puder nw1ca ser modificado, não há necessidade de se preocupar 
com ele sendo compartilhado pelas sessões. Em sistemas de desempenho intensivo, 
pode ser muito benéfico carregar todos os dados apenas de leitura uma única vez e 
mantê-los disponíveis para o processo inteiro. Neste caso, você tem seus Mapas de 
Identidade apenas de leitura em Ltm contexto de processo e seus Mapas de Jdentidnde 
atualizáveis em um contexto de sessão. Isso também se aplica a objetos que não sejam 
completamente apenas de leitura, mas gue sejam atualizados tão raramente que 
você não se importe de limpar o Mnpa de Identidade do processo e potencialmente voltar 
ao servidor quélndo isso acontecer. 

Mesmo se você estiver inclinado a ter apenas um Mapn de ldentidnde, você pode 
clividi-lo em dois: linhas apenas para leitura e linhas atualizáveis. Você pode evitar 
que os clientes saibam qual é quaJ fornecendo uma interface que verifique ambos os 
mapas. 

Quando Usá-lo 

Geralmente você usa um Mapa de identidade para gerenciar qualquer objeto h·azido 
de um banco de dados e modificado. A razão principal é que você não deseja ter uma 
situ ação na qual dois objetos na memória correspondam a um único registro no banco 
de dados -você poderia mocüficar os dois registros inconsistentemente e assim 
confundir o mapeamento do banco de dados. 

Outra importância do Mapn de Identidade é que ele atua como um cache para as 
leituras do banco de dados, o que significa que você pode evitar ir ao banco de dados 
cada vez que precisar de algum dado. 

Você pode não precisar de um Mapa de Identidade para objetos imutáveis. Se você 
não pode alterar um objeto, então não tem que se preocupar com anomalias causadas 
por modificações. Já que Objetos Valor (453) são imutáveis, resulta que você não 
precisa de Mapasda Identidade para eles. Ainda assim, Mapas de ldentidndC! apresenttlm 
vantagens aqui, a mais importante das quais é a de desempenho do cache. Outra é 
que eles ajudam a prevenir o uso das formas errôneas de testes de igualdade, um 
problema importante em Java, onde você não pode sobrescrever o operador ==. 

Você não precisa de um Mapa de Identidade para um Mapeamento Dependente 
(256). Já que objetos dependentes têm sua persistência controlada pelos pais, não há 
necessjdade de um mapa para armazenar identidade. Contudo, embora você não 


ÚPÍTULO 11 • PADRÕES COMPORTAMENTAIS OBJETO-RHACI0NAIS 199 

precise de um mapa, talvez queira fornecer um se precisar acessar o objeto por meio 

de uma chave de banco de dados. Neste caso, o mapa é meramente um índice, de 

modo que é discutível se ele realmente conta como um mapa. 

O Mnpn de Identidade ajuda a evitar conflitos de atualização dentro de wna mesma 
sessão, mas não faz nada para lidar com conflitos que alTavessem sessões. Este é 
um problema complexo que discutimos mais no Bloqueio Offline Otimista (392) e no 
Bloqueio Offline Pessimista (401). 

Exemplo: Métodos para um Mapa de Identidade (Java) 

Para cada Mapa de Identidade, temos um campo mapa e métodos de acesso. 

private Map pessoas= new Hash.~ap( ); 

ptíblic static void adicionarPessoa !Pessoa parâmetro) { 
instãnciaúnica.pessoas.put(parâreetro.lerlDI), paràcetro), 

} 

public static Pessoa lerPessoa (Long chave) { 
return (Pessoal instânciaÚnica.pessoas.get(chave); 

public static Pessoa lerPessoa llong chave! 
return lerPessoa(ne~ Long(chave)); 

Um dos aborrecimentos de Java é o fato de que long não é um objeto, de modo 
que você não pode usá-lo como índice para um mapa. Isso não é tão aborrecedor 
quanto poderia ter sido, já que não fazemos nenhuma operação aritmética no índice. 
A única situação em que isso realmente atrapalha é quando você quer resgatar um 
objeto com um literal. Você quase mmca precisa fazer isso em código de produção, 
mas muitas vezes o faz no código de teste, de forma que incluí um método de leitura 
que recebe um long para tornar o teste mais fácil. 


200 PARTE li • Os PADRÕES 

Carga Tardia (Lazy Load) 

Um objeto que wio contém todos os dados de que você precisa, 
mas sabe como obtê-los. 

um usuário o bane.o de dados 

obter pedidos 

1 
1 
(pedidos não-carregados! : 

carregar pedidos 

<------


retornar pedidos 

Para carregar dados de um banco de dados para a memória, é conveniente projetar 
as coisas de modo que quando você carregar um objeto de interesse também carregue 
os objetos que sejam relacionados a ele. Isso torna a carga mais fácil para o desenvolvedor 
que estiver usando o objeto, que de outra forma tem que carregar explicitamente 
todos os objetos de que precisa. 

Todavia, se você levar isso ao seu final, chegará ao ponto em que carregar um 
objeto pode ter o mesmo efeito de carregar um grande número de objetos relacionados 
-algo que prejudica o desempenho quando apenas alguns dos objetos são realmente 
necessários. 

Uma Carga Tardin interrompe este processo de carga por um tempo, deixando 
um rnarcador na estrutura do objeto de modo que se os dados forem necessários podem 
ser carregados apenas quando forem usados. Como muitas pessoas sabem, se 
você deixar as coisas para mais tarde vai se dar bem quando descobrir que não precisava 
realmente fazê-las. 

Como Funciona 

Há quatro maneiras principais pelas quais você pode implementar a Carga Tnrdin: inicialização 
tarcUa, proxy virtual, armazenador de valor e fantasma. 

Inicialização tardia [Padrões Beckj é a abordagem mais simples. A idéia básica 
é que cada acesso ao campo verifique primeiro para ver seele é nulo. Se for, ele calcula 
o valor do campo antes de retornar esse mesmo campo. Para fazer isso funcionar, 
você tem que assegurar que o campo seja auto-encapsulado, o que quer dizer 
que todo acesso ao campo, mesmo de dentro da classe, é feito por meio de um método 
de leitura. 

Usar um nulo para sinalizar um campo que não foi carregado ainda funciona 
bem, a menos que nulo seja um valor legal de campo. Neste caso, você precisa de al



CAl>ilUL0 11 • PAORôES COMPORTAMENTAIS Oaino-Re1ACI0NAIS 201 

go a mais para sinalizar que esse célmpo não foi C<'lrregado ou usar um Caso Especial 

(462) pnra o valor nulo. 
Usélr inicfolização tardfa é simples, mas tende a forçM uma dependência entre o 
objeto e o banco de dados. Por esta razão, ela funciona melhor com Registro Ativo 
(165), Gateway de Tabelas de Dados (151) e Gateway de Linhas de Dados (158). Se você estiver 
usando um Mapeador de Dados (170), precisará de uma camada adicional de indireção, 
o que você pode obter usando um proxy virtual (Gang of Four]. Um proxy 
virtual é umobjeto que parece com o objeto que deveria estar no campo, mas, na verdade 
não contém nada. Apenas quando um dos seus métodos é chamado, ele carrega 
o objeto correto a partir do banco de dados. 

O bom do proxy virtual é que ele parece exatamente com o objeto que deve estar 
lá. O ruim é que ele não é esse objeto, então você pode facilmente se deparar com 
um desagradável problema de identidade. AJém disso, você pode ter mais de um 
proxy virtual para o mesmo objeto real. Todos esses proxies terão diferentes identidades 
de objeto, mas ainda assim representam o mesmo objeto conceituai. Você tem 
que, no mínimo, sobrescrever o método de igualdade e lembrar-se de usá-lo em vez 
de um método identidade. Sem isso, e disciplina, você irá se deparar com algumas 
falhas difíceis de rastrear. 

Em alguns ambientes, outro problema é que você acaba tendo que criar muitos 
proxies virtuais1 umpara cada classe na qual estiver usando proxy. Você pode normalmente 
evitar isso em linguagens tipa das dinamicamente, mas em Linguagens tipadas 
estatican1ente, as coisas mLútas vezes ficam confusas. Mesmo quando a plataforma 
fornece recursos convenientes, como os proxif!'S de Java, outros obstáculos podem 
aparecer. 

Esses problemas não lhe atingem se você apenas usar proxies virtuais para classes 
coleções, tais como listas. Já que coleções são Objetos Va/01' (453), suas identidades 
não importam. Adicionalmente, você tem apenas umas poucas classes coleção para 
escrever coleções virtuais. 

Com classes do dom.fofo, você pode contornar esses problemas usando um armazenador 
de valor. Este conceito, com o qual me deparei pela primeira vez em 
SmalJtalk, é um objeto que encapsula algum outro objeto. Para obter o objeto subjacente, 
você solicita seu valor ao armazenador de valor, mas apenas no primeiro 
acesso ele pega os dados do banco de dados. As desvê\ntagens do armazenador de 
valor são que a classe precisa saber que ele existe e que você perde a característica 
explícita da forte v~rificação de tipos. Você pode evitar problemas de identidade êlSsegurando 
que o armazenador de valor nunca seja passado para além da classe a 
qual ele pertence. 

Um fantasma é o objeto real em um estado parcial. Quando você carrega o ob~ 
jeto do banco de dados, ele contém apenas seu lD. Sempre que você tentar acessar 
um campo, ele carrega seu estado completo. Pense em um fantasma como um objeto, 
onde cada campo é inicializado tardinmente de uma só vez, ou como um proxy 
virtual, onde o objeto é seu próprio proxy virtual. É claro que não há necessidade de 
carregar todos os dados de uma vez só. Você pode reuni-los em gnipos que sejam comumente 
usados juntos. Se você usar um fantasma, pode colocá-lo imediatamente 
no seu Mapn de Identidade (196). Dessa fom1a, você mantém a identidade e evita todos 
os problemas causados por referências cíclicas durante a leitura de dados. 

Um proxy virrual/ fantasma não precisa ser completamente destinúdo de dados. 
Se você tiver alguns dados que sejam rápidos de pegar e comumente usados, pode 
fazer sentido carregá-los quando você carregM o proxy ou o fantasma. (Isso é às vezes 
referido como um "objeto leve.") 


202 PARTE li • Os PADRÕES 

A herança muitas vezes coloca um problema com a Carga Tardia. Se você for 
usar fantasmas, precisará saber que tipos de fantasmas criar, o que você muitas vezes 
não sabe ruzer sem carregar a coisR apropriadamente. Os proxies virtuais podem 
sofrer do mesmo problema. cm linguagens tipadas estaticamente. 

Outro perigo com a Cargn Tardia é que ela pode facilmente causar mais acessos 
ao banco de dados do que você precisa. Um bomexemplo dessa onda de cargas é se 
você preencher um conjunto com Cargas Tnrdins e então olhar um de cada vez. fsso 
fará com que você vá ao banco de dados uma vez para cada objeto em vez de lê-los 
todos de uma s6 vez. Já vi ondas de cargas prejudicar o desempenho de uma aplicação. 
Uma maneira de evitar isso é nunca ter uma coleçã.o de Cargas Tardias, mas, em 
vez disso, torrn1r a própria coleção uma Cnrgn Tardia c1 quando você carregá-la, carregar 
todos os conteúdos. A limitação desta tática é quando a coleção é muito grande, 
como todos os endereços TP do mundo. Estes normalmente não são conectados 
através de associações no modelo de objetos, de modo que não ocorrem com muita 
freqüência, mas, quando ocorrem, você precisará de uo1 Mm1ipulador de Listns de Valores 
fAlur et nl.]. 

A Cargn Tnrdin é um« boa candidata à programação orientada a aspectos. Você 
pode colocar o comportamento da Cargn Tardia em um aspecto separado, o que lhe 
permite alterar a estratégia de carga tardia separadamente assim como liberar os desenvolvedores 
do domínio de ter que lidar com questões de carga tardia. Já vi também 
um projeto de pós-processador de byte codes Java para implementar a Cllrgn Tardia 
de forma transparente. 

Muitas vezes, você irá se deparar com situações nas quais diferentes casos de 
uso funcionam melhor com diferentes variedades de carga tardia. Alguns precisam 
de um subconjunto do grafo de objetos, outros precisam de outro subconjunto. Para 
uma eficiência máxima, você quer carregar o subgrafo correto para o caso de uso 
con eto. 

A maneira de lidar com isso é ter objetos de interação com o banco de dados separados 
para os dHerentes casos de uso. Assim, se você usar Mapeador de Dados (170) 
pode ter dois objetos mapeadores de pedidos: um que carrega as linhas dos itens 
imediatamente e outro que os carrega tardiamente. O código da aplicação escolhe o 
mapeador apropriado dependendo do caso de uso. Uma variação disso é ter o mesmo 
objeto carregador básico, mas delegar para um objeto estratégia a decisão sobre 

o padrão de carga. Jsto é um pouco mais sofisticado, mas pode ser uma maneira melhor 
de fatorar comportamento. 
Teoricamente você poderia querer uma faixa de diferentes graus de carga tardia, 
mas na prática você precisc1 realmente de apenas dois: uma carga completa e 
uma suficiente para o propósHo de identificação em uma lista. Acrescentar mc1is, normalmente, 
adiciona mais complexidade do que vale a pena. 

Quando Usá-la 

Quando usar a Carga Tn,-din é uma decisão relaciont1da a quanto você quer trazer do 
banco de dados quando carrega um objeto e quantas chamadas ao banco de dados isso 
irá requerer. Normalmente, não tem sentido usar a Carga Ta,,dia em um campo que 
é armazenado na mesma linha do resto do objeto, porque na maioria das vezes não 
custa mais trazer dados <1dicionais em uma chamada, mesmo se o campo for ml.lito 
grande -como um LOB Scrinlizado (264). Isso quer dizer que normalmente s6 vale a 
pena considerar Carga Tardia se o campo requerer uma chamada de banco de dados 
extra para ser acessado. 


CAPilULO 11 • PAORôES COMPORTAMENTAIS ÜSJETO-RELACIONAIS 203 

Em termos de desempenho, trata-se de decidir quando você quer pagar o preço 
de trazer de volta os dados. Muitas vezes, é uma boa id~ia trazer tudo de que você 
irá predsar em uma única chamada de forma que você tenha logo tudo no lugar, especialmente 
se isso corresponder a uma única interação com uma interface gráfica 
com o usuário. O melhor momento para usar a Carga Tardin é quando ela envolver 
uma chamada extra, e os dados que você estiver chamando não forem usados quando 
o objeto principal for usado. 

Acrescentar a Carga Tardin aumenta um pouco a complexidade do programa, 
por isso minha preferência é não usá-la a menos que efc6vamente ache que precisarei 
fazê-lo. 

Exemplo: Inicialização Tardia (Java) 

/\ essência da inicialização tardia é um código como este: 

class fornecedor... 

public List lerProdutos ( ) 
if (produtos:; nulll produtos: Produto.buscarPorFornecedor ller!O( )1 : 
return produtos; 

Desta forma, o primeiro acesso ao campo produtos faz com que os dados sejam 
carregados do banco de dados. 

Exemplo: Proxy Virtual (Java) 

A chave para o pl'OXIJ virtual é fornecer uma classe que se pareça com a classe real que 
você usa normalmente mas que na verdade mantenha um simples envoltório cm torno 
dessa classe real. Assim, a lista de produtos de um fornecedor seria armazenada 
cm um campo de lista comum. 

class LVFornecedor... 

private Lista produtos; 

O mais complicado na criação de um proxy de lista como este é configurá-lo de 
modo que você possa fornecer uma lista subjacente que seja criada apenas quando 
for acessada. Para fazer isso, precisamos passar o código necessário para criar a lista 
na lista virtual quando esta for instanciada. A melhor maneira de fazer isso em Java 
é definir uma interface para o comportamento de carga. 

public interface CarregadorDeListaVirtual { 
List carregar( ); 

Podemos então instanciar a lista virtual com um carregador que chama o método 
de mapeamento apropriado. 

class l~peadoroeFornecedor . .. 

public static class CarregadorOeProduto irnplements carregaâorDeLlstaVirtual ( 
private Long id; 


204 PARTE li • Os PAORÕES 

public ca.rregadorDeProduco ILong id) { 
this.id = id; 

public List carregar ( l ( 
return MapeadorDeProàuto.criarl 1.buscarPorPomecedor(id); 

Durante o método de carga, atribuímos o carregador de produto ao campo lista. 

class MapeadorDeFornecedor.. . 

protected ObjetoDoDominio EazerCarga (Long id, ResultSet rsl thro~s SOLE:xception { 
String parâmetro~o.'lle = rs.getString(2); 
LVFornecedor resultado = new Lvromecedor (id, parâc:etroNomel ; 
resultado.gravarProdutos lnew ListaVirtual {new CarregadorDeProduto tid))) ; 
return resultado; 

Alista fonte da lista virtual é auto-encapsulada e avalia o carregador na primeira 
referência: 

class ListaVircual . .. 

private List fonte; 
private carregadorDeListaVirtual carregador; 
public ListaVirtual (carregadorDeListaVirtual carregador) 

this.carregador; carregadori 

} 

private List lerFonte <) { 
if (fonte=~ null) fonte: carregador.carregar(); 
retum font~; 

Os métodos comuns da lista para os quais delegar são implementados na lista 
fonte. 

class ListaVirtual . . , 

public int size j } { 
return lerFonte( ).size( I; 
) 

public boolean isEtlpty () { 

recurn lerFonte( }.isa:tpty( ); 
} 
li ... e assim por diante para o resto dos métodos de lista 

Dessa maneira, a classe do domínio não sabe nada a respeito de como a classe 
mapeadora executa a Carga Tardia. Na verdade, a classe do domínio não sabe nem 
que há uma Cnrgn Tnrrlin. 


CAPÍTULO 11 • PADRÕES COMPORTAMENTAIS OBJETO-RELACIONAIS 205 

Exemplo: Usando um Armazenador de Valor (Java) 

Um armazenador de valor pode ser usado como uma Carga Tardia genérica. Neste caso 
o tipo do domínio está ciente de que algo está acontecendo, já que o campo produto 
é tipado como um armazenador de valor. Esse fato pode ser escondido dos clientes 
do fornecedor pefo método de lei tum. 

class AVFornecedor ... 

private ArmazenadorDeValor produtos; 
public List lerProdutos ( 1 { 
return (List) produtos.lerValor( ); 

O próprio armazenador de valor executa o comportamento da Carga Tardia. Ele 
predsa receber o código necessário para carregar seu valor quando acessado. Podemos 
fazer isso definindo uma interface carregadora. 

class ArmazenadorDeValor... 

private Object valor; 
private carregaâorOeValor carregador; 
public AnnazenaâorDeValor (carregadorDeValor carregador) 

this.carregador: carregador; 

) 

public Objecc lerValor () { 
if (valor:: null) valor~ carregador.carregar(); 
return valor; 

l 

public interface carregadorOeValor 1 
Object carregar( ); 

Um mapeador pode configurar o armazenador de valor criando uma implementação 
do carregador e colocando-a no objeto fornecedor. 

class NapeadorOeFornecedor... 

protected ObjetoOODolllinio fa2ercarga {Long id, ResultSet rs) throws SQLException ( 
String parâmetro~loate = rs.getStt'ing(2); 
AVFornecedor resultado= new AVFornecedor (id, parârnetroNomel; 
resultado.gravarProdutos (new ArmazenadorDeValor (new CarregadorDeProduto{id)l l; 
return resultado; 

public static class CarregadorDeProduto imple~ents CarregaâorOeValor l 
private Long id; 
public CarregadorDeProduto (Long id) ; 

this.id = id; 

public Object carregar () { 
retum MapeadorDeProduto.criart ) .buscarPorFornecedorlid); 


206 PARTE li • Os PADRÕES 

Exemplo: Usando Fantasmas (C#) 

Mtúto da lógica para tomar objetos fantasmas pode ser criada em Camadas S11pertipo 
(444). Como conseqüência, se você usar fantasmas, tende a vê-los usados em todo lugar. 
Começarei nossa exploração de fantasmas olhando alguns objetos do domínio 
Camada S11pertipo (444). Cada objeto do domínio sabe se é um fantasma ou não. 

class ObjetoDoDor.linio. ,, 

Carregarestado Estado: 
public ObjecoDoDominio (long chave) { 

this.Chave = chave; 
} 
public Boolean ÉFantas~a ( 

get {return Estado== carregarEstado.FANT~.SMA);) 
} 
public Boolean EstáCarregado { 

get (retutn Estado== carregarstatus.CARREGAOO);I 
} 
public void MarcarCarregando ( ) ( 

Debug.AssertlÉFantasma); 
Estado = CarregarBstado.CARREGANOOi 

) 

public void MarcarCarregado () ! 
Debug.AssertlBstado ~= CarregarEstado,CARRE~ANDOI; 
Estado= carregarEstado.CARREGAOO; 

) 

enu:n CarregarEstado {FANTASMA( CARRE.GAHIJO, CARREGADO}; 

Os objetos do domínio podem estar cm três estados: fantasma, carregando e 
carregados. Gosto de encapsular a informação do estado com propriedades apenas 
de leitura e métodos explícitos de alteração de estado. 

O elemento mais intrusivo dos fantasmas é que cada método de acesso precisa ser 
modificado de modo que provoque uma carga se o objeto realmente for um fantasma. 

class Empregado... 

public String Nome ( 

get { 
carregar( 1; 
retum _nome: 

} 

Set ( 

carregar{ ) ; 
_nome = valor; 

String _nome: 

class ObjeroDoDominio... 

protecteõ void carregar( 1 
if (ÉFancasmal 
FonteOe.Oadcs.carregar(th:s) ; 


CAPilUL0 11 • PADRÕES COMPORTAMENTAIS OSJETO-RELACI0NAIS 207 

Essa necessidade é um aJvo ideal para programação orientada a aspectos para 
pós-processamento de byte code. 

Parn que a carga funcione, o objeto do domínio precisa chamar o mapeador correto. 
Entretanto, minhas regras de visibilídade dizem que o código do domínio pode 
não ver o código do mapeador. Para evitar a dependência, preciso usar uma combinação 
interessante de Registro (448) e Jnte,fnce Separada (445) (Figura 11.4). Defino um 
Registro (448) para o donúnio para operações na fonte de dados. 

class FonteOeDados.. . 

public scatic void carregar IObjetoDoDominio obj) { 
1nstance.Carregar (objl ; 

A instância da fonte de dados é definida usando uma interface. 

class FonteDeDados .. . 

public interface IFonteOeDados ( 
void Carregar (ObjecoDo!lominio ol>j); 

O registro de mapeadores, definido na camada de fonte de dados, implementa 
a interface da fonte de dados. Neste caso, coloquei os mapeadores em um dicionário 
indexado pelo tipo de domínio. O método de carga encontra o mapeador correto e 
lhe manda carregar o objeto do domínio apmpriado. 

class RegistroMapeador: IFonteOeOados ... 

public void carregar (ObjetoDo000ínio obj) ( 
Mapeador(obj.GetType( )) .Carregar(cbj); 

) 

public scatic Mapeador Mapeador (Type tipo) ( 
return (lapeador) inscance.mapeadoresltipol; 

IOictionary mapeadores ~ new Hashtable ( ); 

O código anterior mostra como os objetos do domínio interagem com a fonte de 
dados. A lógica da fonte de dados usa Mnpendores de Dados (170). A lógica de atualização 
nos mapeé'ldores é a mesma do caso sem fantasmas -o comportamento interessante 
para este exemplo reside no comportamento de busca e de carga. 

Classes mapeadoras concretas têm seus próprios métodos de busca que usam 
um método abstrato e realizam downcast no resultado. 

class MapeadorDeEr.!pregado. . 

public Empregado Buscar (long chave! 1 
return (Elnpregaôo) Busca_Abstrata (chave); 

c!ass Mapeador .. _ 

public ObjetoDoDominio Busca.Abstrata {long chave) { 
ObjetoDoDomínio resultado; 
resultado= (ObjetoDoDomínio) mapacarregado(chave); 


Carga Tardia 

IV 

o 

00 

= 

• 

«interface»

Objeto do Domínio Fonte de Dados 

IFonte de Dados 

~ 

#Carregar Carregar (ObjetoDoDominio) Carregar (ObjetoDoDomínio) 
init (IFonteDeDados) 

Empregado 

domínio 

---1 ,--
fonte de dados 

1 

Mapeador

Mapeador de 

Registro Mapeador 

0.. 1

Empregado 

.-1 

classe

C> +BuscaAbstrata(chave) -1
+ Buscar (chave) 
+Carregar (ObjetoDoDomfnio) Carregar (ObjetoDoDomínio) 

#fazerCargaDelinha 

#fazerCargaDelinha 

Figura 11.4 Classes envolvidas na carga de um fantasma. 


ÚPlfULO 11 • PADRÕES COMPORTAMENTAIS OSJETO-RHACl0NAIS 209 

if (resultaào == null) { 
resultado= CriarFantasma (chave); 
mapacarregado.Addlchave, resultado)i 

return resultado; 

lDictionary map3Carregado = new Hashtable ( 1 ; 

public abstract ObjetoDoDomínio CriarFantasma(long chave); 

claes MapeadorDeEmpregado ... 

public override ObjetoDoDominio CriarFantasma(long chave) 
return new El:lpregado(chave); 

Como você pode ver, o método de busca reton1a um objeto no seu estado de 
fantasma. Os dados reais não vêm do banco de dados até que a carga seja disparada 
pelo acesso a uma propriedade no objeto de domínio. 

class Uapeador... 

public void Carregar (ObjetoDol>o..tinio obj) { 
if (! obj.ÉFantasma) return; 
IDBCo=imand cor.-.:n = new OleDbCommand (declaraçãoDeBusca( l, DB.connectíon) ; 
comm.Para;neters.Add (new OleDbParameter(•chave', obj,Chave)); 
lOata.~eader leitor= col!illl.ExecuteReader{ ); 
leitor.Read ( ) ; 
CarregarLinba (leitor, obj); 
leitor.Closel 1; 

protected abstract String declaraçãoDeBusc~{ ); 

public void CarregarLinba (IOataReader leitor, ObjecoDoDominio obj) 

if (obj .ÉFantast11a) { 

obj.HarcarCarreganõo! ); 

fa2erCargaDaI.inha (leitor, obj); 

obj . 

HarcarCarregadof 1; 

protected abstract void fazerCar:,aOaLin.~a (IData.~eader leitor, ObjetoDoOominio obj); 

Como é comum nestes exemplos, a Camada Supertipo (444) lida com todo o comportamento 
abstrato e então chama um método abstrato para uma subclõSse específica 
executar seu papel. Para este exemplo, usei um leitor de dados, uma abordagem 
baseada em cursor que é a mais comum para as diversas plataformas no momento. 
Deixarei para você estender isso para um conjunto de dados, o que seria realmente 
mais apropriado para a maior parte dos casos em .NET. 

Para este objeto Empregado, mostrarei três tipos de propriedades: um nome 
que é um valor simples, um departamento que é uma referência a um outro objeto e 
uma lista de regjstt"Os de horários que mostra o caso de uma coleção. Todos são carregados 
juntos na implementação da subclasse do método associado. 


210 PARTE li • Os PAORÕES 

class MapeadorDeEmpregado ... 

protected override void fazerCargaDaLinha llDataReader leitor, ObjetoDoDomínio obj) 
Empregado empregaào = (Ec:pregado) obj; 
eir.pregado.Nome = (String) leitor(•nome•J; 
MapeadorDeDepa.rtattento 111apDep = 

(MapeadorOeDepartat1ento} RegistroMapeador.Mapeador (typeof (Departamento)) ; 
eir.pregado.Oepartat'.ento ,. llapDep.auscarl (int) leitor[" IdDoDepartamento•t ); 
carregarRegistrosDeTempo (empreqadol; 

O valor do nome é carregado simplesmente lendo a coluna apropriada do cursor 
corrente do leitor de dados. O departamento é lido usando o método de busca no 
objeto mapeador de departamento. Isso acabará configurando a propriedade para 
um fantasma do departamento. Os dados do departamento serão lidos apenas quando 
o próprio objeto departamento for acessado. 

A coleção é o caso mais complicado. P,u·a evitar carregamento em ondas, é importante 
carregar todos os registros de tempo em uma única busca. Para isso, precisamos 
de uma implementação de lista especial que atue como uma lista fantasma. 
Esta lista é apenas um envoltório fino em torno de um objeto lista real, para o qual to~ 
do o comportamento real é apenas delegado. A única coisa que o fantasma faz é assegurar 
que qualquer acesso à lista real provoque uma carga. 

class ListaDoDo:ninio... 

IList dados ( 

get { 
Carregar ( 1 ; 
return _dados; 

1 

set (_dados~ valori) 

IList _dados: new ArrayLiscl) 1 
public int Count { 
get { return dados.Count;t 

A classe da lista do domínio é usada pelos objetos do domínio e é parte da camada 
do domínio. A carga real precisa acessar comandos SQL, então uso delegação 
para definir uma função de carga que possa ser fornecida pela camada mapcadora. 

class 4istaDoDomínio... 

public void Carregar ( l 

1f (ÉFantasma) ( 
Marcarcarregando( ); 
BxecucarCazregador(this}; 
HarcarCarregado( 1; 

public delegate void carregador {ListaDoOomínio lista); 
public Carregador lb'.ecutarCarregador; 


um Re istro um Maeeador 

FonteDeDados 

Ma ea or de EmJ1regado banco de dados 

1 

Nome 

carregar 

. 1 
[EFantasma) Carregar(emp) 
Carregar(emp) 

IDataSource 1 

Mapeador(emp.ObterTipo) • 

1 
1 
SELECT ...

Carregar(emp) 

WHERE 1D = emp.Chave 

1 

•• carregar diversas propriedades 

Figura 11.5 A seqüência de carga de um fantasma. 

...tv 

... 


212 PARTE li • Os PADRÕES 

llist 

' \ 1

~ 

1 

' 

1 
1 

1 

1 

lista do Domínio 

e<delegate» 

1 

~ 

-

~ 

-

ExecutarCarregador Carregador(ListaOoOominio) 

/\. «delegate» Y Carregar 

l

domínio 

fonte de dados 

Carregador de Lista 

Sql: String 
Mápeador -• ParâmetrosSql: llist

-

1 +carregar (ListaDoDomínio) 

+ Anexar (ListaDoDomínio) 
Figura 11.6 Classes para uma lista fantasma. Como ainda não há um padrão aceito para 
mostrar delegação em modelos UML, esta é minha abordagem corrente. 

Pense em delegação como uma variedade especial de lntetfnce Sepnrndn (445) para 
uma única função. De fato, declarar uma interface com uma única função é uma 
alternativa razoável de fazer isso. 

O próprio carregador tem propriedades pttra especificar o SQL pMa a carga e o 
mapeador para usar para mapear os registros de tempo. O mapeador de empregados 
configura o carregador quando carrega o objeto empregado. 

class HapeadorDeElnpregado . .. 

void carregarRegistrosDeTempo (Eopregado ecrpregado) 
CarregadorDeLista carregador = new CartegadorDeLista( ); 

carregador.Sql ~ MapeadorDeRegistroDeTempo.SQL_BUSCAA_PEW_EMPREGADO; 

carregador.Parât:1etrosSql.Add(err.pregado.Chave); 
carregador.Mapeador = RegistroMapeador.Mapeador(typeof (RegistroDeTempo)J; 
carregador.Anexar((ListaDeDocúniol err.pregado.RegistrosDeT~ol; 

class carregadorDeLista.. . 

public String Sql; 
public IList ParâmetrosSql = new Al'rayL.ist( J: 
publ ic Mapeador l◄apeador; 


CAPITULO t 1 • PADRÕES COMPORTAMENTAIS OBJH0-RElACI0NAIS 213 

Já que a sintaxe par<1 atribuição de delegação é um pouco complicada, dei é\O 
carregador um método anexar. 

class carregadorDeLista. . . 

public void Anexar (LiscaDoDom!nio lista) 
lista.ExecutarCarregador = new ListaDoDomínio.Canegador(Carregar)f 

Quando o empregado é carregado, a coleção de registros de tempo permanece 
em um estõdo de fantasma até que um dos métodos de acesso dispare o carregador. 
Nesse momento, o carregador executa a consulta para preencher a lista. 

class CarregadorOeLista.. . 

public void Carregar (ListaDoDomínio listai 
lista.EstáCarregada = true; 
TDbCOC'.mand cor..m = new OleDbCof1'.mand ISql, DB.connection): 
éoreach (Object param in ParãmetrosSql) 

comm.Parameters.Add(ne~ OleDbParamecer(param.ToStringl 1, paramll1 
IDataReader leitor= C<lllllll.ExecuteReader( ); 
while (leitor.Readt )) { 

ObjetoDoDomínio obj =Pantas:ua?araLinha(leitorJ; 
Mapeador.CarregarLinha(leitor, obJl; 
lista.Adicionar (obj) ; 

leicor.Cl ose l I; 

private ObjetoDoDomínio FantasmaParaLinha ITDataReader leitor) \ 
retum Mapeador.BuscaAbstrata ( ISystem. Int32) leitor[Mapeador.llomeDaColunactiave)} ; 

Usar listas de fantasmas como essa é importante para reduzir a onda de cargas. 
Ela não a elimina completamente, já que há outros casos em que ela aparece. Nesse 
exemplo, um mapeamento mais sofisticado poderia carregar os dados do departamento 
em uma única consulta com os empregados. Entretanto, carregar sempre todos 
os elementos juntos em Ulna coleção ajuda a eliminar os piores casos. 


CAPÍTULO 1 2 

Padrões Estruturais 
Objeto-Relacionais 


CAPITULO 12 • PADRÕES ESTRUTURAIS Oaiero-RELACI0NAJS 215 

Campo Identidade (ldentity Field) 

Gunrdn o campo ID de w11 bnnco de dndos em um objeto pnra 111nnter n 
ide11lidnde c11treum objeto 11a memória euma li11ltndo bn11co de dndos. 

Pessoa 

id: long 

Os bancos de dados relacionais diferenciam uma linha de outra usando urna chaveem 
particular, a chiwe primária. Entretanto, objetos na memória não precisam de tal 
chave, já que o sistema de objetos, por trás dos panos, assegura a identidade correta 
(ou, no caso de C++, com posições de memória absolutas). Não há problemas para 
ler dados de um banco de dados, mas, para gravá-los de volta, você precisa vincular 

o banco de dados ao sistema de objetos em memória. 
Em essência, o Campo Identidade é muito simples. Tudo o que você faz é armazenar 
a chave primária da tabela do banco de dados relacional nos campos dos objetos. 

Como Funciona 

Embora a noção básica do Campo ldentidndeseja muito simples, há muitas questões 
complicadas que vêm à ton<\. 

Escolhendo a chave A primeira questão é que tipo de chave escolher no seu banco 
de dados. É claro que nem sempre esta escolhél se apresenta, visto que, muiti\s vezes, 
você está lidando com um banco de dados já existente que já tem suas estruturas de 
chaves estabelecidas. Há muita discussão e material sobre isso na comunidade de 
banco de dados. Ainda assim, o mapeamento para objetos adiciona algumas preocupações 
à sua decisão. 

A primeira preocupação é se devem ser usadas chaves com ou sem significado. 
Uma chave com significado é como o número do seguro social nos Estados Unidos 
para identificar uma pessoa. Uma chave sem significado é basicamente um número 
randômico que o banco de dados inventa e que não se destina ao uso de seres humanos. 
O perigo de uma chave com significado é que, embora em teoria elas sejam boas 
chaves, na prática não o são. Para simplesmente funcionar, as chaves precisam ser 
únicas. Para funcionar bem, elas precisam ser imutáveis. Ernbora os números atribuídos 
sejam supostamente únicos e imutáveis, erros humanos mui tas vezes fazem com 
que eles não sejnm nem urnél coisa nem outrn. Se você digitar errado trocando meu 
número do Seguro Social pelo da minha esposa, o registro resultante não é nem único 
e nem imutável (presumindo que você quisesse consertar o erro.) O banco de dados 
deve detectar o problema da unicidade, mas ele só pode fazer isso após meu registro 
ir para o sfatema e é claro que isso só poderia acontecer após o erro. Como conseqíiência, 
deve-se desconfia.r de chaves com significado. Para sistemas pequenos 
e/ou casos muito estáveis, você pode se sair bem. com o seu uso, mas, em geral, você 
deve tomar uma firme posição cm favor da falta de significado da chave. 

Apróxima preocupação são as chaves simples versus as chaves compostas. Uma 
chave simples usa apenas um campo do banco de dados. Uma chave composta usa 
mais de um. A vantagem de uma chave composta é que ela, freqüentemente, é mais 


216 PARlE li • Os PAORÕES 

fácil de usar quando uma tabela faz sentido no contexto de outra. Um bom exemplo 
são os pedidos e as linhas de itens, em que uma boa chave para a linha do item é uma 
chave composta pelo número do pedido e um número seqüencial que identifica a Jinha 
do pedido. Embom freqüentemente as chaves compostas façam sentido, há muito 
a ser dito sobre a maior tmHormidade das chaves simples. Se você usar as chaves 
simples em todo lugar, você pode usar o mesmo código para toda manipulação de 
chaves. As chaves compostas requerem tratamento especial em classes concretas. 
(Com geração de código, isso não é problema). As chaves compostas também carregam 
um pouco de significado, então, ao usá-las, seja cuidtldoso com a regm da unicidade 
e, especialmente, com a regra da imutabilidade. 

Você tem que escolher o tipo da chave. A operação mais comum que você fará 
com uma chave éo teste de igualdade, de modo que você quer um tipo com uma operação 
rápida de igualdade. A outra operação importante é a obtenção da próxima chave. 
Assim, um tipo inteiro longo é freqüentem.ente a melhor aposta. As strings também 
podem funcionar, mas a verificação de igualdade pode ser mais lenta, e incrementar 
strings é um pouco mais difícil. As preferências do OBA podem decidir a questão. 

(Cuidado com o uso de datas ou horas em chave. Elas não apenas têm significado 
como também levam a problemas de portabilidade e consistência. As datas são 
particularmente vulneráveis a isso, porque elas freq(ientemente são armazenadas 
para uma precisão de frações de segundos, que podem facilmente sair de sincronismo 
e levar a problemas de identidade.) 

Você pode ter chaves que são únicas na tabela ou em todo o banco de dados. 
Uma chave única na tabela é única nessa tabela, o que, afinal, é o núnimo que você 
precisa de uma chave. Uma chave única no banco de dados é únicr1 parn todéls as linhas 
de todas as tabelas do banco de dados. Uma chave t'.'uúca na tabela geralmente 
éboa, mas uma chave única no banco de dados é freqüentemente mais fácil de gerar 
e lhe permite usar um único Mnpn de ldentúinde {196). Com os valores modernos sendo 
o que são, é bastante improvável que você fique sem números para novas chaves. 
Se você realmente insistir, pode recuperar as chaves dos objetos excluídos com um 
roteiro simples no banco de dados que compacte o espaço das chaves -ainda que rodar 
este roteiro vã requerer que você tire a apJjcação do ar. Todavia, se você usar chaves 
de 64 bits (o que você deveria fazer), é improvável que você precise disso. 

Seja cauteloso com herança quando você usar chaves únicas por tabela. Se você 
estiver usando Hera11çn de Tabela Concreta (283) ou Hera11çn de Tabela de Classe (276), a 
vida fica muito mais fácil com chaves que sejam (micas na hierarquia em vez de únicas 
em cada tabela. Ainda uso o termo "única na tabela", ainda que, a rigor, isso deveria 
ser como "únictl no grafo da herança.'1 

O tam«nho da sua chRve pode afetar o desempenho, especialmente com índices. 
Isso depende do seu sistema de banco de dados e/ou de quantas linhas você 
tem, mas vale a pena fazer uma verificação por alto antes de tomar Luna decisão. 

Representando o Campo Ide1ttidade em um Objeto A forma mais simples de um 
Campo Identidade é um campo que corresponda ao tipo da chave no banco de dados. 
Assim, se você usar uma chave inteira simples, um campo inteiro funcionará muito 
bem. 

As chaves compostas são mais problemáticas. A meU1or aposta com elas é criar 
uma classe chave. Uma classe chave genérica pode armazenar uma seqüência de objetos 
que atuam como os elementos da chave. O comportamento chave para o objeto 
chave (tenho uma cota de trocadilhos por livro a preencher) é a igualdade. Também 
é útiJ pegar partes da chave quando você estiver mapeando para o banco de dados. 


CAPITULO 12 • PADRÕES ESTRUIUAAIS OSJET0-RElACI0NAIS 217 

Se você usar a mesma estrutura básica para todas as chaves, pode executar toda 
a manipulação de chaves cm uma Camndn S11pt!rtipo (444). Você pode colocar comportamento 
padrão, que funcionará para a maioria dos casos na Cnmndn Supertipo 
{444) e estendê-la para os casos excepcionais nos su,btipos particulares. 

Você pode ter uma única classe chave, que compreende uma lista genérica de 
objetos chave, ou uma classe chave para cada classe do domínio com campos explfcitos 
para cada parte da chave. Normalmente prefiro ser explicito, porém, neste caso, 
não estou certo de que compense tanto assim. Você acaba com muitas classes pequenas 
que não fazem nada interessante. O maior benefício é que você pode evitar os erros 
causados por usuários, colocando os elementos da chave na ocdem errnda, méls 
isso não parece ser um grande problema na prática. 

Se é provável que você vá importar dados de diferentes instâncias de bancos de 
dados, você precisa se lembrar que terí-l colisões de chaves a menos que tenha algum 
esquema para separar as chaves entre os difenmtes bancos de dados. Você pode resolver 
este problema com algum tipo de migração de chaves nas importações, mas 
isso pode facilmente se tornar confuso. 

Obtendo Uma Nova Chave Para criar um objeto, você precisará de uma chave. Isso 
parece ser uma questão simples, mas, muitas vezes, pode ser um problema considerável. 
Você tem três escolhas básicas: deixar o banco de dados gerá-la automaticamente, 
usar uma GUIO ou gerar a sua própria. 

Deixar o banco de dados gerar a chave deveria ser o caminho mais fácil. Cada 
vez que você insere dados no banco de dados, este gera uma chave primária única 
sem que você tenha de fazer nada. Parece bom demais para ser verdade, e, infelizmente, 
muitas vezes é. Nem todos os bancos de dados fazem isso da mesma maneira. 
Muitos dos que fazem lidam com isso de um modo que causa problemas para o 
mapeamento objeto-relacional. 

O método de geração automática mais comum é declarar um campo auto-gerado, 
o qual, toda vez que você inserir uma linha, é incrementado para um novo vAlor. 
O problema com este esquema é que você não consegue determinar facilmente qual 
valor foi criado para a chave. Se você quiser inserir um pedido e diversas linhas de 
itens, você precisa da chave do novo pedido de modo que você possa colocar o valor 
na chave estrangeira da linha do item. AléJn disso, você precisa desta chave antes 
que a transação seja confirmada, de modo que possa gravar tudo dentro da transação. 
lnfeliz1nente1 os bancos de dados normalmente não lhe dão esta informação, de 
modo que você geralmente não pode usar este tipo de geração automática em qualquer 
tabela na qual precise inserir objetos associados. 

Uma abordagem altemativa à geração automática é um contador do banco de 
dados, o qual o Oracle usa com a sua seqüência. Uma seqüência Oracle funciona enviando 
um comando select que referencia uma seqüência. O banco de dados então retorna 
um conjunto de registros SQL consistindo no próximo valor na seqüência. Você 
pode configurar o incremento de uma seqüência para qualquer valor inteiro, o que 
lhe permite obter diversas chaves de uma só vez. A pesquisa dél seqüência é automaticamente 
executada em uma transação separada, de forma que acessar a seqüência 
não bloqueará outras transações inserindo registros no banco ao mesmo tempo. Um 
contador do banco de dados como este é perfeito para nossas necessidades, mas não 
é padrão e não está disponível em todos os bancos de dados. 

Um GUIO (Identificador Globalmente Único) é urn número gerado em uma 
máquina que tem a garantia de ser {mico em todas as máquinas no espaço e no tempo. 
Muitas vezes plataformas lhe dão a APl pare\ gerar um GUTD. O algoritmo é in



218 PARTE li • Os PAORÕES 

teressante e envolve endereços de placõs ethernet, hora do dja em nanossegundos, 
números de identificação dos chips e provavelmente o número de fios de cabelo no 
seu pulso esquerdo. Tudo que importa é que o número resultante é completamente 
único e desse modo uma chave segura. A única dcsvanté\gem do GUIO é que a chave 
resultante é grande e isso pode ser igualmente um grande problema. Sempre há 
ocasiões em que alguém tem que digitar uma chtlve em uma janela ou expressão 
SQL, e chaves longas são difíceis tanto de digitar quanto de ler. Elas também podem 
levar a problemas de desempenho, especfalrnente com índices. 

A última opção é gerar a sua própria chave. Um mecanismo simples para sistemas 
pequenos é fazer uma varredura de tabela usando a função SQL max para encontr
«r a maior chave na tabela e então incrementá-la de uma unidade para usá-la. 
Infelizmente, essa leitura bloqueia a tabela inteira enquanto estiver sendo executada, 

o que significa que funciona bem se as inserções forem raras, mas seu desempenho 
será muito diminuído se você tiver inserções rodando concorrentemente com atualizações 
na mesma tabela. Você também tem que assegurar-se de que possui um completo 
isolamento entre as transações, caso contrário pode acabar com diversas transações 
obtendo o mesmo valor de TO. 
Uma abordagem melhor é usar uma tabela de chaves separada. Esta tabela tipicamente 
tem duas colunas: nome e próximo valor disponível. Se você usar chaves 
únicas no banco de dados, terá apenas uma linha nesta tabela. Se usar chaves ímicas 
por tabela, terá uma linha para cada tabela no banco de dados. Para usar esta tabela 
de chaves, tudo o que você precisa fazeré ler essa linha e anotar o número, íncrementa.
r o número e gravá-lo de volta na linha. Você pode pegar muitas chaves de uma só 
vez adicionando um número apropriado quando atualizar a tabela de chaves. Isso dimintú 
as custosas chamadas ao banco de dados e reduz a disputa na tabela de chaves. 

Se você usar uma tabela de chaves, é urna boa idéia projetá-la de modo que o 
acesso a ela esteja em uma transação separada daquela que atualiza a tabela na qual 
você esteja inser.indo. Digamos que eu esteja inserindo um pedido na tabela de pedidos. 
Para fazer isso, precisarei bloquear a linha da tabela de pedidos na tabela de chaves 
com um bloqueio de gravação Gá que estou atuaLizando). Esse bloqueio irã durar 
enquanto durar a transação na qual estou, bloqueando com is o qualquer outra pessoa 
que queira mna chave. Para chaves (inicas por tabela, isso significa qualquer pessoa 
inserindo na tabela de pedidos. Para chaves únicas no banco de dados, isso significa 
qualquer pessoa inserindo em qualquer lugar. 

Colocando o acesso à tabela de chaves em uma transação separada, você só blotJUCia 
a linha para essa transação, que é muito mais curta. O aspecto negativo é que, 
se você desfizer sua inserção na tabela de pedidos, a chave que você obteve da tabela 
de chaves fica percüda para todos. Felizmente números são baratos, então este não 
é um grande problema. Usar uma transação separada também lhe permite obter o ID 
assim que você cria o objeto na memória, o que mui tas vezes ocorre um pouco antes 
de você abrir a transação para confirmar a transação de negócio. 

Usar uma tabela de chaves afeta a escolha entre chave única por tabela ou por 
banco de dados. Se você usar uma chave única por tabela, tem que adicionar uma linha 
na t<1bela de chaves toda vez que acrescentar uma tabela no banco de dados. Isto 
é mais trabalhoso, porém reduz a disputa pela Linha. Se você mantiver seus acessos 
à tabela de chaves em uma transação separada, a disputa não é um problema tão 
grande, especialmente se você obtém árias chaves em uma única chamada. Todavia 
se você não conseguir fazer com que a ôtualização da ~bela de chaves fique em 
uma transação separada, você terá um forte argumento contra chaves (micas por 
banco de dados. 


CAPllUL0 12 • PADRÕES ESTRIJTURAIS Oaiero-RELACI0NAIS 219 

Ébomseparar o código para a obtenção de uma nova chave na sua própria classe, 
pois isso facilita a criação de um St11b de Serviço (469) para propósitos de testes. 

Quando Usá-lo 

Use um Campo ldentidade quando houver um mapeamento entre os objetos na memória 
e as linhasem um banco de dados. Isso ocorre normalmente quando você usa um 
Modelo de Domínio (126) ou um Gatewny de Unhas de Dados (158). Você não precisa deste 
mapeamento se estiver usando um Roteiro de Transação (120), um Módulo Tabela 

(134) ou um Gate-iJ.my de Tabela de Dados (151). 
Para um objeto pequeno com semântica de valor, como um objeto do tipo dinheiro 
ou uma faixa de datas que não terão sua própria tabela, é mefüor usar um Valor 
Embutido (261). Para um grafo complexo de objetos que não precise ser pesquisado 
dentro do banco de dados relacional, o LOB Serializndo (264) é normalmente mais 
fácil de escrever e apresenta um desempenho melhor. 

Uma alternativa ao Campo identidade é estender o Mnpn de Identidade (196) para 
manter a correspondência. Isso pode ser usado para sistemas no qual você não queira 
armazenar um Campo ldenlidade no objeto em memória. O Mapa de ldenlidade (196) 
precisa procurar em ambas as direções: dê-me a chave de um objeto ou o objeto correspondente 
a uma chave. Não costumo ver isso com muita freqüências porque geralmente 
é mais fácil armazenar a chave no objeto. 

Leitura Adicional 

[Marinescu) discute várias técnicas para a geração de chaves. 

Exemplo: Chave Integral (C#) 

A forma mais simples de um Campolde11tidade é um campo inteiro no banco de dados 
que mapeia para um campo inteiro em um objetona memória. 

class ObjetoDoDonúnio... 

public const long PROCURAOOR_lD = -1; 
public long Id = PROCURAOOR_!D; 
public Boolean éNovo( ) {return !d== PROCURADOR_ID;} 

Um objeto que tenha sido criado na memória mas que não tenha sido salvo no 
banco de dados não terá um valor para a sua chave. Para um objeto .NET este valor 
é um problema, uma vez que valores .NET não podem ser nulos. Eis por que o valor 
do procurador. 

A chave se torna importante em dois locais: na busca e na inserção. Para uma 
busca você precisa formar uma consulta usando uma chave na cláusula WHERE. Em 
.NET você pode carregar muitas linhas em um conjunto de dados e então selecionar 
uma delas emparticular com uma operação de busca. 

class MapeadorOeJogadorDeCrSquete... 

public Jogadoroecríquete Bua,car (long id} 
return (JogadorDeCriquete) BuscaAbstrata(id); 


220 PARTE li • Os PADRÕES 

class Hapeador... 

protecteô ObjetoDoDooúnio BuscaAbstrata (long idl 
DataRow linha: BuscarLinha Cid); 
return (linha=~ null) ? null: Buscar(linha); 

} 

protected DataRow BuscarLinha (long id) ( 
String filtro= String.Format (•id = (o}•, id) ; 
DataRow[ 1 resultados= tabela.Selectlfiltro); 
return {resultados.Length ~= O) ? null: resultados{Ol; 

} 

public ObjetoDoDomínio Buscar (DataRow linha) 1 
ObjetoDoDomínío resultado= CriarObjetoDo!lominío( li 
Carregarlresultado, linha); 
return resultado; 

abstract protecteã ObjetoDoDorllínio CriarObjetoDoDomínio( ); 

A maior parte desse comportamento pode ficar na Camada Superfipo (444), mas 
freqüentemente você terá de definir o método de busca na classe concreta apenas para 
encapsular o downcasf. É claro que você pode evitar isso em uma linguagem que 
não use a ti pagem em tempo de compilação. 

Com um simples Campo Identidade inteiro, o comportamento de inserção também 
pode ser armazenado na Camada Supertipo (444). 

class Mapeador ... 

public virtual ong Inserir (ObjetoDoOoaúnio af9) 
DataRO'il linha ~ tabela. Nell'RO~ ( 1; 
ar9.Id = lerPrôximoID( ) ; 
linha('id'I : arg.Idi 
Gravar (arg, linhal; 
tabela.Rows.Md(linhal; 
return arg. Id; 

Essencialmente, a inserção envolve a criação de tuna nova linha e o uso da próxima 
chave nela. Assim que você a tiver, você pode gravar os dados do objeto localizado 
na memória nessa nova linha. 

Exemplo: Usando uma Tabela de Chaves (Java) 

por Mal t Foemmel e Martin Fowler 

Se o seu banco de dados suportar t.tm contador e você não estiver preocupado com o 
fato de ficar dependente de um SQL espeófico de um determim1do banco de dados, 
deve usar o contador. Mesmo se você estiver preocupado com o fato de ficar dependente 
de um banco de dados, ainda assim você deve considerá-lo -desde que o seu 
código de geração de chaves esteja bem encapsulado, você sempre poderá alterá-lo 
para um algoritmo portável mais tarde. Você pode até mesmo ter uma estratégia 
[Gang ofFour] para usar contadores quando você os tiver e fazer os seus próprios em 
caso contrário. 


CAPITULO 1 2 • PADRÕES ESTRUTURAIS Oruero-RElACIONAIS 221 

Por enquanto, vamos supor que temos que fazer isso do modo cti(ícil. A primeira 
coisa de quc precisamos é uma tabela de chaves no banco de dados. 

CRRATE TABLE chaves (nome varchar primary key, próximolD int) 
INSERT nrro chaves 1'pedidos', l) 

Esta tabela contém uma linha para cada contador no banco de dados. Neste caso 
inicializamos a chave com 1. Se você estiver pré-carregando dados no banco de 
dados, precisará configurar o contador para um m1mero apropriado. Se você quiser 
chaves únicas para todo o banco de dados, precisará de apenas uma linha. Se quiser 
chaves (1nicas por tabela, precisará de uma linha por tabela. 

Você pode encapsular todo o seu código de geração de chaves na sua própria 
classe. Dessa rnaneira é mais fácil usá-lo mais exten samente em uma ou mais aplicações, 
e é mais fácil colocar a reserva de chave na sua própria transação. 

Construímos um gerador de chaves com sua própria conexão de banco de dados, 
juntamente com a informação sobre quantas chaves pegar do banco de dados de 
cada vez. 

class GeradorDeChaves ... 

private Connection con; 

private String nomeDaChave; 

pri11ate long pr6ximo!d; 

private long l.'láximord; 

private int incrementarPor; 

public GeradorDeChaves (Conneccion con, String nOlf~DaChave, int incremencarPor) { 

this.con = con; 

this.nomeDaChave: norceOaChave; 

this.incrementarPor = increment3rPor; 

próxiCIOld = máximold = O; 

try l 

conn.setAutOCottnit(falsel; 

} catch (SQLException exc) ( 

throw ne~ ApplicationExoeption (•Incapaz de desl:9ar a confirmação 

autOl".átíca•, excl; 

Precisamos assegurar que nenhuma confirmação automática está acontecendo, 
já que é fundamental ter a seleção e a atualização operando em uma mesma 
transação. 

Quando pedimos uma nova chave, o gerador verifica se existe uma em cache 
uma vez de ir ao banco de dados. 

class GeradorDeChaves .. , 

public synchronized Long pr6ximaChave I l 1 
ii (próximold = máxioold) { 
reservarids( ) ; 

return new LOng(próx.irr.otd-T); 


222 PARTE li • Os PAORÕES 

Se o gerador não tiver uma chave em cache, ele precisa ir ao banco de dados. 

class Gerador!leChaves ... 

private void reservar!ds( ) 
PreparedStaternent dec = null; 
ResultSet rs = null; 
long prõximolóNovo; 
try ( 

dec = con.prepareStatement{"SBLECT pr6ximoid FROM chaves WlffiRE nome=? 
FOR UPDATE"); 
dec.setString(l, nomeoaChaveJ; 
rs = dec.executeQuery( ) ; 
rs.next () ; 
próximoldNovo= rs.getLong (l); 

catch (SQLException excl ( 
thro~ new ApplicationException ('Incapaz de gerar iàs•, exc): 

) 

:i.nal!y { 
DB.cleanUp(dec, rs); 

long rnáximoidNovo ~ prõx:irnoidtlovo + incrementarPor; 
dec : null; 
try { 

dec = con.prepareStatement(•UPDATE chave.s SE:r próximo!d =? WHBRE nome=?•); 
dec.setl..-Ong(l, máximoidNovo); 
dec.setString(2, nomeDaChave); 
dec.executeUpdate () ; 
conn.cor.mit( ) ; 
próximold = próxi100ld?lovo; 
máxioold = máximoidNovo; 

) 

catch (SQLEx~eption excl l 
throw r.ew ApplicationException(•Incapaz de gerar ids•, exc); 

} 

finally ( 
D8.cleanUp(dec); 

Nesse caso, usamos SELBCT . . . FOR UPDATE para djzer ao banco de dados para 
manter um bloqueio de gravação sobre a tabela de chaves. Este é um comando específico 
do Orade, de modo que sua milhagem irá variar se você estiver usando algo 
diferente. Se você não puder efetuar um bloqueio de gravação no SELECT, corre o risco 
da transação falhar se outra pessoa chegar lá antes de você. Nesse caso, contudo, 
você pode executar novamente reserva1'/ds com segurança, até que você obtenha um 
conjunto imaculado de chaves. 

Exemplo: Usando uma Chave Composta {Java) 

Usar uma chave inteira simples é uma solução boa e simples, porém muitas vezes 
você precisa de chaves de outros tipos ou de chaves compostas. 


CAPITULO 12 • PADRÕES E5TRUTUAAIS OBJETO-RELACIONAIS 223 

Uma Classe Chave Assim que você precisar de algo a mais, vale a pena criar uma 
classe chave. Uma classe cl1ave precisa ser capaz de armazenar múltiplos elementos 
da chave e ser capRz de dizer se duas chiwes são iguais. 

class Chave .. . 

private Object[ l campos; 

public boolean éigual (Object obj) ( 
if (! (obj instanceof Chave)) return false; 
Chave outraChave = (Chave) obj; 
if (this.campos.length !~ outraChave.campos.length) return fal9e; 
Eor (ínt i =O; i< campos.length; i+~) 

if{l this.camposlil .equalsloutraChave.campos(ill) return false; 
return true; 

O modo mais elementar de criar urna d,ave é com um array de parâmetros. 

class Chave... 

public Chave (Object[ 1campos) { 
verificarCha\ieNãoNula (call\pos) ; 
thís.cattp0s = ca~pos; 

privat~ void verificarChaveNàoNula (Object[ l campos) { 
iÍ (campos== null) throw new IllegalArgucentRxception("Nào pode haver uma chave nula"}; 
for ( inc i = O; i< carpos.length; i+t ) 

if (campos[il == null) 
throw new IllegalArgumentBxceptionl"Nào pode haver um elemento nulo na chaven) ; 

Se você descobrir que freqüentemente cria chaves com certos elementos, você 
pode acrescentar construtores convenientes. Exatamente quais construlorcs devem 
ser criados, vai depender dos tipos de chaves que sua aplicação possui. 

class Chave... 

public Chave (long arg) { 
this.campos =new Object(l]; 
this.cattpos{O} = ne~ Long(arg); 

} 

public Chave (Object campo) { 
if (campo== nulll thrO'~ new IllegalArgumentException("Não pode haver uma chave nula•); 
this.campos =new Ohject(l); 
this.caropos(OJ = campo; 

public Chave (Object argl, Object arg2) 
this.campos = new Object(2); 
this.campos[OJ = argl; 
this.campos{l ) =arg2; 
veríficarchaveNãoNula (ca~pos); 

Não tenha receio de adicionar esses métodos por conveniência. Afinal de contas, 
conveniência é importante para todos que usam as chaves. 


224 PARTE li • Os PAORÕES 

De modo similar, você pode adicionar métodos de acesso para ler partes das 
chaves. A aplicação precisará disso para os mapeamentos. 

chss Chave... 

public Object valor (int il 
return campos(il; 

public Object valor ( 1 
verificarSeÉChaveSimples ( ): 
return camposlO} ; 

private void verificarSeÉChaveSimples 11 { 
if (campos.length > ll 
thro~ new IllegalStateException(•Nâo posso pegar o valor de uma chave composta•); 

} 

public long valorLongol 1 { 
verificarSeÉChaveSimples( ): 
return valorLongo(Ol; 

} 

public long valorLongolint ill 
if (! (campos(il instanceof Long) 
throw ne~ IllegalStateRxcepticn(•Não posso usar valorLongo sobre Ull'4 chave que não seja do 

tipo long•); 
return {(Long) carr.pos [i)).longValue( ) ; 

Neste exemplo mapearemos para uma tabela de pedidos e uma de linhas de 
itens. A tabela de pedidos tem wna chave primária inteira simples, a chave primária 
da tabe]a de linhas de itens é uma chave composta pela chave primária da tabela de 
pedidos e um número seqüencial. 

CREATB TABLE pedidos (ID int pri~4ry key, cliente varchar) 
CREATE TABLE linhas_itens (idDoPedido int, seg int, quantia int, produto varchar, 
pri~ary key (iclDoPedido, seq)) 

A Cnmndn S11pertipo (475) para objetos do domínio precisa ter um campo chave. 

class ObjetoDoDominioCor.iChave ... 

private Chave chave; 
protected ObjetoDoDo!rinioComChave (Chave ID) 

t hi s.chave ~ ID; 
} 

protected ObjetoDoDonúnioComChave() 

} 

public Chave lerChave( )( 
retum chave; 

public void 9ravarChave (Chave chave) 1 
this.chavt = chave; 


ÚPIT\.ILO 1 2 • PADRÕES ESTRUTURAIS OSJE"T0-RHACI0NAIS 225 

Lendo Assim como em outros exemplos neste livro, dividi o comportamento em 
busca (que chega à linha correta no banco de dados) e carregar (que carrega dados 
dessa linha para o objeto do domínio). Ambas as responsabilidades si\o afetadas pelo 
uso de um objeto chave. 

A diferença principal entre estes e os outros exemplos neste livro (que usam chaves 
inteiras simples) é que temos que fatorar certas partes do comportamento que são 
sobrescritas por classes que têm chaves mais complexas. Neste exemplo, pressuponho 
que a maioria das tabelas usa chaves inteiras simples. Entretanto, algumas usam 
algo mais, de modo que tornei padrão o caso do inteiro simples e embuti o comportamento 
para isso no mapeador Cnmndn S11pertipo (444). A classe dos pedidos é um 
desses casos simples. Aqui está o código para o comport(lmento de busca: 

class MapeadorDePedido.,. 

public Pedido buscar (Chave chave) 

return (Pedido) buscaAbstrata(chave); 

) 

public Pedido buscar(Long id) { 

retum buscar (new Chavefid) l ; 

protected String stringDoComandoDeBusca 1 1 { 
return ºSELECT id, cliente FROM peôidos ilHBRE id: ?º; 

class MapeaàorAbstrato... 

abstract protected String stringDoCo,-:iandoDeBusca ( I; 

protecced Map 11'.apaCarregado : new HashMap( ) ; 

public ObjetoDoDomínioComChave buscaAbstrata (Chave chave) 

ObjetoDoOomínioCorr.Chave resultado: {ObjetoDoOominioComChave) mapaCarregaâo.get {chave); 

if (resultado!~ null ) return resultado; 

ResultSet rs = null; 

PreparedStateitent c-00.andoDeBusca = nul!: 

try ( 

comandoDeBusca = DB.prepareístringDoComandoDeBusca ( >I; 

carregarComandoDeBusca(chave, comandoDeBusca}; 

rs = comandoDeBusca.executeQuery ( 1; 

rs.next() ; 

if (rs.isAfterLast { ) 1 return null; 

resultado= carregar(rs); 

recuro resultado; 

} catch (SQLRxceptíon e) ( 

throw ne~ ApplicationException (e) ; 

) finally { 

DB.cleanUp(cOll'JndoDeBusca, rs) ; 

// método gancho para chaves que não sejam inteiros sirr.ples 

protecced void carregarComandoDeBusca {Chave chave, PreparedState~ent buscador) 

throws SQLBxcepticn { 

buscador.secLong(l, chave.valorLongo( )); 


226 PARTE li • Os PADRÕES 

Extraí a construção do comando de busca, já que isso requer que p(lrãmetros diferentes 
sejam passados para o comando preparado. A linha de item é uma chave 
composta, então ela precisa sobrescrever esse método. 

class MapeadorDeLínhaDeicero.. . 

public LinhaOeitem buscar (long idDoPedido, long seql { 
Chave chave : new Chave (new Long(idDoPedido) , new Long(seq)) ; 
retum (LinhaDeltem) busca.Abstrata (chave); 

} 

public LinhaDeitem buscar (Chave chave) { 

retorn (LiohaDelte~) busca.Abstrata (chave); 
} 
public String stringoocomandoDeBusca ( 1 ( 

retorn 
~sBLECT idDoPedido, seq, quantia, produto ~i 

• FROM linhas_itens •+ 
• WllERE (id.DoPedido = ?> l\llO (seq = ?) ~; 
// ~étodos gancho sobrescritos para a chave composta 

protected void carregartomandoDeBusca !Chave chave, PreparedStaterient buscador} cbro~s SQLExceptíon { 
buscador.setLong (l, idDoPedido(chave)l; 
buscador.secLong (Z, númeroDaSeqúência(chave)t: 

// métodos auxiliares para extrair valores apropriados âa chave da linha de item 
privace static long idDoPedido (Chave chave) ( 
retum chave.longValue(O); 

private static long nútlleroDaSeqüêncta (Chave chave) 
return chave.lon9Value {li; 

Além de definir a interface para os métodos de busca e fornecer uma string SQL 
para o comando de busca, a subclasse precisa sobrescrever o método gancho para 
permitir a inclusão de dois parâmetros no com(lndo SQL. Também escrevi dois métodos 
auxiliares para extrair os pedaços da informação da chave. Isso cria código 
mais claro do que aquele que eu obteria apenas colocando métodos explícitos de 
acesso com índices numéricos da chave. Esses índices literais cheiram a problemas. 

O comportamento de carga mostra uma estrutura semelhante -o comportamento 
padrão na Cn111adn S11pertipo (444) para chaves inteiras simples, sobrescrito para 
os casos mais complexos. Neste caso, o comportamento da carga do pedido se parece 
com: 

class WapeadorAbstrato... 

protected ObjetoOODominioComChave carregar (ResultSet ts) thro'tS SQLException ( 
Chave chave= criarChave(rs); 
i! (mapaC..rregaâo.containsKey(chavel) return (ObjetoDoDocnín1oCocnChave) 
mapaC..rregado.get (chave); 
ObjetoOoDOl!ínioComChave resultado : fazert'arga (chave, rsl ; 
niapaCarregado.put (chave, resultado) : 
return resultado; 

abstract protected ObjetoDoOOr.únioCOIIChave fazerC..rga (Chave id, ResulcSet rsl th.rows SQL5xception; 


CAPÍTULO 12 • PADRÕES ESTRUTURAIS O8JH0-RELACI0NAIS 227 

// método gancho para chaves que não sejar:i inteiros síttples 
protected Chave criarC"nave (ResultSet rs) throws SQLException { 
return new Chave (rs.getLong(l) l; 

class ~.apeadorDePedido... 

protected ObjetoDoDomínioComChave faierCarga (Chave chave, ResultSet rsl 

throws SQLEXception { 
String usuário= rs.getString(•usuário•) ; 
Pedido resultado= new Pedido(chave, usuário); 
RegistoMapeador. linhaDeitem( ) .carregarTodas1's1inhasDeitemDo (resultado): 
return resultado; 

A linha de i tem precisa sobrescrever o método gancho para criar uma chave baseada 
em dois campos. 

class 14apeadorDeLinhaDeltem... 

protected ObjetoDoDominiOComChave fazerCarga (Chave chave, ResultSet rsl throws SQLException { 
Pedido oPedido = RegistroMapeador.pedidol ).busca(idDoPedido(chave)I: 
return fazerCarga (chave, rs, oPedido); 

protected ObjetoDoDom1niOCOl'IIChave fazerCarga (Chave chave, ResultSet rs, Pedido pedido) 
throws SQLBxceptíon 

LinhaDeltem resultado; 
int quantia= rs.getlnt(•quantia"); 
String produto • rs.getString(•produto•); 
resultado= new LinhaDeitem(chave, quantia, produto) ; 
pedido.adicionarLinhaDeitem(resultado); //conecta ao pedido 
return resultado; 

//sobrescreve o caso padrão 

protected Chave criarChave (ResultSet rsl throws SQLException { 
Chave chave= new Chave (new Long(rs.9ecLo119("idDoPedido•)), new Lons(rs.gecLong(•seq'))); 
return chave; 

A linha de item também tem um método de carga separado parn usar quando 
estiver carregando todas as linhas do pedido. 

class HapeadorDeLinhaDeitem. . . 

public void carregar1'odasAsLinhasDeltem.Do (Pedido arg) { 
PreparedStatement ôec = null; 
ResultSet rs: null; 
try { 

dec = DB.prepare (stringDaBuscaDoPedido); 
dec.setLong(l, arg.lerChave( ).longvalue( )I; 
rs = dec.executeQuery( ); 
while (rs .next l )) 

carregar(rs, arg); 
) catch (SQLException e) 1 
throw nen ApplicationException lei ; 


228 PARTE li • Os PAORÕES 

j finally {DB.cleanup(dec, rsl: 
} 

private final static String stringDaBuscaDoPedido = 
*SELECT idDoPedido, seq, quantia, proàuto • • 

•rR0!4 linhas itens•+ 
•ifflBRE idDoPeóido = ?"; 
protected ObJetoDoDornínioComChave carregar (ResultSet rs, Pedido peôido) throws SQLRxception 1 
Chave chave = criarChave(rsl: 
if (r..apaCarregado.containsKey (chave)) return (ObjecoDcO:>r.únioCor.l'have) QclpaCarregado.9ec(chave); 
ObjetoDoOominiOCocChave resultado= fazerCarga(chave, rs, pedido); 
mapaCarregado.put(chave, resultado); 
return resultado; 

Você precisa do tratamento especial porque o objeto Pedido só é colocado no 
Mnpa de Identidade (196) do pedido depois de criado. Criar um objeto vazio e inseri· 
lo diretamente no Campo Identidade evitaria a necessidade d.isso (págiria 173•174). 

Inserção Assim como a leitura, a inserção tem uma ação padrão para uma chave in· 
teira simples e os ganchos para serem sobrescritos para chaves mais iriteressantes. 
No supertipo do mapcador forneci uma operação para atuar como a interface, junto 
com um método modelo para executar o trabalho da inserção. 

class MapeadorAbstrato ... 

public Chave inserir (ObjeloDoD<x:tínioCOCl.Chave sujeito) 
try { 
return executarinserçào(sujeito, objetoBuscarPr6xiQ.aChaveNoBancoDeDados( )); 
) catch (SOLException e) { 
thro~ new ApplicationException(el; 

} 

protected Chave e-xecutarloserçào (Ohjetoi»r.o:ninioCoo.Chave sujeito, Chave cha,·el ::brows SQLException { 
sujeito.gravarChave(chave); 
PreparedStatement dec = DB.prepare(scringDoComandoDelnserção( )}; 
inserirChave (sujeito, decl; 
1oserirDados(sujeito, dec); 
dec.execute( ); 
mapacarresado.put(sujeito.lerchave( ). sujeito): 
retum sujeito.lerChave( li; 

abscract protected String stringDoCo:nandoDelnserçâo( 1: 

class MapeadorDePedido ... 

protected String stringDoComandoDeinserçào () 
retum 'lNSERT 1NTO pedidos VALUES (?1 ?) • ; 

Os dados do objeto vão para o comando i11sert por meio de dois métodos que 
separam os dados d<1 chave dos dados básicos do objeto. Faço isso porque posso fornecer 
mna implementação padrão para a chave que funcionará pai-a qualquer classe, 
tal como Pedido, que usa a chave inteira simples padrão. 


CAPiTUL0 12 • PADRÕES ESTRUTURAIS OaJET0-RE:lACI0NAIS 229 

class MapeadorAbstrato ... 

protecced void inserirchave (ObjetoDoDor.\inioCom.Chave sujeito, PrepareàStatement dec) 
throi.•s SQLExceptíon 

dec.setLong(l, sujeito.lerCnavel) .lonqValue( )); 

O resto dos dados para o comando i11sert é dependente da subclasse em particular, 
então este comportamento é abstrato na superclasse. 

class NapeadorAbstrato.. . 

abstract protected vos inserirDados (ObjetoDoDomínioComChave sujeito, PreparedStatement dec) 
throws SOLExceptíon; 

class MapeadorOePedido... 

protected void ínseritllados (ObjetoDoDo0ín10Cor.tChave sujeitoAbstrato, PrepareáStatement dec) 
thrO',s SQLBxceptíon ( 

try ( 
Pedido sujeito= (Pedido) sujeitoAbstrato; 
dec.setString(2, sujeito.lerCliente( li; 

) catch (SQLException e) 1 
throw new ApplicationException(e); 

A linha de item sobrescreve esses dois métodos. Ela extraj dois vAlores para a 
chave. 

class 1-!apeadorOeLinhaOeltem... 

protected String stringDoComandoOe!nserção () 
return *INSBRT INTO linhas_itens VALUBS {?, ?, ?, ?)•; 

protecced void inserirChave (ObjecoDolminioCooehave sujeito, PreparedStatement dec) 
throws SQLException 

dec.setL.ong (l, idDoPedido(sujeito.lerChave( li); 
dec.setLong(2, númeroDaSeqüência(sujeito.1erChave( ))): 

Ela também fornece sua própria implementação do comando insert para o res~ 
to dos dados. 

class MapeadorDeLinhaDeitem... 

protected void inserirDados (ObjecoDoDoc:linioC.ooehave sujeito, PreparedStatement dec) 
throws SQLBxception 

LinhaDeitem ite~ = (LinhaOeiteml suJe1to; 
dec.setlnt (3, item.lerQuantia( )) ; 
dec.setlnt (4, item.lerProduto( >l; 


230 PARTE li • Os PADRÕES 

Colocar a cargê'I dos dados no comando insere só vale a pena se a maior parte 
das classes usarem o mesmo campo simples como chave. Se houver mais variação na 
manipulação de chaves, então ter apenas um comando para inserir A informação é 
provavelmente mais fácil. 

Gerar a próxima chave do banco de dados também é algo que eu posso separar 
em um caso padrão e um sobrescrito. Para o caso padrão posso usar o esquema da tabela 
de chaves do qual falei anteriormente. Todavia, para a linha de item nos deparamos 
com um problema. A chave da linha de item usa a chave do pedido como parte 
de sua dtave composta. Entretanto, não existe uma referência da classe linha de 
item para a classe pedido, de modo que é impossível mandar uma linha de item inserir 
a si mesma nobanco de dados sem fornecer também o pecLido correto. Isso leva 
à sempre confusa abordagem de implementar o método na superclasse com luna exceção 
de operação não suportada. 

class MapeadorDeLinhaDeitem... 

pUblic Chave inserir (ObjetoDoDo:ninioComChave sujeito) 
throw new UnsupportedOperalionException 
<•Deve fornecer um pedido ao inserir U.'lla linha de item"); 

) 

public Chave inserir (LinhaDeitem item, Pedido pedido) ( 

try ( 
Chave chave: new Chave(peoido.lerchave( ),value( l, ler?róximonúmeroDaSeqüência(pedido) ); 
retum executarlnserçào(itE!lll, chave); 

) catch (SQLBxception e) l 
th.row new ApplicationException(e): 

É claro que podemos evitar isso tendo uma conexão de retorno da linha de item 
para o pedido, tornando assim, efetivamente, a associação entre as duas classes bidirecional. 
Decidi não fazer isso aqui para ilustrar o que fuzer quando você não temessa 
conexão. 

Fornecendo o pedido, é fácil obter da chave a parte referente ao pedido. O próximo 
problema é obter umnúmero seqüencial para a linha do pecLido. Para encontrai· 
esse número, precisamos descobrir qual é o próximo número seqüencial disponível 
para um pedido, o que podemos fazer tanto com uma consulta em SQL usando max 
ou olllando as linhas de pedido dos pedidos em memória. Para este exemplo, usarei 
esta segunda opção. 

class MapeadorDeLinhaDeitem... 

private Lon9 lerPr6ximoNúceroDaSeqüência (Pedido pedido) 
carregarTodasAsLinhasDeitemDo (pedido); 
Iterator it = pediào.lerltens( l .iterator( ); 
LinhaOelte~ candidata= ILinhaDelte~) it.next( ); 
while (it.hasNext ( )) { 

~inhaDeltera esteltera = (LinhaDeiteQ) it.nextl ); 
if (esteltem.lerCllave( ) :: null) continue; 
if (númeroDaSeqüência(esteicem) > númeroDaSeqüência(candidaca)J candidata: escercem; 

} 
return new Long(núr:eroDaSeqüência(caooidata) , l); 


CAPÍTULO 12 • PADRÕES ESTRUTURAIS O8JH0-RELACIONAIS 231 

private static long nú:ieroDaSeguência (LinhaDeltem li) 
return númeroDaSeqüência !li.lerC'navel )) ; 

//o comparador não funciona bem aqui devido a chaves nulas não gravadas 
protected String linhaDaTabelaDeChaves () { 
throw new UnsupportedôperationBxception( ); 

Esse algoritmo seria muito melhor se eu usasse o método Collections.max, mas 
uma vez que podemos (e de fato iremos) ter pelo menos uma chave nula, esse método 
falharia. 

Atualizações e Exclusões Após tudo isso, atualizações e exclusões são praticamente 
inofensivas. Mais uma vez, temos métodos abstratos para o suposto caso costumeiro 
e métodos sobrescritos para os casos especiais. 

As atualizações funcionam desta forma: 

class ~!apeadorAbstrato .. 

public void atualizar (ObjetoDoDomínioC.omC'nave sujeito) 
PreparedState~.ent õec = nul1; 
try { 

dec = DB.prepare(stringoocomandoDeAtualizaç3o( )) ; 
carregarCón'.andoDeAtualizaçào(sujeito, dec); 
dec.executel ); 

] catch (SQLException e) 1 
throw new ApplicatíonException(el; 
} finally { 
DB.cleanUpldec); 

abstract protected String strin9DoC001andoDeAtualizaçãol l ; 
abstract protected !J'Oid carregarCO!lli3ndoDeAtualização(ObjetoDoDomínioCotnChave sujeito, 
PreparedStatement dec) 
throws SQLBxception; 

class MapeadorDePedido... 

protected ·roid carregarComandoDeAtualização (ObjetoDo[))QúúOComChave sujeito, PrepareàStatement àec) 
throws SQLException 

Pedido pedido; (Pedidol sujeito; 
dec.setString(l, pedido.lerCliente( )) ; 
dec.secl.ong (2, pedido.lerChave ( ) .longValue ( )) ; 

protected String stringDoComandoDeAtualizaçào () { 
return "UPDATB pedidos ssr cliente:? WHERE id : ?"1 

class MapeadorOeLinhaDeitem.. . 

protected String stringDoComandoDeAtualizaçào () { 
recurn 

•uPDATE linhas itens• + 
• SET quantia -: ? , produto :, '? • • 
• WHBRE idDoPedido : ? ANO seg " ?•; 

232 PARTE li • Os PADRÕES 

protected void carregarcomandoDeAtualização (ObjetôDODoc:linio"...oa.chave sujeito, PreparedStatement óec) 
throws SQLException 

dec.setLong(J, idDoPedidolsujeico.lerCilave( )); 
dec.setLong (4, n6meroDaSeqüência (sujeico.lerChave{ )) 1 
LinhaDelte~ li: (LinhaDeitem) sujeito: 
dec.setlnt(l, li.leIQuantía( )); 
dec.setString(2, li.lerProduco( )); 

As exclusões funcionam assim: 

class NapeadorAbstrato... 

public void excluir(ObjetoDoDomínioCcxnChave sujeito) 
PreparedStatemeot dec =null; 
try 1 

dec = DB.prepare(str~ngDoCocnandoDeExclusão( )) : 
carregarComandoDeExclusão(sujeito, dec); 
dec.executel ); 

} cacch (SQLBxception e) { 
thro:.o ne•11 ApplicationExceptíon (e) ; 
) f inally l 
DB.cleanUp(dec); 

abstract protected String stringDoCo:nandoDeExclusão( I; 
protected void carregarCor.andoíleE:xclusão(OojetoDoDomínioC01tChave sujeito, PreparedStaternent dec) 
throi.·s SOLException 

dec.setLong(l, sujeit.o.lerCl'lavet l .longValue( )1 : 

class MapeadorOePedidos. .. 

protecteà String stringDoComandoDeExclusão () 
return ºDELETE FROM pedidos l'!liERE id = ?•; 

class NapeadorDeLinhaDeltem. . . 

protected String stringDoComandoDeExclusão () 
return •DELrn FRO:~ linhas_itens WHERE idDoPedido =? MID seq = ? .. ; 

protected void carregarCor.iandoOeBxclusào(ObjetoDoDocníniOCoroChave sujeito, Prepare<lState:nent dec) 
thr~s SQLException 

dec.setLong(l, idDoPeõidolsujeito.l erChave{ ))); 
dec.setLong(2, númeroDaSequêncialsujeico.lerChave{ ))); 


CAPÍTULO 12 • PADRÕES ESTRUTURAIS OBJETO-RELACIONAIS 233 

Mapeamento de Chave Estrangeira (Foreign Key Mapping) 

Mapein uma nssocínção eutre objetos pnrn uma 
referê11cin de chave estrangeira entre tabelas. 

Álbum 1-Artista 
-
título: String * nome: String 

«1abela» (<tabela» 

Álbuns Artistas 

1D: int 

10: int
título: varchar 

nome: varchar 

idDoArtista: int 

Os objetos podem se referir uns aos outros diretamente por meio de referências. Mes,mo 
o sjstema orientado a objetos mais simples conterá um pequeno grupo de objetos 
conectados entre si por todos os tipos de meios interessantes. Para gravar esses objetos 
em um banco de dados, é vital gravar essas referências. Contudo, já que os dados 
das referências são específicos à instância pMticufar do programa sendo executado, 
você não pode simpJesmente grnvar os valores de dados em estado bruto. Outra 
complicação é o foto de que os objetos podem facilmente possuir coleções de referências 
para ouh·os objetos. Tal estrutura viola a primeira forma normal dos bancos de 
dados1·elacionais. 

Um Mnpeame11to de Chave Estrangeira mapeia uma referência a um objeto como 
Llllla chave estrangeira no banco de dados. 

Como Funciona 

A chave óbvia para esse problema é o Cnmpo ldentidnrle (215). Cada objeto contém a 
chave do banco de dados da tabela do banco de dados apropriada. Se dojs objetos 
são conectados com uma associação, esta associação pode ser substituída por uma 
chave estrangeira no banco de dados. Colocado de forma simples, quando você salvar 
umálbum no banco de dados, você grava o ID do artista ao qual o álbum está associado 
no registro do álbum, como na Figura 12.1. 

Esse é o caso simples. Um caso mais complicado surge quando você tem uma 
coleção de objetos. Você não pode gravar uma coleção no banco de dados, então você 
tem que inverter a direção da referência. Assim, se você tiver uma coleção de faixas 
no álbum, você coloca a chave estrangeira do álbum no registro da faixa, como 
nas Figuras 12.2 e 12.3. A complicação acontece quando você tem uma atualização. 
Atualizações significam que faixas podem ser acrescentadas ou removidas da coleção 
de um álbum. Como você pode saber quais alterações colocar no banco de dados? 
Basicamente, você tem três opções: (1) exduir e inseri,·, (2) adicionar um ponteiro 
reverso e (3) diferenciar a coleção. 


234 PARTE li • Os PAORÕES 

:Álbum 

10 = 1234 
titulo ="Kind of Blue• 

«tabela» 
: linha de Álbuns 

ID = 1234 
idDoArtista = 5678 
título = "Kind of Blue• 

~ 

-

,. 

10 = 5678 
nome = 'Miles Davis" 

«tabela» 
: linha de Artistas 

10 = 5678 
nome = "Miles Davis" 

Figura 12. 1 Mapeando uma coleção para uma chave estrangeira. 

:Álbum

-

ID = 1234 
título = "Kind of Blue• 

«tabela» 
: linha de Álbuns 

ID = 1234 
titulo = "Kind of Blue" 

:Faixa 

... 

,, 

ID = 3333 
título = •so What" 

«tabela» 
: linha de Artistas 

ID = 3333 
idDoÁlbum = 1234 
título = •so What· 

Figura 12.2 Mapeando uma coleção para uma chave estrangeira. 

Álbum 
titulo: String 

utabela» 
Álbuns 

ID: int 
titulo: varchar 

1 Faixa 

-

título: String 

* 
~ 
«tabela» 
Faixas 

1D; int 
idDoÁlbum: int 
título: varchar 

Figura 12.3 Classes e tabelas para uma referência multivalorada. 


CAPITULO 12 • PADRÕES ESlRUIURAIS OSJET0-RELACIONAJS 235 

Com a exclusão e a inserção, você exclui todas as faixas do banco de dados vinculadas 
ao álbum e, então, insere todas as correntemente no álbum. À primeira vista 
isso parece um tanto espantoso, especialmente se você não tjver alterado nenhuma 
faixa. Contudo, a lógica é fáciJ de implementar e, como tal, funciona muito bem compEtrada 
com as alternativas. A desvantagem é que você só pode fazer isso se as faixas 
forem Mapeame11tos Depe11dentes (256), o que significa que elas devem pertencer ao álbum 
e não podem ser referenciadas de fora dele. 

Adicionar um ponteiro reverso coloca um vínculo da faiJ<a de volta para o álbum, 
efetivamente tomando a associação bidirecional. Isso altera o modelo de objetos, 
mas, por outro lado, você agora pode tratar a atualização usando a técnica simples 
para campos univalorados. 

Se nenhuma dessas opções for atrativa, você pode fazer uma diferenciação. 
Existem duas possibilidades aqui: diferenciar em relação ao estado corrente do banco 
de dados ou diferenciar em relação ao que você leu na primeira vez. Diferenciar 
em relação ao banco de dados envolve reler coleção do banco de dados e então compará-
la com a coleção no álbum. Qualquer coisa no banco de dados que não estiver 
no álbum, obviamente foi removida. Qualquer coisé\ no álbum que não estiver no 
disco é obviamente um novo item a ser acrescentado. Observe então a lógica da aplicação 
para decidir o que fazer com cada item. 

Diferenciar em relação ao gue você leu na primeira vez significa que você tem 
que guardêtr o que você leu. Isso é melhorjá que evita outra leitura do banco de dados. 
Você pode também ter de diferenciar em relação ao banco de dados se estiver 
usando um Bloqueio Ofjli11e Otimista (392). 

No caso geral, qualquer coisa que tenha sido adicionada à coleção precisa ser 
primeiro verificada para ver se é Ltm objeto novo. Você pode fazer isso vendo se ele 
tem uma chave. Se não tiver, ele precisa ser adicionado ao banco de dados. Esse passo 
é tornado muito mais simples com uma Unidade de Trabalho (187), porque, dessa 
maneira, qualquer objeto novo será primeiro inser.ido automaticamente. Em qualquer 
caso, você então c1'lcontra a linha associada no banco de dados e atualiza sua 
chave estrangeira para apontar para o álbum corrente. 

Para a remoção, você tem que saber se a faixa foi movida para outro álbum, se 
ela não tem. um Afbum ou se foi completamente excluída. Se ela tiver sido movida para 
outro álbum, ela deve ser atualizada quando você atualizar esse outro álbum. Se 
ela não tiver um álbum, você pl'ecisa colocar um mt// na chave estrangeira. Se a faixa 
foi excluídn, então elf! deveria ser apagada. Tratar exclusões é muito mais fácil se o 
vínculo reverso for obrigatório, como ele é aqui, onde toda faixa deve estar em um álbum. 
Dessa maneira, você não tem que se preocupar em detectar itens removidos da 
coleção, já que eles serão atualizados quando você processar o álbum ao qual eles fo~ 
ram adicionados. 

Se esse vínculo for imutável, significando que você não pode alterato álbum de 
uma faixa, então a adição sempre significa inserção, e a remoção sempre significa exclusão. 
Isso torna as coisas ainda mais simples. 

Uma das coisas com que deve-se tomar cuidado é a existência de ciclos nas suas 
associações. Digamos que você precise carregar um pedido, que tem uma associação 
com um cliente (o qual você carrega). O cliente tem um conjunto de pagamentos (os 
quais você carrega), e cada pagamento tem pedidos os quais ele está pagando, o que 
poderia incluir o pedido original que você está tentando carregar. Por conseguinte, 
você carrega o pedido (c1gora volte ao início deste parágrafo.) 

Para evitar se perder em ciclos, você tem duas escolhas que, no final das contas, 
resumem-se à forma como você cria seus objetos. Normalmente, é uma boa idéia pa



236 PARTE li • Os PADRÕES 

ra um método de criação incluir dados que lhe darão um objeto completamente formado. 
Se voe~ fizer isso, precisará colocar a Carga Tardia (200) cm pontos apropriados 
para quebrar os ciclos. Se você perder algum, você terá um estouro de pilha, mas se 
os seus testes forem bons o suficiente, você poderá gerenciar esse fardo. 

A outra escolha é criar objetos vazios e imediatamente colocá-los em um Mnpa 
de .Identidade (196). Dessa maneira, quando o seu ciclo voltar ao início, o objeto já estará 
carregado, e o ciclo terminará. Os objetos que você cria não estão completamente 
formados, mas deveriam estar ao final do procedimento de cMga. Isso evita ter 
que tomar decisões em casos especiais sobre o uso de Carga Tardia (200) apenas para 
fazer uma carga correta. 

Quando Usá-lo 

Um Mapeame11to de Chave Estrangeira pode ser usado para quase todas as associações 
entre classes. O caso mais comum em que não é possível usá-lo é com associação 
muitos-para-muitos. As chaves estrangeiras são valores únicos, e a primeira forma 
normaJ diz que você não pode armazenar diversas chaves estrangeiras em um único 
campo. Em vez disso, você precisará usar um Mapea1J1e11tnde Tabela Assvciativa (244). 

Se você tem um campo do tipo coleção sem nenhum ponteiro reverso, você deverá 
considerar se o lado "muitos" da associação deve ser um Mapeamento Dependente 
(256). Se esse for o caso, isso pode simplificar o tratamento da coleção. 

Se o objeto relacionado é um Objeto Valor (453), então você deveria usar um Valor 
Emb11lido (261). 

Exemplo: Referência Univalorada (Java} 

Este é o caso mais simples, em que um áJbum tem uma única referência para Ltm artista. 


class Artista ... 

private String nome; 
public Artista ILong ro, String n01r.e) 

super (ID) ; 

this.norr.e = nome; 

public String lerNo.~e() 
return non.e; 

public void gravar~cme{String nooe) 
this.n01te = no~e; 

clas.s Álb\J;\... 

private String título; 
private Artista artista; 
publ1c Álbum lLong ID, String titulo, Art1sta artista) 

super (10) ; 
this.titulo = título; 
this.artista = artista; 

public String lerTítulo ( l 


CAPITULO 12 • PADRÕES E5TRUTUAAIS OBJETO-RELACIONAIS 237 

return título; 

public void 9ravarTítulo (String título~ 
thie.título: titulo; 

public Artista !erArtisca 1 ) 
return artlsta; 

public void gravarArtista {Artista artista) 
this.artista = artista; 

A Figura 12.4 mostra como você pode can:egar um álbum. Quando o mapeador 
de um álbum é instruído a carregar um determinado álbum, ele consulta o banco de 
dados e traz o conjunto resultante dessa pesquisa. Ele então procura no conjunto resultante 
por campo chave estrangeira e descobre esse objeto. Ele agora pode criar o 
álbum com os objetos apropriados encontrados. Se o objeto Artista já estava na memória, 
ele seria trazido do cache. Caso contrário, elé seria carregado do banco de dados 
da mesma maneira. 

A operação de busca usa comportamento abstrato para manipular um Mnpn de 
ldenlidnde (196). 

class MapeadotDeÃlbum... 

public Álbum buscar (I.ong idl { 
return (Álbum) ouscaAl>stratal1d): 

} 

protecteó String comandoDeBusca ( ) ( 
return "SE'LECT ID, título, idOoArtista FRON álbuns WHERE ID = ? "; 

class l~apeadorAbstrato . .. 

abstract protected String c01:andoDeBusca ( 1: 

protecced ObJetoDoDomínio buscaAbstrata (Long id) 
ObjetoOcOomínio resultado : (ObjetoDoDominio) mapaCarregado.getlid); 
if (resultado!= null) return resultado; 
PreparedStatement áec: null; 
ResultSet rs: null; 
try ( 

dec: DB.prepare(comandoDe.Busca( )l; 
dec.setLong(l, id.longValue( )l; 
rs: dec.executeQuery( I; 
rs.next() ; 
resultado= carregar (rs); 
return resultado; 

) catch (SQLException e} ( 
thro~ new ApplicationE:xception (e}: 
} finally IDB.cleanUp(dec, rs) ;) 

private Map c.apaCarregado ~ new HashMap( ); 

A operação de busca chama uma operação de carga para efetivamente carregar 
os dados para o álbum. 


238 PARTE li • Os PAORÕES 

class HapeadorAbstrato... 

protected ObjetoDoDoraínio carregar IResultSet rs) throws SQLException { 
Long id = new Long(rs.getLong(l l); 
if (mapacarregado.containsKey(idJ) recum (ObjetoOODominio) ~~pacarregado.get(id); 
ObjetoDoDomínio resultado= fazerCarga (id, rsl; 
fazerRegistro (id, resultado!; 
return resultado; 

protected void EazerRegistro (Long id, ObjetoDoDominio resultado) 
Assert.isFalse (rnapacarr~ado.containsr.eylidl); 
rnapaCarresado.put (id, resultado); 

abstract protected ObjetoDoDomínio fazerCarga (Long id, ResultSet rs) thro.s SQLException; 

class MapeadorlleÂlbun:1 ... 

protecteà ObjetoDoDorn.ínio fazerCarga (Long id, ResulcSet rs) throws SQLException l 
Stri ng título= rs.getStringl2); 
long ídDoArtista = rs.getLongi3); 
Artista artista= RegistroMapeador.artista( ).buscar(idDoArtista); 
Álbum resultado= new Álbum(id, titulo, artista); 
return resultado; 

Para atualizM um álbum, o valor da chave estrangeira é extraído do objeto artista 
associado. 

um Mapeador um mapeador 

banco de dados 

de Álbum de artista 
1

buscar (1) 
-----e:~ select • from álbuns where 10 = 1 ------


t-----,~conjunto resultante

a result set 

dos álbuns 

ler id do artista 

----------L ---'3' --buscar('
3') 

um artista 

----------L _________ L ___ _ 

novo (um Artista) 

umÂlbum 

Figura 12.4 Seqüência para carregar um campo univalorado. 


CAPÍTULO 12 • PADRÕES EsTRUTUAAIS ÜSJETO-RHACIONAIS 239 

class ~.apeadorAbstrato ... 

abstract public void atualizar {OojetoDoDo!nínio argl; 

class MapeadorDeÁlbum... 

public void atualizar [ObjetoDoDomínio argl 
PreparedStaU!ment dec: null; 
try ( 

dec: DB.prepare t 

•OPDATE álbuns SET titulo •?, tdOoArtista =? WHERE íd = ?•; 
dec.setLong(3, arg.ler!D() .longValue( )}; 
Álbum álbum = {Álbum) arg; 
dec.setString(l, álbum.lerTítulo( )) ; 
dec.setLong(2, álbum.lerArtista( ) .lerID() .longValue( )) ; 
dec, executet ) ; 
) catch {SQLSxception e) f 
thro~ new ApplicationBxception(el; 
} finally { 
cleanUp(dec); 

Exemplo: Busca Multitabelas (Java) 

Embora seja conceitualmente claro executar uma pesquisa por tabela, muitas vezes 
isso é ineficiente, já que SQL consiste de chamadas remotas, e estas chamadas são 
lentas. Por conseguinte, freqüentemente vale a pena encontrar maneiras de recuperar 
informações de diversas tabelas em uma única pesquisa. Posso modificar o exemplo 
anterior para usar uma única consulta para obter as informações tanto do álbun1 
quanto do artista com uma única chamada SQL. A primeira alteração é a do SQL do 
comando de busca. 

class MapeadorDeÁlbum.. , 

public Álbum buscar (Long id) 
return (Álbum) buscaAhstrata(id): 

} 

protected String comandoDeBusca ( ) { 
return •SELECT a. ID, a.titulo, a.iâDoArtista, r.nome •• 
~ FROM álbuns a, artistas r, • + 

• WHBRB !O:? AND a.idDoArtista = r .10"; 
A seguir uso um método de carga diferente que carrega tanto a informação do 
álbum quanto a do artista. 

class l~apeadorDeÃlbwn... 

protected ObjetoDoDomínio fazerCarga {Long id, ResultSet rs) thrmis SOLException ( 
String título= rs.getString(2); 
long idDoArtista = rs.getLong{31; 
MapeadorDeArtista mapeadorDeArtista = RegistroMapeador,artista( ); 
Artista artista; 
íf (mapeadorDeArtista.estáCarregado{idDoArt:istal) 


240 PARTE li • Os PAORÕES 

artista= rnapeadorDeArrista.buscarlidDoArtiscal; 
eise 

artista= carregarArtista(idDoArtista, rs); 
Álbum resultado= new Ãlbum(íd, titulo, artista): 
return resultado; 

private Artista c~rregarArtista (long id, ResultSet rs) throws SQL!ixception { 
String nOOíe = ni.getString(4); 
Artista resultado =-new Artista !new Long (id), nome); 
Registro~lapeador .arcisca1 } .registrar(resultado.lerID ( ) , resultado); 
return resultado; 

Há alguma animosidade envolvendo a decisão sobre onde colocar o método 
que mapeia o resultado da consulta SQL para o objeto artista. Por um lado é melhor 
colocá-lo no mapeador de artista, já que est« é a classe que normalmente carrega o artista. 
Por outro lado, o método de carga é intimamente associado ao SQL e, dessa maneira, 
deveria ficar com a consulta SQL. Neste caso, votei na segunda opção. 

Exemplo: Coleção de Referências (C#) 

O caso da coleção de referências ocorre quando você tem um campo que constitui 

uma coleção. Usarei aqui um exemplo de equipes e jogadores em que iremos supor 

que não podemos totnar um jogador um Mapeamento Depeud,mte (256) (Figura 12.5). 

cbss Equipe... 

public String NOQe; 

public IList Jogadores; ( 
get {retum ArrayList.ReadOnly(daàosDosJogadoresl;} 
set {dadosDosJogadores = new ArrayList (valot)J} 

public void AdicionarJogador(Jogador arg) 
dadosDosJogadores.Addlarg!; 

private IList dadosDosJogadores = new ArrayList ( ); 

No banco de dados, isso será manipulado com o registro do jogador tendo uma 
chave estrangeira para a equipe (Figura 12.6). 

class Ma~adorDeRquipe ... 

public Equipe Buscarllong id) 
return (Equipe) BuscaAbstrata(id); 

~--Eq-pe_~-*__;;:>=M~I J gado_~

-ui__ -----------___o____r 

1 

Figura 12.5 Uma equipe com vários jogadores. 


CAPÍTULO 12 • PADRÕES ESTRUTURAIS O8JET0-RE:lACIONAIS 241 

(itabela» Htabela» 
Equipe Jogador 
1D: long 1D: long 
idDaEquipe: long 

Figura 12.6 Estrutura do banco de dados para uma equipe com vários jogadores. 

class f.!apeadorAbstrato... 

protected ObjetoDoDominio BuscaAbstrata llong id) { 
Assert.True (id != ObjetoDoDooúnio.PROCURAOOR_ID); 
DataRow linha= BusearLinha(id); 
return (linha== null) ? nul!: Carregar(linha); 

} 

protected DataRow BuscarLinha (long idl { 
String filtro= String.Formatl•id = (o)•, id); 
DataRow [ ) resultados = tabela.Select{filtrol; 
return (resultados.Length = O) ? null: resultados[Ol; 

l 

protected DataTable tabela { 
get {retum acd.Dados.Tables(No:neDaTabelaJ;) 

public ArmazenadorDoConjuntoDeDados acd; 

abstract protected String Nor.eDaTabela {get; ) 

claes MapeadorDeEguipe ... 

protected override String NoceDaTabela ( 
get {retum •Equipes";} 

O armazenador do conjunto de dados é uma classe que armazena o conjunto de 
dados em uso, junto com os adaptadores necessários para atualizá~los no banco de 
dados. 

class ArmazenadorDoConjuntoDeDados .. . 

public OataSet Dados= ne~ OataSec( ) ; 

private Hashtable AdaptadoresDeDados = new Hashtable( ); 

Para esse exemplo, iremos supor que a classe já foi povoada por algumas consultas 
apropriadas. 

O método de busca chama um método de carga para efetivamente carregar os 
dados no novo objeto. 

class MapeadorAbstraco... 

protecced ObjetoD0Dom!n10 Carregar (DataRO'N linha) { 

long id = (int) linha(•id"I; 

if (mapa.Deidentidade[idl != null) return (ObjetoDoDominio) mapaOeldentidad.e[id); 

else { 

ObjetoDoOomínío resultado= CriarObjetoDoDomínio( l; 
resultado. Id = id; 


242 PARTE li • Os PAORôES 

mapaDeldentidade.Add lresulrado.Id, resultado); 
fazerCarga fresultado, linha) ; 
return resultado; 

abstract procected ObjetoDoDominio CriarôbjetoOoDomínio ( l; 
private lOictionary mapaDeidentidade = ne~ Hast.able ( l; 
abstract protected void fazerCarga (ObjetoDoDomínio obj, DataRow linhat; 

class ~.apeadorDeEquipe... 

protecteà override void fazercarga (ObjetoDoDomlnio obj, DataRow linhal 1 
Equipe equipe = (Equipe) obj; 
equipe.Nane= (String) linha('no:ne•J; 
equipe.Jogadores~ RegistroMapeador.Jogador.SuscarPorEquipe(equipe.!d); 

Para trazer os jogadores, executo um método especializado de busca sobre o 
mapeador de jogadores. 

class MapeadorOeJogador... 

public IList BuscarPorEquipe (long id) 1 
String filtro= String.Formatl•idDaEquipe {o}•, id); 
OataRow( 1 linhas = tabela.Select(filtro); 
IList resultado= new ArrayList( ); 
íoreach (DataRow linha in linhas) i 

resultado.Add(Carresar (linha)) : 

return resultado; 

Para a atualização, a equipe grava seus próprios dados e delega ao mapeador 
de jogadores a gravação dos dados na tabela de jogadores. 

class MapeadorAbstrato... 

public virtual void Atualizar (ObjetoOoDO'línio argl 
Gravar (arg, Buscarkinha (arg.Ià)); 

abstract protected void Gravar (ObjetoOoOomínio obj, DataROII' linha); 

class MapeadorOeEquipe ... 

protected override void Gravar (ObjetoOoDominio obj, DataRow linha) 1 
Equipe equipe= (Equipe) obj; 
linhal'nome•J = equipe.Non:e; 
gravarJogadores (equipe): 

private void gravarJogadores (Equipe equipe) 1 
foreach (Jogador j in equipe.Jogadores) ( 
Regístro.~apeador.Jogador.AssociaçãoEquipe (j, equipe.!d) ; 


CAPi'f\JL0 12 • PADRÕES ESTIMUAAIS Oaiero-RELACIONAIS 243 

class MapeadorDeJogador ... 

public voíd AssociaçãoEquípe (Jogador jogador, long idDaEquipe) ( 
DataRo~ linha: BuscarLinha (jogador.lá); 
linha(•idDaEquipe•J: idDaEquipe: 

O código de atualização torna-se muito mais simples pelo fato da associação do 
jogador com a equipe ser obrigatória. Se movermos um jogador de uma equipe para 
outra, desde que atualizemos ambas as equipes, não temos que fazer uma diferenciação 
complicada pa1·a lidar com os jogadores. Deixarei esse caso como exercício para 

o leitor. 

244 PARTE li • Os PADRÕES 

Mapeamento de Tabela Associativa {Association Table Mapping) 

Crava 11ma associnçiio como 11111a tabela com ciumes estrangeiras 
para as tabelas quesão vi11c11/ndas pela associação. 

Empregado ** Habmdade

1-1-------------'>~1 

((tabela» 

<<tabela» «tabela» 

habilidade


Empregados Habilidades

empregados 

1D 1 DdoEmpregado 1D 
IDdaHabilidade 

Os objetos podem manipular campos muJtivalorados com bastante facilidade usando 
coleções como valores de campos. Os bancos de dados relacionais não têm essa 
característica e são restritos apenas a campos tmivalorados. Quando você estiver mapeando 
uma associação um-para-muitos, pode manipulá-la usando um Mapeamento 
de Chave Estrangeira (233), basicamente usando uma chave estrangeira para o lado 
wúvalorado da associação. Contudo, uma associação muitos-para-muitos não pode 
fazer isso porque não há lado uruvalorado para armazenar a chave estrangeira. 

A resposta é a solução clássica que tem sido há décadas usada pela comunidade 
de dados relacionais: criM uma tabela extra para armazenar o relacionamento. Depois 
use um Mapeamento de Tabela Associativa para mapear o campo multivalorado 
para essa tabela de vinculação. 

Como Funciona 

A idéia básica por trás do Mapeamento de Tabela Associativn é usar uma tabela de vinculação 
para armazenar a associação. Essa tí'lbcla tem apenas os IDs das chaves estrangeiras 
para as duas tabelas que são vinculadas. Ela possui uma linha para cada 
pM de objetos associados. 

A tabela de vinculação não tem um objeto correspondente em memória. A con


seqüência disso é que ela não tem {O . Sua chave primária é a composição das duas 

chaves primárias das tabelas que são associadas. 

Em termos simples, para carregar dados da tabela de vinculação, você executa 
duas consultas. Considere carregar as habilidades de um empregado. Neste caso, pelo 
menos conceitualmente, você executa consultas em duas etapas. A primeira etapa 
consulta a tabela habilidadesBmpregados para encontrar todas as linhas que referenciam 

o empregado que você quer. A segunda etapa, para cada linha do conjunto resultante, 
encontra o objeto habilidade correspondente usando o 1D relacionado. 
Se toda a informação já estiver em memória, este esquema ftmdona bem. Se não 
estiver, ele pode ser terrivelmente custoso no que diz respeito às consultas, já que você 
tem de executar uma consulta para cRda habilidade na tabeJa associativa. Você po~ 


CAPITULO 1 2 • PADRÕES ESlRUTURAtS Oaiero-RelACI0NAIS 245 

de evitar este custo juntando a tabela de habilidades com a tabela associativa, o que 
lhe permite obter todos os dados em uma única consulta, embora ao custo de tornar 

o mapeamento um pouco mais complicado. 
Attmlizar os dados referentes à associação das tabelas envolve muitas das questões 
da atualização de campos multi valorados. Felizmente a questão é tornada muito 
mais simples já que você pode, de muitas maneiras, tratar a tabela associativa como 
um Mapeamento Dependente (256). Nenhuma outra tabela deve referenciar a tabela 
associativa, de modo que você pode livremente criar e destruir vmculos na medida 
em que eles forem necessários. 

Quando Usá-lo 

O caso canônico de Mapenmento de Tabela Associativa é uma associação muitos-paramuitos, 
já que realmente não há alternativas para essa situação. 

O Mapeamento de Tabela Associativa também pode ser usada para qualquer outra 
forma de associação. Entretanto, devido ao fato de ele ser mais complexo que o 
Mapeamento de Chave Eslmngeira (233) e envolver uma junção (joi11) extra1 ele, usualmente, 
não é a melhor escolha. Ajnda assim, em dois casos, o Mapenme11to de Tabela 
Associativa é apropriado par~ uma associação mais simples. Ambos os c<1s0s envolvem 
bancos de díldos em que você tem menos controle sobre o esquema. Às vezes, 
você pode precisar associar duas tabelas existentes, mas não pode adicionar colunas 
a essas tabelas. Neste caso, você pode criar uma nova tabela e usar o Mapeamento 
de Tabela Associativa. Outras vezes, um esquema existente usa uma tabela associativa, 
mesmo quando ela não é realmente necessária. Neste caso, freqüentemente é 
mais fácil usar um Mapeamento de Tabela Associativa do que simplificar o esquema 
do banco de dados. 

Em um projeto de banco de dados relacional, você pode muitas vezes ter tabelas 
associativas que também carregam informação sobre o relacionamento. Um 
exemplo é uma tabela associativa pessoa/companhia que também contenha informações 
sobre o emprego da pessoa na companhia. Neste caso, a tabela pessoa/ companhia 
realmente corresponde a um verdadeiro objeto do domínio. 

Exemplo: Empregados e Habilidades (C#) 

Aqui está um exemplo simples usando o modelo do esboço. Temos uma classe Em


pregado com u.m conjunto de habilidades, cada uma das quais pode aparecer asso


ciada a mais de um empregado. 

class Empregado ... 

public IList Habilidades { 
get {retum ArrayList.ReadOnly(dadosDasHabilidades);} 
set {dadosDasHabilidades ~ new ArrayList(valor)i} 

public void AdicionarHabilidade (Habilidade arg) 
dadosDasHabilidades.Add(arg); 

public void rerr.overHabilidade (Habilidade argl 
dadosDasHabilidades.Remove{arg); 

privace lList dadosDasHabílidades = new ArrayList( ); 


246 PARTE li • Os PAORÕES 

Para carregar um empregado do banco de dados, precisamos pegar as habilida~ 
desusando um mapeador de empregado. Cada classe mapeadora de empregados tem 
um método de busca que cria um objeto empregado. Todos os mapeadores são sub• 
classes da classe mapeadora abstrata que junta serviços comuns para os mapeadores. 

class MapeadorDeE1npre9ado... 

public Empregado Buscar (long iô) 
retum (Empregado) BuscaAbstrata (id) ; 

class HapeadorAbstrato... 

protected ObjetoDoDom.ínio BuscaAbstrata (long id) 
Assert.isTrue (id != ObjetoDoDominio.PROCURADOR_ID}; 
DacaRo~ linha= BuscarLinha(id); 
return (linha=~ null) ? null: carregar(linhal; 

} 

protected DataR<rN BuscarLinha (long id) j 
String filtro= Striog.Format (•íd = {o)•, id); 
DacaRowl I resultados= tabela.Select [filtro}; 
return (resultados.Length == Ol ? null: resultados(O); 

} 
protected DataTable tabela 1 
get /return acd.Dados.Tables(NOll'~DaTabela) 1} 

public Arr.lazenadorDoConjur.toDeDados acd; 
abstract protected Str1n9 NOilleDaTabela {get; } 

class HapeadorDes:npregado ... 

protected o,erride String NOiileDaTabela { 
get (return "Elr.pregados";) 

O armazenador do conjunto de dados é wn objeto simples que contém um conjunto 
de dados ADO.NET e os adaptadores relevantes para g-ravar este conjunto no 
banco de dados. 

class ArmazenadorDoConjuntoDeDados... 

public OataSet Dados=-new DataSet( 1; 
private l!ashtable AdaptadoresDeDados = new Hashtablel ~. 

Para tornar este exemplo simples -na verdade, simplista -iremos supor que o 
conjunto de dados já foi carregado com todos os dados de que precisamos. 
O método de busca chama os métodos de carga para carregar os dados do em~ 
pregado. 

class MapeadorAbstrato... 

protetced ObjetoDoDominio Carregar (DataRow linhal 
long id: (intl linha]•id•]; 
if (mapaDetdentidadelidl l= null return (ObjetoOODominio) mapaDeidentióade{idl; 
else ( 

ObJetoDoDocínio resultado = CriarObjetoDoDomioio( l; 


CAPÍTULO 12 • PADRÕES EsTRUTURAIS O8JH0-RElACI0NAIS 247 

resultado.Id =id; 
mapaDeldentidade.Add(resultado.:d, resultado); 
fazerCarga (resultado. linha); 
return resultado; 

abstract protected ObjetoOODominio CriarObjetoOoDominio( ); 
private IDictionary lllilpaOe!dentidade =new Hashtahle( >: 
abstract protected void tazercarga (ObjetOOODo:ninio obj, DataRow linha); 

class MapeadorOeEmpregado... 

protected O\'erride void fazerearqa IObjetoOoDo.11inio obj, DataR01,1 Unha} { 
Empregado emp ; (~pregado) obj; 
emp.Nome =(String) linha(•nome•J; 
carregarHabilidades (eep); 

Carregar as habilidades é suficientemente complicado para justificar um método 
separado para realizar o trabalho. 

class MapeadorDeErnpregado. . . 

private IList carregarHabilidaàes (Empregado emp) 
DataRow( 1 linhas= linhasHabilidadesAssociadas(empl; 
IList resultado = new ArrayList ( ); 
foreach (DataRow linha in linhas) { 

long idDaRabilidade: (int) linha[•idDaHabilidade•); 
e~p.AdicionarHabílidade{RegistroMapeador.Habiliàade.Buscar(idDaHabilidade}I ; 

return resultado; 

private DataRow{ l linhasHabilidadesAssociadas (Empregado emp) 1 
String filtro= String.Format{"idDoEmpregado = {oj•, eitp.Id) ~ 
return tabelaHabilidadesAssociadas.Select{filtro); 

} 

prívate DataTable tabelaHabilidadesAssociadas ( 
get {return acd.Dados.Tables(•habilidadesE!npregados•J ;} 

Para tratar as alterações nas informações sobre as habilidades, usamos um lnétodo 
de atualização no mapeador absb·ato. 

class MapeadorAbstrato... 

public virtual void Atual izar (ObjetoDoDoclinio argl 
Cravar (arg, BuscarLinha (arg.Id)) ; 

abstract procected void Gravar (ObjtetoDoDomínio arg, DataRow linha); 

O método de atualização chama um método de gravação na subclasse. 

class MapeadorDeEmpregado ... 

protected ovezride void Gravar {ObjetoDoDominio obj, DataRow linha) 1 
Ei;ipr89ado emp = (.Et.lpregadol obj: 


248 PAATE li • Os PADRÕES 

linhal•nome~J = err.p.Nooe; 

gravarHabilidades (emp); 

Mais uma vez, criei um método separado para gravar as habilidades. 

class MapeadorDeE'mpregado ... 

private void gravarHabilidades (Empregado emp) { 
excluirHabilidades(ernp); 
foreach (Habilidaàe h in emp.Habilidadesl { 

DataRow linha= tabelaHabilidadesAssociadas.MewRowl ); 
linha(1 idDoEmpregado1} = emp.!d; 
linha(•ióDaHabilidade•J = h.Id; 
tabelaHabilidadesAssociadas.Ro'tls.Add(linha) : 

private void excluirHabilidades (Empregado emp) 
DataRow[ 1 linhasoasHabilidades : linhasHabilidadesAssociadas(e(l'p): 
foreach (DataRow li in linhasDasHabilidades) li.Delete( ); 

A lógica aqui executa a ação simples de apagar todas as linhas existentes na ta


bela associativa e criar novas linhas. Isso me poupa de ter que descobrir quais foram 

adicionadas e quais foram excluídas. 

Exemplo: Usando SQL Direto {Java) 

Uma das coisas boas de ADO.NET é que ele me permite discutir o básico de um maperunento 
objeto-relacional sem me prender aos detalhes pegajosos relativos à minimização 
de consultas. Com outros esquemas de mapeamento relacional, você fica 
mais próximo do SQL e tem que levar muito disso em conta. 

Quando você está indo dfretamente ao banco de dados, é importante minimizar 
as consultas. Para a minha primeira versão, pegarei o empregado e todas as suas habilidades 
em duas consultas diferentes ao banco de dados. Isso é fácil de acompanhar, 
mas não é a melhor maneira de fazer, então, tenha paciência comigo. 

Aqui está a ODL para as tabelas: 

create table empregados (ID int primary key, prenome varchar, sobreno:ne varcharl 

create table habilidades (ID int pri~ary key, no;ne varcharl 

create table empregadoHabilidades (idDoEmpregado int, idDaHabilidade inc, pri~Ary key 
(idDoEmpregado, idDaHabilidade)) 

Para carregar um único Empregado, seguirei uma abordagem semelhante à que 
utilizei antes. O mapeador de empregado define um envoltório simples para um método 
abstrato de busca na Cnmndn S11pertipo (444). 

class MapeadorDeE:lpregado ... 

public Empregado buscar (long chavel 
return buscar (ne'tl Long (chave) ): 

public Erripregado buscar (Long chave) 


CAPITULO 12 • PADRÕES ESTRUTURAIS O8JH0-REt:ACI0NAIS 249 

recum (Empregado) busc~.bstrata (chave); 
} 
protecteà String comandoDe.Busca () ( 

return 
"S612CT • t LlSTA_DE_COLUNAS • 

• FROM empregados•~ 
• WHBRE ID = ?•; 
public static final String LISTA_DB_COLUNAS =. ID, sobrenome, prenorr.e · : 

class MapeadorAbstrato... 

protected ObjetoDoDomfnio buscaAbstrata (U:ng id) { 
ObjetoDoDomínio resultado= (ObjetoDoDomínio) mapacarregado.get(id); 
if (resultado l= null) return resultado; 
PreparedStatemenc dec = null; 
ResulcSet ra e null; 
try 1 

dec = DB.prepare(comandoDeBusca( )li 
dec,setLong(l, id.longValue( )); 
rs = dec.executeOuery( ); 
rs.next( l; 
resultado= carregar lrs); 
return resultado; 

) catch {SQLBxception e) 1 
throw new ApplícationExoeptionlel; 
) finally {DB.cleanUp(dec, rs); 
l 

abstract protected Str!og cooandoDeBusca{ I; 
protected Map mapaCarregado = new HashMapl I; 

Os métodos de busca chamam então os métodos de carga. Um método abstrato 
de carga trata a carga do 1D enquanto os dados reais do empregado são carregados 
no mapeador de empregados. 

claS'S MapeadorAbstrato... 

protecced ObjetoDoDom!nio carregar (Resulcsec rsl chro~s SQLException { 
Long id = new Long(rs.getLong(ll); 
recum carregar (id, rs): 

public ObjeroDoDomínio carregar (Long id, ResultSet rs) throws SQLException { 
if (foiCarregado(idl) return (ObjetoOoDominio) r.apaCarregado.get(id); 
ObjetoDoDomínio resultado= fazercarga (id, rs); 
mapaCarregado.put(id, resultado); 
return resultado; 

abstract protected ObjetoOODoolinio fazer<:arga {U>ng id, ResultSet rsl thro~s SQLException; 

class MapeadorDeErnpregado... 

protected ObjetoDoDomínio fazerCarga (Long id, ResultSet rs) throws SQLSxception ( 
Bt.;pregado resultado= ne~ trnpregado(id); 
resultado.gravarPrenor.ie(rs.getString{•prenome•); 
resultado.9ravarSobreno.11e(rs.9etStrin9{~sobrencxr.e~) ; 


250 PARTE li • Os PADRÕES 

resulcado.gravarHabilidades(carregarHabilidadestid) I; 
retum resultado; 

O empregado precisa executar outra consulta para carregar as habilidades, mas 
ele pode facilmente carregar todas as habilidades em uma única consulta. Para fazer 
isso, ele chama o mapcador de habilidades para carregar os dados de uma habilidade 
especifica. 

class WapeadorDeF:mpregado. . , 

protected List carregarHabilidades ILong idDoErnpregado} 
PreparedStatement dec = null : 
ResultSe~ rs = nulli 
try { 

List resultado= new ArrayList( ); 
dec = DB.prepare (comandoDeBuscaDeHabilidades)1 
dec.setObjectll, idDoEmpregado); 
rs = dec.executeQuery! ); 
while (rs.next l )) { 

Long idDaHabilidade = new Long(rs.gectong(ll); 
resultado.Add( (Habilidade! RegistroMapeador.habilidade( 1.carregarLinha 

(idOaHabilidade, rs}) ; 
} 
return resultado; 
} catch (SQLException e) 

throw new ApplicationException le); 
} finally (D5.cleanOp(âec, rs): 
l 

private scatic final String comandoDeBuscaDeHabi1idades = 
"SELECT habilidade. TO, • • MapeadorDeHabHidade.LISTA_Dll_COLUNAS t 
~ FRO~ habilidades habilidade, empregadoHabilidades eh•+ 

• l♦rnERE eh.idDoEmpregado = ? A!ID habilidade. 10 :e eh. idDaHabilidade•; 
class HapeadorOeHabilidade... 

public static final String LISTA_OE_COLONAS =~habilidade.nome nomeDal!¾bilidade •; 

class MapeadorAbstrato... 

protected ObjetoDoDorúnio carregarLinha (u,ng id, ResultSet rs) thro~s SQ~Exception 1 
return carregar(id, rs); 

class MapeadorDeHabilidade... 

protected ObjetoDoDominio fazer<:arga (Long id, ResultSet rs) throws SQLException ( 
Habilidade resultado= new Habilidade (idl; 
resultado.gravarNooe (rs.getString l 'oomeDaHabilidade'}) ; 
return resultado; 

O mapeador abstrato também pode ajudar a encontrar empregados. 

class MapeadorDeEmpregado ... 

publíc Líst buscarTodos ( 1 


ÚPÍT\)Lô 12 • PADRÕES ESTRUTURAIS OSJET0-RElACI0NAIS 251 

retum buscarTodos (comandoBuscar'l'odos); 

private static final String c-omandoBuscarTodos = 

~sELBCT • + L1STA_DE_COLUNAS 


• FROM ecpregados empregado•~ 
fl 

ORDER BY empregado.sobrenome•; 

class ~apeadorAbstrato ... 

protected List buscarTodos (String sqll 
Preparedscatement dec: null; 
ResultSet rs = null; 
try 1 

List resultado= new ArrayListí ); 
dec = DB.prepare(sql); 
rs = dec.executeQuery( ); 
while (ts .next( )) 

resultado.add(carresar(rs)l; 
return resultado; 
) catch (SQLSxception e) 1 
thro-~ new ApplicationException(el; 
} finally {0!3.cleanop(dec. rs);} 

} 

Tudo isso funciona muito bem e é muito simples de acompanhar. /\inda assim, 
há um problema no número de pesquisas., e isso se deve ao fato de que cada empregado 
gasta duas consultas SQL p<1ra ser carregado. Embora possamos carregar os dados 
básicos de um empregado para mtútos empregados em uma única consulta, ainda 
precisamos de uma consulta por empregado para carregar as habilidades. Assim, 
carregar 100 empregados exige 101 consultas. 

Exemplo: Usando uma Única Consulta para Vários Empregados (Java) 

É possível trazer do banco vários empregados, juntamente com suas habilidades, 
em uma única busca. Este é um bom exemplo de otimização de consultas em mais 
de uma tabela, o que certamente é mais complicado. Por esse motivo, faça isso somente 
quando precisar, em vez de em todas as vezes. É melhor colocar mais energia 
em acelerar as suas buscas lentas do que em muitas consultas que sejam menos importantes. 


O primeiro caso que investigaremos é um caso simples no qual trazemos do 
banco todas as habilidades de um empregado na mesma consulta que traz os dados 
básicos. Para fazer isso, usarei um comando SQL mais complexo que realiza a junção 
das três tabelas. 

class NapeadorDeEl!lpregado... 

protected String comandoDeBusca r) 
return 

•SELECT • t LlSTA_DE_COLUNfiS + 
• FROM eClpregados err.pregado, habil idaàes habilidade, empregadoHabilidades eh• + 
• WHE.RE e~regado.ID = eh.idDoElnpregado ANO habilidade.ID = eh.idDaHabilidade AND 
empregado.ID= ?"; 
) 


252 PARTE li • Os PADRÕES 

public stacic final String LISTA_DB_COWNAS = 

• empregado.TO, err.pregado.sobrenome, empregado.prenome, • + 
• eh.idDaHabil idade1 eh.idDoEmpregado, • + 
"habilidade.ID, habilidade.nome~; 
Os métodos buscaAhstrata e carregar da superclasse são os mesmos do exemplo 
anterior, de modo que não irei repeti-los aqui. O mapeador de empregados carreg;i 
seus dados de maneira diferente parn tirar proveito das múltiplas linhas de dados. 

class Mapeadoroeenpregado... 

protected ObjetoDoDominio fazercarga (Long id, ResultSet rs) throws SQL'Sxception 1 
Empregado resultado = {Empregado) carregarLinha lid, rsl; 
carregarDadosDasHabilidades {resultado, rs); 
while {rs.nextl )} { 

Assert.isTrue(aLinhaÉParaal.esmoEmpregadolid, rs)); 

carregarDadosDasHabilidadesíresultado, rsl; 

return resultado; 

protected ObjetoDoDominio carregarLinha(Long id, ResultSet rs) throws SQLException { 
Rtrpregado resultado= new Empregadolid); 
resultado.gravarPrenorne(rs.getString(-prenor.ie•); 
resultado.gravarsobrenome(rs.getString(•sobrenome"); 
return resultado; 

privace hoolean aLinhaBParaOMesmoEmpregado (Long id, ResulcSet rsl throws SQLBxcepcion ( 
return id.equals(newLong!rs.getLông(l ll): 

) 

private void carregarDadosDasHabil idades (Empregado pessoa, Resultset rs) thro~s SQL~ceptíon { 
Long idDaHabilidade = new Long(rs.getLong("idDaHabilidade•); 
pessoa .adicionarHabilidade ( (Habilidade) Registrot-lapeaáor.habilidade ( l.carregarLinha 

(idDaHabilidade, rs)I; 

} 

Neste caso, o método de carga do mapeador de empregados, em verdade percorre 
o resto do conjunto resultante para carregar todos os dados. 

Tudo é simples quando estamos carregando os dados de urn único empregado. 
Entretanto, o benefício real desta consulta em mais de uma tabela aparece quando 
queremos carregar muitos empregados. Obter a leitura correta pode ser complicado, 
especialmente quando não queremos forçar o agrupamento do conjunto resultante 
por empregados. Neste ponto é útil introduzir uma classe auxiliar para percorrer o 
conjunto resultante focando na própria tabela associativa, carregando os empregados 
e habilidades à medida que prossegue. 

Começarei com o SQL e n chamada para a clMse carreg<1dora especial. 

class MapeadorDeEmpregado ... 

public tist buscarTodo3 ( 1 
return buscat'Fodos(comandoBuscarTodosl; 

privace static final String comandoBuscaríodos = 
"SELeCT' • LISTA_DE_COWNAS • 

• FROM empregados empregado, habilidades habilidade, empregadoHabilidades eh• i 

CAPITULO 12 • PADRÕES ESTRUTURAIS OSJET0-RHACI0NAIS 253 

• WHER.E ellqlregado.ID = eh.idDoEmpregado Mm habilidade.ln= eh.idDaHabilidade• t 
• ORDER BY ernpregado.sobreno.~e•; 
protected List buscarTodos(String sql} { 
CarregadorDaTabelaAssociativa carregador= new carregadorDaTabelaAssociati'.'a(this, new 
AdicionadorDeHabílídade( l); 
return carregador.rodar(comandoBuscarTodos); 

class carregadorOaTabelaAssociativa ... 

private MapeadorAbstrato m.apeadorFonte; 
privace Adicionador adicionadorAlvo; 
public CarregadorDaTabelaAssociativa (MapeadorAbstraco mapeadorPrincipal, Adicionador 

adicionadorAlvo} { 
this.mapeadorFonte = ~~peadorPrincipal; 
this.adicionadorAlvo = acilcionadorAlvo; 

Não se preocupe com o adicionadorDeHabilidade -mais tarde ele se tomará um 
pouco mais claro. Por enquanto, perceba que construímos o carregador com uma referência 
ao mapeador e então o mandamos fazer uma carga com uma consulta apropriada. 
Essa é a estrutura típica de um objeto método. Um objeto método [Beck Patterns] 
é uma maneira de transformar um método complicado em um objeto por si só. 
A grande vantagem disso é que Jhe permite colocar valores em campos em vez de 
passá-los por parâmetros. A maneira comum de usar um objeto método é criá-lo, dispará-
lo e então deixá-lo morrer assim que o seu trabalho estiver terminado. 

O comportamento de carga se dá em três passos. 

class CarregadorDaTabelaAssociat iva... 

protected List rodar !String sql) { 
carregarOados(sqll ; 
adicionar'l'odoSObjetosNovosAoNapaDeidentiàadel ); 
return fonnarResultado; 

O método carregarDados constrói a chamada SQL, executa-a e efetua um laço no 
conjunto resultante. Já que este é um objeto método, coloquei o conjunto resultante 
em um campo de modo que não o tenha de passar por parâmetro. 

class CarregadorDaTabelaAssociativa ... 

private ResultSet rs: null i 

private void carregarDados (String sqll 
PreparedStatement dec: null; 
try 1 

dec = OB.prepare (sql); 
rs = dec.executeQuery( t; 
while (rs.nextl )) 

carregarLinhal 1; 
) catch (SQLException e} i 

throw new A;Jplícat!onSxception(eJ; 
) finally {DB.cleanUp(dec, tsl; 
} 


2 54 PARTE li • Os PADRÕES 

O método carregarLinha carrega os dados de uma única linha no conjunto resultante. 
Ele 15 um pouco complicado. 

class CarregadorDaTabelaAssociativa... 

private List idsResultantes =new ArrayList l ); 
private Map emProg-resso "newHashMap( ); 
private void carregarLinha () thro~s SQLException ~ 

L-0119 1D = new Long(rs.getLong(l )); 
íf (!idsResultantes.contains{ID)l idsResultantes.add(ID); 
if (!mapeaàorPonte.carregou(ID)) { 

if (!emProgresso.keySet( l.contains(ID)) 
emProgresso.put{lD, mapeadorPonte.carregarLinha(IO, rs)I; 
adicionadoillvo.adicionar( (ObjetoDoDaninio) emProgresso.get(ID), rs} ; 

class MapeadorAbstrat o ... 

boolean carregou(Long id) 
return mapaCartegado.containsKey(idl ; 

O carregador preserva qualquer ordenação presente no conjunto resultante, de 
modo que a lista de saída de empregados estará na mesma ordem inicial Então, 
mantenho uma lista de IDs na ordem em que os vejo. Assim que tiver o ID, vejo se ele 
já está totalmente carregado no mapcador -normalmente por uma consulta anterior. 
Caso não esteja, carrego os dados que tiver e guardo-os em uma lista "em progresso". 
Preciso de tal lista já que diversas linhas serão combinadas para reunir todos os 
dados do empregado e posso não chegar a essas linhas consecutivamente. 

A parte mais delicada deste código é assegurar que posso adicionar a habilidade 
que estou carregando na lista de habilidades dos empregados e ainda assim manter 
genérico o carregador de modo que ele não dependa de empregados e habilidades. 
Para alcançar isso, preciso procurar fundo no meu baú de truques para encontrar 
uma interface interna -o Adicionador. 

class carr-egadorDaTahelaAssociativa. ,. 

public static interface Adicionador { 
void adicionar (ObjetoDoDominio hospedeiro, ResultSet rs) throws SOLBxception; 

O solicitante original tem que fornecer uma implementação para a interface, para 
especializá-la para as necessidades específicas do empregado e habilidade. 

class MapeadorDeEmpregado ... 

private stat1c class AdicionadorDeHabilidade implements CarregadorDaTabelaAssociatíva.Adicionador { 

public void adicionar (ObjetoDoDomínio hospedeiro, ResultSet rs) throws SOLException ( 
Empregado err.p =(Empregado} hospedeiro; 
Long idDaHabilidade = new Long(rs.9etLong("idDaHabilidade•) I; 
emp.adicionarHabilidade( (Habilidade) RegistroMapeador.habilidade{ ) .CclrregarI,inha 

(idDaHabilidade, rs)l; 

) 


CAPITULO 12 • PADRÕES ESTRUTURAIS OBJETO-RELACIONAIS 255 

Este é o tipo de coisa que fica mais natural em linguagens que possuem ponteiros 
para funções ou fechamentos (c/0s11res), mas pelo menos a classe e a interface conseguem 
executar o traba1ho. (Elas não têm que ser internas neste caso, mas isso ajuda 
a enfatizar seu escopo estreito.) 

Você pode ter pe-rcebido que tenho um método carregar e um método carregarLinha 
definidos na superclasse e a implementação de carregarLinha é uma chamada ao 
método carregar. Fiz isso porque existem ocasiões em que você quer ter certeza de que 
uma ação de carga não avançará o conjunto resultante. A carga faz o que ela tiver de 
fazer para carregar um objeto, mas carregarLinba garante a carga de dados de uma linha 
sem alterar a posição do cursor. Na maior parte do tempo, esses dois métodos são 
a mesma coisa, mas no caso deste mapeador de empregados, eles são diferentes. 

Agora todos os dados vieram do conjunto resultante. Tenho duas coleções: uma 
lista dos IDs de todos os empregados que estavam no conjunto resultante, na ordem 
da sua apaiição inicial e uma lista de novos objetos que a.inda não haviam aparecido 
no Mnpn de Identidade(196) do mapeador de empregados. 

O próximo passo é colocar todos os novos objetos no Mnpo de Identidade (196). 

class carregadorDaTabelaAssociativa ... 

prh·ate void adicionarTodosObjetosNovosll.oMapaDeidentidade 1 } { 
for Uterator it = emProgresso.values 1 1. iteratorl 1: it.hastlext1 } : l 
mapeadorFonte.colocarComocarregado((ObjetoDoDomínio) it.next( I); 

class MapeadorAbstrato.. . 

void colocarCOl'ilOCarregado (OojetoDoDomínio obj) 
mapaCarregado.put (obj.lerIDI 1, obj); 

O passo final é montar a lista resultante procurando os IDs no mapeador. 

class CarregadorDaTabelõ.Associat:va ... 

private List formarResultado() { 

List resultado= new ArrayList ( 1; 

Eor ( Iterator it = idsResultantes.íterator( I; it.hasNext( );) { 

Long id = (Long) ic.nextl ) ; 

resultado.add (mapeadorFonte.procurar (id)l ; 

return r esultado: 

class MapeadorAbstrato. . . 

protected ObjetoDoDonúnio procurar ILong íd) 
retum (ObjetoOoDo;ninio) mapaCarregado.get. (id); 

Tal código é mais complexo do que o código de carga usual, mas esse tipo de 
coisa pode ajudar a diminuir o número de consultas. Já que é complicado, isso é algo 
a ser usado com parcimônia, quando você tiver partes lentas de interação com o banco 
de dados. Entretanto, é um exemplo de como o Mnpcndor de Dntfos (170) pode fornecer 
boas consultas sem que a camada do domínio tome conhecimento da complexidade 
envolvida. 


256 PARTE li • Os PADRÕES 

Mapeamento Dependente (Dependent Mapping) 

Fnz 111110 classe executar o mapenmento do banco de dados 

para uma classefillta. 

{ordenado} Fai)(a 

-~

Álbum -


título 

;,

1 

"'1 
* 

1 

1 
1 

1 
1 

f 

M apeador 
de Álbum 

Alguns objetos apélrecem naturalmente no contexto de outros objetos. As faixas de 
um álbum podem ser carregadas ou gravadas sempre que o álbum correspondente 
for carregado ou gravado. Se elas não forem referenciadas por nenhuma outra tabela 
no banco de dados, você pode simplificar o procedimento de mapeamento fazendo 
o mapeador do álbum executar também o mapeamento das faixas -ou seja, tratando 
este mApeamento como um mnpenmento dependente. 

Como Funciona 

A idéia básica por trás do Mapeamento Dependente é que uma dasse (a dependente) 

depende de alguma outra (a proprietária) para a sua persistência no banco de dados. 

Cada dependente deve ter uma e apenas uma proprietária. 

Isso se manifesta em termos das classes que executam o mapeamento. Para o 
Registro Ativo (165) e o Gateway de Li11ltns de Dndos (158), a classe dependente não conterá 
qualquer cócLigo de mapeamento para o banco de dados. Seu código de mapeamento 
reside na proprietária. Com o Mapcador de Dados (170) ni'io há um mapeador 
para a dependente. O código de mapeamento reside no mapeador da proprietária. 
Em um Gatewny de Tabelas de Dados (151), tipicamente não haverá nenhuma dasse dependente, 
todo tratamento da dependente é feito na proprietária. 

Na maioria dos casos, cada vez que você carrega uma proprietária, você também 
carrega as dependentes. Se for custoso carreg<'lr as dependentes e elas não são 
usadas com freqüência, você pode usar uma Carga Tardia (200) para evitar carregar as 
dependentes até que você precise delas. 

Uma propriedade importante de uma dependente é que ela não tem um Campo 
Identidade (215) e, portanto, ela não é armazenada em um Mapa de Identidade (196). 
Por conseguinte, ela não pode ser carregada por um método de busca que procure 
um 10. De fato, não existe um método de busca para uma dependente, já que todas 
as buscas são feitas com a proprietária. 

A própria dependente pode ser a proprietária de outra dependente. Neste caso, 
a proprietária da primeira dependente é também responsável pela persistência da se



CAPl'r\.lL0 12 • PADRÕES ESTRUTURAIS OSJET0-RE:lACI0NAJS 257 

gunda dependente. Você pode ter toda uma hierarquia de dependentes controlada 
por uma única classe proprietária. 

Normalmente é mais fácil para a chave primária no banco de dados ser uma 
chave composta que inclua a chave primária da proprietária. NcnhUJl'Ul outra tabela 
deverié\ ter uma chave estrangeira apontando para a tabela da dependente, a menos 
que que esse objeto tenha a mesma classe proprietária. O resultado é que nenhum 
objeto na memória além da proprietária ou suas dependentes deve ter uma referência 
para uma dependente. A rigor, você pode relaxar essa regra desde que a referência 
não seja persistida no banco de dados, no entanto, uma referência não persistente 
é por si mesma uma boa fonte de confusão. 

Em um modelo UML, é élpropriado usar composição pa.ra mostrar o relacionêlmento 
entre uma proprietária e suas dependentes. 

Já que a escrita e a gravação das dependentes são deixadas a cargo da proprietária 
e não há referências externas, as atualizações nas dependentes podem ser tratadas 
por mefo de exclusões e inserções. Assim, se você quiser atualizar a coleção 
de dependentes, você pode seguramente excluir todas as linhas que apontam para 
a proprietária e então inserir novamente todas as dependentes. fsso evita que você 
tenha de fazer uma análise dos objetos adicionados ou removidos da coleção da 
ptoprietária. 

As dependentes são, de muitas formas, parecidas com Objetos Vnlor (453), ainda 
que, freqüentemente, elas não precisem de todos os mecanismos que você usa para 
tornar algo emum Objeto Valor (453) (tal como sobrescrever o método equnls). A principal 
diferença é que não há nelas, estritamente no que diz respeito à memória, nada 
de especial A natureza dependente dos objetos, em verdade, deve-se apenas aocomportamento 
de mapeamento para o banco de dados. 

O uso do Mnpenmento Dependeute torna mais complicado descobrir se a proprietária 
foi alterada. Qualquer alteração em uma dependente precisa marcar aproprietária 
como alterada a fim de que a proprietária grave as alterações no banco de dados. 
Você pode simplificar isso consideravelmente tornando a dependente imutável, 
a fim de que qualquer alteração neln tenha de ser feita removendo-a e adicionando 
uma nova. Isso pode tornar o modelo na memória mais difícil de trabalhar, mas simplifica 
o mapeamento para o banco de dados. Embora, em teoria, o mapeamento em 
memória e o mapeamento no banco de dados devessem ser independentes quando 
você está usando um Mnp<'ndor de Dados (170), na prática você tem que, ocasionalmente, 
aderir a essa solução conciliatória. 

Quando Usá-lo 

Você usa um Mapeamento Dependente quando você tem umobjeto que é referendado 
apenas por um único objeto, o que normalmente ocorre quando um objeto tem uma 
coleção de dependentes. O Mnpe11111e11to Dependente é uma boa forma de lidar com a 
situação complicada em que a classe proprietária tem uma coleção de referências para 
as suas dependentes, mas não há um ponteiro reverso. Desde que os muitos objetos 
não precisen, de suas próprias identidades, o uso do Mapenmenf<>Dependente torna 
mais fáci l gerenciar sua persistência. 

Para que o Mnpaa111ento Dependente funcione, existem várias pr~-condições que 
devem ser satisfeitas. 

• Uma classe dependente deve ter uma e apenas uma proprietária. 

258 PARTE li • Os PADRÕES 

• Nenhum outro objeto, com exceção da classe proprietária, deve referenciar as 
dependentes. 
Há uma corrente de projeto 00que usa a noção de objetos entidades e objetos 
dependentes ao projetar um Modelo de Domínio (126). Tendo a pensar no Mnpenmento 
Dependente como uma técnica para simplificar o mapeamento para o banco de dados 
em vez de como uma parte essencial do projeto 00. Em particular, evito grandes 
grafos de dependentes. O problerna com eles é que é impossível referenciar uma dependente 
de fora do grafo, o que muitas vezes leva a complexos esquemas de busca 
basec1dos na proprietária raiz. 

Não recomendo o Mapeamento Dcμc11dcnte se você estiver usando uma Unidade 
de Trabalho (187). A estratégia de remoção e reinserção absolutamente não ajuda se 
você tiver uma Unidade de Trabnllzo (187) cuidando das coisas. Também pode levar a 
problemas, uma vez que a Unidade de Trabalho (187) não estará controlando as dependentes. 
Mike Rettig contou-me a respeito de uma aplicação em que uma U11idade de 
Trnballio (187) cuidaria das linhns inseridas para teste e então as excluiria ao terminar. 
Devido a ela não manter registro das dependentes, linhas órfãs apareceram e causêlrnm 
faU1as nos testes. 

Exemplo: Álbuns e Faixas (Java) 

Neste modelo de domínio (Figurn 12.7), um álbum mantém uma coleção de faixas. 
Esta quase que inútil aplicação simples não precisa de mais nada para referenciar 
urna faixa, de modo que é uma cand.idélta óbvia para um Mapea111e11to Dependente. 
(De fato, qualquer um pensaria que o exemplo foi deliberadamente cliado para o 
padrão.) 

Esta faixa tem apenas o atributo título. Eu a defini como uma classe imutável. 

class Faixa .. . 

private final String título: 
public Faixa (String título) 
this.titulo = título; 

public String lerTítulo ( 1 
retum título: 

As faixas são armazenadas na classe álbum. 

{ordenado} Faixa 

Álbum -


~ 

* 


titulo 

Figura 12.7 Um álbum com faixas que podem ser manipuladas usando um Mapeamento 
Dependente. 


CAPiTUL0 12 • PADRÕES ESTRUTURAIS O8JH0-REtACI0NAIS 259 

class Álbum... 

priva:.e List fa1xas = new Array~ist( ); 
public void adicionarFaixa (Paixa arg) ( 
faixas .add (,1_r9); 

public void removerFaixa (Faixa argl { 

faixas.remove (arg}; 
); 
public void removerFaixa(int i) 

faixas.re.11ove(i ); 

public Paixa{) lerPaixas , ) { 
recurn (Faixa[ J) faixas.toArray(ne~ Paixalfaixas.size( ))); 

A classe mapeadora de álbw1s manipula todo o SQL para as faixas e, portanto, 
define os comandos SQL que acessam a tabela de faixas. 

c_ass MapeadorDeÂlbu~... 

protected String comandoDeBusca () { 
return 
"SELECT ID, a.titulo, f.l{tulo as tituloDaFaixa•+ 

• FROM álbuns a, faixas f•1 
~ WHBRE a.!D s ? ANO f.idDoÁlbum = a.ID' t 
• ORDBR 8Y f ,seq•; 
As faixas são carregadas no álbum sempre que o álbum for carregado. 

class MapeadorDeÂlbum ... 

protected ObjetoDoDominio fazerCarga (Long id, ResultSet rs) throws SQLException ( 
String título= rs.getString(2); 
Álbum resultado= new Ãlbum(id, titulo!; 
carregarFaixastresultado, rsl: 
return resultado; 

} 

public void carregarFaíxas (Álbum arg, ResultSet rs} throws SQLE:xeêption l 
ar9.adicionarFaixa (novaFaixa(rs)) ; 
while (rs.next( ))( 

arg,adicionarFaixa(novaFaixalrs)) ; 

privace FaiY.a novaFaixa (ResultSet rs) thro•,qs SQLBxception { 
String título= rs.getString(3); 
Faixa novaFaixa = new Faixa (titulo}; 
return novaFaixa; 

Para aumentar a clareza, executei a carga de faixas em uma consulta separada. 
Por questões de desempenho, você poderia considernr carregá-las na mesma consulta 
de acordo com a linha seguida no exemplo da página 239-240. 


260 PARTE li • Os PADRÕES 

Quando o álbum é atualizado, todas as faixas são apagadas e reinseridas. 

class MapeadorDeÃlbum... 

public void atualizar (ObjetoOoDo.'tÚnio argl 
PreparedStacement comsndoDeAtual1zacão ~ null; 
try { 

comandolleAtuali2ação = DB,prepare(•UPOATE álbuns SET título=? WHERB id = ?•)r 
comandoDeAtualização.setLong(2, arg.lerlD( ).longValue( )I ; 
Álbum álbum= (Álbum) arg; 
comandolleAtualização.setStri09(l, álbum.lerTitulol )) ; 
comandoDeAtualização.executel ) ; 
atualizarFaixas(álbuml i 

} catch (SOLException e){ 
throw new ApplicationExoeption fe); 
} finally {OB.cleanUp(comandoDeAtualização); 

} 

public void atualizarFaixas (Álbum ar9) thro..-s SQLException { 
PreparedStatement comandoExcluirFaixas: null; 

ti:y { 
comandoExcluirFaixas: DR.prepare('DELSTê FR0M faixas WHERE idDo.Obum: ?•) ; 
comandoExcluírFaixas.setL-0ng{l, arg.lerlD( ).longValue( )); 
comandoExcluirFaixas.executel ); 
for (int i = O; i < arg.lerFaixas() .length; i1+) { 

Faixa faixa e arg.lerFaixas l ) li); 
inserirFaixa(íai.xa, itl, arg); 

Einally {DB.cleanOp(co~andoBxcluirFaixas); 

public void inserirFaixa {Faixa faixa, int seq, tJbum álbum} tbro~s SQLEY.ception ( 
PreparedStaterr.ent comandornserirFaixas: null; 

t!')' { 

comandolnserirFaixas ~ 

DB.prepare(•INSERT INTO faixas (seq, idDoÁlhum, título) VALUBS (?, ?, ?}"); 
comandoinserirFaixas.setint(l, seq); 
comandoinserirFaixas.setLongf2, álbum.lerID() .longValue( li; 
comandoinserirFaixas.setScring(3, faixa.lerTítulo ( )) ; 
comandolnserirFaixas.execute( ); 

Einally {DB.cleanup(cOltàndo!nserirFaixas); 


ÚPllUL0 12 • PADRÕES ESTRUTURAIS OBJET0-RHACI0NAIS 261 

Valor Embutido (Embedded Value) 

Mapeia 11m objeto em diversos campos da tabela de um outro objeto. 

«tabela))

Emprego 

Empregos 

10 1D: int 
pessoa: pessoa idDaPessoa; int 
período: FaixaOeDatas inicio: date 
salário: Dinheiro fim: date 

ValorDoSalãrio: decimal 
moedaDoSalário: char 

Mtúlos objetos pequenos que fazem sentido em um sistema 00não fazem sentido 
como tabelas cm um banco de dados. Exemplos incluem objetos dinheiro que conhecem 
sua moeda e faixas de datas. Embora o pensamento padrão seja gravar um objeto 
como uma tabela, nenhuma pessoa sensata iria querer uma tabela de valores monetários. 


Um Valor Embutido mapeia os valores de um objeto em campos do registro do 
proprietário do objeto. No desenho ten"tos um objeto emprego com referências para 
um objeto faixa de datas e um objeto dinheiro. Na tabela resultante, os campos referentes 
àqueles objetos são mapeados para campos na tabela empregos em vez de eles 
mesmos, criarem novos registros. 

Como Funciona 

Este exercício é, emverdade, muito simples. Quandoo objeto proprietário (emprego) 
é carregado ou gravado, os objetos dependentes (faixa de datas e dinheiro) são carregados 
e gravados ao mesmo tempo. As classes dependentes não terão seus próprios 
métodos de persistência já que toda a persistência é feita pelo proprietário. Você pode 
pensar no Vnlor Embutido corno um caso especial do Mnpenmc11to Depe11de11te (256), 
em que o valor é um único objeto dependente. 

Quando Usá-lo 

Este é um dos padrões no qual a execu~o é bastante direta, mas saber quando usálo 
é um pouco mé\is complicado, 

Os casos mais simples de Valor Embutido são os Objetos Valor (453) claros e simples, 
como dinheiro e faixa de datas. Uma vez que os Objetos Valor (453) não têm 
identidade, você pode criá-los e destruí-los facilmente sem se preocupar com coisas 
como Mapas de Identidade (196) para mantê-los todos em sincronismo. De fato, todos 
os Objetos Valor (453) deveriam ser persistidos como um Valor Embutido, já que você 
nW\ca iria querer urna tabela para eles. 

Uma questão nebulosa é se vale a pena armazenar objetos de referência, talcomo 
um pedido e uma remessa, usando um Valor Embutido. A principal questão Aqui 
é se os dados da remessa têm alguma relevância fora do contexto do pedido. Uma 
questão é a carga e a gravação. Se você só carregar os dados da remessa na memória 


262 PARTE li • Os PAORÕES 

quando você carregar o pedido, este é um argumento para gravar ambos na mesma 
tabela. Uma outra queslc:10 é se você vai querer acessar os dados da remessa separadamente 
por meio de SQL. Isso pode ser importante se estiver fazendo relatórios por 
meio de SQL e não tiver um banco de dados separado para relatórios. 

Se você estiver mapeando para um esquema existente, você pode usar um Vnlor 
Embutido quando uma tabela contiver dados que você divide em mais de um objeto 
na memória. Isso pode ocorrer porque você quer um objeto separado para fatorar 
algum comportamento no modelo de objetos, mas, no banco de dados, ele ainda 
é uma t'mica entidade. Neste caso, você tem que Lomar cuidado para que qualquer alteração 
nos dependentes marque o proprietário como sujo -o que não é um probJema 
com Objatos Vnlor (453) que são substittúdos no propriet~rio. 

Na maioria dos casos, você somente usará um Valor Embutido em um objeto de 
referência quando a associação entre eles tiver um único valor em ambas as extremidades 
(uma associação um-para-um). Ocasionalmente você pode usá-lo se houver 
vários candidatos a dependentes e seu número for pequeno e fixo. Neste caso, voce 
terá campos numerados para cada valor. Isso é um projeto confuso de tabelas, e muito 
ruim pMa consultar com SQL, mas pode trazer benefícios no que se refere ao desempenho. 
Se, entretanto, este for o caso, o LOB Serializado (264) é normalmente a 
melhor escolha. 

Uma vez que muito da lógica para decidir quando usar um Valor Embutido é a 
mesma parél um LOB Serializado (264), existe a questão óbvia de escolher qual dos 
dois usar. A grande vantagem do Valor Embutido é que ele permite que sejam feitas 
consultas SQL nos valores do objeto dependente. Ainda que o uso de XML como Lécnica 
de serialização, junto com extensões do SQL que permitam consultas baseadas 
em XML, possa alterar isso no futuro, no momento você realmente precisa de um Valor 
Emb11tido se quiser usar valores dependentes em uma consulta. Isso pode ser importante 
para mecanismos de relatórios separados no banco de dados. 

Um Vnlor Embutido só pode ser usado para dependentes razoavelmente simples. 
Ele funciona bem para um único dependente solitário, ou para alguns poucos 
dependentes separados. O LOB Seria/izndo (264) funciona melhor com estrutwas 
mais complexas, incluindo subgrnfos de objetos potencialmente grandes. 

leitura Adicional 

O Vnlor E111b11lidc>, emsua história, tem sido chamado por vários nomes diferentes. O 
TOPLink se refere a ele como 111apen111e11to ngregndo. Visual Age se refere a ele como 
compositor. 

Exemplo: Objeto Valor Simples (Java) 

Este é o exemplo clássico de um objeto valor mapeado com um Valor Embulido. Começaremos 
com uma classe simples de oferta de produto com os seguintes campos. 

claes OfertaDeProduto... 

pri~ate Produto produto; 
private Dinheiro custoBásico: 
privace lnteger {O; 


CAPITULO 12 • PADRÕES ESTRUTURAIS OSJET0-RElACIONAIS 263 

Nesse campos o 1D é um Campo identidade (215), e o produto é um mapeamento 
de registros comwn. Mapearemos o custo básico usando um Valor Embutido. Para 
manter as coisas simples, faremos o mapeamento global com um Registro Ativo (165). 

Uma vez que estamos usando um Registro Ativo (165), precisamos de procedimentos 
de gravação e carga. Estes procedimentos simples estão na classe de oferta de 
produtos porque ela é a proprietária. A classe dinheiro não tem nenhum comportamento 
de persistência. Aqui está o método de carga. 

class OfertaDeProduto ... 

public static OfertaDe.Produto carregar (ResulcSet rs) 

try 1 
Integer id = (Integer) rs.getOl>ject(MID~I; 
BigDecinal valorCUstoBâsico = rs.getBigDecimal (•valor_custo_bàsico•I; 
CUrrency moedaCUstoBásico = 
Registro.lerMoeda{rs.getString(•moeda_custo_bàsico•)} ; 
Dinheiro custoBâsico: new Dinheiro {valorCUstoBásico, moedaCUstoBâsiool; 
Integer idDoProduto =(Integer) rs.getObject ("produto-) : 
Produto produto= Produto.buscar( IInteger) rs.9etObject("produto~II; 

return new Ofertao.eProduco(id, produto, custoBásicol; 
} catch (SQLException e)( 
throw new ApplicationException(eJ; 

Aqui está o comportamento de atualização. Mt1is uma vez, é uma simples variação 
das atuaJizações. 

class OfertaDeProduto ... 

public void atualizar 1 ) { 
PreparedStatement d~c =null; 
try { 

dec = OB.prepare(st ringDoComandoDeAtualização); 
dec.setBigDecioal(!, cuscoBásico.quantia( )); 
dec.setString(2, custoBâsico.mceda( ).cóâigo, )>; 
dec.setlntl3, ID.intValue( )l; 
dec.execute( ); 

} catch (Exception e) { 
throw ne·,; ApplicationException(el; 
} finally {DB.cleanUp(decJ;} 

private String stringDoC01!'4ndoDeAtualização e 
'UPDATE oferta_produtos• + 

• SET valor_custo_básico = ?1 moeda_custo_básico = ? • + 
• WHBRE id = ?•; 

264 PARTE li • Os PADRÕES 

LOB Serializado (Serialized LOB) 

Grava 11111 gmfo de objetos sel'ialiumdo-os em 11111 IÍnico objeto grande 
(LOB -í.Arge OBject), oqual ele armazena em 11111 campo do banco de dados. 

{hierarquia} 

pai 

1 
filhos 
Cliente 
1 * Departamento 
* 

«tabela» 

Clientes 

departamentos: 

BLOB 

Os modelos de objetos muitc1s vezes contêm grafos complicados de pequenos objetos. 
A maior parte da informação nestas estruturas não está nos objetos, mas nas associações 
entre eles. Considere o armazenamento da hierarquia de organização de 
todos os seus clientes. Um modelo de objetos muito naturalmente apresenta opadrão 
composição para representar hierarquias organizacionais, e você pode facilmente 
adicionar métodos que lhe permitemobter ancestrais, irmãos, descendentes e 
outros relacionamentos comuns. 

Não é tão fácil colocar tudo isso em um esquema relacional. O esquema básico 
é simples -uma tabela organização com uma chave estrangeira origem, entretanto, 
sua manipulação do esquema requer muitas junções, o que é lento e complicado. 

Os objetos não têm que ser persistidos como linhas de tabelas relacionadas 
umas às outras. Outra forma de persistência é a serialização, onde todo um grafo de 
objetos é gravado como um único objeto grande (LOB) em uma tabela. Este LOB Serializado 
então se toma uma forma de memento [Gang of Four]. 

Como Funciona 

Há duas maneirns por meio das quais você pode executar a serialização: como umbinário 
(BLOB) ou como caracteres texto (CLOB). O BLOB é, freqüentementef o mais 
simples de ct iar, uma vez que muitas plataformas incluem a hAbilidade de serializar 
automaticamente um grafo de objetos. Gravar o grafo éuma simples questão de apli~ 
cara serialização em um buffer e grava.r esse buffer no campo pertinente. 

As vantagens do BLOB são que ele é simples de programar (se a sua plataforma 
suportá-lo) e que ele usa o mínimo de espaço. As desvantagens são que o seu banco 
de dados deve suportar um tipo binário de dados para ele e que você não pode reconstruir 
o gráfico sem o objeto, de modo que o campo é completamente impenetrável 
a uma passada de olhos. O problema mais sério, contudo, é com o controle de 
versões. Se você alterar a classe departamento, você pode não conseguir ler todas as 


CAPITULO 1 2 • PADRÕES ESlRUIURAIS OBJET0-RElACI0NAJS 265 

suas serializações anteriores. Uma vez que os dados podem residir no banco de dados 
por wn longo período, a quantidade de dados pode não ser pequena. 

A alternativa é um CLOB. Neste caso, você serializa o grafo do departamento 
cm uma string de texto que carrega toda a informação de que você precisa. Esta string 
pode ser lida facilmente por um humano vendo a linha, o que ajuda em uma passada 
de olhos pelo banco de dados. Todavia a abordagem do texto normalmente precisará 
de mais espaço, e você pode precisar crfar seu próprio analisador (parser) para o 
formato textual que você estiver usando. Também é provável que ele seja mais lento 
do que uma serialização binária. 

Muitcls das desvantagens dos CLOBs podem ser superadas com o uso de XML. 
Vários analisadores XML estão disponíveis como software livre, de modo que você 
não precisa escrever o seu próprio. Além disso, XML é um padrão amplamente suportado, 
de modo que, para fazer manipulações adicionç1is, você pode tirar proveito 
das ferramentas à medida que elas se tomam disponíveis. A desvantagem que o 
XML não resolve é a questão do espaço. De fato, ele torna a questão do espaço muito 
pior porque ele é um formato bastante prolixo. Uma maneira de lidar com isso é .. 
usar um XML zipado como o seu BLOB -você perde a legibilidade humana dfreta, 
mas é uma opção, se o espaço for realmente um problema. 

Quando você usa um LOB Serializado, cuidado com problemas de identidade. 
Digamos que você queira usar um LOB Serinlízado para armazenar os detalhes do 
cliente em um pedido. Para isso, não coloque o LOB do cliente na tabela de pedidos, 
caso contrário os dados do cliente serão copiados" cada pedido, o que tort1a a c1tualização 
um problema. (Isso pode ser uma coisa boa, entretanto, se você quiser armazenar 
um instantâneo dos dados do cliente como elesernm no instante da colocação 
do pedido -isso evita relacionamentos temporais.) Se você quiser que os dados do 
seu cliente sejam atualizados em cada pedido no sentido relacional clássico, precisa 
colocar o LOB em uma tabela de clientes de modo que muitos pedidos podem ser associados 
a ela. Não há nada de errado com uma tabeJa que tenha apenas um TO e um 
Úl'lico campo LOB como seus dados. 

De um modo geral, tenha cujdado com a duplicação de dados ao usar estepadrào. 
Freqüentemente, não é todo um LOB Serinlizndo que é duplicado, mas parte de 
um que se sobrepõe com parte de outro. O que se tem a fazer é prestar muita r1tenção 
aos dados que são armazenados no LOB Serializado e estar certo de que eles não pos~ 
sam ser alcançados de nenhum outro lugar, mas apenas de um único objeto que atua 
como o proprietário do LOB Serinlizndo. 

Quando Usá-lo 

O LOB Serinlizado não é considerado tão freqüentemente quanto poderia. XMLo torna 
muito mc1is atrativo, uma vez que ele fornece uma abordagem textual fácil de implementar. 
Sue\ principétl desvantagem é que você não pode consultar a estrutura 
usando SQL. Algumas extensões SQL que têm surgido se propõem a alcançar os dados 
XML dentro de um campo, mas ainda não é a mesma coisa (ou portável). 

Este padrão funciona melhor quando você pode extrair um pedaço do modelo 
de objetos e usá-lo para representar o LOB. Pense em um LOB como uma maneira de 
pegar um grupo de objetos que provavelmente não serão pesquisados de fora da 
aplicação usando SQL. Este grafo pode então ser enganchado no esquema SQL. 

Um LOB Serinlizado tem um desempenho sofrível quando objetos fora do LOB 
referenciam objetos enterrados dentro dele. Pr1ra lidM com esse caso você tem que 
descobrir algum tipo de esquema de referências que suporte referências a objetos 


266 PARTE li • Os PADRÕES 

dentro de um LOB -não é de forma alguma impossível, mas é complicado o suficiente 
para geralmente não valer a pena. Mais uma vez XML, ou mais exatamente 
XPath, reduz um pouco esta complicação. 

Se você estiver usando um banco de dados separado para os relatórios, e todas 
as outras consultas SQL forem executadas sobre esse banco de dados, você pode 
tnmsformar o LOB em uma estmtura de tabela apropriada. O fato de que um banco 
de dados para relatórios é normalmente não-normalizado significa que as estruturas 
apropriadas para um LOB Serializado são freqüentemente apropriadas também para 
um banco de dados separado para relatórios. 

Exemplo: Serializando uma Hierarquia de Departamentos em XML (Java) 

Para este exemplo, pegaremos a noção de clientes e departamentos do desenho e 
mostraremos como você poderia scrializar todos os departamentos em um CLOB 
XlvlL. No momento que escrevo isto, a manipulação Java de XML é um tanto primitiva 
e volátil, de modo que, quando você estiver lendo este código, ele poderá parecer 
um pouco diferente daquilo a que você está habituado (também estou usando 
uma versão antiga de JDOM). 

O modelo de objetos do esboço dá origem às seguintes estruturas de classe: 

class Cliente ... 

private String nome; 
private List departamentos = new ArrayList ( ) : 

class Departamento. .. 

private String nome; 
private List subsidiárias= new ArrayList ( I; 

O banco de dados para isso tem apenas wna tabela. 

cre.ite table clientes IID 1nt primary key, nome varchar, departamentos varchar) 

Trataremos o cliente como um Registro Ativo {165) e ilustraremos a gravação dos 
dados com o comportamento de inserção. 

class Cliente... 

public Long inserir () 
PreparedStatement comandoDelnserção = null; 
t:y 1 

comandoDeinserção = OB.prepare (stringDoComando!:lelnserção); 
gravarID (encontrarOPr6ximoIDdoBancoDeDados( )) i 
comandoDeinserçào.set!ntll, lerIO() .intValue( )) ; 
comandoDeinsercão.setString(2, nome); 
comandoDeinserçâo.setScring(3, XmlStringer.write{àepartatnP..ntosParaElementoX~l( ))) ; 
comandoDeinserção.execute( )1 
Registro.adicionart'liente(thisl; 
return lerID( ); 

) cacch (SQLBxception e) 1 

throw nen ApplicationExcepcion(e); 
} f inally {DB. çleanop(cOll'.an(!oDeinserção); 
} 


CAPl)VLO 12 • PADRÕES E5TRUTUAAIS OBJETO-RELACIONAIS 267 

public Element departamentosParaEle~ientoXml () { 
Elemenc raiz: new Elemenc("listaDeDepartameru:os•); 
Iterator i = departa~~ntcs.iteratorl l~ 
wbile (i.hasNexc( li { 

oepartanento dep = (Deparcar.ento) i.next( 1: 
raiz.addC-0ntent (dep.paraEle~entoXml( ll; 

reem,, raiz; 

class Departa~ento... 

Element paraBlementoXml C l t 
Elemento rai2: new Element ("Departamento•) ; 
rai2.setAttribute(•no!:!e", nCY.11e); 
Iterator i = subsidiárias.iterator(); 
whi le (i.has?!ext ( 1) f 

Depananento dep = (Departar.ento) i.next( J; 
raiz.addC-0ntent(dep.paraBlen:eatoXml( 1); 

return raiz; 

O cliente tem um método para serializar seu campo departamentos em um único 
DOM XML. Cada departamento tem um método para serializar a si próprio (e recursivamente 
às suas subsidiárias) também em um DOM. O método de inserção então 
pega o DOM dos departamentos, converte-o em uma string (por meio de uma 
classe utilitária) e a coloca no banco de dados. Não estamos particularmente preocupados 
com a estrutura da string. Ela é legível para humanos, mas não iremos olhar 
para ela regularmente. 

<?xml version:•1.0• encoding=•OTF-8ª?> 
<listaDeDepartalllentos> 
<departamento norne:"US"> 

<departaoenco nome=•New England'> 
<departamento nOlle=•Boston /"> 
<departamento noce=•Verr..ont /"> 

</departamento> 
cdepartaraento nome:NCalifornia /'> 
<departamento nome:•Mid-West /"> 

</departamento> 
<departa0ento nome,,•Europe" /> 
</listaDeDepartamentos> 

Ler os dados de volta é razoavelmente simples. Basicamente é o reverso desse 
processo. 

class Cliente ... 

public static Cliente c.arregar tResultSet rsl throws SQLException { 
Long id: new Long(rs. gettong("idfl)I; 
Cliente resultaào = (Cliente) Regiscro.lerCliente(idl; 
if (resultado J= nulll return resultado; 
String nome = rs.getstring(•no~e•); 


268 PARTE li • Os PAORÕES 

String lobDepartamento: rs.getString(•departamencos•); 
resultado= new Cliente(nome); 
resultado.lerOepartaffientosfXmlStringer.read(lobDeparcamento)I i 
retum resultado; 

void lerDepartamentos (Element fonte) { 
List resultado = new ArrayList ( 1: 
Iterator it = Eonte.getChildren (~departamento•).itentor( I; 
while (it.hasNe.xt{ li 
adicionarDeparramento(Departamento.lerXml((Elemento) it.next( )li ; 

class Departamento. . . 

static Departamento lerXml (Element fonte) ( 
String nome = fonte.gecAttributeValue/•nor.e'); 
Departamento resultado= new Deparcamento{no.ne); 
lterator it = fonte.getChildren(•departamentoft) .iterator( 1: 
while (it ,hasNext ( )) 

resultado.adicionarSubsidiária(lerY.mlf(Slement) Lt.next( 1)1; 
recurn resultado; 

O código de carga é obviamente mna imagem espelhada do código de inserção. 
O departamento sabe como criar a si próprio (e suas subsidiárias) a partir de um elemento 
XML, e o cliente sabe como pegar em elemento XMLe criar a lista de departamentos 
a partir dele. O método de carga usa uma classe utilitária para transformar a 
string do banco de dados em um elemento utilitário. 

Um perigo óbvio aqtú é que alguém pode tentar editar à mão o XML no banco 
de dados e estragar o XML, tornando-o ilegível p<1ra o procedimento de leitura. Ferramentas 
mais sofisticadas que suportassem a adição de um campo contendo um 
DTD ou esquema XMLcom o propósito de validação obviamente ajudaria. 


CAPITULO 1 2 • PADRÕES ESlRUTUAAtS Oaiero-RELACI0NAIS 269 

, 

Herança de Tabela Unica (Single Table lnheritance) 

Representn umn hierarquia de ltemnçn de clnsses como umn 1,11icn tnbela que 
tem coltwns pnrn lodos os campos dns diversas classes dn hiernrquin. 

Jogadores 

nome 
<<tabela» 
Jogadores 
nome 
Jogador de Futebol Jogador de Críquete clube 
média de rebatidas 
clube média de rebatidas média de pontos 
tipo 

Jogador de Boliche 

média de pontos 

Os bancos de dados relacionais não suportam herança, então ao mapear de objetos para 
os bancos de dados, temos que considerar como representar nossas belas estruturas 
de herança como tabelas relacionais. Ao mapear para um banco de dados relacional, 
tentamos minimizar c1s junções (joins) que podem crescer rapidamente ao processar 
uma estrutura de herança em diversas tabelas. A Herança de Tabela Única mapeia todos 
oscampos de todas as classes de uma estrutura de herança em uma única tabela. 

Como Funciona 

Neste esquema de mapeamento de herança, temos uma única t:tbela que contém todos 
os dados de todas as classes da hierarquia de herança. Cada classe armazena os 
dados que sejam relevantes para ela em uma única linha da tabela. Quaisquer colunas 
no banco de dados que não sejam relevantes são deixadas em branco. O comportamento 
básico de mapeamento segue o esquema geral dos Mnpeadores de Herança (291). 

Ao carregar um objeto na memória, você precisa saber qual classe instanciar. 
Para isso você tem um campo na tabela que indica qual classe devetia ser usada. Este 
pode ser o nome da classe ou um campo com um código. Um campo codificado 
precisa ser interpretado por algum código para mapeá-lo para aclasse pertinente. Este 
código precisa ser estendido quando uma nova classe é adicionada ã hierarquia. Se 
você embutir o nome da classe na tabela, você pode usá-lo diretamente para inst,mciar 
uma instância da d<1sse. O nome da classe, entretanto, demandará mais espaço e 
pode ser menos fácil de ser processado por aqueles usando diretamente a estrutura 
da tabela do banco de dados. Além disso, o nome da classe pode acoplar mair fortemente 
é\ estrutltré\ dõ classe ao esquema do bc1nco de dados. 

Ao carregar os dados, você primeiro lê o código para descobrir qual subclasse 
instanciar. Ao salvar os dados, o código precisa ser gravado pela superclasse na 
hierarquia. 


270 PAATE li • Os PADRÕES 

Quando Usá-la 

A Hernnça de Tabela Única é uma das opções para mapear os campos de uma hierarquia 
de herança para um banco de dados relacional. As alternativas são a Herança de 
Tabeln de Classes (276) e a Herança de Tabela Concreta (283). 

Estes são os pontos fortes da Herança de Tabela Única: 

• Só há uma única tabela com a qual se preocupar no banco de dados. 
• Não há junções na recuperação dos dados. 
• Qualquer refatoração que mova campos para cima ou para baixo na hierarquia 
não requer que você altere o banco de dados. 
Os pontos fracos da Nernuça de Tabela Única são: 

• Algumas vezes os campos são relevant~s, algumas vezes não, o que pode ser 
confuso para as pessoas usando diretamente as tabelas. 
• As colunas usadas apenas por algumas subclasses levam a um desperdício 
de espaço no banco de dados. O quanto isso é realmente um problema depende 
das características especificas dos dados e o quão bem o banco de dados 
comprime as colunas vazias. O Oracle, por exemplo, é muito eficiente em 
eliminar espaço desperdiçado, especialmente se você mantiver suas colunas 
opcionais no lado direito da tabela do banco de dados. Cada banco de dados 
tem os seus próprios artifícios para fazer isso. 
• A tabela única pode acabar ficando grande demais, com muitos índices e com 
bloqueios freqüentes, o que pode prejudicar o desempenho. Você pode evitar 
isso tendo tabelas de índices separadas que listem as chaves das linhas que 
tenham uma certa propriedade ou que copiem um subconjunto de campos 
relevantes para um índice. 
• Você tem um único espaço de nomes (11n111espace) para os campos, de modo 
que você tem de estar certo de que não usa o mesmo nome para diferentes 
campos na hie.rarquia. Nomes compostos, com o nome da classe como prefixo 
ou sufixo, ajudélm aqui. 
Lembre-se de que você não precisa usar uma única forma de mapeamento de 
herança para toda a sua hierarquia. É perfeitamente correto mapear meia dúzia de 
classes similares em uma única tabela, desde que você use a Hernnçn de Tabela Concreta 
(283) para quaisquer classes que tenham uma quantidade grande de dadosespecíficos. 


Exemplo: Uma Tabela Única para Jogadores (C#) 

Como nos outros exemplos de herança, baseei este aqui nos Mapeadores de Herança 
(291), usando as classes da Figura 12.8. Cada mapeador precisa ser associado a uma 
tabela de dados em um conjunto de dados ADO.NET. Esta associação pode ser feita 
genericamente na superclasse mapeadora. A propriedade dos dados dognteway é um 
conjunto de dados que pode ser carregado por uma consulta. 


CAPllUL0 12 • PADRÕES ESTRUTURAIS OBJH0-RE:lACIONAIS 271 

class Mapeador ... 

protecced llataTable tabela { 
get freturn Gateway.Data.Tables{NomeOaTabela); ) 

protected Gateway Gate~ay; 
abstract protected String NoceDaTab;!la {get; ) 

Uma vez que só há uma única tabela, esta pode ser definida pelo mapeéldor de 
jogador abstrato. 

class ~apadorDeJogadorAbstrato ... 

protected override String Nor.eDaTabela 1 
get { retum •Jogaàores•;) 

Mapeador 

Mapeador Abstrato 
+inserir(Objeto do Domínio) de Jogador 
+atualizar(Objeto do Domínio) 

<}

+excluir(Objeto do Domínio) 

#gravar

••mêtodos gancho 

#carregar 

#gravar(Objeto do Domínio, Linha) 
#carregar(Objeto do Domínio, Linha) 

6 ~ 

1 
Mapeador de 
Jogador de Futebol 

1


+ busc.ar (chave): Jogador 
-
-
de Futebol 
# gravar 
#carregar Mapeador de 

MapeadordeJogador Jogador de Críquete 

~ 

-
-
+ buscar (chave): Jogador 

+ buscar (chave): Jogador 
-de Críquete 

+ inserir 
~ 
1 #gravar

+ atualizar 
#carregar 

~ 

Mapeadorde 

Jogador de Boliche 

1 + buscar (chave): Jogador 

-,,. de Beliche 
#gravar 
#carregar 

Figura 12.8 O diagrama de classes genérico dos Mapeadores de Herança (291). 


272 PARTE li • Os PADRÕES 

Cada classe precisa de um código de tjpo para auxiliar o código do mapeador a 
descobrir com que tipo de jogador ele está lidando. O código do tipo é definido na 
superclasse e implementado nas subclasses. 

class HapeadorAbstratoDeJ09ador ... 

abstract public String CóóigoDoTipo (get;) 

class MapeadorDeJogadorDeCríquete ... 

public const String CÕDIGO_DO_TIPO = ·e•; 
public override String CódigoDoTipo { 
get (return CÓDIGO_DO_TIPO;) 

O mapeador de jogador tem campos para cada tuna das três classes mapeadorns 
concretas. 

class MapeadorDeJogador... 

private l•!apeadorOeJogadorDeBoliche mapeadorB; 
private MapeadorDeJogadorDecríguete mapeadorC; 
private MapeadorOeJogadorDaF'lltebol mapeadorF; 
public private MapeadorOeJogador (Gate1r,ay gateway) : base (gateway) 

napeadors = new MapeadorDeJogadorDeBoliche (Gate~ayl; 
mapeadorC = new MapeaàorDeJogadorDeCríquete (Gateway); 
mapeadorF = new MapeaàorDeJogadorDePUtebol (Gatewayli 

Carregando um Objeto do Banco de Dados 

Cada classe mapeadora concreta tem um método de busca que traz um objeto dos 
dados. 

class MapeadorDeJogadorDeCríquete ... 

public JogadorDeCríquete Buscar (lons id) 
return (JogadorDeCriquetel BuscaAbstrata(id); 

Isso invoca um comportamento genérico para buscar um objeto. 

class Napeador... 

protected ObjetoOODominio Buscal\bstrata (long idl 
DataRow linha= BuscarLínha (idl; 
return (linha== nulll ? null: Buscar(linha); 

) 

protected DataRow BuscarLinha (long id) 1 
Strir.g filtro= String.Format ("id = (O}", id); 
DataRowl I resultados : tabela.Select (filtro); 
return (resultados.Length == O) ? null: resu!tados(O] ; 

} 

public Objeto.DoDorninio Buscar (DataRow linha) ( 
ObjetoOODomínio resultado= criarObjetoDoDominio ( 11 
Carregar !resultado, linha); 


CAPiT\.IL0 12 • PADRÕES ESTRUTURAIS O8JH0-REl:ACI0NAIS 273 

return resultado; 

abstract protected ObjetoDoDofflínio Cr iarObjetoDoD<:xnlnio( ); 

class ~apeadorDeJogadorOeCríquete .. . 

protected override ObjetoDoDocllinio criarobjetoOODominio ( 1 
return ne~ JogadorDeCriquete( ,; 

Carrego os dados no novo objeto com uma série de métodos de carga, um em 
cada classe na hierarquia. 

class MapeadorOeJogadorOeCríquete... 

protected ovetride void carregar (ObjetoDoOominio obj, DataRo~ linha! 
base.carregar fobj, linhal: 
JogadorOeCríquete jogadorDeCríquete = IJogadorOeCríquete) obj; 
jogadoroecríquete. i:édiaDeRebatidas = (double) linha ( •médiaDeRe.batidas•1 ; 

class ~.apeadorAbstratoDeJogador... 

protected override void Carregar !ObjetoDoDoaínío obj, DataRo-~ linha! 1 
base.carregar (obj, linlull; 
Jogador jogador= (Jogador) obj ; 
jogador.nome " (String) linha(-nome•J ; 

class Mapeador... 

protecced virtual void Carregar (ObjetoDol>om!nio obj, DacaRow linha} 
obj.Id = lintl linha (~id"); 

Também posso carregar um jogadorpor meio do mapeador de jogador. Ele precisa 
ler os dados e usar o código de tipo para determinar qual mapcador concreto usar. 

class MapeadorOeJogador .. . 

public Jogador Buscar llong chave} 
OataRow linha= BuscarLinha (chave); 
if (linha== null) return null; 
else ( 

String códigoOeTipo ~ (String) linha[•cipo•J; 
s~itch (códigoOeTipo) [ 
case MapeadorDeJogadorDeBoliche.CÓDIGO_DE_TIPO: 

return (Jogador) ~~peadorB.Buscar(linha); 
case MapeadorDeJogadorDeCriquete.CÓDIOO_DE_TIPO: 
return (Jogador) mapeadorC.Buscar{linha); 

case MapeadorOeJogadorDeFUtebol.CÓDIGO_DE_TIPO: 
return (Jogador) mapeadorF.Buscar{linha); 
default: 
thr<»' new Excepcion (•tipo desconhecido') ; 


274 PARTE li • Os PAORôES 

Atualizando um Objeto A opernção básica para a atualização é a mesma para todos 
os objetos, de modo que posso defini-la na superclasse mapcadora. 

class Mapeador... 

public virtual void Atualizar (ObjetoOoDoclinio argl 
Gravar (arg, Buscar~inha (arg.id}) ; 

O método de gravação é similar ao método de carga -cada classe o define para 
gravar os dados que contém. 

class MapeadorDeJogadorDeCríquete . . . 

protected override void Gravar (ObjetoDoOomínio obj, OataRow linha) 
base.Gravar(obj, linha); 
JogadorDeCríquece jogadorDeCríquete: (JogadorDecríguete) obj; 
linha(•~édiaDeRebatidasMJ ; jogadorDeCríquete.médiaDeRebatidas; 

class MapeadorAbstratoDeJogacor,.. 

protected override void Gravar (ObjetoDoOOmíoio obj, OataRO'II• tinha} 1 
Jogador jogador : (Jogador} obj : 
linha(Mno.'Tle•J : jogador.nooe; 
linha 1•tipo•) : C6digoDoTipo; 

O mapcador de jogadores transfere para o mapeador concreto apropriado. 

class MapeadorOeJogador... 

public override void Atualizar (ObjetoOoOomi.nio objl 
MapeadorPara(obj) .Atualizar (obj) ; 

priva~e Mapeador ~.apeadorPara (ObjetoOoOor:únio obj) 
if (obj is JogadorDeFutebol) 
return mapeadorF; 
if (obj is JogadorDeBolicheJ 
retum mapeadorB; 
if (obj is JogadorOeCríquete) 
return mapeadorC; 
throw ne~ Exception (•Nenhura mapeador disponível"); 

Inserindo um Objeto As inserções são semelhantes às atualizações. A única diferença 
real é que uma nova linha precisa ser criada na tabela antes da gravação. 

class Hapeador... 

public virtual long Inserir (ObjetoOoDocnlnio argl 
DataRow linha = tabela. NewRa.,( 1; 
arg,Iõ ~ LerPróximoID( ); 
linhal'id~I : arg.!d; 
Gravar (ar9, linha); 


CAPil\JLO 12 • PADRÕES ES'ffiUTUAAIS 0WETO-RELAOONAIS 275 

tabela.Rows.Add(linhal; 

return arg. Id; 

class mapeadorOeJogador .. . 

public override long Inserir (ObjetoDoDonúnio obj) 
return MapeadorPara(obj) .tnserir(obj}; 

Excluindo um Objeto As exclusões são bastante simples. Elas são definidas no nfvel 
do mapcador abstrato ou no envoltório do jogador. 

class Mapeador.. . 

public virtual void Kxcluir (ObjetoDoDo.1\Ínio obj) 
DataRow linha= BuscarLinha (obj.Idl ; 
linha.Delete( ); 

class Mapeado.rOeJogador ... 

public override void Kxcluir (ObjetoDoDonúnio obj) 
MapeadorPara(obj ).Bxcluir(obj); 


276 PARTE li • Os PADRÕES 
Herança de Tabela de Classes {Class Table lnheritance} 

Representa 11111n J,ietarquin de /zcrança de classes 
com 11111n tabela para cnda classe. 

Jogador «tabela» 
JogadoresDeFutebol 
nome 

clube 

«tabela» 
JogadoresDeCríquete 
Jogador de futebol Jogador de Críquete 
média de rebatidas 
clube média de rebatidas 

«tabela» 
Jogadore.sDeBoliche 

média de pontos 
Jogador de Beliche 

média de pontos ,<tabela» 

Jogadores 

nome 

Um aspecto muito visível da incompatibilidade objcto-reladonnl é o fato de que os 
bcmcos de dados relacionais não suportam heranç<1. Você quer estn1turas de bancos 
de dados que mapeiem claramente para os objetos e que permitam associações em 
qualquer litgar da estrutura de herança. A Herança de Tnbeln de Clnsscs suporta isso, 
usando uma tnbela no bérnco de dados por classe da esb·utura de herança. 

Como Funciona 

A característica evidente da Herança de Tabela de Classes é que ela possui uma tabela 
por classe no modelo do domínio. Os campos nas classes do domínio são mapeados 
diretamente para campos nas tabelas correspondentes. Assim como com os outros 
mapeamentos de herança, aqui também se aplica a abordagem básica dos Mapendo


res de Hern11çn (291). 

Uma questão é como associar as linhas correspondentes das tabelas do banco 
de dados. Uma solução possível é usar um valor de chave primária comum, de modo 
que, digamos, a linha dA chave 101 na tabela de jogadores de futebol e a linha da 
chave 101 na tabela de jogadores correspondam ao mesmo objeto do domínfo. Visto 
que a tabela da superclasse tem uma linha para cada linha nas outras tabelas, se você 
usar este esquema as chaves primárias serão únicas por todas as tabelas. Uma alternativa 
é deixar cada tabela ter suas próprias chaves primárias e usar chaves estrangeiras 
apontando para a tabela da superclasse para conector as linhas. 

O maior problema na implementação da Herança de Tabela de Classes é como recuperar 
os dados a partir de diversas tabelas de uma maneira cfiàente. Obviamente, fazer 
uma chamada para cada tabela não é bom, já que você teria divexsas chamadas para 
o banco de dados. Você pode evitar isso fazendo uma junção (joitt) pelas diversas ta



ÚPllUL0 12 • PADRÕES ESTRUTURAIS O!UET0-RHACI0NAIS 277 

belas componentes. Não obstante, junções paJ'a mais de três ou quatro tabelas tendem 
a ser lentas devido ao modo pelo qual os bancos de dados executam suas otimizações. 

Além disso, há o problema de que freqüentemente você não sabe exatamente 
quais tabelas juntar em uma consulta. Se você estiver procurando um jogador de futebol, 
você sabe usar a tabela de jogadores de futebo1, mas se você estiver procurando 
por um grupo de jogadores, quais tabelas você usa? Para realizar junções de maneira 
eficaz quando algumas tabelas não têm dRdos, você precisRrá fazer uma junção 
externa (outer join), a qual não é padrão e, freqüentemente, é lenta. A altern<ltiva é ler 
primeiro a tabela raiz e então usar um código para descobrir quais tabelas ler a segwr, 
mas isso envolve múltiplas consultas. 

Quando Usá-la 

Herança de Tabela de Classes, Herança de Tabela Única (269) e Hera11ça de Tabela Concreta 

(283) são as três alternativas a considerar para o mapeamento de herança. 
Os pontos fortes da Herança de Tabela de Classes são: 
• Todas as colunas são relevantes para todas as linhas, de modo que as tabelas 
são mais fáceis de compreender e não desperdiçam espaço. 
• O relacionamento entre o modelo do donúnio e o banco de dados é bastante 
direto. 
Os pontos fracos da Hera11ça de Tnbeln de Clnsses são: 

• Você precisa alcançar diversas tabelas para carregar um objeto, o que significa 
uma junção ou diversas consultas para depois costurar os pedaços em memória. 
• Qualquer refatoração de campospara ci_ma ou para baixo na hierarquia gera 
alterações no banco de dados. 
• As tabelas dos supertipos podem se tornar um gílrgalo porque elê'ls têm de 
ser acessadas freqüentemente. 
• A alta normalização pode torná-la difícil de entender em consultas rui hoc. 
Você não tem que escolher apenas um padrão de mapeamento de herançR para 
uma hierarquia de classes. Você pode usar Herança de Tabela de Classes para as classes 
no topo da hierarquia e uma coleção de Heranças de Tabela Concreta (283) para aquelas 
mais abaixo. 

Leitura Adicional 

Vários textos da IBM referem-se a este padrão como Mapeamento Raiz-Folha (RootleafMappi11g) 
[Brown et ai. ]. 

Exemplo: Jogadores e Assemelhados (C#) 

Aqui está a implementação para a descrição. Novamente seguirei o tema familiar 

(talvez um pouco tedioso) de jogadores e assemelhados, usando Mnpearlores de Heran


çn {291) (Figura 12.9). 


278 PARTE li • Os PAORôES 

Mapeador 

Mapeador Abstrato 

+inserir (Objeto do Domínio) de Jogador 
+atualizar (Objeto do Dominio) 
+excluir (Objeto do Domínio) 
<1 

#gravar

-métodos gancho 

#carregar

#gravar {Objeto do Domínio, Linha) 
#carregar (Objeto do Domlnio, Linha) 

6 1 
~ 

Mapeador de 
Jogador de Futebol 

1 

+ buscar (chave): Jogador 
-

~ 

de Futebol 
#gravar 
#carregar Mapeador de 

Mapeador de Jogador Jogador de Críquete 

-+ buscar (chave): Jogador 

+ buscar (chave): Jogador -
deCriquete

+ inserir 
~ 
1 #gravar

+ atualizar 
#carregar 

~ 

Mapeador de 
Jogador de Boliche 

1 + buscar (chave): Jogador -de Boliche

-

#gravar 
#carregar 

Figura 12.9 O diagrama de classes genérico dos Mapeadores de Herança (291). 

Cada classe precisa definir a tabela que armazena os seus dados e um código de 
tipo para ela. 

claes HapeadorAbstratoDeJogador... 

abstract pub!ic String CódigoDoTipo (get;) 
protected static String NOME_DA_TABELA = 'Jogadores•; 

claes Hapeadol'OeJogadorDeF\Jtebol ... 

public override String C6digoDoTipo { 
get lreturn •r•;) 

protecteó new static String ll014B_DA_TABSLA :e •JogadoresOeFutebol"; 

Diferentemente dos outros t?Xemplos de herança, este não tem um nome de tabcla 
sobrescrito porque temos de ter o nome da tabela para esta classe mesmo quando 
a instância é uma instância da subcl<1sse. 


CAPiTUL0 12 • PADRÕES EsTRUTURAIS OaJET0-RE:lACIONAIS 279 

Carregando um Objeto Se você tiver lido os outros mapeamentos, você sabe que o 
primeiro passo é o método de busca nos mapeadores concretos. 

class MapeadorOeJogadorDeFutebol . . . 

public JogadorDeFutebol Buscar llong idl 
return (JogadorDeFutebol) BuscaAbstrata lid, NOME_DA_TABE!J\); 

O método abstrato de busca procura uma linha que seja igual à chave e, se encontrar, 
cria um objeto do domínio e chama o seu método de carga. 

class Kapeador... 

public ObjetoDoDominio BuscaAbstrata (long id, String nomeDaTabela) 
DataRo~ linha= BuscarLinha lid, tabelaPara (noffieDaTabela)) ; 
if (linha:: null) return null; 
else ( 

ObjetoDoDominio resultado e CriarôbjetoOoOominio( l; 
resultado.Id = id; 
Carregar (resultado); 
return resultado; 

protecteà DataTable tabelal►.lra 
(String nomet 
return Gateway.Data.Tables{nome); 

protected DataRow BuscarLinha (long id, DataTable tabela) 
String filtro= String.Fc!ll'lat('id = {oJ•, id); 
DataRow [) resultados= tabela.Select {filtro); 
return (resultaóos.Length == OI ? null: resultados[O) ; 

protecced DataRow BuscarLinha (long id, String nooeDaTabela) 
return BuscarLinha (id, tabelaPara(norr.eDaTabela)I; 

protected abstract ObjetoDoDocn!nio criarObjetoDoDomínio l I; 

class NapeadorOeJogadorDePutebol ... 

protected override ObjetoDoDomlnio CriarObjetoOoDominio 11 
return new JogadorDeFutebol ( ) ; 

Existe um método de carga para cada classe que carrega os dados definidos por 
essa classe. 

class MapeadorDeJogadorDeFUtebol.,. 

protected override void Carregar (ObjetoDoOomínio obj ) 
base.carregar(obj ); 
DataRow linha: BuscarLinha (obj.là, tabelaPara (NOME_DA_TABEL.~)t ; 
JogadorDeFutebol jogadorDeFutebol = (JogadorDeFutebol) obj; 
jogadorDePutebol.clube ,. {String) linha [•clube•J; 


280 PARTE li • Os PAORÕES 

class MapeadorAbstratoDeJogaàor ... 

protected override void carregar !ObjetoDoDominio obj) 
DataRO'N linha: BuscarLinha fobj.Id, tabelaPara(NOME_0A_TABELA)); 
Jogador jogador~ (Jogador) obj; 
jogador.nor.ie; (String! linha(ttnome'I; 

Assim com o outro exemplo de código, porém de forma muito mais perceptível 
aqui, estou contando com o fato de que o conjunto de dados AOO.NET trouxe os dados 
do banco de dados e os colocou em cache em memória. Tsso me permite fazer diversos 
acessos à estrutura de dados baseada em tabeJas sem um alto custo em desempenho. 
Se você for diretamente ao banco de dados, precisará reduzir essa carga. 
Neste exemplo, você poderia fazer isso criando uma junção por todas as tabelas e 
manipulando o resultado. 

O mapeador de jogadores determina que tipo de jogador ele tem que buscar e 
então delega ao mapeador concreto correto. 

class MapeadorDeJogador... 

public Jogador Buscar (lcng chave} 
DataRO'» línha = BuscarLinha (chave, cabelaPara (NOME_DA_TABBLA)); 
if (linha == null) recurn null; 
else { 

String códigoDoTipo = (String) linha[•tipo•J; 
if (códigoDoTipo == mapeadorB.CódigoDoTipo) 
return mapeadorB.Buscar(chave); 
if (c6digoDoTipo == mapeadorC. CódigoDoTipo) 
return mapeadorC.Buscar(chave); 
if tc6digoDoTipo == mapeadorF. CódigoDoTipo) 
return mapeadorF.Buscar(chave); 
throw new Exception(•tipo desconhecido"); 

protected static String NOME_DA_TABSLA = •Jogadores•; 

Atualizando um Objeto O método de atualização aparece na superclasse mapeadora. 

class Napeador... 

public virtual void Atualizar (ObjetoDoOooinio arg) 
Gravar (argl; 

Ele é implementado por meio de uma série de métodos de gravação, um para 
cada classe na hierarquia. 

class NapeadorDeJogadorDe:'utebol ... 

protecteã override ,·oid Gravar (0bjetoDoDoatinio oi>j} 
base.Gravar(objl; 
DataRow 1 inha = BuscarLinha (obj. ld, tabelaPara(N0:-18_DA_TABELAI) ; 
JogadorDe?utebol jogadorDeFutebol = (JogadorDe?utebol) obj; 
linha ( 'clube') = jogadorDeFUtebol.clube; 


ÚPÍT\JL0 12 • PADRÕES ESTRUTURAIS O8JH0-RElACIONAIS 281 

class MapeadorAbstratoDeJogador... 

protected override void Gravar (ObjetoDoDominio objl 
Data~w linha: Buscarl.inha (obj.ló, tabelaPara{NO:-lB_DA_TABELA)); 
Jogador jogador = (Jogador) obj; 
linhal•nocne•J : jogador.nQne; 
linhal"tipo•) = CódigoDoT1po; 

O método de atualização do mapeador de jogadores redefine o método geral 
para transferir pê'lra o mapeador concreto correto. 

class KapeadorDeJogador ... 

public override void Atualizar (ObjetoDoDomínio objl 
MapeadorPara (obj) .Atualizar(obj 1; 

private Mapeador MapeadorPara (ObjetoDOOOt!Únio obj) 
if (obj is JogadorDeFuteboll 
return mapeadorP; 
if (obj is JogadorDeBoliche) 
return ma.peadorB; 
if (obj is iTogadorDeCríqueceJ 
return ma.peadorC; 
thrm, new Exception (•Uenhum mapeador disponível•) ; 

Inserindo um Objeto O método para inserir um objeto é declarado na superclasse 
mapeadora. Ele tem dois estágios: criar novas linhas no banco de dados e, então, 
usar os métodos de gravação para atualizar estas linhas em branco com os dados 
necessários. 

class Mapeador ... 

public virtual long L~serir (ObjetoDoDomínio obj) 
obj.Id = LerPr6ximoID () ; 
Adícionartinhalobj) ; 
Gravar (obj1 ; 
retum obj. Id; 

Cada dasse insere uma linha em sua tabela. 

cl~ss MapeadorDeJogadorDeFUt ebol . .. 

protected override void AdicionarLinha (ObjetoDo!lomínio obj) 
base.AdicíonarLinha (obj); 
lnserirLinha (obj, cabelaPara(NOME_DA_TABEt.All ; 

class MapeadorAbstratoDeJogador.. . 

protected override void AdicionarLinha (ObjetoOODomínio obj) 
lnserirLinha (obj, tabela?ara (NONE_DA_TABEt.A) 1; 


282 PARTE li • Os PAORÕES 

class Mapeador ... 

abstract protected void AdícionarLinha (Objet-0DoDomínio obj); 

protecteà virtual void InserirLinha ((ObjetoDoDo<ninio arg, DataTable tabela) 
DataRow linha= tabela.Ne~Ro~ ( l: 
linhal'id~l : arg,Id; 
tabela.Rows.Add llinhal ; 

O mapeador de jogadores delega ao mapendor concreto apropriado. 

class MapeadorDeJogador.. . 

public override 10119 Inserir (ObjetoDoDomínio obj) 
return MapeadorPara(obj) .loserir(obj}; 

Excluindo um Objeto Para exduir um objeto✓ cada classe exclui uma linha da tabela 
correspondente no banco de dados. 

class MapeadorDeJogadorDe?'lltebol . .. 

public override void Excluir {ObjetoDoDooúnio obj) 
base.Excluir (obj); 
Dat aRow linha= BuscarLinha (obj.Id, l{O~!E_DA_TABELA)i 
linha.Deletel I; 

class MapeadorAbstratoOeJogador .. , 

public override void Excluir (ObjetoDoDominio obj) { 
DataRow linha = BuscarLinha lobj .Id, tabelaPara UIO.\JE_DA_TABELA) 1 ; 
linha.Delate(); 

class Mapeador ... 

public abstract void Excluir {ObjetoDoDominio obj); 

O mapeador de jogadores novamente foge do trabalho duro e apenas delega 
para o mapeador concreto. 

class MapeadorDeJogador... 

public override void Excluir {ObjetoDoDomínio obj) 
MapeadorPara (obj) . Excluir(ohj) ; 


CAPi'rUL0 1 2 • PADRÕES ESTRUTURAIS OBJETO-RELACIONAIS 283 

Herança de Tabela Concreta (Concrete Table lnheritance) 

Representa t1111 hierarquia de lterm1çn de classes 
co111 11111a tabela por classe concreta na ltiernrq11ia. 

Jogador «tabelan 
Jogadores-DeFutebol 

nome 

nome 
clube 

Jogador de Futebol Jogador de Críquete e1 tabela» 
JogadoresOeCrlquete 
clube média de rebatidas 
nome 
média de rebatidas 

Jogador de Beliche utabela» 

JogadoresDeBoliche 
média de pontos 

nome 

média de rebatidas 

média de pontos 

Como qualquer purista da orientação a objetos lhe dirá, os bancos de dados relacionais 
não suportam herança -um fato que complica o mapeamento objeto-relacional. 
Do ponto de vista da instância de um objeto, um caminho sensato para pensar em tabelas 
é pegar cada objeto na memória e mapeá-lo para uma única linha no banco de 
dados. Isso sugere a Herança de Tabela Concreta, na qual existe uma tabela para cada 
classe concreta na hierarquia de herança. 

Confesso que tive alguma dificuJdade para dar um nome para este padrão. A 
maioria das pessoas pensa nele como orientado a folhas, já que você normalmente 
tem uma tabela por classe fofüa em uma hierarquia. Segufado essa lógica, eu poderia 
chamar este padrão de herança de tabela fofüa, e o termo "folha" é freqüentemente 
usado para este padrão. A rigor, entretanto, uma classe concreta que não seja uma 
folha normalmente também tem uma tabela, de modo que resolvi escolher o termo 
mais correto, ainda que menos intuitivo. 

Como Funciona 

AHerança de Tabela Concreta usa uma tabela do banco de dados para cada classe concreta 
na hierarquia. Cada tabela contém colunas para a classe concreta e todos os 
seus ancestrajs, de modo que qualquer campo na superclasse é duplicado pelas tabelas 
das subclasses. Assim como com todos estes esquemas de herança, o comportamento 
básico usa Mapeadores de Herança (291). 

Com este padrão, você precisa prcst<1r atenção às chaves. Fazendo um trocadilllo, 
a chave é assegurar que as chaves sejam únicas não apenas para uma tabela, mas 
para todas as tabelas de uma hierarquia. Um exemplo clássico de onde você precisa 
disto é se você tiver uma coleção de jogadores e estiver usando um Campo Identidade 


284 PARTE li • Os PAORÕES 

(215) com chaves com escopo de tabela. Se as chaves puderem ser duplicéldas entre 
as tabelas que mapeiam as classes concretas, você terá diversas linhas para um valor 
pArticular da chave. Assim, você realmente precisa de wn sistema de alocação de 
chaves que fique de olho no uso das chaves pelas tabclas. Além disso, vocc não pode 
depender do mecanismo de unicidade de chaves primárias do banco de dados. 
Isso se torna especialmente complicado se você estiver preso a bancos de dados 
usados poroutros sistemas. Em muitos desses casos, você não pode garantir a unicidade 
das chaves pelas tabelas. Nesta situação, ou você evita usar os campos da superclasse 
ou usa uma chave composta que envolva um identificador de tabela. 

Você pode evitar algw1s destes problemas não tendo campos do tipo da superclasse, 
mas isto obviamente compromete o modelo de objetos. Um;i alternativa é ter 
métodos de acesso para o supertipo na interface mas usar vários campos privados 
para cada tipo concreto na implementação. A interface então combina os valores dos 
campos privados. Se a interface pública for um único valor, ela pega qualquer um 
dos valores privados que não forem nulos. Se a interface pública for uma coleção, ela 
responde com a união dos valores dos campos da implementação. 

Para chaves compostas você pode usar um objeto chave especial como seu campo 
[0 para o Campo Identidade (215). Esta chave usa tanto a chave primária da tabela 
como o nome da tabela para garantir unicidade 

Relacionados a isso, estão os problemas com a integridade referencial no banco 
de dados. Considere um modelo de objetos como o da Figura 12.10. Para implementai-
integridade referencial, você precisa de uma tabela associativa que contenha colunas 
de chaves estrnngeiras para a função caridade e para o jogador. O problema é 
que não existe uma tabela parn o jogador, de modo que você não pode montar uma 
restrição de integridade referencial para o campo da chave estrangeira que recebe 
tanto jogadores de futebol quanto de críquete. A sua escolha éentre ignorar a integridade 
referencfal ou usar múltiplas tabelas associativas, uma para cada uma das tabelas 
concretas no banco de dados. Além d.isso, você terá problemas se não puder garantir 
a unicidade das chaves. 

Se você estiver procurando por jogadores com um comando select, precisa 
olhar todas as tabelas para ver quais contêm o valor apropriado. Isso significa usar 
múltiplas consultas ou usar uma junção externa (outer joi11}, ambas opções ruins no 
que se refere ao desempenho. Você não sofre o problema do desempenho quando 
sabe de qual classe precisa, mas você tem que usar a classe cona-eta para melhorai
º desempenho. 

Jogador 

Função Caridade 

* * 
* * 
nome 

y 

1 1 

Jogador de Futebol Jogador de Críquete 

clube média de rebatidas 

Figura 12.1 O Um modelo que causa problemas de integridade referencial para a 

Herança de Tabela Concreta. 


ÚPllUL0 12 • PADRÕES ESTRUTURAIS OíilET0-RElACI0NAIS 285 

Muitas vezes, este padrão é mencionado como sendo alinhado com o padrão 
herança de tabela de folhas. Algumas pessoas preferem uma variação na qual 
você tem uma tabela porclasse folha em ve-z de uma tabela porclc1sse concreta. Se 
você não tiver nenhuma superclasse concreta na hierarquia, isso acaba sendo a 
mesma coisa. Mesmo se você tiver superclasses concretas, a diferença é bem pequena. 


Quando Usá-la 

Ao buscar a solução para mapenr herança, as alternativas são: Hcra11çn de Tabela Concreta, 
l lernnça de Tabeln de Classes (276) e llerm1ça de Tabela Ú11icn (269) . 
Os pontos fortes da Hera11ça de Tahela Concreta são: 

• Cada tabela é autocontida e não tem campos irrelevantes. A conseqüência é 
que ela faz bastante sentido quando usada por outras aplicações que não estejam 
usando os objetos. 
• Não há junções a realizar durante a leitura dos dados dos mapeadores concretos. 
• Cada tabela é acessada apenas quando a classe é acessada, o que pode desconcentrar 
n carga de acesso. 
Os pontos fracos da Hernuçn de Tabela Concreta são: 

• Pode ser difícil tratar as dtaves primárias. 
• Você não pode forçar relacionamentos no banco de dados parn classes abstratas. 
• Se os campos das classes do domínio subirem ou descerem na hierarquia, você 
tem que alterar as definições das tabelas. Você não tem que fazer tantas alterações 
como com a llemnçn de Tnbeln de Classes (276), mas você não pode ignorar 
esse fato, como fizemos na Hcrnnçn de Tnbcln Única (269). 
• Se um campo da superclasse for alterado, você precisa aJterar cada tabela que 
tenha este campo porque os campos da superclasse são duplicados pelas tabelas. 
• Uma busca na superclasse obriga você a vei:ificar todas as tabelas, o que leva 
a múltiplos acessos ao banco de dados (ou a uma junção esquisita). 
Lembre-se de que o trio de padrões de herança pode coexistir em uma única 
hierarquia. Assim, você poderia usar a Herança de Tabela Concreta para uma ou duas 
subclasses e Hernnçn de Tabela Única (269) para o resto. 

Exemplo: Jogadores Concretos (C#) 

Aqui mostrarei uma implementação pt'lra a descrição do padrão. Assim como em to


dos os exemplos de herança neste capítulo, estou usando o projeto básico das classes 

de Mapcadores de Herança (291), mostrado na Figura 12.11. 

Cada mapeador é associado à tabela do banco de dados que é a fonte dos dados. 
Em ADO.NET um conjunto de dados (dntn sef) armazena os dados da tabela. 


286 PARTE li • Os PADRÕES 

Mapeador 

Mapeador Abstrato 

+inserir (Objeto do Domínio) de Jogador 
+atualizar (Objeto do Domínio) 

+ excluir (Objeto do Oomlnio) 
<J 

#gravar

-métodos gancho 

#carregar

#gravar (Objeto do Domínio, Linha) 
#carregar (Objeto do Domínio, Linha) 

6 ~ 

1 
Mapeadorde 
Jogador de Futebol 

1


+ buscar (chave): Jogador 
-de Futebol 
#gravar 
#carregar Mapeador de 
Mapeador de Jogador Jogador de Críquete 
+ buscar (chave): Jogador 
+ inserir 
+atualizar 
-~ -+ buscar (chave): Jogador -de Críquete 
1 #gravar 
#carregar 

~ 

Mapeador de 
Jogador de Boliche 

1 

+buscar (chave): Jogador -de Boliche
-

#gravar 
#carregar 

Figura 12.11 O diagrama de classes genérico dos Mapeadores de Herança (291 ). 

class Mapeador... 

public Gateway Cateway; 
private rolctionary mapaDeident1daôe: ne-i.• Hashcablel >: 
publ ic Mapeador (Gateway 9ateway) ! 

this .Gateway: gateway; 

} 

private DataTable tabela { 
get {return Gateway.Data.Tables!NocneOaTabelaJi) 

} 

abstract public String No::ieDaTabela {get;) 

A classe gaft:wny armazena o conjunto de dados dentro de sua prnpriedade de 
dados. Os dados podem ser carregados fornecendo-se consultas apropriadas. 

class Gateway... 

public OataSet Dados : ne~ DataSet ( ); 


CAPiT\JL0 1 2 • PADRÕES ESTRUTURAIS O8JET0 -RElACI0NAtS 287 

Cada mapeador concreto precisa definir o nome da tabela que armazena seus 
dados. 

claes MapeadorOeJogadorDeCriquete ... 

public overrjde String No.1eDaTabela { 
9ec {return •JogadoresDeCríquete~;J 

O mapeador de jogadores tem campos para cada mapeador concreto. 

class NapeadorDeJogador.. 

privat~ ~.apeadorDeJogadorOeBoliche mapeadorB; 
private MapeadorDeJogaâorDeCriquete mapeadort; 
private MapeadorDeJogadorDeFutebol mapeadorF; 
public MapeadorDeJogador (Gateway gate'l/ay): base (gateway) 

mapeadora = new MapeadorDeJogadorOeBoliche (Gatewayl1 
mapeadorC = new MapeadorDeJogadorDeCriquete IGateway); 
mapeadorF = new MapeadorDeJogadorOeFUtebol (Gatewayl; 

Carregando um Objeto do Banco de Dados Cada classe mapeadora concreta tem 
um método de busca que retorna um objeto dado um valor da chave. 

class MapeadorOeJogadorOeCríquete... 

public JogadorDeCriquete Buscar (long id) 
recurn (Jogadoroecríquetel BuscaAbstrata{idl; 

O comportamento abstrato na superclasse busca a linha correta do banco de dados 
para o 1D, cria um novo objeto do domínio do tipo correto e usa o método de carga 
para carregá-lo (descreverei a carga logo em seguida). 

class Mapeador... 

public ObjetoDoDomínio Buscv.bstrata (:ong idl { 
DataRow linha= BuscarLinha tidl; 
if (l inha== null) return null; 
else{ 

ObjetoDoDomínio resultado= CciarObjetoOoDomíniol l ; 
Carregarlre&ultado, linha)1 
return resultado; 

private DataRo~ BuscarLinha (long id) { 
String filtro= String.Foill\at( ijid ~ (o}•, id) ; 
DataRo~( 1 resultados= tabela.Select{filtro); 
if {resultados.Length =~ O) return null; 
else retum resultados[O); 

} 

protected abstract ObjetoDoDomínio CriarO~jetoDoOO.~ínio( ); 


288 PARTE li • Os PAORÕES 

class MapeadorDeJogadorDeCriquete... 

protetected override ObjetoDoDomínio CriarObjetoDoDominio 1 1 ( 
retum new Jogador:>eCriquete l ); 

A c.u·ga real de dados do banco de dados é feita pelo método de carga, ou entiio 

por diversos métodos de carga: um de cada para a classe mapeadora e para todas as 

suas superclasses. 

class MapeadorOeCríÇ\lete... 

protected override void Carregar IObjetoOeOominio obj. DataRO'x linha) 
base.Carregar(obj, linha); 
JogaàorDeCriquete jogadorOeCriquete; IJogadorDeCriquete) obj; 
jogadorDeCríquete. ~édiaDeRebatidas: (double) linha(•médiaDeRebatidas~I; 

class MapeadorAbstratoDeJogador... 

protected override void Carregar (ObjetoOoDomínio obj, DataROíi linha) { 
base.Carregar(obj, linha); 
Jogacor jogador~ (Jogador) obj; 
jogador.nome: (String) linhal•non:e•J; 

class Mapeador .. . 

protecteô virtual void Carregar (ObjetoOODom!nio obj, DataRow linha) ( 
obj.Id: (intl linhal"id•); 

Esta é a lógica para encontrar um objeto, usando um mapeador para uma classe 
concreta. Você também pode usar um mapeador para a superclasse: o mapeadot 
de jogadores, o qunl precisa buscar um objeto de qualquer tabela em que ele esteja residindo. 
Uma vez que todos os dados já estão no conjunto de dados em memória, 
posso fazer isso como: 

class HapeadorDeJogador.. . 

public Jogador Buscar (long chave) 
Jogador resultado; 
resultado " etapeadorF .Buscar(chave); 
if (resultado!= null ) return resultado; 
resultado= QapeadorB.Buscar(chavel; 
lf (resultado l= nulll return resultado; 
resultado= capeadorC.Buscar(chavel; 
if (resultado l= null) return resultado; 
return null; 

Lembre-se de que isso é razoável apenas porque os dados já estão na memória. 
Se você precisar ir ao banco de dados três vezes (ou mais para mais subclasses), isso 
ficará lento. Pode ajudar a executar uma junção por todas as tabelas concretas, o que 
lhe permitirá acessar os dados em uma única chamada ao banco de dados. Entretanto, 
junções grandes são, por direito, freqüentemente lentas, de modo que você preci



CAPITULO 12 • PADRÕES ESTRUTURAIS OaJET0-RELACIONAIS 289 

sará executar alguns testes com sua própria aplicação para descobrir o que funciona 
e o que não fw1ciona no seu caso. A16m disso, esta será uma junção externa (outer 
join), a qual, além de tomar lenta a consulta, usa uma sintaxe não-portável e freqüentemente 
obscura. 

Atualizando um Objeto O método de atualização pode ser definido na superclasse 
mapeadora. 

class Napeador ... 

public virtual void Atualizar (ObjetoDoDo:ninio arg) 
Gravar (arg, BuscarLinha (arg.Jd) ); 

De forma semelhante à carga, usamos uma seqüência de métodos de gravação 
para cada classe mapeadora. 

class MapeadorDeJogadorDeCríquete. . . 

protected override void Gravar {ObjetoDoOominio obj, DataRow linha) 
base.Gra·,ar (obj, linha); 
JogadorDeCriquete jogadorDeCríquete =(JogadorDeCríquete) obji 
linhal""-édiaOeRebatidas•j =jogadorDeCríquete.médiaDeRebatidas; 

class MapeadorOeJogadorAbstrato.. . 

protecced override void Gravar (ObjetoDeDooúnio obj, Dat.aRow linha) 
Jogador jogador= (Jogador) obj; 
linhal~nome~J : jogador.nome; 

O mapeador de jogadores precisa encontrar o mapeador concreto correto a ser 
usado e então delegar a chamada de atualização. 

class l~peadorDeJogador... 

public override void Atualizar (ObjetoDoDominio objl { 
MapeadorPara (obj) .Atualizar (obj 1; 

private Mapeador MapeadorPara (ObjetoDoDominio obj) 

i: (obj is JogadorDeFute.bol) 
return ClélpeadorF; 
if (obj is JogadorDeBoliche) 
return mapeadorS; 
if (obj is JogadorDeCriquete) 
retum mapeadorC; 
thrõl;.l new Exception t~Nenhum mapeador disponível~) i 

Inserindo um Objeto A inserção é uma variação da atualização. O comportamento 
extra é a criação de uma nova linha, o que pode ser feito na superclasse. 


290 PARTE li • Os PAORÕES 

class Mapeador... 

public virtual long Inserir (ObjetoDoDominio argl 
DataRo~ linha: tabela.Ne~RO"II{ ); 
arg. Id :e LerPr6ximoID ( ) ; 
linha(•id'I : arg.Id; 
Gravar(arg, linha); 
tabela.Rows.Md (linha); 
retum arg. Id; 

Mais uma vez, a classe jogador delega para o mapeador apropriado. 

class MapeadorOeJogador... 

public override long Inserir {Objetoll000nún10 objl { 
return MapeadorPara (obj) .Inserir(o:>j); 

E)(cluindo um Objeto A exclusão é bastante direta. Como antes, temos um método 
definido na superclasse. 

class Mapeador ... 

public virtual void Excluir IObjetoDoDomínio obj) 
DataRo~ linha= BuscarLinha {obj.ldl ; 
linha.Delete! l; 

e um método no rnapeador de jogadores que executa a delegação. 

class HapeadorOeJogador... 

public override void Excluir (ObjetoDoDominio obj) 
MapeadorPara(cl>j) .&.xcluir(obj); 


CAPITULO 12 • PADRÔES ESlRUTURAIS OBJET0-RHACI0NAIS 291 

Mapeadores de Herança (lnheritance Mappers) 

Uma estrutura para orga11i?11r os 111apeadores de bancos de dndos que lidn111 
com hierarquias de hernnçn. 

Mapeador 

MapeadorAbstrato 
+Inserir (Objeto do Domínio) de Jogador 

+ atualizar (Objeto do Domlnio) 
+ excluir (Objeto do Domínio) 
<J 

#gravar 

-métodos gancho 

#carregar

#gravar (Objeto do Domínio, Linha) 
#caffegar (Objeto do Domínio, Linha) 

6 1 ~ 
Mapeador de 
Jogador de Futebol 
1 
~ 
+ buscar (chave): Jogador 
de Futebol 
#gravar 
#carregar Mapeador de 
MapeadordeJogador Jogador de Críquete 

~ 

-
-
+ buscar (chave): Jogador 

+ buscar (chave): Jogador 
~ 

-de Criquete

+ inserir 
1 #gravar

..-atualizar 

#carregar 

~ 

Mapeador de 
Jogador de Soliche 

-
-
1 + buscar (chave): Jogador 
, de Boliche 

#gravar 

#carregar 

Quando você mapeia de uma hierarquia de herança orientada a objetos em memória 
para um banco de dados relacional, tem que minimizar a quantidade de código necessária 
para gravar e carregar os dados do banco de dados. Você também quer fornecer 
tanto comportamento abstrato de mapeamento qmmto comportamento cone.
reto que lhe permitam gravar ou carregar uma superclasse ou uma subclasse. 

Ainda que os detall,es deste comportamento variem com o esquema de mapeamento 
de herança utilizado (Herança de Tabeln Única (269), Hemnça de Tnbeln de Classes 

(276) e Herança de Tabela Co11crefn (283)), a estruhtra geral funciona da mesma maneirn 
para todos eles. 

292 PARTE li • Os PADRÕES 

Como Funciona 

Você pode organizaros mapeadores com uma hierru·quia a fim de que cada classe do 
domínio tenha um mapeador que grave e carregue os dados para ela. Dessa forma, 
você tem um ponto em que pode alterar o .mapcarnento. Esta abordagem funciona 
bem com mapeadores concJ'etos que sabem como mapear os objetos conc1•etos na hierarquia. 
Existem ocasiões, no entanto, em que você também precisa de mapeadores 
para as dasses abstratas. Estes podem ser implementados com mapeadores que, na 
verdade, estão fora da hierarquia básica, mas delegam para os mapeadores concretos 
apropriados. 

Para explicar melhor como isso funciona; começarei com os mapeadores concretos. 
No exemplo, os mapeadores concretos são os mapeadores dejogadoces de futebol, 
de críquete e de bolichc. Seu comportamento básico inclui as operações de busca, 
inserção, atualização e exclusão. 

Os métodos de busca são declarados nas subclasses concretas porque retomarão 
uma classe concreta. Portanto, o método de busca no MapeadorDeJogadorDeBoliche 
deveria retomar um jogadorde boliche, não urna classe êtbstrata. As linguagens 
00 comuns não deixam você alterar o tipo de retorno declarado de um método, de 
modo que não é possfvcl herdar a operação de busca é ainda declarar um tipo específico 
de retorno. Você pode, é claro, retornar um tipo abstrato, mas isso obriga o 
usuário da classe a executar um downcast -o que é melhor evitar. (Uírul linguagem 
com atribuição dinâmica de tipos não tem este problema.) 

O comportamento básico do método de busca é encontrar a linha apropriada 
no banco de dados, instanciar umobjeto do tipo correto (uma decisão que é tomada 
pela subclasse) e então carregar o objeto com os dados do banco de dados. O método 
de carga é implementado por cada mapeador na hierarquia, o qual carrega o 
comportamento para o seu objeto do domínio correspondente. Isso significa que o 
método de carga do mapeador de jogador de beliche carrega os dados específicos 
para a classe jogador de boliche e dlama o método da superclasse para carregar os 
dados específicos do jogador de críquete, o qual chama o método díl sua superclasse 
e assim por cUante. 

Os métodos de inserção e atualização opernm de forma semelhante, usando um 
método de gravação. Aqui você pode definir a interface na superclasse -na verdade, 
em uma Cnmnrln Superlipo (444). O método de inserção cria uma nova linha e então 
grava os dados do objeto do dominio usando os ganchos para os métodos de gravação. 
O método de atualização apenas grava os dados, também usando os ganchos 
para os métodos de gravação. Estes métodos operam de forma similar aos ganchos 
para os métodos de carga, com cada classe armazenando os seus dados específicos e 
chamando o método de gravação da superclasse. 

Este esquema torna fácil escrever os mapeadores apropriados para gravar as informações 
necessárias para urna parte específica dê'\ hierarqt,úê'\. O próximo passo é 
suportar a carga e gravação de uma classe abstrata -neste exemplo, um jogador. Ainda 
que o primeiro pensamento seja colocar métodos apropriados no mapeador da 
superclasse, isso, na verdade, se torna complicado. Embora as ela ses mapeadoras 
concretas possam apenas usar os métodos de inserção e atualização do mapeador 
abstrato, a inserçã.o e atualização do mapeador de jogadores precisam sobrescrevêlos 
para, em seu lugar, invocar um mnpeador concreto. O resultado é uma dessas 
combinações de generalização e composição que dão um nó na sua cabeça. 


CAPtiuL0 12 • PADRÕES ESTRUíURAIS OSJET0-RHACI0NAIS 293 

Prefiro separar os mapeadores em duas dasses. O mapeador abstrato de jogadores 
é responsável por carregar e gravar os dados do jogador especifico no banco de 
dados. Esta é uma classe abstrata cujo comportamento é usado apem1s pelos objetos 
mnpeadorcs concretos. Uma classe mapeadora de jogadores distinta é usada como 
interface para as operações no nível do jogador. O mapeador de jogadores fornece 
um método de busca e sobrescreve os métodos de inserção e atualização. A responsabilidade 
de todos eles é descobrir qual mapeador concreto deveria tratar a tarefa e 
delegar para ele. 

Ainda que um esquema genérico como este foça sentido para todos os tipos de 
mapeamento de herança, os detalhes de fato vari<1m. Portanto, não é possível mostrar 
um exemplo de código para este caso. Você pode encontrar bons exemplos em 
cada uma das seções dos padrões de mapeamento de herança: Herança de Tabela ú,úcn 
(269), Herança de Tabela de Classes (276) e Herança de Tabela Concreta (283). 

Quando Usá-los 

Este esquema geral faz sentido para qualquer mapeamento de banco de dados baseado 
em herança. As alternativas envolvem coisas como duplicar o código de mapeamento 
da superclasse entre os mapeadores concretos e incluir a interface do jogador 
na classe mapeadora abstrata de jogadores. O primeiro é um crime hediondo, e o último 
épossível, mas leva a um.a classe mapeadora de jogadores deselegante e confusa. 
Em geral, então, é difícil pensar em uma boa alternativa para este padrão. 


CAPÍTULO 13 

Padrões de Mapeamento em 
Metadados Objeto-Relacionais 


CAPilULO 13 • PADRÕES DE MAPEAMENTO EM M ETA0A00S OSJETO-RHACI0NAIS 295 

Mapeamento em Metadados (Metadata Mapping) 

Armazena os detalhes do 111npeamento objeto~rclncio11al em mcladados. 

Mapa de Dados Mapa de Colunas 

classeDoDomínio ... -nomeDaColuna

-

-

nomeDaTabela nomeDoCampo 

* 

Mt1ito do código que lida com mapeamento objeto-relacional descreve como os campos 
no banco de dados correspondem aos campos dos objetos na memória. O código 
resultante tende a ser tedioso e repetitivo de escrever. Um Mapeamento em Metadndos 
permite aos desenvolvedores definir os mapeamentos em uma forma tabular simples, 
a qual então pode ser processada por código genérico para realizar os detalhes 
de leitura, inserção e atualização dos dados. 

Como Funciona 

A maior decisão a ser tomada no uso do Mapeamento em Metnrlndos é como as informações 
nos metadados se expressam em termos de código cm execução. Há dois caminhos 
principais a trilhar: geração de código e programação reflexiva. 

Com a geração de código você escreve um programa cuja entrada são os metadados 
e cuja saída é o código fonte das classes que executam o mapeamento. Essas 
classes parecem ter sido escritas à mão, rnas são inteirarnente geradas durante o processo 
de construção, normalmente, imediatamente antes da compilação. As classes 
de mapeamento resultantes são distribuídas com o código servidor. 

Se você usar a geração de código, você deve se assegurar de que ela é completamente 
integrada ao seu processo de construção (b11ild) seja qual for o roteiro de 
construção que você estiver usando. As classes geradas nunca devem ser editadas à 
mão e, desta forma, não precisam ter o seu código fonte controlado. 

Um programa reflexivo pode solicitar um método chamado gravarNome num objeto 
e então executar uma chamada a esse método passando o parâmetro apropriado. 
Tratando métodos (e campos) como dados, o programa reflexivo pode ler os nomes 
de campos e métodos de um arquivo de metadados e usá-los para realizar o mapeamento. 
Normalmente, desaconselho a reflexão, em parte porque ela é lenta, mas 
principalmente porque ela freqüentemente produz código difícil de depurar. Ainda 
assim, a reflexão é, na verd<1de, bastante apropriada para o mapeamento em banco 
de dados. Uma vez que você está lendo os nomes dos campos e dos métodos de um 
arquivo, você está tirnndo total proveito da flexibilidade da reflexão. 

A geração de código é uma abordagem menos dinâmica, já que qualquer alteração 
no mapeamento requer a recompilação e a redistribuição de pelo menos parte do 
software. Com uma abordagem reflexiva, você pode apenas alterar o arquivo de dados 
do mapeamento, e as classes existentes usarão os novos metadados. Você pode 
fazer isso até mesmo em tempo de execução, relendo os metadados quando ocorrer 
alguma interrupção específica. Alterações nos mapeamentos deveriam ser bastante 
raras, já que implicam alterações no banco de dados ou no código. Os modernos ambientes 
de desenvolvimento facilitam ainda a tarefa de redistribuir parte de uma 
aplicação. 


296 PARTE li • Os PAORÕES 

A programação reflexiva muitas vezes padece com a velocidade, embora o problema 
aqui dependa muito do ambiente que você estiver usando -cm alguns, uma 
chêtmada reflexiva pode ser uma ordemdegrandeza mrus lenta. Lembre-se, contudo, 
de que a reflexão está sendo executada no contexto de wna chamada SQL, então, sua 
velocidade mais lenta pode não fazer tanta diferença assim, considerando a baixa velocidade 
da chamada remota. Como com qualqueraspecto relacionado ao desempenho, 
você precisa efetuar mecüdas dentro do seu ambiente para descobrir o quanto 
este é um fator importante para você. 

Ambas as êtbordagens podem ser um pouco con,plicadas para depurar. A comparação 
entre efas depende muito do quão habituados estão os desenvolvedores com 
código gerado e código reflexivo. O código gerado é mais ex-plícito, de modo que você 
pode ver o que está acontecendo no depurador. Como conseqüência, normalmente, 
prefiro a geração à reflexão e penso que ela é normalmente mais fácil para desenvolvedores 
menos sofisticados (o que, suponho, faz de mim um desenvolvedor nãosofisticado 
). 

Na maioria das ocasiões, você mantém os metadados em um formato de arquivoseparado. 
XML é, atualmente, uma escolha popular uma vez que fornece uma esh'utura 
hierárquica ao mesmo tempo em que o livra de escrever seus próprios analisadores 
(pnrsers) e outras ferramentas. Uma etapa de carga pega esses metadados e 
os transforma em uma estrutura de linguagem de progt'amação, a qual então conduz 

o processo de geração de código ou o mapeamento reflexivo. 
Nos casos mais simples, você pode cüspensar o arquivo externo e criar arepresentação 
dos metadados diretamente no código fonte. Isso lhe poupa de ter que 
realizar a análise sintática (parse), mas torna a edição dos metadados um pouco 
mais difícil. 

Uma alternativa é manter as informações do mapeamento no próprio banco de 

dados, que as mantém junto aos dados. Se o esquema do banco de dados for altera


do, a informação do mapeamento já está lá. 

Quando você estiver decidindo de que modo amu12cnar as informações cm mctadados, 
você pode, quase que completamente, esquecer as questões relativas ao desempenho 
no acesso e na análise sintática (parsi11g). Se você usar a geração decódigo, 

o acesso e a análise ocorrem apenas durante a construção e não durante a execução. 
Se você estiver usando a programação reflexiva, você, tipicamente, efetuará o acesso 
e a análise dw·ante a execução, mas apenas uma única vez, durante a inicialização do 
sistema; você pode então mélnter a representação em memória. 
O quão complexo tornar seus metadados é uma das suas maiores decisões. 
Quando você se depara com um problema genérico de mapeamento relacione-li, existe 
uma série de fatores diferentes para manter nos metadados, mas muitos ptojetos 
podem arranjar-se com muito menos do que um esquema geral completo, e, assim, 
seus metadados podemser muito mais simples. Nogeral, vale mais a pena desenvolver 
seu projeto à mectida que as suas necessidades aumentarem, já que não é djfícil 
adicionar novas capacidades a umsoftwnre orientado a metadados. 

Um dos desafios dos metadados é que, embora um esquema simples de metadados 
freqüentemente funcione bem durante 90% do tempo, há casos espedrus que 
tomam a vida muito mais complicada. Para lidar com esta minoria de casos, você freqüentemente 
tem que adicionar uma grande complexjdade aos meradados. Uma alternativa 
útil é sobrescrever o código genérico com subclasses nas quais o cócügo especial 
é escrito à mão. Essas subclasses de casos especiais são subclasses tanto do código 
gcmdo quanto das rotinas reflexivas. Uma vez que esses casos especiais são ... 
bem ... especiais, não é fácil descrever em termos gerais como você deve orgnnizar é\S 


CAPi'tULO 13 • PA0RôES OE MAPEAMENTO EM METADA00S OSJET0-RE:LACI0NAIS 297 

coisas para sustentar a sobrescrita. Meu conseUlo é tratá-las caso a caso. Quando vo


cê precisar da sobrescrita, altere o código gerado/ reflexivo para isolaro método que 

deve ser sobrescrito e então sobrescreva-o no seu caso especial. 

Quando Usá-lo 

O Mapeamento em Mel adados pode reduzir muito a quantidade de trabalho necessária 
para tratar o mapeamento em um bancode dados. Entretanto, algum trabalho de configuração 
é requerido para preparar o fm111ework do Mapen,11ento em Meladados. Além 
disso, ainda que freqüentemente seja f!lcil tratar a maioria dos casos com Mnpea111e11to 
em Metndndos, você pode encontrar exceções que realmente complicam os metadados. 

Não é surpresa que as ferramentas comerciais para o mapeamento objeto-relacional 
usem o Mapeamento em Metadados -ao vender um produto, produzir um Mnpenmento 
em Metndados sofisticado sempre vale o esforço. 

Se você estiver construindo seu próprio sistema, você mesmo deve avaliar os 
compromissos. Compare a adição de novos mapeamentos usando código escrito à 
mão com o uso do Mapeamento em Metndados. Se você usar reflexão, investigue seus 
efeitos sobre o desempenho. Às vezes, ela causa uma diminuição na velocidade, mas, 
às vezes, não. Sua própria medição revelará se este é um problema para você. 

O trabalho adicional de codificar à mão pode ser grandemente reduzido pela 
criação de uma boa Camada Supertipo (444) que trate todo o comportamento comum. 
Desta maneira, você precisará apenas adicionar algumas poucas rotinas para cada 
mapeamento. Normalmente, o Mapeamento em Metadndos pode reduzir ainda mais 
este número. 

O Mapenme11toem Metadados pode interferir com a refatoração, especialmente se 
você estiver usando ferramentas automatizadas. Se você alterar o nome de um campo 
privado, pode fazer uma aplicação falhar inesperndamente. Mesmo as ferramentas 
automatizadas de refatoração não conseguirão descobrir o nome do campo escondido 
em um arquivo XMLde dados de um mapeamento. Usar a geração de código 
é um pouco mais fácil, uma vez que os mecanismos de busca podem descobrir a 
co.tlvenção corrente. Ainda assim, qualquer atualização automática será perdidél 
quru1do você regerar o código. Uma ferramenta pode lhe avisar sobre um problema, 
mas é sua responsabilidade alterar os metadados. Se você usar reflexão, você nem 
mesmo receberá o aviso. 

Por outro lado, o Mnpenmento em Metadados pode tornar a refatoração do banco 
de dados mais fác-iJ, já que os metadados representam uma declaração da interface 
do esquema do seu banco de dados. Dessa forma, alterações no banco de dados pode 
ser contingenciadas por alterações no Mapeamento em Mctadados. 

Exemplo: Usando Metadados e Reflexão {Java) 

A ma ioda dos exemplos neste livro usa código exp1ícito porque é o mais fácil de entender. 
Entretanto, isso leva a uma programação bastante tediosa, e programação tedfosa 
é um sinal de que algo está errado. Você pode remover bastante dél programação 
tediosa usando metadados. 

Armazenando os metadados A primeira questão a ser respondida sobre os metadados 
é como eles serão mantidos. Aqui os estou mantendo em duas classes. O mapa 
de dados corresponde ao mapeamento de uma classe para uma tabela. Este é um mapeamento 
simples, mas será suficiente para o exemplo. 


298 PARTE li • Os PAORÕES 

class MapaDeDados ... 

private Class classeDoDomínio; 
private String nomeDaTabela; 
private List mapasDeColuoas; new ArrayList f 1; 

O mapa de dados contém uma coleção de mapas de colunas que mapeiam colunas 
na tabela para campos. 

class MapaOeColunas... 

private String nomeDaColuna; 
private String nomeDoCampo; 
private Field campo; 
private MapaDeDados mapaDeDados; 

Este não é um mapeamento extremamente sofisticado. Estou apenas usando os 
mapeamentos de tipos padrão de Java, o que significa que não há conversão de tipos 
entre campos e colunas. Também estou forçando um relacionamento t1m-para-um 
entTe tabeJas e dasses. 

Estas estruturas armazenam os mapeamentos. A próxima questão é como elas 
são povoadas. Para este exemplo irei povoá-las com código Java em classes específicas 
de mapeamento. Isso pode parecer um pouco estranho, mas proporciona a 
maioria dos benefícios dos metadados-evitando código repetitivo. 

class MapeadorOePessoa ... 

protected void carregarMapaDeDados 1 ) 1 
mapaDeOados = new ~4paOeDados lPessoa.class, •pessoas•> : 
mapaDeDados.adicionarColuna( • so!:>renome\ •varchar•, Nsobrello1t:e•) ; 
mapaDeDados.adicionarColuna(•prenOlf~•, •varchar•, "preNome~I; 
mapaDeDados.adicionarColuna("núr.ero_de_dependentes•, •int•, •núrnerQ!)eDependentes'): 

Durante a construção do mapeador de colunas, crio a conexão com o campo. A 
rigor, isso é uma oti.mizaçiio, de modo que você pode não ter que calcular os campos. 
Entretanto, fazer isso reduz os acessos subseqüentes em uma ordem de magnitude 
no meu pequeno lnptop. 

class MapaDeColunas... 

pui>lic MapaDeColunas !String norneDaColuna, String noceDoCa1tp0, MapaDeoados 11'.apaDeDados) t 
this.n01r.eoacoluna = nooeDaColuna; 
thís.nomeDoCampo = non:eDOCampo; 
this.mapaOeDados: mapaDeOados; 
inicializarcampo( ~; 

private void irúcializarCampo ( 1 

try 1 
campo= mapaDeDados.lerClasseCoDo:ninio( ).getDe<:laredField (ler~omeDoCampo( )) ; 
campo.setAccessible (truel ; 

) catch (Exception e) ( 
tbrow oew ApplicationException ("Não foi possível configurar o campo: • t ncxreDoCampo, e); 


CAPilULO 13 • PADRÕES DE MAPEAMENTO EM M OADAOOS OBJETO-RELACIONAIS 299 

Não é um desafio mujto grande escrever uma rotina para carregar o m<1pa de 
um arquivo XML ou dos mctadados de um banco de dados. Embora esse desafio não 
seja grande, declinarei dele e o deixarei para você. 

Agora que os mapeamentos estão definidos, posso fa~er uso deles. O poder da 
abordagem de metadados é que todo o código que em verdade manipula alguma 
coisa está em uma superclélsse, de modo que não tenho que escrever o código de mapeamento 
que tive de escrever nos casos explícitos. 

Busca pelo 1D Começarei com o método de busca pelo 1D. 

class ~apeador... 

public Object buscarObjeto (Long chave) { 
íf (udt .estáCarregadolchave}I return udc.letObjeto(chave); 
String sql = 'SBLECT" + mapaDeDados.lístaDeColunas() • • FROM ~. mapaDeDados. 

lerNomeI>aTabela ( 1 , " WHERS to :: ?•; 
PreparedStatement dec = null: 
ResultSet rs = null; 
ObjetoDoDomínio resultado= null: 
try { 

dec = DB.prepare(sql); 
dec.setLong(l, chave.longValuel Jl, 
rs = dec.executeQuery( ) ; 
rs.next() ; 
resultado : carregar(rs); 

) catch (Bxception e) { thro~ newApplicationExcept ion (e); 
) finally {DB.cleanUp(dec, rs); 

} 

return resultado: 

} 

private UnidadeDeTrabalho udt; 
protected MapaDeDados li'.!apaDeDados; 

class DataMap.. . 

public Stri ng listaDeColunae 1 ) 
StringBuffer resultado = new StringBuffer(" 10"); 
for (lceracor ir= mapasDeColunas.iteratort ): it.hastlext( 1:} { 

resultado.append(•,•) ; 
MapaDeColunas mapaDeCOlunas " (MapaDeColunas) it.next ( 1 ; 
resultaào.append{mapaDeColunas.ler?romeOaColuna ( )) ; 

return resultado.toString( ); 

public String lerNoeteDaTabela () 
return nomeDaTabela; 

O comando SELECT é construido mais dinamicamente do que os outros exemplos, 
mas ainda assim vale a pena prepará-lo de modo que seja possível ã sessão do 
banco de dados colocá-la em cache. Se isso for um problema, a lista de colunas pode 
ser calculada durante a construção e colocada em cache, uma ve.z que não há ncnlrnmél 
chamada para atunlização de colunas durante a vida do mapa de dados. Para este 
exemplo estou usando uma Unidade de Trabnl'1o (187) para lidar com a sessão do 
banco de dados. 


300 PARTE li • Os PADRÕES 

Como é comum nos exemplos neste livro, separei a carga da busca, de modo 
que podemos usar o mesmo método de carga a partir de outros métodos de busca. 

class Napeador ... 

public ObjetoDoDo.~ínio carregar (ResultSet rs) 
thro..·s lnstantia.tion.Exception, IllegalAcc-essSxception. SQLException 

l.,ong chave: new Long (rs.getLong{•to•)) ; 
ií (udt.estáCarregado(chave)) return udt.lerObjeto(chave); 
ObjetoDoOolllinio resultado : 

(ObjetoDoDoaínio) mapaDeDados.lerClasseDoDornínio( l.newlnstance(); 
resultado.gravar!Dlchave); 
udt .regiscrarLi0po{resultado]; 
carregarCampos(rs, resu1t~dol ; 
return resultado; 

privace void carregarCampos (ResultSet rs, ObjetoDoOomínio resultado) thrO'As SQLRxception ( 

for (tterator it = inapaDeDados.lerColunas( ); it.hasNext( ); 1 { 
MapaDeColunas mapaDeColunas = (MapaDeCOlunas) it .nextC); 
Object valorDaColuna = rs.gecObject(mapaDeColunas.lerNomeDaColuna( 1); 
mapaDeColunas.gravarCampo{resultado, valorDaColuna); 

class MapaDeCOlunas... 

publ ic void 9ravareampo (Object resul tado, Object vaiorOaColuna) 
try { 
campo.se~(resultado, valorDaColuna); 
} catch (Exoeption e) ( throw ne11· ApplicacionBxcepcion (•trro na gravação • ➔ noo.eDoC.ampo, e); 

) 

Este é um programa reflexivo clássico. Passamos por cada um dos mapas de colunas 
e os usamos para carregar o campo no objeto do domínio. Separei o método 
carregarcampos para mostrar como podemos estendê-lo para casos mais complicados. 
Se tivermos uma classe e uma tabela onde a hipótese simples dos metadadosnâo vale, 
posso simplesmente sobrescrever o método carregarCampos em uma subclasse mapeadora 
e colocar aí o código arbitrariamente complexo. Esta é uma técnica comum 
com metadados -fornecer um lugar em que sobrescrever em casos menos comuns. 
Normalmente, é muito mais fácil sobrescrever os casos incomuns com subclasses do 
que criar metadados sofisticados o suficiente para armazenar (llguns casos esped<'lis 
e raros. 

É claro que, se tivermos uma subclasse, poderíamos também usá-la para evitar 

downcasting. 

class HapeadorDePessoa... 

publíc Pessoa buscar(t.ong chave) 
return (Pessoal buscanlbjeto(chave); 


CAPilUL0 13 • PADRÕES DE MAPEAMENTO EM M eTADAD0S OBJETO-RELACIONAIS 301 

Gravando no Banco de Dados Para atualizações uso uma única rotina. 

class Napeador... 

public void atualizar IObjetoDoDoaúnio obj} { 
String sql = "UPDATE • + rr.apaDeDados.lerNCX"'..eOaTabela 1 ) -mapaDeDados. listaDeAtua1izaç3o ( 1 T 

' ili!ERE li) " ?•; 
PreparedStatement dec = null; 
try ( 

dec = DB.preparelsql); 
int contadorDeParâmetros = 1; 
for (Iterator it = mapaDeDados.lerColunasl ); it.hasNext( l; 

MapaDeColunas col = IMapaDeColunasl it.nextl); 
dec.setObject (contadorDeParâmetros++, col.lerValor(obj)); 

dec.setLong(contadorDeParâmetros, obj.lerID( >.longValue( )) ; 
dec.executeUpdatel 1; 
} cacch (SQLBxcepcion e) { chrow new ApplicacionExcepcíon (e}; 
} finally {DB.cleanUp(decl: 

} 

class MapaDeDados... 

public String listaDeAtualização 1 1 { 
StringBuffer resultado= new SttringBuffer(' SRT •) ; 
for (Iterator it = mapasDeColunas. iteratorf ) ; it.hasNext 1 1; ) 1 

Mapar>eColunas mapaDeColunas = (Mapa.OeColunas) it.next( ) ; 
resulcado.append(mapaDeColunas.ler!lomeoacoluna( ll, 
resultado.append('=?, ") ; 

re.sultado.setLength(resultado.length () -l); 
retutn resultado.toString( ); 

} 

public Iterator lerColunas( ) { 
return Collections.un:iodifiableCollectionlmapasDeColunas) .iterator!); 

class Hapaoecolunas.. , 

public Object lerValor(Object sujeito) 
try ( 
recum campo,gec(sujeitol; 
}catch (5xception e) { 
throw new ~.pplicationException (e}; 

Inserções usam um esquema semelhante. 

class Mapeador ... 

public Long inserir (ObjetoDo!>omínio obj) 

T

String sgl = •msBRT rnro • T mapaDeDados. lerNomeDaTabela ( ) ' VALUES 

(?N I mapaDeDados.listaDelnserçãol ) t •)•; 
Preparedstatement dec =null: 
try { 


302 PARTE li • Os PAORÕES 

dec = DB.prepare(sql) ; 
dec.set0bject 11, obj.lertD{ l); 
int contadorDeParâroetros: 2; 
for (Icerator it =mapaDeDados.lerColunas( ); it.hasNext( l; 

Mapaoecolunas col : (MapaDeColunasl it.nextl ); 
àec.setObject (contaêorDeParâmetros++, col.lervalor{obj)); 

dec.executeUpdate l ); 
) catch (SQLException e) 1throw ne..• Appl icationBxception (e); 
} finally {DB.cleanUp(decl: 
) 
return obj.lerID( ); 

class mapaDeDados .. . 

public String listaDelnserção ( l 
Strir.9Buffer resultado= new StringBuffert ); 
for (iot i = O; i < mapasDeColunas.size( ); i~+l 

resulc..append(•, 11) ; 
result.append(•?•J: 

return resultado.coscring( ); 

Buscas Multiobjeto Há alguns caminhos que você pode seguir para obter diversos 
objetos com uma única consulta. Se você quiser uma capacidade de consulta genérica 
no mapeador genérico, você pode ter uma consulta que receba uma cláusula SQL 
wbere como parâmetro. 

class Mapeador. .. 

public Set encontrar0l:>jetos0nde (String cláusulaWhere) 
String sql: "SELECT" + n:apaDeDados.listaDeColunas( l , "PP.O~!"· mapa!leDados. 

lerNorneDaTabela() t • WHE:RE • À cláusulah"here; 
PreparedStacement dec = null; 
ResultSet rs =null; 
Set resultado= new HashSet () ; 
try { 

dec: DB.prepare(sql); 
rs = dec.executeQuery{ ); 
resultado= carregarTudo(rs>; 

} cacch (Exception e) { 

throw new ApplicationException (e); 
} finally {DB.cleanUp(dec, rs); 
} 

retum resultado; 
} 
public Set carregarTudo (ResultSet rsl throws SOLBxception, InstantiationExce!)tion. I1 

legalAccessBxception ( 
Set resultado= ne~ HashSet I l; 
wnile (rs.next l l) { 

ObjetoDoDominio nov~j: (ObjetoDoOoilliniol mapaDeDados.lerClasseDoDominío{ l.newlnstance{ ); 
novoObj = carregarlrs) ; 


CAPilULO 13 • PAORÕES OE MAPEAMENTO EM M ETAOAOOS QaJETO-RELACIONAIS 303 

resultado.add(novoObj) ; 

} 

return resultado; 

Uma alternativa é fornecer métodos de busca para casos especiais nos subtipos 
do mapeador. 

class HapeadordePessoa ... 

public Set encontrarSobrenomesC()ffl() (String padrão) 
String sql: 

•SEL&CT • ♦ mapaDeDados. listaDeColunas ( ~ ,. 
• FRCX~ • + mapaDeDados. lerNomeDaTabela 1 1 t 
• WHE?RE OPPER(sobrenorne) like UPPER(?}~; 
PreparedStatemenc dec =null; 
ResultSet rs =null; 
try ( 
dec = DB.prepare(sql); 
dec,setString(l, padrão): 
rs = dec.executeQuery( ); 
recuro carregarrudo (rs); 

} catch (Exception e) { throw new A~plieationException (el; 
) finally ( DB.cleantJp(dec, rs); 

} 

Uma alternativa adicional para seleções gerais é um Obíetode Pesquisa (304). 

No geral, a grande vantagem da abordagem de metadados é que posso agora 
adicionr1r novas tabelas e classes ao meu mapeamento de dados, e tudo o que tenho 
que fazer é fornecer um método carregarMapaDeDados e quaisquer métodos de busca especiaUzados 
que eu possa conceber. 


304 PARTE li • Os PADRÕES 

Objeto de Pesquisa (Query Object) 

Um objeto que representa 11mn co11s1tltn no l>anco de dados. 

:Consulta 

o 

1 / 

' J 

:Critério :Critério 

operador= ">" operador =•=~ 
campo ="númeroDeDependentes• campo =•sobrenome• 
valor= O valor = "fowler" 

A SQL pode ser uma linguagem complJcada, e muitos desenvolvedores não estão 
particularmente farniliaázados com ela. Além disso, você precisa conhecer o esquema 
do banco de dados para fom1uiar consultas. Você pode evitar isso criando métodos 
de pesquisa especia)jzados que escondam a SQL dentro de métodos parametrizados, 
mas isso torna difícil formular consultas mais especializadas. isso também leva 
a duplicação nas declarações SQLse o esquema do banco de dados mudar. 

Um Objeto de Pesqui~n é um interpretador [Gang of PourL ou seja, uma estrutura 
de objetos que pode transformar-se em uma consulta SQL. Você pode criar esta 
consulta fazendo referência a classes e campos em vez de tabelas e colunas. Dessa 
maneira, aqueles que escrevem as consultas podem fazê-lo independentemente do 
esquema do banco de dados, e alterações no esquema podem ser localizadas em um 
único lugar. 

Como Funciona 

Um Objeto de Pesquisa é uma aplicação do padrão Interpretador destinado a representar 

uma consulta SQL. Suas principais tarefas são permitir a um cliente formular consultas 

de vários tipos e transformar essas estruturas de objetos na string SQL apropriada. 

Para representar qualquer consulta, você precisa deum Objeto de Pesquisa flexível. 
Muitas vezes, no entanto, as aplicações podem se virar c:ommuito menos do que 
a capacidade total do SQL, caso em queseu Objeto de Pesquisa pode ser mais simples. 
Ele não será capnz de representar todas as coisas, mas pode satisfazer as suas necessidades 
específicas. Além disso, normalmente, não é mais trabalhoso melhorá-lo 
quando for preciso mais capacidade do que é o·iar um Objeto de Pesquisa inteiramente 
apto desde o prinópio. Como conseqüência, você deve criar um Objeto de Pesquisa 
minimamente funcional para suas neccssidcldes correntes e aperfeiçoá-lo à medida 
que essas necessidades aumentarem. 

Uma carncterística comum do Objeto de Pesquisa é que ele pode representar consultas 
na linguagem dos objetos na memória em vez da linguagem do esquema do 
banco de dados. Isso significa que, em vez de usar nomes de tabelas e colunas, você 
pode usar nomes de objetos e campos. Embora isso não seja importante seos seus ob



CAPhULO 13 • PADRÕES DE MAPEAMENTO EM METADAD0S OSJET0-RElACI0NAJS 305 

jetos e banco de dados tiverem a mesma estrutura, pode ser muito útil se você tiver 
variações entre os dois. Para efetuar essa mudança de visão, o Objeto de Pesquisa precisa 
saber como a estTutura do banco de dtldos é mapeada para a estrutura dos objetos, 
umct habilidade que realmente precisa do Mnpen111e11to em Metndados (295). 

Para bancos de dados múltiplos, você pode projetar seu Objeto de Pesquisa de modo 
que ele produza strings SQLs diferentes dependendo do banco de dados sobre o 
qual a pesquisa está sendo executada. No caso mais simples, isso pode dar conta das 
aborrecidas diferenças na sintaxe SQL que continuam surgindo. Em um nível mais ambicioso, 
um Objeto de Pesquisa pode usar diferentes mapeamentos para lidar com as 
mesmas classes sendo armazenadas em djferentes esquemas de banco de dados. 

Um uso especialmente sofisticado do Objeto de Pesquisa é para eliminar pesquisas 
redundantes sobre um banco de dados. Se você perceber que executou a mesma 
consulra anteriormente em uma sessão, você pode usá-Ja para selecionar objetos do 
Mapa de Jdentirlnde (196) evitando assim uma ida ao banco de dados. Uma abordagem 
mais sofisticada pode detectar se uma pesquisa é um caso particular de uma pesquisa 
anterior, tal como uma consulta que é idêntica a uma consulta anterior a menos de 
uma cláusula adicion<ll acrescentada por um "AND". 

A mar,eira ex<lta de obteressas características mais sofisticfldas est(\ além doescopo 
deste livro, mas elas são o tipo de característica que as ferramentas de mapeamento 
0/R podem fornecer. 

Uma variação do Objeto de Pesquisa consiste em permitir que uma consulta sejé\ 
especificada por um exemplo de objeto de domínio. Assim, você poderia ter um objeto 
pessoa cujo sobrenome fosse gravado como Fowler, mas todos os outros atributos 
fossem gravados como nulos. Você poderia tratá-lo como um exemplo de consulta 
o qual é processado com.o o Objeto de Pesquisa do estilo Interpretador. Tsso retorna 
todas as pessoas no banco de dados cujo sobrenome seja Powler, e é muito simples e 
conveniente de usar. Entretanto, isso não funciona com pesquisas complexas. 

Quando Usá-lo 

Os Objetos de Pesquisa consistem em um padrão bastante sofisticado para construir, então, 
a maioria dos projetos não os usa, se eles tiver-em uma camadn de fonte de dados 
criada à mão. Você só precisa realmente deles quando você estiver usando um Modelo 
de Domínio (126) e um Mapeado,•de Dados (170). Você realmente também precisa de 
um Mapenniento em Metndados (295) para fazer um uso sério dos Objetos de Pesquisa. 

Mesmo nesses casos os Objetos de Pesquisa não são sempre necessários, já que muitos 
desenvolvedores se sentemconfortáveis com SQL. Você pode esconder muitos dos 
detalhes do esquema do banco de dados atrás de métodos específicos de busca. 

As vantagens do Objeto de Pesquisa vêm com necessidades mais sofisticadas: 
manter esquemas de bancos de dados encapsulados, suportar múltiplos bancos de 
dados, suportar múltiplos esquemas e otimizar para evitar múltiplas consultas. Alguns 
projetos com uma equipe de fonte de dados particularmente sofisticada poderia 
querer construir ela mesma estas capacidades, mas a maior parte das pessoas que 
usé,lm Objeto de Pesquisa o fazem com uma ferramenta comercial. Tendo a achar que 
quase sempre você fica melhor comprando uma ferramenta. 

Dito tudo isto, você pode descobrir que um Objeto de Pesquisa limitado satisfaz 
suas necessidades, e não é difícil construir em um projeto que não justifique u.ma versão 
integral do mesmo. O arüfício aqui é reduzir a funcionalidade a não mais do 
aquilo que você realmente usa. 


306 PARTE li • Os PADRÕES 

Leitura Adicional 

Você pode encontrar um exemplo de Objeto de Pesquisa em (Alpert ef ai.) na cüscussão 

dos interpretadores. O Objeto de Pesquisa também está intimamente ligado ao padrão 

Especificação em [Evans e FowlerJ e [Evans]. 

Exemplo: Um Objeto de Pesquisa Simples (Java) 

Este é um exemplo simples de um Objeto de Pesquisa -na verdade menos do que seria 
útil na maior parte das sjtuações, mas o stÚicíente para lhe dar uma idéia do que 
é um Objeto de Pesquisn. Ele pode pesquisar uma única tabela baseado em um conjunto 
de critérios Ligados por um conectivo "AND" (em uma linguagem ligeiramente 
mais técnica, ele pode tratar uma conjw1ção de predicados elementares). 

O Objeto de Pesq11 isa é configurado usando a linguagem dos objetos do domínio em 
vez daquela da estrutura da tabela. Assim, uma pesquisa sabe a que classe ela pertence 
e um conjunto de critérios que correspondem às cláusulas de uma cláusula where. 

class ObjetoDePesquisa.. , 

privace Class classe; 

private r.ist critério = new ArrayList ( ) ; 

Um critério simples é o que pega um campo e um valor e um operador SQL para 
compará-los. 

class Critérios ... 

private String operadorSql; 
protected Strir.g ca~po; 
protected Object valor; 

Para tornar mais fácil criar os critérios corretos, posso fornecer um método de 
criação adequado. 

class Critérios.. , 

public stacic Critérios maiorQue (String nomeDoCampo, int valor) 
recuro Crícérios.maiorQue (norr.eDoCampo, new Integer(valor)): 

public stacic critérios m~io::Que !String nomeDoCarnpo, Object valor) 
recurn new Critérios(•>•, nomeDoca~po, valor); 

private Critérios (String sgl, String campo, Object valor) { 
this.operadorSql = sql; 
this.campo = can:.po; 
this.valor = valor; 

lsso me permite encontrar todas as pessoas com dependentes formando uma 
pesquisa tal como 

class Critérios... 

ObjetoDePesquisa pesquisa= new ObjetoDePesquisa (Pessoa.class)1 

pesquisa.adicionarCritérios {Crítérios.maiorQue("núr.eroOeDependentes•, O)); 


CAPilULO 13 • PADRÕES DE MAPEAMENTO EM MtTADAOOS 0f1JETO-RHACl0NAIS 307 

Assim, se eu tiver um objeto pessoa como este: 

class Pessoa ... 

private String sobrenome; 

private String prenome; 

private int númeroDeDependentes; 

Posso solicitar todas as pessoas com dependentes, criando uma pesquisa para 
pessoas e adicionando um critério. 

ObjetoDePesguisa pesquisa= new ObjetoDePesquisa (Pessoa.class); 
pesquisa.adícionarCtitérios (Critérios.ma1o~e1•núteroDeDependentes•, Oll; 

Isso é suficiente para descrever a pesquisa. Agora essa pesquisa precisa ser executada 
transformando-se a si mesma em um select SQL. Neste caso, pMto do princípio 
de que minha dasse mapeadora suporta um método que busque objetos baseíldo 
em uma string que corresponda a uma cláusula wl,ere. 

class ObjetoDePesquisa... 

public Set executar (UnidadeDeTrabalho udtl 
this.udt = udt; 
return udt.lerMapeador (classe) .enoontrarObjetosOnde (geraClãusulaWhere\ )1 ; 

class l~apeador... 

public Set encontrarObjetosônde {String cláusulaWhere) 

String sql = •ssr.scr• • 1t.apaDe.Oados. listaDeColunas ( l , • FR0!-1 • • ~paDeDados. 

lerNaneDaTabela ( 1 • • WHERS ~ • cláusulaWhere; 
PreparedStatement dec = nul1; 
ResulcSec rs = null; 
Set resultado= new HashSet( ); 
try { 

dec = OB.prepare (sql); 

rs = dec.executeQuery( ); 

resultado= carregar'l\ldo(rs); 

} catch (Exception el { 

throw ne~ ApplicationExoeption [e}: 

} flnally {DB.cleanUp(dec, rsl; 

) 

return resultado; 

) 

Aqui estou usando uma Unidade de Trabalho (187) que armazena mapeadores indexados 
pela classe e um mapeador que usa Mapeamento em Metadndos (295). O código 
é igual àquele do exemplo do Mapeamento em Metadarlos (295), para evitar a repetição 
de cócLigo nesta seção. 

Para gerar a cláusula where, a consulta percorre cada um dos critérios e faz com 
que cada um imprima a si próprio, juntando-os com um conectivo "ANO". 

class ObjetoDePesquisa... 

private String gerar<:láusulaWhere ( 1 { 


308 PARTE li • Os PADRÕES 

Stri.ngBuifer resultado= new StringBuffer ( J; 

for (Iterator it ~ critérios. iteratorl l; it.has!lext ( 1; ) { 
Critérios c e (Critérios) it.oext( I; 
if (resultado.length() !=OI 

resultado.append(• ANO''); 

resultado.append(•c.gerarSql (udt.lerHapeador(classel .lerMapaDel>ados( ))); 
} 
return resultado.toString( ); 

class Critérios ... 

public String gerarSql (MapaDeDados rnapaDel>ados) { 
return mapaDeDados.lerColunaParaCa.:rpo!car..po) + operadorSql + valor: 

class MapaDeDados .. . 

public String lerColunaParacampo !String n0111eDoCampo) 1 

for (Iterator it = lerColunas( l; it.hasNext( ); ) ( 
MapaDeColunas mapaDeColunas = (MapaDeCOlunas) ic..next ( }; 
if (~apaDeCo!unas.lerNOll'.eOoCampo( 1 .equals(nomeDoCa~po)l 

return mapaDeColunas. lerllor:ieDaColuna ( } ; 

throw ne~ Applicat.ionException (•Não foi encontrada a coluna para~+ nollleDoCampo); 

Assim como critérios com operadores SQL simples, podemos criar classes de 
critél'ios mais complexas que façam um pouco mais. Considere uma busca por um 
padrão de letras que não dilerencie letras maiúsculas de minúsculas, como a que 
busca todas as pessoas cujos sobrenomes comecem com a letra F. Podemos formar 
um objeto de pesquisa para encontrar todas as pessoas com tais dependentes. 

ObjetoDePesguisa pesquisa= new ObjetoDePesquisa(Pessoa.class); 
pesquisa.adicionarCritérios(Critérios.maior(!ue (•númeroDeDependentes• , O)) r 
pesquisa.adicionarCritérios(Critérios.éiguall'sobrenotne•, •f\•)); 

O Objeto de Pesquisa usa agora uma classe de critérios diferente que forma uma 
cláusula mais complexa na declaração where. 

class Critérios... 

public static Critérios élgual (String norr.eOoCampo, String padrão) 
retum new CritérioDelgualdade(nome.DoCampo, padrão}; 

class critériooergualdade extends critérios . .. 

public String gerarSql (HapaDeDados mapaDeOados) 
return •UPPER(• + ai.apaDeDados.lerColunaParaCan:.po(campo} + •) L!KE UPPER(1 +valor+ ••)•; 

• 


CAPhULO 13 • PADRÕES DE MAPEAMENTO EM META0AD0S OBJETO-RELACIONAIS 309 

Repositório {Repository) 

por Edward Híenll eRob Mee 

Fnz n medinçiio ,mtre as camndns de domínio ede mapea111e11to de dados 

11sn11do uma interface de tipo coleção para acessar objetos do domínio. 

~-----........------------, 

,-------, 

estrat~ 

o reoositório uma Pessoa 
na memória 

1 

' 1 ' 

novo 

1 
umCntério 1 

1 

1 

1 1 

1 

igual (this, BENFEITOR) : 

igualando ~ : 
(umCritério) Lr1 1 igualando1----------.------;::-(umCritério) " satisfaz 

~ 

1 (umCritério) 

1 

1 -u 

1 K ---------,

1 1 
1 pessoas que 1 1 
1 satisfizeram 1 1 
l 1 o critério 1 1 
X 1 

Um sistema com um modelo de domínio complexo muitas vezes se beneficia de uma 
camada, como a fornecida pelo Mnpeador de Dados (170)1 que isola os objetos do domínio 
dos detalhes do código para acesso ao banco dedados. Em tais sistemas, pode 
valer a pena construir uma camada adicional de abstração sobre a camada de mapeamento 
em que o código de criação de consuJtas fica concentrado. lsso se torna mais 
importante quando há um grande número de classes do domínio ou consultas pesadas. 
Nestes casos, em especial, a adição desta camada c1juda a minimizar a lógica de 
consulta duplicada. 

Um Repositório realiza a mediação entre as camadas mapeadoras de dados e as 
camadas de domínio, agindo como uma coleção de objetos de domínio cm memória. 
Os objetos clientes criam especificações de consultas declarativamente e as submetem 
ao Repositório para que sejam satisfeitas. Objetos podem ser adicionados e removidos 
do Repositório, assim como o podem ser de uma simples coleção de objetos, e o 
código de mapeamento encapsulado pelo Repositório executará as operações apropriadas 
por trls)s dos panos. Conceitualmente, um Repnsit6rio enctlpsula o conjunto de 
objetos persistidos e as operações executadas sobre eles, fornecendo uma visão mais 
orientada a objetos da camada de persistência. O Repositório também dá suporte ao 
objetivo de alcançar uma separação limpa e uma dependência unidirecional entTe as 
camadas de domínio e as camadas mapeadoras de dados. 


31 0 PARlE li • Os PAORÕES 

Como Funciona 

Repositório é um padrão sofisticado que faz uso de um número razoável de outros pad1•
ões descritos neste livro. De fato, ele se parece com um pequeno banco de dados 
orientado a objetos e, neste sentido, ele é semelhante ao Objeto de Pesq11isa (304), o 
qual é mais provável de ser encontrado pelas equipes de desenvolvimento em uma 
ferramenta comercial para o mapeamento objeto-relacional do que construir um elas 
mesmas. Entretanto, se uma equipe aceitou o desafio e construiu ela mesma um Objeto 
de Pesquisa (304), não é um passo muito grande adicionar a capacidade de um Repositório. 
Quando usado em conjunto com o Objeto de Pesquisa (304), o Repositório 
acrescenta sem muito esforço, uma grande quantidade de aplicabilidade à camada 
de mapeamento objeto-relacional. 

Apesar de toda o mecanismo por h·ás dos panos, o Repositório apresenta uma interface 
simples. Os clientes criam um objeto critérios especificando as características 
dos objetos que eles querem que sejam retornados por uma pesquisa. Por exemplo, 
para encontrar objetos pessoa pelo nome, primeiro criamos ttm objeto critérios, configurando 
cada critério individual apropriadamente: critérios.éIgual (Pessoa.SOBRENOME, 
'Fowler•) e critérios.como(Pessoa. PRENOME, "W). Então chamamos repositório.atendenào(
critérios) para retornar uma lista de objetos do domínio tepresentando pessoas 
com o sobrenome Fowler e um prenome começando com M. Diversos métodos convenientes 
semelhantes a atendendo (critérios) podem ser definidos em um repositório 
abstrato. Por exemplo, quando apenas uma combinação é esperada únicoAtendendo(
critérios) poderia retomar o objeto encontrado em vez de uma coleção. Outros 
métodos comuns incluem peloIOdoObjeto(id}, o qual pode ser implementado trivjalmcnte 
usando únicoAtendendo. 

Para o código que usa um Repositório, ele se parece com uma coleção simples de 
objetos do domínio em memória. O fato dos objetos do domínio geralmente não serem 
armazenados diretamente no Repositório não é exposto ao código cliente. É claro 
que o código que usa o f~eposit6rio deve estar ciente de que esta coleção aparente de 
objetos pode muito bem mapear uma tabela produto com centenas de milhares de rcgish
·os. Invocar o método todos( ) no RepositóricDeProdutos de um sistema de catálogo 
pode não ser uma boa idéia. 

O Repositório substitui métodos especializados de busca em classes do tipo Mapeador 
de Dados (170) por uma abordagem baseada em especificações para êl seleção 
de objetos (Evans e Fowler]. Compare isso com o uso cLireto do Objeto de Pesquisa 
(304), no qual o código no cliente pode construir um objeto critérios (um exemplo 
simples do padrão especificação), adicionar ( l o mesmo diretamente ao Objeto de 
Pesquisa (304) e executar a consulta. Com um Repositório, o código cliente constrói os 
critérios e então os passa para o Repositório, pedindo a ele para selecionar dentre os 
seus objetos, aqueles que satisfaçam aos critérios. Da perspectiva do código do 
cliente, não existe a noção de "execução" de uma consulta. Em vez disso, ocorre a 
seleção dos objetos apropriados por meio da "satisfação" da especificação da pesquisa. 
Isso pode parecer uma distil\ção acadêmica, mas ilustra o sabor declarativo 
da interação dos objetos com o Repositório, o que é uma parte signgüicativa do seu 
poder conccitual. 

Por trás dos panos, o Repositório combina o Mapeamento em Metadados (295) com 
um Objeto de Pesquisa (304) para gerar automaticamente código SQL a partir dos critérios. 
Se os critérios sabem como adicionar a si mesmos a uma consulta, se o Objeto 
de Pesquisa (304) sabe como incorporar objetos critérios, ou se o próprio Mapenmento 
em Metadados (295) controla a interação, é um detalhe de implementação. 


CAPilULO 13 • PAORÕES OE MAPEAMENTO EM METAOAOOS 0SJETO-RELACIONAJS 311 

A fonte de objetos para o Repositório não precisa necessariamente ser um banco 
de dados relacional, o que é bom pois o Repositório é bastante apropriado pa1·a a substituição 
do componente de mapeamento de dados por objetos de estratégia especializados. 
Por esta razão, ele pode ser especialmente t1l:i1 em sistemas com múltiplos esquemas 
de bancos de dados ou múltiplas fontes de objetos de domínio, assim como 
durante os testes, quando o uso de objetos exclusivamente em memória é desejável 
por motivos de velocidade. 

O Repositório podeser um bom mecanismo para melhorar a legibilidade e a clareza 
em um código que faz uso extensivo de consultas. Por exemplo, um sistema baseado 
em um navegador, contendo muitas páginas de pesquisa, precisa de um mecanismo 
perfeito para transformar objetos HttpRequest em resultados de consultas. O código 
manipulador da solicitação pode, geralmente, sem muita complicação, converter 
o HttpRequest em um objeto critérios. Submeteros critérios ao Repositório apropriado 
deve requerer apenas uma linha ou duas de código adicional. 

Quando Usá-lo 

Em um sistema grande, com muitos tipos de objetos de domínio e muitas pesquisas 
possíveis, o Repositório reduz a quantidade de código necessário para lidar com todas 
as consultas que ocorrem. O Repositório promove o padrão Especificação (na forma 
do objeto critérios, nos exemplos mostrados aqui), o qual encapsula a consulta a 
ser realizada de uma forma puramente orientada a objetos. Portanto, todo o código 
para configurar um Objeto de Pesquisa em casos específicos pode ser removido. Os 
clientes nunca precisam pensar em SQL e podem escrever código puramente em termos 
de objetos. 

Entretanto, em situações com diversas fontes de dados, é onde reahnente vemos 
o Repositório ter sua oportunidade de mostrar o quanto é útil. Suponha, por 
exemplo, que às vezes estejamos interessados em usar um armazenamento de dados 
simples em memória, comumente quando queremos executar um conjunto de 
testes de unidade inteiramente em memória para obter melhor desempenho. Sem o 
acesso a um banco de dados, muitos conjuntos de testes longos rodam significativamente 
mais rápido. Criar um artefato para testes de unidade pode também ser mais 
direto se tudo o que tivermos que fazer for criM alguns objetos do domínio e atixálos 
em uma coleção em vez de ter que gravá-los no banco de dados no início e exclui-
los no final. 

Também é possfvel, quando a aplicação estiver rodando normalmente, que certos 
tipos de objetos do domínio devam sempre ser armazenados em memória. Um 
exemplo de tal situação são os objetos de domínio imutáveis (aqueles que não podem 
ser alterados pelo usuário) os quais, uma vez em memória, devem permanecer 
lá e mmca ser trazidos novamente. Como veremos mais adiante neste capítulo, uma 
extensão simples do padrão Repositório permite que diferentes estratégias de consulta 
sejam empregadas dependendo da situação. 

Outro exemplo, no qual o Repositório poderia ser útil, é quando um alimentador 
de dados é usado como fonte de objetos do domínio -digamos, um fluxo XML pela 
fnternet, talvez usando SOAP, poderia estar disponível como fonte. Uma Estratég!aOeRepositórioAlimentadaPorXML 
poderia ser implementada para ler dados do fluxo e 
criar objetos do domínio a partir do XML. 


312 PARTE li • Os PADRÕES 

Leitura Adicional 

O padrão Especificação não tem ainda uma boa fonte de referência. A melhor descri


ção publicada até o mornento é (Evans e Fowler). Uma descrição melhor está atual


mente sendo preparada por (Evans]. 

Exemplo: Encontrando os Dependentes de uma Pessoa (Java) 

Da perspectivç1 do objeto cliente, us;1r o Reposít6rioé simples. Para recuperar seus de


pendentes do banco de dados, um objeto pessoa cria um objeto critérios representan


do os critérios de busca e os envia ao Repositório apropriado. 

public class Pessoa 1 

public List dependentes 1) 
Repositório repositório= Registro.reposit6rio?essoa( 1 t 
Critérios critérios= new Critérios( )1 
critérios.igual(Pessoa.BENPBITOR, thisl; 
return reposit6rio.satiefazendo(critériosl; 

Pesquisas comuns podem ser supridas com subclasses especializadas do Repositório. 
No exemplo anterior, poderíamos criar uma subclasse de Repositório, RepositórioPessoa, 
e mover a criação do critério de pesquisa para o próprio J<eposit6rio. 

9ublic class RepositórioPessoa extends Repositório! 

public List dependentesDe (Pessoa umaPessoa) 1 
Critérios critérios = new Critérios( ) ; 
critérios.igual (Pessoa.BEtlFE!TOR, umaPessoa}: 
return satistazendo(critérios); 

O objeto pessoa ~ntào chama o método dependentesf ) diretamente no seu Repo


sitório. 

public class Pessoa 1 

public Líst dependentes ( 1 
return Re9istro.reposit6ri0Pessoa() .dependentesOe{thisl; 

Exemplo: Trocando Estratégias de Repositório (Java) 

Uma vez que a interface do Repositório isola a camada do domínio da fonte de dados, 
podemos refatorar a implementação do código da consulta dentro do Reposit6rio sem 
alterar quaisquer chamadas dos clientes. De fato, o código do domínio não precisa se 
preocupar com a fonte ou com o destino dos objetos do domínio. No caso do armazenamento 
em memória, queremos alterar o método satisfazendo( ) para selecionar, 
a partir de uma coleção, os objetos do domínio que satisfaçam os critérios. Entrctan



CAPiWL0 13 • PADRÕES OE M APEAMENTO EM M eTA0AD0S Oaiero-RHACI0NAIS 313 

to, não estamos interessados em alterar permanentemente a fonte de dados usada, 
mas, em vez disso, em poder escolher à vontade entre diversas fontes de dados. Vem 
daí a necessidade de alterar a implementação do método satisfazendo{ ) para delegar 
a um objeto estratégia o qual executa a pesquisa. O poder disso, é claro, é que podemos 
ter diversas estratégias e podemos estabelecer a estratégia conforme desejado. 
No nosso caso, é apropriado ter duas delas: uma Bstraté9iaRelacional, que busca no 
banco de dados, e umél EstratégiaEmMemória, que busca na coleção de objetos do domínio 
em memória. Cada estratégia implementa a interface EstratégiaOeRepositório, que 
expõe o método satisfazendo( ), de modo que obtemos a seguinte implementação da 
classe Repositório: 

abstract class Repositórío 1 

private EstratégiaDeRepositório estratégia; 

protected List satisfazendo (Critérios algunsCritérios} 

return estratégia.satisfaiendo(atgunSCritériosl; 

Uma SstratégiaRelacional implementa satisfazendo( 1 criando um Objeto de Pesquisa 
a partir dos critérios e, então, pesquisando o banco de dados usando este Objeto 
de Pesquisa. Podemos configurá-lo com os campos e valores apropriados conforme 
definidos pelos critérios, pressupondo aqui que o Objeto de Pesquisa sabe como povoar 
a si próprio a partir dos critérios. 

public class EstratégiaRelacional i~plen-.ents Bstratégia!leRepositório ( 

protected List satisfazendo(Critérios critérios) ( 

Pesquisa pesquisa = new Pesquisa (classeDo."leuObjetoDoDomíniol ) ) 

pesquisa.adicionarCritérios(critérios); 

return pesquisa.executar(unidadeDeTrabalho{ )) ; 

Uma EstratégiaEmMemória implementa percorrendo a coleção de objetos do domínio 
e perguntando aos critérios para cadc1 objeto do domínio se estes são satisfeitos 
por este objeto. Os critérios podem implementar o código que valida os objetos usando 
reflexão para inquirir os objetos do domínio sobre os valores de campos específicos. 
O código para fazer a seleção se parece com este: 

pub-lic class BstratégiaBrnMemória implerr.ents EstratégiaDeRepositõrio t 

private Set objetosDoDomínio; 

protected List satisfazendo (Critérios critérios) 

List resultados= new htrayList l I; 

Iterator it = objetosOoDoctínio.Sterator( ); 

whíle (it.hasNext ( )) { 

ObjetoDoDomínio cada= (ObjetoDoDoclínio) it.next( I; 

if (critérios.sãoSatisfeitosPor(cada)l 

resultados.add(cada); 

return resultados; 


CAPÍTULO 14 

Padrões de Apresentação Web 


ÚPÍl'ULO 14 • PAl>RÔES DE APRESENTAÇÃO WEB 315 

Modelo Vista Controlador (Model View Controller} 

Divide ninteração da inlerface com o usuário em três papéis distintos. 

Vista !<:-----------> Controlador 

1 1 

1 1 

' 
' 
1 1 
1 
1 1 
1 1 
~---------1 ,---------'

1 1 
1 1 
1 1 

1 1 
1 

' 

Modelo 

O Modelo Vista Controlador (MVC) é um dos padrões mais citados (e mais citildos indevidamente). 
Ele começou como um fmmework desenvolvido por Trygve Reenskaug 
para a plataforma Smalltalk no final dos anos 70. Desde então ele tem exercido 
um papel de influência na maioria dos Jranreworks para a interface como usuário e no 
pensar sobre o projeto de interfaces com o usuário. 

Como Funciona 

O MVC considera três papéis. O modelo é um objeto que representa alguma informação 
sobre o domínio. É um objeto não-visual contendo todos os dados e comportamento 
que não os usados pela interface de usuário. Na sua forma 00mais pura, o 
modelo é um objeto dentro de um Modelo de Domínio (126). Você também poderia 
pensar em um Roteiro de Trnnsnçiio (120) como o modelo, desde que ele não contenha 
nenhum mecanismo de interface com o usuário. Tal definição amplia a noção de modelo, 
mas se adapta à divisão de papéis do MVC. 

A vista representa a exibição do modelo na interface com o usuário. Assim, se 
nosso modelo for umobjeto cUente nossa vista poderia ser umfrn111e cheio de controles 
para a interface com o usuário ou uma página HTML com informações do modelo. 
A vista diz respeito apenas à apresentação de informações, quaisquer alterações 
nessas informações são manipuladas pelo terceiro membro da tl-íade MVC: o controlador. 
O controlador recebe a entrada do usuário1 manipula o modelo e faz com que 
a vista seja atualizada apropriadamente. Dessa forma, a interface de usuário é uma 
combinação da vista e do controlador. 

Quando penso sobre o MVC, vejo duas separações principais: separar a apresentação 
do modelo e separar o controle da vista. 
Destas, separar a apresentação do modelo é uma das heurísticas mais fundamentais 
do bom projeto de softwnre. Esta separação é importante pordiversas razões. 

• Fundamentalmente, a apresentação e o modelo referem-se a preocupações 
diferentes. Quando você está desenvolvendo uma vista, você está pensando 
nos mecanismos de interface com o usuário e em como construir uma boa in

3 16 PARfE li • Os PAORÕES 

terface com o usuário. Quando você está trabalhando com um modelo, você 
está pensando em políticas de negócio, talvez em interações com bancos de 
dados. Certrunente você usará bibliotecêls dHerentes, muito diferentes, ao trabalhar 
com a vista ou com o modelo. Muitas vezes, as pessoas preferem uma 
área ã outra e se especializam em um dos lc1dos da linha. 

• Dependendo do contexto, os usuários querem ver as mesmas informações 
básicas do modelo de diferentes formas. Separar o modelo da vista permite 
que você desenvolva diversas apresentações -de fato, interfaces completamente 
diferentes -e ainda use o mesmo código do modelo. O mais notável é 
que isso poderia estar fornecendo o mesmo modelo com um cUente rico, um 
navegador Web, uma API remota e uma interface em linha de comando. 
Mesmo dentro de uma única interface Web você poderia ter dHerentes páginas 
de clientes em diferentes pontos de uma aplicação. 
• Os objetos não-visuais são geralmente mais fáceis de testar do que os visuais. 
Separar a apresentação do modelo permite que você teste facilmente toda a 
lógica do domínio, sem recorrer a coisas tais como complicadas ferramentas 
de roteiros (scripting) para a interface com o usuário. 
Um ponto-chave nesta separação é a direção das dependências: a apresentação 
depende do modelo, mas o rnodelo não depende da apresentação. As pessoas programando 
o modelo não deveriam ter conhecimento algum de qual apresentação éStá 
sendo usada, o que ao mesmo tempo simplifica a sua tarefa e torna mais fácil a adição 
de novas apresentações mais tarde. [sso também significa que as alterações na 
apresentação podem ser feitas livremente sem alterar o modelo. 

Este princípio introduz uma questão comum. Com uma interface de cliente rico 
com diversas janelas, é provável que existam diversas apresentações de um modelo 
cm uma tela de uma só vez. Se um usuário fizer uma alteração no modelo a partir 
de uma apresentação, as outras precisam mudar também. Para fazer isso sem criar 
uma dependência, você normalmente precisa de uma implementação do padrão Observer 
fGang of Four ], tal como propagação de evento ou um lisfpner. A apresentação 
atua como o observador do modelo: toda vez que o modelo muda, ele dispara um 
evento e as a.presentações ahmlizarn a informação. 

A segunda divisão, a separação da vista e do controlador, é menos importante. 
De fato, a ironia é que quase todas as versões de Smalltalk não fizeram realmente 
uma separação vista/controlador. O exemplo clássico de por que você iria querer separá-
los é para suportar comportamento editável e não-editável, o que você pode fazer 
com uma vista e dois controladores para os dois casos, em que os controladores 
são estratégias LGang of Four] para a vista. Na pratica, entretanto, a maioria dos sistemas 
tem apenas um controlador por vista, de modo que esta separação geralmente 
f\ão é feita. Ela voltou a estar em voga com interfaces Web nas quais ela se torna 
útil para novamente separar o controlador e a vista. 

O fato da maioc.iil dosfmmeworks para a interface com o usuário combinar vista 
e controle levou a muitas citações errôneas do padrão MVC. O modelo e a vista são 
óbvios, mas onde está o controle? A .idéia comum é que ele se situa entre o modelo e 
a vista, como no Co11trolndor de Aplicnçiio (360) -o fato da palavra "controlador" ser 
i1sada em ambos oscontextos não ajuda. Sejam quais forem os méritos de um Controlador 
de Aplicaçiío (360), tratn-sc de algo muito diferente de umconh·ole MVC. 


CAPilULO 14 • PADRÕES DE APRESENTAÇÃO Wta 317 

Para os propósitos deste conjunto de padrões, estes prindpios são realmente tudo 
o que você precisa saber. Se você quiser se aprofw1dar mais em MVC a melhor referência 
djsponível é [POSA]. 

Quando Usá-lo 

Como eu disse, o valor do MVC está nas suas duas separações. Destas, a separação 
entre a apresentação e o modelo é um dos mais in1portantes princípios do projeto de 
software, e a única vez em que você não deve segui-lo é em sistemas muito simples 
em que o modelo não tem nele nenhum comportamento real. Assim que você tiver 
alguma lógica não-visual, deve aplicar a separação. lnfelizmente, muitos dos Jrame~ 
works para interface com o usuário tomam isso difícil, e aqueles que não o fazem, 
mtútas vezes, são ensinados sem enfatizar a separação. 

A separação entre a vista e o conb·olador é menosimportante, de modo que eu 
s6 a recomenda.ria quando fosse real.mente útil. Para sistemas com clientes ricos, isso 
acaba sendo quase nunca, embora seja comum em front ends Web no qual o controle 
é separado. A maioria dos padrões sobre o projeto Web é baseada nesse princípio. 


318 PARTE li • Os PADRÕES 

Controlador de Página (Page Controller) 

Um objeto que trntn 111110 solicitnçno rmrn 11111t1 pngi11nº" ação específicn em 11111 site Web. 

Modelo 

-------:~---------! 

-lógica do domínio

Controlador de Página 

--------~-------J 

'T'

•· tratar comandos get 1 
epost HTTP 
1

•· decidir qual 1 
modelo e 1
~---------.1 
1 

vista usar 

• Vista 
<'" 

~-------~-------


-mostrar HTML 

A experiência Web básica da maioria das pessoas é com páginas HTML estáticas. 
Quando você solicita um HTML estático, você passa para o servidor Web o nome e o 
caminho de um documento HfML nele armazenado. A noção-chave é que cada página 
em um site Web é um documento separado no servidor. Com páginas dinâmicas, 
as coisas podem ficar mtúto mais interessantes já que há um relacionamento 
muito mais complexo entre nomes de caminhos e o arquivo que atende à solicitação. 
Entretanto, a abordagem de um caminho levando a um arquivo que trata a solicita• 
ção é um modelo simples de entender. 

O resultado é que o Co11trolndor de Página tem um controlador de entrada para 
cada página lógica do site Web. Esse controladorpode ser a própria página, como freqüentemente 
ocorre em ambientes de páginas servidoras, ou pode ser um objeto separado 
que corresponda àquela página. 

Como Funciona 

A idéia básica por trás de um Conlrolndor de Pdgi11a é fazer com que um módulo no 
servidor Web aja como umcontroladorpara cada página no site Web. Na prática, ele 
llào fwlciona exatamente como um módulo por página, já que, às vezes, você pode 
clicar em um link e obter páginas diferentes, dependendo da informação dinâmica. 
Mais precisamente, os controladores se associam a cada ação, que pode ser clicar em 
um link ou em um botão. 

O Co11trolador de Ptfgi11a podeser estrutUiado tanto como um roteiro (script CGI, 
servlet, etc), quanto como uma página servidora (ASP, PHP, JSP, etc). Usar uma página 
servidora geralmente combina o Co11trolndor rle Páginn e uma Vista Padrão (333) 
no mesmo arquivo. Isso hmciona bem para a Vista Padrão (333), mas não tão bem para 
o Confrotador de Página, porque é mais complicado estruturar apropriadamente o 
módulo. Se a págim1 for uma apresentação simples, isso não é problema. Gntretanto, 
se houver lógica envolvida para extrair dados da solicitação ou decidir qual vista 
mostrat·, então você pode acabar com um código scripllet complicado na página 
servidora. 

Um modo de lidar com o código scriptlet é usar um objeto auxiliar. Neste caso, 
a primeira coisa que a página servidora faz é chamar o objeto auxiliar para tratar to



ÚPITTJLO 14 • PADRÕES DE APRESENTAÇÃO WEB 319 

da a lógica. O objeto auxiliar pode retornar o controle para «página servidora original 
ou ele pode transferi-lo para uma outra página servidora diferente para que esta 
atue como a vista. Neste caso, a página servidora trata «so1icitação, mas a maior parte 
da lógica do controlador fica no objeto auxiliar. 

Outra abordagem é tornar o controlador e o manipulador um scripf. O servidor 
Web passa o controle para o scripl, este executa as responsabilidades do controlador 
e finalmente transfere o controle para uma vista apropriada para que esta mostre os 
resultados. 

As responsabilidades básicas de um Controlador de Página são: 

• Decodificar a URL e extrair quaisquer dados do formulário para ter disponíveis 
todos os dados para a ação. 
• Criar e chamar quaisquer objetos do modelo para processar os dados. Todos 
os dados relevantes da solicitação HTML devem ser passados para o modelo, 
de modo que os objetos do modelo não precisem de nenhuma conexão 
com a solicitação HTML. 
• Determinar qual vista deve mostrar a página de resposta e transferir a informação 
do modelo parn ele\. 
O Controlador de Página não precisa ser uma única classe, mas pode chamar 
objetos auxiliares. Isso é particularmente útil se diversos manipuladores tiverem que 
executar tarefas semelhantes. Uma classe auxiliar pode então ser um bom lugar para 
colocar qualquer código que, de outra forma, seria duplicado. 

Não há nenhum motivo para que você não possa ter algumas URLs tratadas 
por páginas servidoras e algumas por scripts. Quaisquer URls que tenham pouca 
ou nenhumél lógica de controle são meU\or manipuladas por uma página servidora, 
uma vez que ela fornece um mecanismo simples que é fácil de entender e modificar. 
Quaisquer URLs com lógica mais complicada vão para um script. Já me deparei 
com equipes que queriam tratar tudo da mesma forma: tudo são páginas servidoras 
ou tudo é um roteiro. Quaisquer vantagens de consistência cm tal aplicação 
são gernlmente contrabahmçadas pelos problemas de páginas servidoras carregadas 
de scriptlets ou um número grande de scripts que servem apenas como uma simples 
passagem. 

Quando Usá-lo 

A principal decisão a tomar é quando usar um Controlador de Ptíginn ou um Controlador 
Frontal (328). Dos dois, o Controladorde Página é o mais rotineiro para se trabalhar 
e leva a um mecanismo natural de estruturação no qual ações particulares são tratadas 
por páginas servidoras particulares ou classes scripts. Seu compromisso é, portanto, 
a maior complexidade do Controlador Fro11tal (328) contra as várias vantagens 
do Controlador Frontal, a maior parte das quais faz diferença em sites Web que tenham 
maior complexidade de navegação. 

O Controlador de Página funciona especialmente bem em umsite onde a maior 
parte da lógica de controle seja bastante simples. Neste caso, a maioria das URLs pode 
ser tratada com uma página servidora e os casos mais complicados com objetos 
auxiliares. Qu,1ndo a sua lógica de controle é simples, o Controlador Frontal (328) adiciona 
um grande overltcad. 


320 PARTE li • Os PAORô ES 

Não é raro encontrar um site onde algumas solicitações são tratadas por Controlndores 
de Pngi11n e outras por Controlndores Frontais (328), especialmente quando uma 
equipe estiver refatorando de Luna solução para a outra. Na realidade, os dois padrões 
se misturam sem muito problema. 

Exemplo: Apresentação Simples com um Controlador Servlet 
e uma Vista JSP (Java) 

Um exemplo simples de um Controlador de Pngina exibe algumas informações arespeito 
de alguma coisa. Aqui o mostraremos exibindo algumas informações sobre um 
artista. A URL é executada em http://www.thir.gy.com/recordingApp/artista?name=daniela· 
Mercury. 

O servido!' Web precisa ser configurado para reconhecer /artista como uma chamada 
para o ControladorDeArtista. Em Tomcat, você faz isso com o seguinte código no 
arquivo web.xml: 

<servlet> 

cservlet-name>a[:ista</ser~let·name> 

<servlet• class >actionControl1er.ControladorDeArtista</servlet•class> 
</servlet> 
<servlet-mapping> 

<servlet-narne>artista</servlet•name> 
<url ·pattern>/ artista</url·pattern> 
<servlet-mapping> 

O controlador de artistas precisa implementar um método para tratar a solicitaçãô. 


Aetion Servlet 

Artista 

Controlador 
~ 

buscar

de Artista 

lerNome 

1 
1

1 ~---------------Auxiliar de Artista ------3>

1

1 

1' 

1 

1

1 

1 

l ______-----------~ Art;sta.jsp 

Figura 14.1 Classes envolvidas em uma exibição simples com umservlet Controladorde 
Página e uma vista JSP. 


CAPiTIJLO 14 • PADRÕES OE APRESENTAÇÃO WEB 321 

class ControladorDeArcista. , . 

public void executarLeitura (HttpServletRequest solícitacào, HttpServletResponse resposta) 

throws IOBxception, ServletException l 
Artísta artista = Artista.buscarChamado(solicitaçào.gec?aramecer(•no.'lle•)>; 
if (artista== null) 

forward (• /N()(lleDoJl.rcistaPaltando. jsp•, solicitação, resposta): 

else { 
solicitação.setAttribute(•auxiliar•, new Aw:iliarDeArtista (artista)!; 
:orward ("/artista.jsp', solicitação, resposta); 

Embora este seja um caso muito simples, ele cobre os pontos mais importantes. 
Primeiro, o controlador precisa crinr os objetos do modelo necessários para executar 
suas tarefas; no caso do exemplo, apenas encontrar o objeto do modelo correto para 
a apresentação. Em segundo lugar, ele coloca a informação correta na solicitação 
HTTP a fim de que a JSP possa exibi-la apropriadamente. Neste caso, ele cria um objeto 
auxiliar e coloca-o na solicitaçâo. Finalmente, ele transfere o controle para a Visln 
Padrão (333) para que esta trate a apresentação. A transferência de controle é um 
comportamento comum, logo, ele naturalmente se situa em uma superclasse parn todos 
os Conlrolndores de Páginn. 

class Actionservlet... 

protected void forward (Stri119 alvo, 
HctpServletRequest solicitação, 
HttpServletResponse resposta ) 

throws lORxception, ServletExcept ion 

RequestDispaccller despachante= getServletContext() ,getRequestDispatcher(alvo}; 
despachante.forwardtsolicicação, resposta); 

O ponto principal de acoplamento entre a Vista Padrão (333) e o Controlndor de 
Página são os nomes dos parâmetros usados na solicitação (request) para passar 
quaisquer objetos de que a JSP precise. 

A lógica do controlador aqui é realmente muito simples, mas podemos continuar 
a usar o servlet como um controlador mesmo quando ela fica mais complexa. 
Podemos ter um comportamento semelhante para álbuns, com a ressalva de que os 
álbuns clássicos têm um objeto do modelo diferente e são apresentados com uma JSP 
diferente. Para obter este comportamento, podemos novamente usar uma classe controladora. 


class ControladorMlbum... 

public void executarLeítura (HttpServletRequest solicitação, HctpServlecResponse resposta) 
throws IOException, ServletE-xception 

Álbuo álbum: Álbum.buscar (solicitação.getPararneter(•1d')I; 

if (álbum:: null) { 
forward("/erroÂlbu.':\Faltando.jsp•, solicitacào, resposta); 
return 


322 PARTE li • Os PADRÕES 

solicitação.setAttribute(•auxiliar•, álbu:I); 
if (Album inscanceof ÁlbumClássico) 
forward ("/álbumClássico.jsp•, solicitação, resposta); 
else 
for,,ard (•/álbum.jsp•, solicitação, resposta); 

Perceba que neste caso estou usando os objetos do modelo como auxiliares em 
vez de criar uma classe auxiliar separada. Vale a pena fazer isso se uma classe auxiliar 
for élpenas um despachante burro para a classe do modelo. Porém, se você fizer 
isso, assegure-se de que a classe do modelo não contém qualquer código dependente 
do servlet. Qualquei-código que seja dependente do servlet deve estar em uma classe 
nuxfüar separada. 

Exemplo: Usando uma JSP como Manipulador (Java) 

Usar um servlet como controlador é um caminho possível, mas o caminho mais com 
um é fazer da própria página servidora o controlador. O problema com esta abordagem 
é que ela resulta em código scriptlet no início da página servidora, e, comovocê 
deve ter percebido, penso que o código sc1·iplet tem a mesm<1 relação com um software 
bem-projetado que o wrestling profissional tem com o esporte. 

Apesar disso, você pode tratar solicitações com uma página servidora como um 
manipulador, enquanto delega o controle para o objeto auxiliar p<1ra que este efetivamente 
execute a função de controlador. Isso preserva a propriedade simples de ter 
sua URL disponibilizada por páginas servidoras. Farei isso para a exibição do álbum, 
usando a URL na forma http: / /localhost: 8080/isa/album. jsp?id=zero. A maioria dos álbuns 
é apresentada diretamente com a JSP de álbum, mas gravações de clássicos requerem 
uma apresentação diferente, uma JSP de álbum clássico. 

O comportamento deste controlador aparece em uma classe auxiliar para o JSP. 
Aclasse auxiliar é configurnda na própria JSP do álbum. 

álbuni. jsp.. . 

<jsp:useBean id:'auxiliar' class=•actionController.Aux:liar<:trlÁlburn•/> 
<\au.xiliar.1nit(sol1citaçào, resposta); i> 

A chamada ao método init configura o auxiliar para executar o comportamento 
do controlador. 

class AuxiliarCtrlÃlbum extends ControladorAuxiliar ... 

publ ic void init{HttpServletRequest solicitação, HttpServletRespcnse resposta) 
super.init(solicitação, resposta); 
if (lerÃlbum( l == nulll fon.,arô (•erroFalcandoÃlbuo.jsp•, solicicacão, resposta): 
if (lerÁlbum( 1 instanceof ÁlbumClãssicol { 

solicitação.setAttribute(•auxiliar•, lerÁlbum( 1), 

forward(•/álbur.Clássico.jsp•, solici tação, resposta); 

O comportamento comum do auxiliar fica, naturalmente, em umc1 superclasse 
auxiliar. 


ÚPÍTULO 14 • PADRÕES DE APRESENTAÇÃO WEB 323 

class ControladorAux.iliar. .. 

public void init (HttpServletRequest solicitação, HttpservletResponse resposta) 
this.solicitaçâo = solicitação; 
this.resposta = resposta; 

protecteó vois Eorward (String alvo, 
HttpServletRequest solicitação, 
HttpServletResponse resposta) 

try 1 
RequestOispatcner despachante= solicitação.getRequestDispatcher(a_vo); 
if (despachante = nulll resposca. sendErrortresposta. se_uo _CONTES!l ; 
else despach.ante.forward (solicitação, resposta)1 

} catch (IOException el { 
throw new ApplicationExoeption (e}: 
) catch (ServletBxception et 1 
throw new ApplicationExoeption [e); 

A principal diferença entre o comportamento do controlador aqui e aquele 
quando do uso de um servlet é que a JSP manipufadora também é a vista defa11lt e, a 
menos que o controlador transfira o controle para uma outra JSP, este retorna para o 
manipulador original. Isso é uma vantagem quando você tem páginas na qual, na 
maior parte do tempo, a JSP atua diretamente como a vista e, portanto, não há nenhuma 
transferência a ser feita. A inicialização do objeto auxiliar atua para dar a partida 
em qualquer comportamento do modelo e configurar as coisas para a vista mais 
tarde. É um modelo simples de seguir, já que as pessoas geralmente associam uma 
página Web com a página servidora que atua como sua vista. Freqüentemente isso 
também se adapta naturalmente à configuração do servidor Web. 

A chamada para i.njcializar o manipulador é um pouco deselegante. Em um ambiente 
JSP essa complicação pode ser muito melhor trêltada com uma etiqueta personalizada 
(c11sto111 lag).Tal etiqueta pode criar automaticamente um objeto apropriado, 
colocá-lo na solicitação e inicializá-lo. Com isso, tudo o que você precisa é de uma 
etiqueta simples na página JSP. 

<auxiliar:init name: •aetionCôntroller.AuxiliarCtrlÁlbu.~•/> 

A implementação da etiqueta personalizada executa então o trabalho. 

class EtiquetaDelnicializaçãoDoAuxiliar extends EtiquetaDoAuxiliar... 

private String nOOJeDaClasseAuxiliar; 
public void gravarNome (Suing nometlaClasseAuxiliar) ( 
this.nomeDaClasseAuxi!iar = nomeDaClasseAuxiliar; 

public int iniciarEtiqueta () thro-~"S JspException { 
ControladorAuxiliar auxiliar: null; 
try 1 

auxiliar= (COntrolaàorAuxiliar) 
Class.forNar.e!nomeDaClasseAuxiliar) .newlnstance( li 
) catcb (Exception e) { 


324 PARTE li • Os PAORÕES 

throw ne\\' ApplicationRxcepcion ('Não foi possível instanciar• • nomeDaClasseAuxiliar, e); 
} 
iniciarAux.iliar(auxllia.r); 
pageContext.setAttribute(AUXILIAR, auxiliar}; 
retum SKIP_BODY; 

private void iniciarAuxiliar (COntroladorAuxiliar aw<iliarl 
HttpServletRequest solicicacào: (HttpServletRequest) pageContexc.getRequest( ) ; 
HttpServletResponse resposta= IHttpServletResponsel pageCOntext.getResponsel ) ; 
auxiliar.init{solicitação, resposta); 

class EtiquetaAuxiliar... 

public stacic final String AUXILIAR: •auxiliar•; 

Se eu for usar etiquetas personalizadas dessa forma, eu poderia ainda criá-las 
para acessar também as propriedades. 

class BtiquetaAuxiliarDeLeitura extends etiquetaAuxiliar... 

private String nomeDaPropriedade; 
public void gravarPropriedade (String nomeOaPropriedadel 
this.non:eDaPropriedade: nomeOaPropriedade; 

public int iniciarEtiqueta () throws JspE~ception { 
try ( 
pagecontext.getOutl ).printllerPropriedade{nomeDaPropriedadel)1 
} eacch (IOException e) l 
throi.-new JspException{"!lào Eoi possível imprimir em um writer"l; 

retum SKtP_BODY; 

class EtiquetaAuxiliar... 

protected Object lerPropriedade(String propriedade) throws JspException ( 
Object auxiliar~ lerAuxiliar{ l; 
try ( 

final Mechod leitor~ auxiliar.getClass( }.getMethod(lendoMétodo(propriedade), null); 
return leitor.invoke{aUYJliar, null}; 
} eacch (Bxception e) { 
throw new JspException 
("Nào foi poss:vel chamar•, lendoMécodo{propriedaàe) , • -• ♦ e.getMessage( )); 

private Object lerAuxiliar ( ) throws JspException l 
Object auxiliar= pageContext.getAttribute(AIJXILIAR}; 
if (auxiliar:: null) throw new JspException(~Auxiliar não encontrado"!; 
return auxiliar; 

private String lendoMétodo(String propriedade) { 
String nomeDoMétodo: 'ler" t propriedade.substring(0,11 .toUpperCase[) + 
propriedade.substring(l ); 
return noo:eDd-!étodo; 


ÚPÍl'ULO 14 • PADRÕES DE APRESENTAÇÃO WEB 325 

(Você pode achar que é melhor usar o mecanismo de Java Beans do que apenas 
chamar um método de leitura usando reflexão. Se este for o caso, provavelmente você 
está certo ... e, provavelmente, você também é inteligente o bastante para descobrir 
como alterar o método para fazer isso.) 

Com a etiqueta de leitura definida, posso usá-la parn extrair informações do objeto 
auxifüu. A etiqueta é mais curta e elimina qualquer chance de eu digitar "auxiliar" 
errado. 

<B><aux.ilia.r:9ec prc,perty = •citulo"/></B> 

Exemplo: Manipulador de Página com um Código Por Trás {C#) 

O sistema Web em .NET é projetado para trabalhar com os padrões Controlador de Página 
e Vista Padtiio (333), ainda que você certamente possa decidir tratar eventos Web 
com uma abordagem diferente. Neste próximo exemplo, usarei o estilo preferido de 
.NET, construindo a camada de apresentação sobre um domínio usando um Módulo 
Tal,ela (134) e usando conjuntos de dados (data seis) como os principais transportadores 
de informação entre as camadas. 

Desta vez, teremos uma página que mostra pontos marcados e a média de pontos 
para um turno de uma partida de críquete. Como sei que terei muitos leitores aflitos 
com a falta de experiência nesta forma de arte, deixe-me resumir dizendo que os 
pontos marcados são os pontos do rebatedor, e a média de pontos é o número de 
pontos que ele marca dividido pelo número de bolas arremessadas em sua direção. 
Os pontos marcados e as bolas arremessadas estão no banco de dados. A média de 
pontos precisa ser calculada pela aplicação -um pedaço de lógica de domínio pequeno, 
mas pedagogicamente útil. 

O manipulador neste projeto é uma página Web ASP.NET, capturada em um arquivo 
.aspx. Assim como com outras construções de páginas servidoras, este arquivo 
permite que você insira lógica de programação diretamente nas páginas como 
scríptlets. Já que você sabe que eu preferiria beber cerveja ntim a escrever scriptlets, 
você sabe que há poucri chance de eu fazer isso. Meu salvador neste caso é o mecanismo 
de código por trás da ASP.NET que permite que você associe um arquivo e 
classe comuns à página aspx, sinaliza.do no cabeçalho da página aspx. 

<\. Page language = •e;• Codebehind="bat.aspx.cs• 11utoEventWireup=•false• trace:•False• 
Inherits=•rebatedores.PáginaDeRebat1das• I> 

A página é configurada como uma subclasse da classe código "por trás'',e desta 
forma pode usar todas as suas propriedades e métodos do tipo protected. O objeto 
página é o manipulador da solicitação, e o código por trás pode definir o tratamento 
definindo um método Carregar_Página. Se a maioria das páginas seguir um fluxo comum, 
posso definir uma Camnda Supertipo (444) que tenha um método padr~o [Gang 
of Four] para isso. 

class PáginaDeCriquete... 

protected void Carregar_Página (objecc remetente, System.Rvent11rgs el { 
db = newOleDbConnect ion(DB.ConnectionString); 
if(háParâmecrosFaltando( )1 

transfere6.rro lmensagemDeFalt~DeParã~etrosl, 
DataSet ós = lerDados(); 


326 PARTE li • Os PADRÕES 

if(nãoHáDados(ds)l 

transfereErro !"Nenhum dado corresponde â sua solic~tação•); 
aplicarLógicaDoDominio(ds); 
DataBind ( 1 ; 
prepararlnterfaceCo.~Usuário(dst ; 

O método padrão divide o tratamento da solicitação em vários passos comuns. 
Desta maneira, podemos definir um fluxo único comum para tratar solicitações Web, 
ao mesmo tempo em que permitimos que cada Controlador de Pági11a forneça implementações 
para os passos específicos. Se você fizer isso, depois que tiver escrito unS 
poucos Controladores de Páginas, saberá que fluxo comum usar no método padrão. Se 
alguma página precisar fazer algo completamente diferente, ela sempre poderá sobrescrever 
o método de carga da página. 

A primeira tarefa é fazer a validação dos parâmetros chegando à página. Em 
um exemplo mais realista, isso poderia requerer a verificação de valores de várias 
formas, mas neste caso estamos apenas decodificando urna URL na forma 
http://localhost/rebatedores/bat.aspx?equipe;Inglaterra&período=2&jogo=90S.A única validação 
neste exemplo é que os vários parâmetros requeridos para a consulta ao 
banco de dados estejam presentes. Como de costume, tenho sido extremamente 
simplista na manipulação de erros até que alguém escreva um bom conjunto de padrões 
sobre validação -então, aqui, a página especificada define um conjunto de 
parâmetros obrigatórios, e a Ca111nda Supertipo (444) tem a lógica para verificá-los. 

class PáginaDeCriquete.. . 

abstract protecteà String( 1 parãmetrosôbrigatórios l l ; 
private Boolean háParãoetrosfaltando () { 
foreach (String parâmetro in paràmetrosObrigat6riosl )) 
if (Request.Params{parâmetroJ == null} return true; 
return false; 

private String r.ensagemDeFal taDeParámetros () 
get ( 
Strin<J resultado= "<p>Escào faltando parâmetros obrigatórios nesta 

página: <P>º; 
resultado += "<UL>"; 
foreach (String parâmetro in parâmetrosObrigatóriosl )1 

if (Request.Params[parâmetro) = null) 

resultado t= String.Format('<LI>{O}</L!>", parâmetro); 
resultado+= "</UL>" 
return resultado; 

protected void transfereErro (String mensagem) 
Context.ltems.Add(•mensagemDeSrro', ~ensageml: 
Context.Server.Transfer("Brro.aspx'); 

class PágU'laDeRebatidas.. . 

override protected String( j parámetrosObrigatórios ( ) { 
String( } resulc~do = {"equipe•, •período•, •jogo•); 
return resultado; 


CAPil'ULO 14 • PADRÕES DE APRESENTAÇÃO W EB 327 

O próximo estágio é extrnir os dados do banco de dados e colocá-los em um objeto 
do tipo conjunto de dados (dnfn sat) ADO.NET desconectado. Aqui está uma úrúca 
consulta para a tabela de rebatidas. 

class PáginaDeCríquete... 

abstract protected DataSet lerDados( ) ; 
protected Boolean nãoHáDados (DataSet ds) 
éoreach {DacaTable tabela in ds.Tables) 
if(tabela.Rows.Count != OI return false; 
return nue; 

class PáginaDeRebatidas ... 

override protected DataSet lerDados i, 
OleDbCOl1''"1and c0111ando = new OleObCo:nmand(SQL, db); 
co.-nando.Parameters.Add (new OleDbParameter(•equipe•, equipe)); 
c<XMndo.Parameters.Add (new OleDbParameter(•periodo•, período)); 
c0a1ando.Parameters.Add (new OleDbParameter(•jogo•, jogo)); 
OleDbAàapter da: new OleDbAdapter(comando); 
DataSet resultado= new DataSetl ); 
da.Fill(resultado, Rebatidas.TABLi_NAMB); 
return resultado; 

private ccnst String SQL= 
a•SBL.ECT • from rebatidas 
WHBRE equipe : ? AN'D período : ? AJID idDoJogo : ? 

OP.DER BY ordemDeRebatidas•; 

Agora é a hora da lógica do domínio., organizada como um Módulo Tabela (134). 
O controlador passa o conjunto de dndos encontrado para o Módulo Tabela (134) para 
processamento. 

class PáginaDeCríquete ... 

protected virtual voió aplicarLóqicaDoDo:ninio {DataSet ds} { ) 

class PágínaDeRebatidas, . . 

override protected void apl icarLógicaDoDonúnio (DataSet conjuntoDeDados) 
rebatidas= new Rebat idas(conjuntoDeDados)1 
rebatidas.Calcular«édias ( l; 

Neste ponto, a parte controladora do manipulador da página está terminada. 
Quero dizer com isso, em termos clássicos do Modelo Vista Co11frole (315), que o contJ
·olador deve agora transferir a apresentação para a vista. Neste projeto, a PáginaDeRebatidas 
atua tanto como controle quanto como vista, e a última chamada a preparar_nterfaceComUsuádo, 
é parte do comportamento da vista. Posso agora clizer adeus a este 
exemplo deste padrão. Entretanto, suspeito que você pensará que falta um certo fechamento 
dramático, então você poderá encontrar a continuação do exemplo mais 
adiante (página 333). 


328 PARTE li • Os PADRÕES 

Controlador Frontal (Front Controller) 

Um controlndor que trnln Iodasns solicitações para 11111 site Web. 

Comando

Manipulador 

Abstrato 

executarGet processar 
executacPost 

y 

Comando Comando 
Concreto 1 Concreto 2 

processar processar 

Em um sife Web complexo, há muitas coisas semelhantes que você precisa fazer ao 
tTatar uma solicitação. Estas coisas incluem segurança, internacionalização e fornecimento 
de apresentações particulares para determinados usuários. Se o comportamento 
do controlador de entrada for espalhado por vários objetos, muito deste comportamento 
pode acabar duplicado. Além disso, é difícil alterar comportamento em 
tempo de execução. 

O Controlador Fro11tnl consolida todo o tratamento de solicitações canalizandoas 
através de um único objeto manipulador. Este objeto pode executar o comportamento 
comum, o qual pode ser modificado em tempo de execução com decoradores. 
O manipulador entiío despacha para objetos do tipo comando que possuem comportamento 
espeáfico relacionado a uma solicitação. 

Como Funciona 

Um Controlndor Fro11tal trata todas as chamadas a um site Web, e é normalmente estruturado 
em duas partes: um manipulador Web e uma hierarquia de comandos. O 
manipulador Web é o objeto que efetivamente recebe as solicitações postou get do 
servidor Web. Ele extrai apenas as informações necessárias da URL e da solicitação 
para decidir que tipo de ação iniciar e então delega a um objeto comando para executar 
a ação (veja a Figura 14.2). 

O marupulador Web é quase sempre implementado como uma classe em vez 
de como uma página servidora, já que ele não produz nenhuma resposta. Os comandos 
também são classes em vez de páginas servidoras e, na verdade, não precisam 
de nenhum conhecimento sobre o ambiente Web, emborn freqüentemente a informação 
HTrPseja passada a eles. O manipulador Web é, ele próprio, normalmente 
um programa razoavelmente simples que não faz nada além de decidir quéll comando 
executar. 


CAPilULO 14 • PADRÕES DE APRE:SENTAÇÃO WEB 329 

um mani_e.ulador 

tratar get HTTP 

examinar URL 

new (com dados) 
comando 
concreto 
processar 

Figura 14.2 Como o Controlador Frontal funciona. 

O manipulador Web pode decidir qual comando executar tanto estática quanto 
dinamicamente. A versão estática envolve analisar a URL e us'1r lógica condicional. 
A versão dinâmica envolve pegar um pedaço padrão da URL e usar instanciação dinâmica 
para criar uma classe comando. 

O caso estático tem a vantagem da lógica explicita, verificação de erros no despachoem 
tempo de compilação e muita flexibilidade na aparência das suas URLs. O caso 
dinâmico permite a você adicionar novos comandos sem alterar o manipulador Web. 

Com a invocação dinâmica você pode colocar o nome da cfasse comando na 
URLou você pode usar um arquivo de propriedades que liga as URLs aos nomes das 
classes comando. O arqujvo de propriedades é outro arquivo para editar, mas torna 
mais fácil alterar os nomes de suas classes sem ser necessária uma gtandc pesquisa 
pelas suas páginas Web. 

Um padrão particularmente útil a ser usado com o Cotttrolador Fl'ontnl é o Filtro 
/11terceptndor, descrito em [Alur et ai. ]. Este é basicamente um decorador que encapsula 
o manipulador do controlador fron tal permitindo a você criar uma cadeia de filtros 
(ou pipeline de filtros) para lidar com questões télis como autenticação, loggi11g e 
identificação de local. O uso de filtros permite que você, dinamicamente, prepare os 
filtros a usar em tempo de configuração. 

Rob Mee mostrou-me uma variação interessante do Controlador Frontn/ usando 
um manipulador Web de dois estágios, djvidido em um manipulador Web degenerado 
e em um despachante. O manipulador Web degenerado extrai os dados básicos 
dos parâmetros http e os passa para o despachante de tal modo que o despachélnte é 
completamente independente do fra111ework do servidor Web. Isso torna os testes 
mais fáceis, porque o código de teste pode alimentar diretamente o despachante sem 
ter que rodar em um servidor Web. 

Lembre-se de que tanto o manipulador quanto os comandos são parte do controlador. 
Emfunção disso, os comandos podem (e devem) escolher que vista usar parn 
a resposta. A única responsabilidade do manipulador é escoU1er qual comando 
executar. Uma vez que isso tiver sido feito, ele participa mais dessa solicitação. 


330 PARTE li • Os PAORôES 

Quando Usá-lo 

O Confl'olador frontal é um projeto mais complicado do que sua contraparte óbvia, o 
Controlador de Página (318). Ele precisa portanto apresentar algumas vantagens para 
justificar o esforço. 

Apenas um único Controlador Frontal tem que ser configurado no servidor Web; 

o manipulador Web fa7. o resto do trabalho de despacho (dispatclLi11g). Isso simplifica 
a configuração do servidor Web, o que é uma vantagem se ele for complicado de configurar. 
Com objetos co1Tu1ndo dinâmicos, você pode adicionar novos comandos sem 
alterar nada. Eles também tornam mais fácil portar a aplicação, já que você tem apenas 
que registrar o manipulador em um modo específico do servidor Web utilizado. 
Devido ao fato de você criar novos objetos comando em cada solicitação, você 
não tem que se preocupar em tornar as classes dos comandos seguras a f/1reads. Dessa 
maneira, você evita as dores de cabeça da programação multitlircad, entretanto você 
tem de se assegurar de que não compMtilha quaisqueroutros objetos, tais con10 os 
objetos do modelo. 

Uma vantagem comumente mencionada de um Controlador Frontal é que ele 
permite que você fatore código que, de outra forma, seria duplicado no Controlador 
de Pngi11a (318). Contudo, para ser justo, você também pode fazer muito disso com 
uma superclasse Controlador de Página (318). 

Existe apenas um único controlador, então você, usando decoradores [Gang of 
Fourj, pode facilmente meUlorar o seu comportamento em tempo de execução. Você 
pode ter decoradores para autenticação, codificação de caracteres, intemacionalizaçâo1 
e assim por diante, e adicioná-los usando um arquivo de configuração ou, até 
mesmo, enquanto o servidor estiver rodando. ([Alur ct ai.] descrevem esta abordagem 
cm detalhe sob o nome Filtro lnferceptador.) 

Leitura Adicional 

[Alur et ai.] fornecem uma descrição detalhada de como implementar o Controlador 
Frontal em Java. Eles também descrevem o Filtro lnterceptador, que combina muito 
bem com o Controlador Fro11tal. 

Váriosjra111eworks Web Java usam este padrão. Um exemplo excelente aparece 
em {Struts ]. 

Exemplo: Exibição Simples (Java) 

Aqui está um caso simples de uso de Controlador Frontal para a tarefa otiginal e inovadora 
de exibição de informações sobre um artjsta. Usaremos comandos djnâm.kos com 
uma URL da forma http ://localhost :8080/isa/musíca?nome=malFunciona&comando=Artista. O 
parâmetro comando diz ao manjpulador Web qual comando usar. 

Começaremos com o manipulador, que implementei como um serolel . 

class ServletFrontal ... 

publ ic void executarGet (HttpServletRequest solicitação, HttpServletResponse resposta) 

thro11•s IORxception, Servlet&xception 1 
COITlandoFrontal co.'tlalldo = lerComando (solicitação); 
c0;'Mndo.init (getServletContext! ), solicitação, resposta): 
cGn1ando.processar( ); 


ÚPÍlULO 14 • PADRÕES DE APRESENTAÇÃO WEB 331 

HttpServlet 

Front Servlet Front Command 

executarGet processar 
executa(Post 

y 

Controlador Controlador 
de Artista de Álbum 

processar processar 

Figura 14.3 As classes que implementam o Controlador Frontal. 

private Comandorrontal lerCOtr'4ndo (HttpservletRequest solicitação) ( 
try ! 
return (COmandoFrontal) ler<:1asseDoCcxaanâo(solicltaçào).newlnstance( ); 
) catch {Exception e) ( 
thro..., new ipplicat ionExoeption (e}; 

private Class ler<:lasseDoCOillando (HttpServletRequest sol icitação) 
Class resultado; 
final String noceDaClasseDoComando: 

•oontroladorfrontal ,• + •comando• -(String) solicitação.9etPararneter(•c011'1ilndo'l; 
try 1 
resultado: Class.forllame(nomeDaClasseDoComando); 
) catch (ClassNotFoundKxception el { 
resultado= UnknowCoomand.class; 

return resultado; 

A lógica é direta. O manipulador tenta instanciar uma classe cujo nome é formado 
pela concatenação do nome do comando e a palavra "Comando". Assim que ele 
obtém o novo comando, ele o inicializa com as informações necessárias provenientes 
do servidor HITP. Passei o que precisava para este exemplo simples. Você pode precisar 
de mais, como a sessão HTTP. Se você não conseguir encontrar um comando, usei 

o padrão Cnso Especial (462) e .retornei um comando desconhecido. Como é muitas ve

332 PARTE li • Os PADRÕES 

zes o caso, o Caso Especial (462) permite que você evite muita verificação adicional de 
erros. 
Os comandos compartilham umél quantidade razoável de dados e comportamento. 
Todos eles precisam ser uticializados com informações do servidor Web. 

class ComandoFrontal . .. 

pr-0tected ServletContext contexto; 
protected HttpServletRequest solicitação; 
protected HttpServletResponse resposta; 
public void init(ServletContext contexto, 

HttpServletRequest solicitação, 
HttpServletResponse resposta ) 

this.contexto: contexto; 
this.solici tação : solici tação; 
this.resposta: resposta; 

Eles também podem fornecer comportamento comum, como urn método para 
pRssar adiante, e definir um método abstrato de processRmento para os comandos 
reais sobrescreverem. 

class FrontCocr.mand. . . 

abstract public void process() tbro~s ServletException, roException; 
protected ~orAard (String alvo) throws ServletException, 10Bxception 

{ 

RequestDispatcher despachante: context-0.9etRequestDispatcber(alvo); 

despachante.fon.-ardfsolicitação, respostal; 

O objeto comando é muito simples, pelo menos neste caso. Ele apenas implementa 
o método de processamento, o que envolve chamar o comportamento apropriado 
nos objetos do modelo, colocando a informação necessária para a vista na solicitação 
e passando adiante para uma Vista Padrão (333). 

class ComandoArtista... 

publíc void process( ) throws ServletException, IOException { 
Artista artista= Artista.buscarPeloN011:e(solicitação.getParameter(•nor.ie"}l; 
solicitaçào.setAttributel"auxiliar•, new AuxiliarOeArt1sta(artista)); 
forward("/artista.jsp•); 

O comando desconhecido apenas traz uma entecliante página de erro. 

class UnknowCoounand... 

public void process( ) throws ServletException, !OException { 
forward(• /desconhecido. jsp~); 


CAPituLO 14 • PADRÕES DE APRESENTAÇÃO WEB 333 

Vista Padrão (Template View) 

Represe11tn informnções em HTML 
inserindo marcadores em 11111n pngina HTML. 

Modelo 

Auxiliar do Livro

1 

Livro 

~-----lerTítulo 1-E----


Autor 

lerAutor 

< HTML> <P><B> 

<jsp:lerPropriedade 
name="AuxiliarDeUvro" 
property='tltulo"/></8> 

<BR/> 

Autor: 
<jsp: lerPropriedade 
name= "AuxiliarDolivro• 
property= •autor'/> 

</P> 

</HTML> 

Escrever um programa que produza HTML é muitas vezes mais difícil do que você 
poderia imaginar. Embora linguagens de programação estejam melhores na criação 
de texto do que costumavam ser (alguns de nós lembram a manipulação de caracteres 
em Fortran e Pascal padrão), criar e concatenar sh"ings ainda é trabalhoso. Se não 
houver muito a ser feito, isso não é tão núm, mas uma página HTML inteira é muita 
manipulação de texto. 

Com páginas HTML estáticas -aquelas que não se alteram de solicitação para • 
solicitação -você pode usar bons editores WYSlWYG. Mesmo aqueles que gostan1 
de editores de texto primitivos acham mais fácil simplesmente digitar o texto e identificadores 
em vez de mexer com concatenação de strings em uma linguagem de programação. 


É claro que o problema é com páginas Web dinâmicas -aquelas que pegam o 
resultado de algo como pesquisas em bancos de dados e as inserem cm HTML. A página 
parece diferente em cada resultado, por isso editores HTML comuns não são 
apropriados para o trabalho. 

A melhor maneira de trabalhar é organizar a página Web dinâmica como você 
foz com uma página estática, mas colocar marcadores que podem ser transformados 
em chamadas para juntar informações dinâmicas. Já que a parte estáticfl da página 
atua como um padrão para a resposta específica, chamo isso de Vistn Pndl'ào. 

Como Funciona 

A idéia básica da Vista Padrão é inserir marcadores em uma página HTML estática 
quando ela é escrita. Quando a página é usada parn atender uma solicitação, os marcadores 
são substituídos pelo resultado de alguma computação, como uma pesquisa 
em um banco de dados. Dessa forma a página pode ser mostrada do modo costumeiro, 
muitas vezes com editores WYSJWYG, muitas vezes por pessoas que não são programadoras. 
Os marcadores então se comunicam com programas reais para enviar 
os resultados. 


334 PARlE li • Os PADRÕES 

Muitas ferramentas usam a Vistn Padrão. O resultado é que este padrão não diz 
respeito a como construir você mesmo uma Vistn Padrão, mas sim como usá-la eficazmente 
e qual é a alternativa. 

Inserindo os Marcadores Há um número de maneiras pelas quais os marcadores 
podem ser colocados no HTML. Uma é usar etiquetas H'IML-like. Isto funciona bem 
com editores WYSIWYG porque eles percebem que qualquer coisa entre os colchetes 
em ângulo(<>) é especial e a ignora ou a trata de maneira diferente. Se os identificadores 
seguirem. as regras de XMLbem-formada, você também pode usar ferramentas 
XML no documento resultante (desde que seu HTML seja XHTML, é claro). 

Outra maneira de fozer isso é usando marcadores de texto especiais no corpo do 
texto. Editores WYSIWYG tratam isso como texto comum, ainda ignorando-o mas 
provavelmente fazendo coisas aborrecidas tais com<J verificação ortográficé'I. Avantagem 
é que a sintaxe pode ser mais fácil do que a sintaxe pesada de HTML/XML. 

Muitos ambientes fornecem o conjunto de etiquetas que você usa, mas mais e 
mais plataformas agora lhe dão a habilidade de definir suas próprias etiquetas e 
marcadores, de modo que você pode projetá-los para se ajustarem às suas necessidades 
específicas. 

Uma das formas mais populares de Vista Pndriio é uma página servidora como 
ASP, JSP ou PHP. Estas realmente vão um passo à frente em relação à forma básica de 
uma Vístn Padriio, visto que permitem que você insir<1 na página lógica de programação 
arbitrária, referida como scriptlet. Entretanto, no meu modo de ver, esta característica 
é em verdade um grande problema e, ao usar tecnologia de páginas servidoras, 
você estaria melhor limitando-se ao comportamento básico da Vista Padrão. 

A desvantagem mais óbvia de colocar muitos scriptlets em uma página é que isso 
elimina a possibilidade de não-programadores editarem a página. Isso é especi<1lmente 
import<'lnte quando você estiver usando projetistas gráficos para o projeto da 
página. Entretanto, os maiores problemas de inserir scriptlets na página decorrem do 
fato de que uma página é um módulo pobre para um programa. Mesmo com uma 
linguagem orientada a objetos a construção na página faz com que você perca a 
mtlior parte das características est:ru turais que tornam possível fazer um projeto modular 
quer seja em 00 quer em um estilo procedural. 

Pior ainda, coloc:ar muitos scriptlets na página toma fácil demais misturar as diferentes 
camadas de uma aplicação corporativa. Quando a lógica do domínio começa 
a aparecer em páginas servidoras, torna-se muito difícil estrutm á-la bem e muito 
fácil duplicá-la em diferentes páginas servidoras. Tudo considerado, o pior código 
que vi nos últimos anos foi o código de páginas servidoras. 

Objeto Auxiliar A chave para evitar scriptlets é fornecer u.-r, objeto comum como um 

auxiliar para cada página. Este auxiliar tem toda a lógica real de programação. A pá


gina s6 tem d1amadas para ele, o que? a simplifica e a torna uma Vista Padrão mais pu


m. A simplicidade resultante permite a não-programadores editarem a página e aos 
programadores concentrarem-se no objeto auxiliar. Dependendo da ferramenta que 
você estiver usando, você muitas vezes pode reduzir todos os padrões em uma página 
para etiquetas HTML/XML, o que mantém a página mais consistente e mais acessível 
a suporte com ferramentas. 
Isso soa como um princípio simples e recomendávt?I, mas, como sempre, algumas 
questões tornam as coisas mais complicadas. Os marcadores mais simples são 
aqueles que obtêm informações do resto do sistema e as colocam no lugar correto na 


ÚPÍlULO 14 • PADRÕES DE APRESENTAÇÃO WEB 335 

página. Eles são facilmente traduzidos em chamadas par« o objeto auxiliar que resuJtam 
cm texto (ou algo trivialmente transformado cm texto), e o mecanismo coloca o 
texto na págim1. 

Exibição Condicional Uma questão mais complicada é o comport<1mento condkion<
1l da página. O caso mais simples é a situação em que algo é mostrado apenas se 
uma condição for verdadeira. Poderia ser algum tipo de etiqueta condicional do tipo 
<lF condição ; ~$quedaDePreço > O. 1 •> ... mostrar alguma coisa </IP>. O problema é que, 
quando você começa a teretiquetas condicionais como essa, você começa a ir pelo caminho 
de trttnsformM os padrões em uma linguagem de programação. Isso o leva 
aos mesmos problemas com os quais se depara quando insere scriptlefs na página. Se 
você precisar mesmo de uma li_nguagem de progrc1mação, até poderia usar scripllets, 
mas você sabe o que eu penso dessa idéia! 

Como conseqüência disso, vejo etiquetas puramente condicionais como indício 
de problemas, algo que você deveria tentar evitar. Você não pode evitá-las sempre, 
mas deve tentar alguma coisa mais focado do que uma etiqueta <lF> de propósito 
geral. 

Se você estiver mostrando algum texto condicionalmente, uma opção é mover 
a condição para o objeto auxiliar. A página então irá sempre inserir o resultado da 
chamada no objeto auxiliar. Se a condição não for verdadeira o objeto auxiliar irá enviar 
de volta uma string vazia, mas, desta forma, ele armazena toda a lógica. A abordagem 
funciona melhor se não houver 111nrk11ps para o texto retomado ou se for suficiente 
retornar um markup vazio que é ignorado pelo navegador. 

lsto não funciona se, digamos, você quiser realçar em uma lista itens que apresentam 
boas vendagens colocando seus nomes em negrito. Em tal situação, você 
sempre precisa dos nomes exibidos, mas, às vezes, quer o markup especial. Uma maneira 
de obter isso é fazer o objeto auxiliar gerar o 111nrk11p. Isso mantém toda a lógica 
fora da página, ao custo de retirar a escolha do mecanismo de destaque do projetista • 
da página e de dá-la ao código de programação. 

Para manter a escolha do HTML nas mãos do projeto da página, você precisa de 
algum tipo de etiqueta condicional. Entretanto, é importante olhar para além de um 
simples <IF>. Um bom caminho a escolher é uma etiqueta focada,. de modo que, em 
vez de uma etiqueta que se parece com 

<lf eicpressào = •es: áVendendoBastante( )"><B></lt> 
<property oame ~ •preço"/> 
<lF expressão= •estãVendendoBastante( l"></B></IF> 

você tem uma como 

<destacar se condiç.!o =•estáVendendol-luito• style =•bold•> 
<property name = •preço•/ , 

</óestacar, 

Em ambos os casos é importante que a condição seja feita baseada em uma única 
propriedade Boleana do objeto auxiliar. Colocar alguma expressão mais complexa 
na página é na verdade colocar a lógica na própria página. 

Outro exemplo seria colocar informações em uma página que dependa do local 
no qual o sistema esteja sendo executado. Considere algum texto que só deva ser 
mostrado nos Estados Unidos ou oo Canadá, o qual, em vez de 


336 PARlE li • Os PADRÕES 

<IF expressão= •local= •us• 11 •e.~• • > .. text~ especial </lF> 

Seria algo como 

<local includes = •us, CA"> ... texto especial </ local> 

Iteração Iterar sobre uma coleção apresenta problemas semelhantes. Se você quiser 
uma tabela em que cada linha corresponda a uma linha de item em um perudo, você 
precisa de uma construção que permüa a exibição fáciJ de informação pMa cada linha. 
Aqui é difícil evitar uma iteração gernl sobre uma etiqueta de coleção, mas isso 
geralmente funciona com simplicidade suficiente para se ajustar bem. 

Éclaro que os tipos de etiquetas com as quais você temque trabalhar muitas v-ezes 
são limitados pelo ambiente no qual você está. AJguns ambientes lhe dão um 
conjunto fixo de padrões, caso em que você pode estar mais limitado do que gostaria, 
seguindo estes tipos de diretrizes. Em ontros ambientes, entretanto, você pode 
ter mais escolha nas etiquetas a usar. Muitos deles permitem até que você defim, suas 
próprias bibliotecas de etiquetas. 

Quando Processar O nome Vista Padrão salienta o fato de que a função primária deste 
padrão é executar o papel de vista no padrão Modelo Vistn Co11frolndor (315). Para muitos 
sistemas a Vista Padrão deveria apenas executar o papel de vista. Em sistemas mais 
simples, pode ser razoável que ela execute o papel do controle, e possivelmente até o 
de modelo, emborn eu fosse lutar para separar o processamento do modelo tanto 
quanto possível. Onde a Vista Padrão tem outras responsabilidades além da vista, é imporrnnte 
assegurar que essas responsabilidades são manipuladas pelo objeto auxiliar, 
não pela página. Responsabilidades de modelo e de controle envolvem lógica de programação 
que, como qualquer lógica de programação, deveria ficar no objeto auxiliar. 

Qualquer sistema padrão demanda um processamento extra pelo servidor Web. 
Isso pode ser feito compilando-se a página após ela ser criada, compilando-a na sua 
primeira solicitaçã.o ou interpretando-a a cada solicitação. Obviamente esta última 
opção não é uma boa idéia, se a interpretação tomar algtm1 tempo. 

Uma coisa a observar com a Vista Padrão são as exceções. Se uma exceção chegar 
ao contâiner Web, você pode se descobrir com uma página tratada pela metade, 
que, cm vez de um redirecionamento, fornece alguma saída estranha para o navegado.
r solicitante. Você precisa investigar como o seu servidor Web manjpula exceções. 
Se ele fizer algo estranho, capnue você mesmo todas as exceções na classe auxiliar 
(outra razão para desdenhar os scripflets.) 

Usando Scripts Embora páginas servidoras sejam uma das formas mais comW\s de 
Vista Padrão Rttrnlmente, você pode escrever scripts no estilo Vista Padrão.Tenho visto 
uma quantidade razoável de Perl feita desta maneira. Mais notadamente demonstrada 
pelo CGl.pm de Perl, o truque é evitar concatenar strings tendo chamadas de funções 
que tenham como saída os identificadores apropriados à resposta. Dessa forma, 
você pode escrever o script na sua linguagem de programação e evitar a confusão de 
misturar a impressão de strings com lógica de programação. 

Quando Usá-la 

Pélra implementar a vista no Modelo Vista Controlador (315), a escolha principal é entre 
Vista Padrão e Vista de Transformação (343). A fotça da Vista Padrão é que ela permi



CAPilULO 14 • PADRÕES OE APRESENTAÇÃO Wee 337 

te que você forme o conteúdo da página olhando a estrutura da mesma. isso parece 
ser mais fácil de fazer e aprender para a maioria das pessoas. Em especial, cJa suporta 
muito bem a idéia de um projetista gráfico compondo uma página com um programador 
trabalhando no auxiliar. 

A Vista Padrão tem duas fraquezas significativas. Primeiro, as implementações 
comuns tornam fácil demais colocar lógica complicada na página, tornando-a assim 
difícil de sofrer manutençifo, especialmente por não-programadores. Você precisa 
de mtúta disciplina para manter a página simples e orientada à exibição, colocando 
a lógica no auxiliar. A segunda fraqueza é que a Vista Padrão é mais difícil de testar 
do que a Vista de Ti'ansformação (343). A maioria das implementações de Vista Padrão 
são projetadas para trabalhar dentro de um servidor Web e são muito difíceis ou impossíveis 
de testar de outra forma. Implementações de Vista ria Transformação (343) 
são muito ma_js fáceis de inserir em uma rotina de testes e testar sem rodar um servidor 
Web. 

Ao pensar sobre uma vista, você também precisa considerar Vista em Duas Etapas 
(347). Dependendo de seu esquema do padrão, voe~ pode conseguir implementar 
este padrão usando identificadores especializados. Entretanto, você pode achar 
mais fácil implementá-lo baseado em uma Vistn de Transformação (343). Se você vai 
precisar de Vista em D11as Etnpns (347), você precisará levar isso em consideração na 
sua escolha. 

Exemplo: Usando uma JSP como uma Vista 
com um Controle Separado (Java) 

Quando se usa uma JSP como uma vista apenas, ela é sempre chamada a partir de 

um controle em vez de diretamente do contâiner de se.n.1/et. Assim, é importante pas


sar para a JSP qualquer informação de que ela vá precisar para descobrir o que exi


bir. Uma boa maneira de fazer isso é fazer o controlador criar um objeto auxiliar e • 

passá-lo para a JSP usando a solicitação HTTP. Mostraremos isso com o exemplo de 

exibição simples do Controlador de Página (318). O método de manipulação Web para 

o servlet parece com o seguinte: 
claBs ControladorDeArtista... 

public void executarGet (HttpServletRequest solicitai.Ao, HttpServletResponse resposta) 

tht'O\l•s IOException, ServletException 1 
Artista artista = Artista.buscarPeloNooe(solicitaçào.getParameter(•norne•>Ji 
if (art ista==null) 

forward (• /ErroArtístallãoEncontrado. jsp•, solicitacão, resposta); 

else { 
solicitacão.setAttril>ute(•auxiliar•, new AuxiliarDeArtista (artista)): 
forward (~/artista.jsp•, solicitação, resposta); 

Quando se considera a Vista Padrão, o comportamento importante é criar o au


xiliar e colocá-lo na soJidtação. A página servidora pode agora alcançar o a11xiliar 

com o identificador useBean. 

<jsp:useBean id='auxiliar• type=•actíonController.auxi!iarDeArtista• scope=•solicitaç.ão•/, 


338 PARTE li • Os PAORô ES 

Com o auxilié\r no lugar, podemos usá-lo para acessar as informações que precisamos 
exibir. As informações do modelo de que o auxiliar precisa foram passadas 
para ele quando foi criado. 

class AuxiliarDeArtista.. . 

private Artista artista; 
private AuxiliarDeArtista {Artista art1stal 
this.artista = artista; 

Podemos usar o auxiliar para obter informações apropriadas sobre o modelo. 
No caso mais simples, fornecemos um método para obter dados simples, como o nome 
do artista. 

class AuxiliarDeAr~ista... 

puhlic String lerNome( ) 
return artista.ler?lome( }; 

Então acessamos esta informação por meio de uma expressão Java. 

<B> <l=auxiliar.lerNome( ,,></B> 
ou uma propriedade 

<B><jsp:lerPropriedade name;•auxiliar• property=•nome".></B> 

A escofüél entre propriedades ou expressões depende de quem está editando a 
JSP. Os programadores acham as expressões fáceis de ler e mais compactas, mas editores 
HTML podem não ser capazes de manipulá-las. Não-programadores irão provavelmente 
preferir identificadores, já que eles se adaptam à forma gera) de HTML e 
deixam menos espaço para erros que confundem. 

Usar um auxiliar é um modo de remover código scriptlet complicado. Se você 
quiser mostrar uma lista de álbuns de um artista, você precisa executar um laço, o 
que você pode fazer com um scriptlet na página servidora. 

for (Iterator it = auxiliar.lerÁlbuns( }.íterator( l; it.hasNextt l;l 
Álbum álbu~ = (Álbum) ít.next ( ) ;\> 
<LI><l=álbum.lerTítulo( )\></Ll> 

<\ ~ h 

</UL> 

Francamente, esta mistura de Java e HTMLé realmente horrível de ler. Uma alternativa 
é mover o laço dofor para o auxiliar. 

class AuxiliarDeArtista... 

public String lerListaDeÁlbuns() 
Strir.9Buffer resul:ado = new StringBuffer( ): 
resultado.appendl"<UL>"); 


CAPiluLO 14 • PADRÕES DE APRESE'NTAÇÃO WEB 339 

for (Iterator it = lerÃlbuns( ).iterator( ); 1t.hastlex:t( );) { 
Álbw:t álbum= (Álbum) ít.next( 1: 
resultado.append(1<LI>"); 
resultado.append(álbum.lerT1tulo( )) ; 
resultado.append(~</LI>"I 1 

resultado.append(•c/UL>"I; 

return resultado.toString( t; 

public List lerÃlbuns{ > { 
return artisca.lerÁlbuns( l; 

Considero isso mais fácil de acompanhar porque a quantidade de HTMLé bem 
pequena. Isso também permite que você use uma propriedade para ler a Lista. Muitas 
pessoas não gostam de colocar código HTML em auxiliares. Embora eu prefira 
não fazê-lo, havendo a escolha entre HTML e scriptlets, eu escolho o primeiro em auxiliares 
em qualquer momento. 

O melhor caminho a seguir é um identificador especializado para iteração. 

<OL><tag:forEach host: •auxiliarr coliection ~ ~álbuns· id ~ •cada"> 
<Ll><jsp:lerPropriedade name=•cada" p~operty = •título•/,c/Ll> 

</tag!forEach></UL> 

Esta é uma alternativa muito melhor, pois mantém os scriptlcts fora da JSP e 
HTML fora do auxiliar. 

Exemplo: Página Servidora ASP.NET (C#) 

Este exemplo continua o que comecei no Controlador de Página {318) (página 325). Recordando 
para você, ele mostra os pontos feitos por rebatedores em um único período 
de uma partida de críquete. Para aqueles que pensam que críquete (cricket, grilo) 
é um inseto pequeno e barulhento, omitirei as longas rapsódias sobre o esporte mais 
imortal do mundo e resumirei tudo no fato de que a página exibe três informações 
essenciais: 

• Um número de TO para referenciar a partida. 
• Os pontos de quajs equipes estão mostrados e de quais períodos eles são. 
• Uma. tabela mostrnndo o nome de cada rebatedor e a médfa de pontos (o 
número de bolas que ele recebeu dividido pelo número de pontos que ele 
marcou). 
Se você não entende o que estas estatísticas significam, não se preocupe. O críquete 
é cheio de estatísticas -talvez sua maior contribuição à humanidade seja fornecer 
estatísticas estranhas para artigos excêntricos. 

A discussão sobre o Controlador de Pngi11a (318) abordou como uma solicitação 
Web é manipulada. Para resumir, o objeto que atua como o controlador e como a vista 
é a página ASP.NET aspx. Para manter o código do controle fora de um scriptlet, 
você define um código separado atrás da classe. 


340 PARTE li • Os PAORÕES 

<ll Page language = •c4• Codebehind=•bat.aspx.cs• AutoEventWireup:•false• trace="False• 
Inherits:•rebatedores.PáginaDeRebatidas• t> 

A página pode acessar os métodos e propriedades do cócügo atrás da classe diretamente. 
Além disso, esse código pode definir ummétodo Carregar_Página para manipuJar 
a solicitação. Neste caso, definj Carregar_Página como um método padrão 
[Gang of Four] em uma Camada Supertipo (444). 

class PáginaDeCríquete... 

protected void Carregar_Página (0bject senàer, System.EvencArgs el 
db = new OleDbConnectionfDB.ConnectionString); 
iflháParâmetrosFaltando( )) 

erroDeTransferência (mensagemOeFaltaDeParàmetros) i 
DataSet ds: lerDados ( l; 
if(nãoHáDados(dsll 

etroDeTransferência ("Henhu:n dado corresponde à sua solicitação•); 
aplicarL6gicaoooominio(ds); 
LigarOados 1 1; 
PrepararinterfaceDeUsuár1o(ds); 

Para os propósitos da Vista Padrão, eu posso ignorar tudo menos as duas últimas 
linhas da carga da página. A chamada a LigarDados permite que diversas variáveis 
de página sejam ligadas apropriadamente a suas fontes de dados correspondentes. 
Isso será suficiente nos casos mais simples, mas para os mais complicados a última 
linha chama um método no código separado da página especifica para preparar 
quaisquer objetos para seu uso. 

O número de ID, equ.ipe e período do jogo são valores únicos para a página, to


dos eles vindos para a página como parâmetros na solicitação HTTP. Posso fornecer 

esses valores usando propriedades no código atrás da classe 

class PãginaDeRebatidas... 

protected String equipe { 

get (return Request.Params[•equipe•J ;} 
) 
protected String jogo 1 

get {return P.equest.Paran:.s[•jogo•J;} 

l 

protected String período { 

get {return Request.Params["período•] ;) 
} 
protecteà String perídoOrdinal ( 

get {returo (período:: '1") ? •1°•: •2°•;} 

Com as propriedades definidas, posso usá-Ias no texto da página. 

Id do Jogo: 
<asp: label id = "rótuloJogo~ Text:"d# jogo hn runat='server• font•bold=ªTrue"> 
</asp:label>&nbsp: 


CAPiTULO 14 • PADRÕES OE APRESENTAÇÃO WEB 341 

</P> 

<P> 
<aap:label id: "rótuloEquipe• Text;"<l# equipe\>' runat;•server• ~ont•bold="True"> 
</asp:label>&nbsp; 
<asp: label id " "rótuloPeríodoOrdinal" Text="<I# períodoOróinal \>" runat=•server• 

font-bold="!rue"> 
</asp:label>&nbsp;periodO</P> 
<P> 

A tabela é um pouco mais complicada, mas realmente funciona facilmente na 
prática, devido aos .recUisos gráficos de projeto no Visunl St11dio. O Visual Studio fornece 
un, controle de grid de dados que pode ser ligado a uma t'tnica tabela de um 
conjunto de dados. Posso fazer isso ligando o método prepararinterfaceDeUsuário que 
é chamado pelo método Carregar_Página. 

class PáginaDeRebatidas.. . 

override protecced •roid prepararinterfaceOeUsuário {DataSet ds) 
DataGridl.OataSource = ds; 
DataGridl.Datallind( )i 

A classe de rebatidas é um Módulo Tabela (134) que fornece lógica de domínio 
para a tabela de rebatidas no banco de dados. A propriedade de seus dados são os 
dados dessa tabela enriquecidos pela lógica de donúnio do Módulo Tal,ela (134). Aqui 

o enriquecimento é a média de pontos, que é calculada cm vez de armazenada no 
banco de dados. 
Com o grid de dados ASP.NET, você pode seJecionar quais colunas da tabela você 
quer exibir na página Web, junto com informações sobre a aparência da tabela. 
Neste caso, podemos seledonar as colunas do nome, pontos e média. 

<asp:DataGrid iô="DataGridl" runat=•server• Width;"480px~ Height=•111px• 
BorderColor:"#336666" BorãerStyle="Double• BorderWidth: ª3px• BackCOlor:~white" 
CellPadding=•~• GridLines="Horizontal• AutoGeneratedColuima:•False•> 

<SelecteditemStyle Font·Bold='True• ForeColor=•Whice• BackColor=•#339966"></ 

Selected!tet:IStyle> 
<Ite:oStyle ForeColor="#333333" BackColoit"White"></ItemStyle> 
<HeaderStyle Font•Bold:•True• ForeColor="White" BackColor="#33E666'></HeaderStyle> 
<FooterStyle ForeColor=•~333333• BackColor="tihiteN></FooterStyle> 
cColu:nns> 

<asp:BoundColuon DataPield= •nome• ReaderText=•Rebatedor"> 

cHeaderStyle Width="70px"></HeaderStyle> 
</asp:BoundColumn> 
<asp:BoundColumn DataField= •pontos• HeaderText=•Pontos"> 

<HeaderStyle Width="30px"></HeaderStyle> 
</asp:BoundColunm> 
<asp:Bou.~Column DataField~ •stringMédia• HeaderText~"Média•, 

<HeaderStyle Wídth:"30pxº></HeaderStyle> 

</asp:BowidColumn> 
</Columns> 
<PagerStyle HorizontalAlign="Center• foreColor=•White• BackColor='#336666" 

Mode=•NumericPagesª></PagerStyle> 
</asp:DataGrid></P) 


342 PARTE li • Os PAORÕES 

O HTML para este grid de dados parece intimidador, mas no Visual Sludio você 
não o manipula diretamente, mas sim por meio de folhas de propriedades no ambiente 
de desenvolvimento, como você faz para uma boa parte do resto da página. 

Esta habilidade de ter controles de formulário Web na página Web que com• 
preendem as t1bstrações de ADO.NET dos conjuntos de dados e tabe)as de dados é a 
força e a limitação deste esquema. A força é que você transfere informações por meio 
de conjuntos de dados, graças ao tipo de ferramentas que o Visual Shtdio fornece. A 
li.tnitação é que isso só funciona sem alterações quando você usa padrões como Módulo 
Tnb<!la (134). Se você tiver lógica de donúnio muito complexa, então um Modelo 
de Domínio {126) se torna útil. Para tirar proveito das ferramentas, o Modelo de D0111{nio 
(126) precisa criar seu próprio conjunto de dados. 


ÚPÍl\JLO 14 • PADRÕES DE APRESENTAÇÃO WEB 343 

Vista de Transformação (Transform View) 

Uma vista que processa dados do domínio ele111enfo por elemento 

eos transfor111t1 e111 HTML. 

Modelo 

Transformar

Álbum 

cria HTML 

Artista 

----------transformarÁlbum ,_______ 
ler 

transformarArtis1a 

Quando você envia solicitélçôes de dados para o domínio e camadas de fontes de dados, 
recebe de volta todos os dados de que precisa pélra satisfazê-las, mas sem a formatação 
necessária para criar uma página Web apropriada. O papel da vista no Modelo 
Vista Controle (315) é representar esses dados cm uma página Web. Usar Vista de: 
Trn11sformaçiio significa pensar nisso como uma transformação em que você tem os 
dados do modelo como entrada e seu HTML como saída. 

Como Funciona 

A noção básica de Vistn de Trn11sfor111nçiio é escrever um programa que olha os dados 
orientados ao domínio e os converte para HTML. O programa percol're a estrutura 
dos dados do domínio e, quando reconhece cada forma de dado do domínio, grava 
a parte especifica de HTML para ela. Se você pensar nisso de uma forma imperativa, 
poderá ter um método chamado exibirCliente que recebe um objeto cliente e o exibe 
em HTML Se o çljente contiver muitos pedidos, este método percorre os pedidos 
chamando exibirPedido. 

A diferença-chave entre Vista de Transformação e Vista Padrão (333) é o modo pelo 
qual a vista é organizada. Uma Vista Padrão (333) é organizada em torno da saída. 
Uma Vista de Trnnsfon11nçno é organizada em torno de transformações separadas parn 
cada tipo de elemento de entrada. A transformação é controlada por éllgo como um 
laço simples que olha cada elemento de entrada, encontra a transformação apropriada 
pélra esse elemento e então cfo,ma a transformação sobre ele. As regras de uma 
Vista de Tmnsformnçiio típica podem ser arrumadas em qualquer ordem sem afetar a 
saída resuJtantc. 

Você pode escrever uma Vistn de Trnnsformnção em qualquer linguagem. No momento, 
entretanto, a escoUu, dominante é XSLT. O interessante disso é que XSLT é 
uma linguagem de programação funcional, similar a Lisp, Haskell e outras linguagens 
que nunca chegaram a ser 111ninslrea111. Como tal, ela tem um tipo diferente de 
estrutura para isso. Por exemplo, em vez de chélmar rotinas explicitamente, XSLT reconhece 
elementos nos dados do domínio e então chama as transformações para exibição 
apropriadas. 

Para executar uma transformação XSLT, precisamos começar com alguns dados 
XML. A maneira mais simples pela qual isso pode acontecer é se o tipo de retorno m,tural 
da lógica de domínio for ou XML ou algo transfol'm"vcl automaticamente em 
X1VlL-por exemplo, um objeto .NET. Se isso falhar, precisamos nós mesmos produzir 
o XML, talvez povoando um Objeto de Transferência de Dados (380) que possa seria



344 PARTE li • Os PAORÕES 

lizar a sj próprio em XML. Dessa forma, os dados podem ser juntados usando uma 
API conveniente. Em casos mais simples, wn Roteiro de Transação (110) pode retormuXML 
di[etamente. 

O XMLque alimenta a transação não tem que ser urna string, a menos que uma 
forma de string seja necessária para passar por uma linha de comunjcação. É geralmente 
mais rápido e mais fácil produzir um DOM e passá-lo para a transformação. 

Assim que tivermos o XML, passamos o mesmo para um mecanismo XSLT, o 
qual está se tomando cada vez mais disponfvel comercialmente. A lógica para a 
transformação é capturada em uma style sllect XSLT, a qual também passamos para o 
transformador. Este, então, aplica a sh;le sl,eet na entrada XML para produzir a saída 
HTML, a qual podemos gravar diretamente 1,a resposta HTTP. 

Quando Usá-la 

A escolha entre uma Vistn de Tmnsformação e uma Vistn Pndriio (333) na sua maior parte 
recai sobre qual ambiente a equipe trabalhando no software de vista prefere. Apresença 
de ferramentas é um fator-chave aqui Há mais e mais editores HTML que você 
pode usar pan1 escrever Vistas Padrão (333). Ferramentas para XSLT são, pelo menos 
até agora, muito menos sofisticadas. Além disso, XSLT pode ser uma linguagem 
complicada de dominar, devido ao seu estilo de programação funcional acoplado 
com sua sintaxe XML complicada. 

Uma das forças de XSLT é sua portabilidade a quase que qualquer plataforma 
Web. Você pode usar o mesmo XSLT para transformar XML criado a partir de J2EE 
ou .NET, o que pode ajudar a colocar uma vista comum HTML sobre dados de fontes 
diferentes. 

O XSLT também é muitas vezes mais fácil se você estiver construindo uma vista 
sobre um documento XML. Outros ambiente$ geralmente requerem que você 
transforme tal documento em um objeto ou aceite passar o DOM XML, o que pode 
ser complicado. XSLT se ajusta naturalmente a um mundo XML. 

Vista de Trrmsformnção evita dois dos maiores problemas com Vistn Padrão (333). 
É mais fácil manter a transformação focada apenas em representar HTML, desta forma 
evitando ter mwta outra lógica na vista. Também é fácil executar Vista de Trn11sfor111açiio 
e capturnr a saída para teste. Isto torna mais fácil testar a vista e você não 
precisa de um servjdor Web para rodar os testes. 

A Visfn de Transformação transforma ditetamentc de XML orientado a domínio 
para HTML. Se você precisar alterar a aparência geral de um. site Web, isso pode forçá-
lo a alterar diversos programas de transformação. Usar transformações comuns, 
como as que incluem XSLT, ajuda a reduzir este problema. De fato, é muito mais fácil 
chamar transformações comuns usando Vista de Transformação do que usando Vista 
Padrão (333). Se você precisar fozer alterações globais facilmente ou suportar diversas 
apcuências para os mesmos dados, você poderia considerar Vista em 011as Etapas 
(347), a qual usa um processo de duas etapas. 

Exemplo: Transformação Simples (Java) 

Estabelecer uma transformação simples envolve o preparo de código Java parél chamnr 
a style sl,eal correta para compor a resposta. Também envolve preparar a sty/e 
sl,eet para formatar a resposta. A maior pMte da resposta a uma página é bastante genérica, 
de modo que faz sentido usar Ccntrolndor Frontnl (328). Descreverei apenas o 


CAPiluLO 14 • PADRÕES DE APRESENTAÇÃO WEB 345 

comando aqui, e você deve olhar o Controlador Frontn/ (328) para ver como o objeto 
comando se ajusta ao resto da manipulação de resposta da solicitação. 

Tudo o que o objeto comando faz é chamar os métodos no modelo para obter 
um documento XML de entrad<1 e, então, p<1ss,ir esse documento XML através de um 
processador XML. 

class ComandoÂlbum.. , 

public void processar() 

try{ 
Álbut.1 álbum = Álbum.buscarPelo?lome (solicicação.9et?arameter ( •nome• l); 
Assert.notNull (álbum); 
Print~riter saida = resposca.getWricer( l; 
XsltProcessor processador = ne~ SingleStepXsltProcessor('álbum.xsl"); 
saída.print(processador.getTransfomation(álbum.toXnllDocu~ent( li); 

l catch (Exception e) { 
throw new Application&xoeption [e}; 

O documento XNfL pode se parecer um pouco com isto: 

<álbum> 
<título>Stonncock</titulo> 
<artista>Roy Harper</artista> 
<listaDeFaixas> 

<faixa><título>Hors d'Oeuvres</titulo><t~pô>8:37<cell><tow> 
<faixa><título>The Same Old ROCX</títUlO><tempo>l2:24<cell><rOW> 
<faixa><títulox>ne Man Rock and Roll</títulO><teopo>7:23<cell><row, 
<faixa><título>Me and My Wooan</titulo><tenpo>l3:0l<cell><roA> 

</lístaDeFaixas> 
</álbulll> 

A tradução do documento XML é feita por um programa XSLT. Cada padrão se 
enquadra a uma parte específica do XML e produz uma saída HTML apropriada para 
esta páginf!. Neste caso, mantive a formataç,ão em um nível excessivamente simples 
para mostrar apenas o essencial. As cláusulas do padrão a seguir enquadram os 
elementos básicos do arquivo XML. 

<XSl:template match="álbum'> 
<h11<L><BODY bgcolor;•wbite•> 
cxsl :apply-templates/> 
</BOD'i></HTJ;!L> 

</xsl:template> 
<xsl :template match=ftálbuill/título•> 

<hl><xsl:apply•tew.plates/></hl> 
</xsl:ten:plate> 
<xsl:template match=•&lbum/artista"> 

<P><B>Altista: </B><xsl:apply-templates/><IP> 
</xsl: tew.plate> 


346 PARTE li • Os PADRÕES 

Estes padrões manipuJam a tabela, que aqui tem linhas alternadas destacadas 
em cores diferentes. Este é um bom exemplo de algo que não é possível com fluxos 
de shJle sheets, mas é razoável com XML. 

<xsl: template match="listaOeFaixas•) 

<table><Xsl: aaply-templates/></table> 
</xsl: te1q1late> 
<xsl: template e1atch=''faixa"> 

<XSl:variable na~e=•bgcolorfl> 

<Xls:choose> 
<xsl:when test=•(position( ) mod2} = l•> linen</xsl:wheo) 
<xsl:otherwise>white</xsl:other~iee> 

</xsl:choose> 
</xsl:varíable> 
<tr bgcolor='{$bgcolor) ft><Xsl:apply-templates/x/tr> 

</xsl: te1q1late> 
<Xsl: template match=" faixa/titulo•> 

<td><xsl:apply-te~.plates/></td> 
</xsl: terr.plate> 
<JCsl: template match="faixa/tempô~> 

<td><xsl:apply-te~.plates/></td> 
</xsl: tereplate> 


ÚPÍlULO 14 • PADRÕES OE APRESE'NTAÇÃO WEB 347 

Vista em Duas Etapas (Two Step View) 

Transfimun dndos do domínio em 1/TMLem duasetnpas: 
primeiroJormnndo nlg11111 tipo de página lógica edepois 
represe11tn11do essa ptfgi11n /6gicn em HTML. 

Álbum 

ler 

~...

......

artista: Artista .... Estágio 1 

,epresentarÁlbum

criar 

representarArtista 

Tela 

ler

artista: Field 
Estágio 2 

representarTelacriar . representarCampo 

_,,,

,.


HTML 

Se você tem uma aplicação Web com muitas páginas, você geralmente quer uma aparência 
e organizaçno consistentes no site. Se cada pngi.na tiver umél aparência diferente, 
você acaba com um site que os usuários achrun confuso. Você também pode querer 
fazer alterações globais na aparência do site com facilidade, porém técnicas comuns 
usando Vista Padrão (333) ou Vistn de Transfomznçiio (343) tornam isso difícil, 
porque decisões relativas a apresentação estão muitas vezes duplicadas em diversas 
páginas ou módulos de transformação. Uma alteração global pode obrigá-lo a alterar 
diversos arquivos. 

A Vista em Duns Etapas lida com este problema dividindo a transformação em 
dois estágios. O primeiro b·ansforma os dados do modelo cm uma élpresentação lógica 
sem qualquer formatação especifica. O segundo converte essa apresentação lógica 
na formatação real necessária. Dessa forma, você pode fozer uma alteração global 
alterando o segundo estágio, ou pode suportar diversas aparências de 011tp11I cada 
uma com um segundo estágio. 

Como Funciona 

A chave deste padrão fazer da transformação para HTML um processo em dois es-

é 

tágios. O primeiro junta a informação em uma estrutura de tela que

l ógica é uma in


dicação de que os elementos de exibição ainda não contêm HTML. O segt.mdo estágio 
pega essa estrutura orientada a apresentação e a representa em HTML. 

Esta forma intermediária é um tipo de tela lógica. Seus elementos podem incluir 
coisas como campos, cabeçalhos, rodapés, tabelas, seleções, e assim por diante. Como 
tal, ela é certamente orientada a apresentação e certamente força a tela a seguir 
um estilo preciso. Você pode pensar no modelo orientado a apresentação como um 


348 PARTE li • Os PADRÕES 

que define os diversos dispositivos que você pode ter e os dados que eles contêm, 
mas que não especifica a aparência HTML. 

A estrutura orientada a apresentação é montada por um código específico escrito 
para cada tela. A responsabilidade do primeiro estágio é acessar um modelo orien• 
tado a domínio, ou um banco de dados, um modelo real de domínio ou um Objeto de 
Tmnsferéncin de Dados (380) orientado a domínio, extrair as informações relevantes 
para essa tela e então colocar essas informações em uma estrutura orientada a apresentação. 


O segundo estágio transforma a estrutura orientada a apresentação cm HTML. 
Ele conhece cada elemento da estrutura orientada a apresentação e sabe como mostrá-
los como HTML. Assim, um sistema com muitas telas pode ser representado em 
HTML por um único segundo estágio de modo que todas as decisões de formatação 
de HTML são tomadas emum lugar. É claro que a restrição é que a tela resultante deve 
ser derivável de uma estrutura orientada a apresentação. 

Há diversas maneiras de criar uma Vista em Duas Etapas. Talvez a mais fácil seja 
com XSLT em duas etapas. O XSLT de uma etapa segue a abordagem de Vista de 
Trnnsfommçiío (343), na qual cada página tem uma style s11cet XSLT que transforma o 
XML orientado a domínio em HTML Na abordagem de duas etapas, há duas style 
sheets XSLT. A stylesheet da primeira etapa transforma XML orientado a domínio em 
XML orientado a apresentação, enquanto que a da segunda etapa representa esse 
XN!L em HTML 

1 

Pedido -------------41 Linha de Item 
.___,,-----, * ..__----,.-_____, 

❖ à 

1 1 

1 1 
1 1 
1 1 

1 1

i__________ Estágio do Pedido _________J 

representarPedido 
1 ----------representarlinhaDeltem ---------1 

1 1 
l 1 
1 1 
l 1 

❖ v 

1 
Tabela 1---------------11 Linha 

,___________, * ._____ 

~ ~ 

1 1 

1 ! 

1 1 
1 1

Segundo Estágio

l :
L-----------1===========+----------' 

representarTabela 
representarUnha 

Figura 14.4 Classes exemplo para representação em duas etapas. 


uma linha 

um Controlador 

um Pedido 

Figura 14.5 

novo 

-. I um primeiro 1 
-1 está_gio 

ler dados 

1 

-

de item 

1 1 
1 1 
1 1 
1 1 

-

1 
1

-u 1 1 

1 

1 1

novo 

:ler dados LJ 

1 1 

1 1 

1 1 
1 1 

1 
1 
1 
1 

1 

1 

1 

1 

1 

1 

1 

1 

1 

1 

1 
1 
1 
1 
1 

Diagrama de seqüência para representação em duas etapas. 

;;l'luma Ta bela! 

1 
1 
novo 
1 
1 -->;MI uma Linha 1 
1 1 
1 1 

1 

1 

ü ler dados 

ler dados 

uma Res osta 

adicionar 
HTML 

• 

~ 

adicionar o ,o

o, 
m

HTML 

"' 

o 

m 
)> 

:X 

m 

m 

"' 

z

;;: 

~. 

o 

~ 

m 

a, 

seden sena wa e1s1A 


350 PARlE li • Os PAORÕES 

Outra maneira é usando classes. Aqtti você define a estrutura orientada a apresentação 
como um conjunto de classes: com uma classe tabela, uma classe linha, e assim 
por diante. O primeiro estágio pega iniormações do domínio e instancia estas 
classes cm uma estrutura que modela uma tela lógica. O segundo estágio representa 
as classes em HTML, seja pegando cada classe orientada a apresentação para gerar 
HTML por si mesmo, seja tendo uma classe separada responsável por representar em 
HTML. 

Ambas as abordagens são baseadas em Vista de Tmnsformação (343). Você tam


bém pode usar uma abordagem baseada em Vista Pndriio (333), na qual escolhe pa


drões baseados na idéia de uma tela lógica -por exemplo: 

O sistema padrão converte então estes identificadores lógicos em I-ffML. Neste 
esquema, a definição da página não inclui HTML, mas apenas estes identificadores 
de tela lógica. O resultado disso é que ele provavelmente será um documento 
XML, o que é claro significa que você perde a. habilidade de usareditores WYSTWYG 
HTML. 

Quando Usá-la 

O valor-chave da Vista em D11ns Etapas vem da separação do primeiro e do segundo 
estágios, permitindo que você faça alterações globais mais facilmente. Ela ajuda a 
pensar em duas sitttações~ aplicações Web com diversas aparências ou com uma 
única aparência. Aplicações Web com diversas aparências são mais raras, mas estão 
aumentando. Nelas a mesma funcionalidade básiCél é fornecida pordiversas organizações, 
e cada organização tem sua própria aparência djstinta. Um exemplo atttal 
são sites de viagens aéreas, nos quais, quando você os olha, pode perceber pela aparência 
e projeto que são todas variações de um site básico. Suspeito que muitas linhas 
aérefls querem essa mesma funcionalidade, mé\S com uma clparência distintamente 
individual. 

Aplicações de uma única aparência são mais comuns. Apenas uma organização 
faz sua parte frontal, e elas querem uma aparência consistente em todo o site. Isso as 
torna o caso majs fácil para considerar primeiro. 

Com uma vista de único estágio (Vistn Pnd,·ão (333) ou Vista de Trnnsfon11nç1io 
{343)), você constrói um módulo vista por página Web (veja a Figura 14.6). Com uma 
Vista em Duns Etapas, você tem dois estágios: um módulo de primeiro estágio por página 
e um de segundo estágio para a aplicação inteira (Figurn 14.7). Sua compensação 
por usar Vista e111 Duas Etnpns é que qualquer alteração na aparência do site no segundo 
estágio é muito mais fácil de fazer, já que uma alteração no segundo estágio 
afeta o site como um todo. 

Com uma aplicação de diversas aparências, esta vantagem é aumentada porque 
você tem uma vista de único estágio para cada combinação de tela e aparência (Figura 
l4.8). Assim, dez telas e três aparências requel'em. trinta módulos vista de único estágio. 
Usando Vista cm Duns Etapas, entretanto (veja a Figura 14.9), você pode conseguir 
seu intento com os dez primeiros estágios e os três segundos estágios. Quanto 
mais telas e aparências você tiver, m11ior a economiél. 

Apesar disso, sua habilidade de ser bem-sucedido depende de qufio bem você 
conseguir criar a estrutura orientada a apresentação para realmente servir as neces



CAPiTULO 14 • PADRÕES OE APRESENTAÇÃO WEB 351 

Dados do 
Cliente 

Vista do 

Cliente 

«criam 

HTML do 
Cliente 

Figura 14.6 Vista de único es1ágio com uma aparência. 

Dados do 
Cliente 

Primeiro 
Estágio 
do Cliente 

«criar» 

Tela Lógica 
do Cliente 

Segundo 
Estágio 

.,

., 

«criarn 
/ 
/ 

., 
., 
/
/ 

., 

/ 

.,/

., 

/ 

HTML do 
Cliente 

Dados do 
Pedido 

Vista do 
Pedido 

((criar» 

HTML do 
Pedido 

Dados do 
Pedido 

Primeiro 
Estágio 
do Pedido 

«criar» 

Tela Lógica 
do Pedido 

HTML do 
Pedido 

Figura 14.7 Vista de dois estágios com uma aparência. 


352 PARTE li • Os PADRÕES 

Dados do Dados do 
Cliente Pedido 

1 1 1 1 

1 1 1 1 

____J 1_____

'----------' 

1 1 1 1 
1 1 1 1 

Vista Cliente Vista Cliente Vista Pedido Vista Pedido 
Foo Bar Foo Bar 

«criarn (<criam <•criar» ucrian, 

1 1 1 1 

HTML Cliente HTML Cliente HTML Pedido HTML Pedido 
Foo Bar Foo Bar 

Figura 14.8 Vista de único estágio com duas aparências. 

Dados do Dados do 
Cliente Pedido 

Primeiro Primeiro 
Estágio Estágio 
do Cliente do Pedido 

«criar>> «criar» 
1 1 

1 1 

1 : 
1 1 

1 1

'----------""--,

1 1 

1 1 
Segundo : 
Estágio Foo _______, 
'-Segundo 
Estágio Bar 

. 1 1 .

(<CrlaO> _ ____., 

~-----<1cnar,1 

1

' 

1 ((criar» «criar» 1 

1 1 
1 1 
1 1 
1 1 
1 1 

HTML do HTML do HTML do HTML do 
Cliente Foo Pedido Foo Cliente Bar Pedido Bar 

Figura 14.9 Vista de dois estágios com duas aparências. 


CAPiTULO 14 • PADRÕES DE APRESENTA<;ÃO WEB 353 

sidades da aparência. Um site com projeto pesado, no quaJ cada página deva parecer 
diferente, não funcionará bem com Vistn em Duns Etapas, porque é difícil encontrar 
coisas em comum em qwmtidade suficiente entre as telas para obter uma estrutura 
orientada a apresentação simples o suficiente. Basicamente o projeto do site é limitado 
pela estrutura orientada a apresentação, e para muitos sites é uma limitação demasiada. 


Outro empecilho de Vistn em Duas Etapas são as ferramentas requeridas para 
usá-la. Há muitas ferramentas para projetistas sem habilidade de programação criarem 
páginas HTML usando Vista Pndl'áo (333), mas Vista em Duns Etnpas obriga os 
programadores a escreverem os objetos representadores e controh:,dores. Assim, os 
programadores têm que estar envolvidos em qualquer alteração no projeto. 

Também é verdade que a Vista em Duns Etapas, com suas múltiplas camadas, 
apresenta um modelo de programação mafa difícil de aprender, embora assim que 
você esteja acostumado com ele não é difícil, e pode ajudar a reduz.ir código repetitivo. 


Uma variação no tema das aparências múltiplas é fornecer segundos estágios 
diferentes parn dispositivos djferentes, de modo que você possa ter um segundo estágio 
para um navegador e outro para um PDA. A limitação costumeira aqui é que 
ambas as aparências devem seguir a mesma tela lógica e, para dispositivos muito diferentes, 
isso pode ser pedir muito. 

Exemplo: XSLT em Duas Etapas (XSLT) 

Esta abordagem de Vista em Duns Etapas usa uma tré'lnsformação XSLT de dois está


gios. O primeiro estágio transforma XML específica do domínio em XML de tela ló


gica. O segundo estágio transforma XML de tela lógic<1 em HTML 

O XML inicial orientado a domínio se parece com o seguinte: 

<álb1m> 

<t1tu1o>Zero !!01tr</title> 
<artista>Astor Piazzola</artist> 
<lístaDeFaixas> 

cfaixa,ctítulo>Tanguedia IIl</t ítulo><terr.po>4:39<oell><r0'~> 
cfaixa>ctítulo>Milonga del Angelc/título>cteC\l)0>6:30ccell><row> 
cfaixa><título>Concierto Para Quintetoc/titulo><tecpo>9:00<cell><ro~> 
<faixa><título>Milonga Loca</titulo><te~po>3;05<cell><rO~> 
<faixa><titulo>Mid1elangelo '70</título><terr.po>2;50<cell><row> 
cfaixa><Citulo>Contrabajisim0</titulo><tempo>lO:l~<cell ><row> 
<faixa><titul o>Mutwki</título><tenq:o>9: 32<ce11><t o:..'> 

</lístaDeFaixas, 
</álbum> 

O processador XSLT da primeira página a transforma em XML orientado a tela: 

, screen> 
<titulo>Zero Hour</ticle, 
<field label:•Artista'>Astor Piazzola</field> 
<table> 

crOW><Cell>fanguedia IIIc/cell><Cell >4:39<cell><tOW> 
<row><cell>Milonga del Angel</cell><cell>6; JO<cell><tO'.o 
crow><cell>Concierco Paia Quinteto</cell><cell,9:00<cell><ro~> 


354 PARTE li • Os PAORÕES 

crowxcel 1 >'.-lilonga Loca</cell><cell>3:OS<cell><row> 
<row><cell>MÍChelangelo '70c/cell><Ce11>2:50<cell><row, 
crow><Cell,Contrabajisimoc/cell ><Oel1>10:18<cell><rOw> 
crow-><cel1>MlllWki</cel1 ><celh9: 32cce11><row> 

</table> 
</screen, 

Para fazer isso, precisamos do seguinte programa XSLT: 

cxsl:ternplate match="album•> 

<screen>cxsl:apply-cemplate&/></screen> 
c/xsl:ternplate> 
cxsl:template match="albwn/title'> 

<title>cxsl:apply-te~plates/></title> 
</xsl:cemplate> 
<xsl:ternplate match="artist"> 

c:ield label="Artist"><xsl:apply-te~places/></field> 
c/xsl: tecplate> 
<xsl:ternplate match="trackList~> 

<table><xsl:apply•templates/></table> 
</xsl:template> 
<Xsl :template match=•track'> 

crow,cxsl:apply•te~plates/></row> 
</xsl :template> 
<xsl:template match="track/title•, 

ccell><xsl:apply•templates/></cell> 
</xsl:template> 
cxsl:ternplate match=•crack/time"> 

ccell><xsl:apply-templates/></cell> 
</xsl:templat.e> 

O XML orientado a tela é bastante simples. Para transformá-lo em H1ML usamos 
um programa XSLT de segundo estágio. 

cxsl: terr.plate match~•screen"> 
<H11~L><BODY bgcolor:ªwhite"> 
<xsl:apply-templates/> 
</BODY></HTML> 

</xsl: ten:plate> 
<XSl: template IQatCh='titulo"> 
<hl><xsl:apply-teraplates/></hl> 
</xsl: ten:plate><.XSl: template reatch= "field" > 

<P><B><XSl:value-of select: •tlabel"/>: </B><XSl:apply•templateS/></P> 
</xsl: te~plate> 
cxsl: template match=•table"> 

<table><xsl:apply-templates/></table> 
c/xsl: template> 
<Xsl: terr.plate match:"table/row•> 

<xsl:variable narne=•bgcolorª> 
cxsl:choose> 
<XSl:when test:•(position( ) mod 2) = l">línen</xsl:when, 

<xsl:otherwise>white</xsl:other~ise> 
</xsl:choose> 
<XSl :variable> 


CAPilULO 14 • PADRÕES OE APRESfNTAÇÀO W EB 355 

<tr bgcolor='{$bgcolor}•xxsl:apply-te:iplates/ ></tr> 

c/xsl: template> 

cxsl: template match~~table/row/cell"> 
<td><Xsl:apply-ternplates/></td> 
</xsl: template> 

Ao montar as duas partes, usei o Co11tro/t1dor Frontnl (328) para ajudar a separar 

o código que executa o trabalho. 
class AlbumCOrt'.mand .. . 

public void process () 

try { 
Álbum álbum ~ Álb~.buscarPeloUcme (solicitaçào.getParameter ( "nCX1eº I); 
álbuo "Álbum.buscarPelollome(~l~34•); 
Assert.notNull (álbum); 
PrintWriter saída = resposta.getWriter( 1; 
XsltProcessor processador= new TwoStepXsltProcessor(•álbum2.xsl•, •segundo.xsl~I; 
saída.print(processador.getTransformatíon(álbum.toxmlDocu~ent( ll) ; 

} cacch (Bxception el { 
throw ne,, ~plicationExoeption (e ) ; 

É útil comparar esta com a abordagem de estágio único em Vistn de Transformação 
(343). Se você quiser alterar as cores das linhas alternadas, r1 Vista de Trn11sfor111ação 
(343) requer a ecUção de cada programa XSLT, mas com Vista em 011as Etapas apenas 
o único programa XSLT segunda etapa precisa ser alterado. Poderia ser possível 
usar padrões que possam ser chamados para fazer algo semelhante, mas isso precisa 
de um pouco de ginástica XSLT para ser bem-sucedido. O aspecto negativo da Vista 
cm Duas Etapas é que o HTML final é muito limitado pelo XMLorientado a tela. 

Exemplo: JSP e Identificadores Customizados (Java) 

Embora o caminho de XSLT seja conceitualmente a forma mais fácil de pensar em 
implementar Vista em Duas Etapas, existem muitas outras maneiras. Para este exemplo, 
usarei JSPs e .identificadores customizados. Embora eles sejam complicados e 
menos poderosos que XSLT1 mostram como o padrão pode se expressar de cliferentes 
modos. Estou sendo um pouco audacioso neste exemplo, pois não vi isto feito em 
campo. Contudo, acho que um exemplo um pouco especulativo lhe dará uma idéia 
do que seria possível. 

A regra chave de Vista e111 Duas Ctnpas é que escolher o que exibir e escolher o 
HTMLque o fará estejam totalmente separados. Para este exemplo, meu primeiro estágio 
é manipulado por uma página JSP e seu auxiliar, e meu segundo estágio por 
um conjunto de identificadores customiz"dos. A parte interessante do primeiro estágio 
é a páginíl JSP. 

<1i taglib ur: = "2passo.tld~ prefix = •2paeso~ l> 
<\l page session = •false"l> 
<jsp:useBean id = •auxiliar• class:•accionConcroller.AuxiliarConÃlbum•/> 
<tauxiliar.init(solicitação, resposta);\> 
<2passo:screen> 


356 PARTE li • Os PADRÕES 

<2passo:cítulo>cjsp:lerPropriedade name = •auxiliar• property = "título"/></2passo:título> 
<2passo:field label = "Artista'><jsp: lerPropriedade narae =•auxiliar• property = 
•artista"/></2passo:field> 
<2passo:cable host ="auxiliar• colleccion = •listaDe?aixas• colu:ms = •título, tempo"/ > 
</2passo:screen> 

Estou usando Co1111'0/ador de Ptígina (318) para a página JSP com um objeto auxiliar. 
Você pode checar Controlndor de Páginn (318) para ler mais sobre isso. O importante 
aqlú é olhar os identificadores que fazem parte do namespace 2passo. São eles que 
estou usando para chamar o segundo estágio. Perceba também que não há HTML na 
página JSP. Os únicos identificadores presentes são ou identificadores do segundo estágio 
ou identificadores de manipulação de bea11s para ler valores do auxiliar. 

Cada identificador de segundo estágio tem uma implementação para obter o 
HTML necessário para esse elemento da tela lógica. O mais simples deles é o título. 

class IdentificadorDoTítulo... 

public int executaridentificadorinicial I l thro-,s JspEXception ( 
try ( 
pageContext.getOut() .print("<El>"J; 
) catch (IOrxception e) { 
throw new JspException 1·não foi possível irr;prn:ilr o início~;; 

return EVAL_BODY_U:CLUDR; 

public int execu~ridentifícadorFinal 1) throws JspException { 
try 1 
pageContext.getOut\ 1 .print("</Hl>•); 
} catch IIOException e) { 
throw new JspException (~não foi possível irr.prirnir o final• ); 

return EVAL_PAGE; 

Para aqueles que não permitiram, um identificador custooúzado funciona implement.'
lndo métodos associados chamados, no início e no final do texto, identificado. Este 
identificador simplesmente envolve o conteúdo do seu corpo com um identificador 
<Hh. Um identificador mais complexo, como o campo, pode receber um atributo. Esse 
atributo é vinculado :na classe do identificador usando um método de gravação. 

class ldentificadorDoCampo... 

private String rórulo; 
public void 9ravarRóculo {String rótulo) 
this.r6tulo =rótulo; 

Assim que o valor tiver sido gravado, você pode usá-lo na saída. 

class ldentificadorDoCampo.. . 

public int executarldentificadortnicial 1 ! tbro~s JspException ( 
try ( 
pageCoatext.getOut( 1 .printl"<P>' •rótulo• •: <B>" ); 


CAPitULO 14 • PADRÕES OE APRESENTAÇÃO WEB 357 

) catch (IOException el { 
throw new JspException ("não foi possível lrr~rimir o início•); 

return BVAL_BODY_INCLUDB; 

public int executarldentificadorFinal 11 throws JspExceptícn { 
try f 
pageContext.getOut( ) .printl'</B></P>"); 
J catch {IOliX.ception el ( 
throw oew JspException (•não foi possível itLprimír o final") ; 

} 

return EVAL_PAGE; 

O Table é o mais sofisticado dos identificadores. AJém de pemi.itir ao escritor JSP 
escolher quais colunas colocar na tabela, ele destaca linhas alternadas. A implementaç~
o do identificador atua como o segundo estágio, então o destaque é feito lá, de 
modo que uma alteração no sistema inteiro possa ser feita globalmente. 

O identificador Table recebe atributos para o nome da propriedade collection, o 
objeto no qual a propriedade collection fica, e uma lista de nomes de colunas separados 
por vírgulas. 

class IdentificadorDaTabela... 

private String nome.DoConjunto; 

pri,;ate String nomeDoHospedeiro; 

private String colunas; 

public void gravarCOnjunto (String nomeDoConjunto) 

this.nomeDoConjunto = nomeDoeonjunto; 

public void gravarHospedeíro (String nomeDoHspedeiro) 
this.nomeDoHospedeiro = nomeDoHospedeiro; 

public void gravarColunas {String colunas) 
tbis.colunas= colunas; 

Criej um método auxiliar para ler uma propriedade de um objeto. Há um bom 
argumento para usar as diversas classes que suportam Java benus, em vez de apenas 
chamar um método "lerAlgumaCoisa", mas isso ai.nda servirá para o exemplo. 

class IdentificadorDaTabeia... 

private Object lerPropriedade (Object obj, String propri.edade) throws JspEXception ( 

try{ 

String nomeDoMêcodo = 8ler• + propriedade.substring(0,l) .coUpperCase{) • 

propriedade.substring(l); 

Object resultado= obj.getClasse( 1 .getMethod{nooeDoi~étodo, nulll .invoke{obj, null); 

retum resultado; 

J catch(Exception e) { 

chrow new JspException(ªnào Eoi possível ler a propriedade' • propriedade f 

• do objeto• • obj); 
} 


358 PARTE li • Os PADRÕES 

Este identificador não tem um corpo. Quando ele é chôffiado, pega o conjunto 
nomeado da propriedade da solicitação e itera por meio desse conjunto para gerar as 
linhc1s da tabela. 

class IdentificadorDaTabela... 

public int executar!dentificadorinicial 1 1 thro~s JspException ( 

try 1 
JspWriter saíàa =pageConcext.getOUt( ); 
saída.print ("<table>•Ji 
co_lection coll = (Collection) lerPropriedadeOoAtributo(nomeDoHospedeiro, no.~.eDoConjunto); 
Iterator linhas~ coll.iteratorl 1; 
int númeroDaLinha = O; 
while {linhas.hasllextl )) { 

saída.print('<tr"l ; 
if 1 (nGmeroDaLinha+i) 1) == O) saida.print(• bgcolor = • + COR_DESTAQOE)1 
saida.print(•>•) i 
imprimircélulas (linhas.next l 1) i 
saída.printl1</tr>")i 

saída.print("</table>"); 
} catch(IOException e) { 
thro~ new JspException (•não foi possível ittprimir'I; 

return SKIP_BOOY; 

private Object lerPropriedaóeDohtributo (String atributo, String propriedade) 
throws JspException 

Object objetoHospedeiro =pageContexc.findAttribute(atributo); 
if (objetoHospedeiro =: null) 
throw new JspException ('Atributo• t atributo+• não encontrado."); 
return lerPropriedade (objetoHospedeiro, proprieàade); 

public static fir.al String COR_DESTAQUB: • 1linen•u, 

Durante a iteração, ele configura uma linha sim outn, não com a cor de fundo 
usada para dar destaque a e.la. 
Para imprimir as células de cada linha, uso os nomes das colunt1s como sendo 
os valores da propriedade nos objetos do conjunto. 

class IdentificadorDeTabela... 

private void impri~irCélulas (Object cbj) thtONS IOException, JspException { 
JspWriter saída= pageContext.getOut ( ); 
for (int i = O; i< lerListaDeColunas ( 1 .length; i•+) { 

saida.print("<tà>"); 
saída.print(lerPropriedade (obj, lerListaDeColunasl) {íJ )) ; 
saida.print("</td>•); 

private String 1 1 lerListaDeColunas 1) { 
StringTokenizer tk = new StringTokenizer (colunas, •,~); 
StrÍI19 [] resultado= ne~ String(tk.countTokensl )]; 


ÚPÍl'ULO 14 • PADRÕES DE APRESENTA<;ÁO WEB 359 

for (lDt i = O; ck.hasMoreTokens; 1••) 

resultadoli) = tk.nextTokenl ); 

return res~ltado; 

Comparada com a implementação XSLT, esta solução é menos limitante quanto 
à uniformidade da aparência do site. Um autor de urna página, querendo mover 
algum HTML individual para ela, achará isso fácil de ser feito. É claro que, embora 
permita o ajuste de páginas de projeto pesado, isso também está exposto ao uso inapropriado 
por pessoas não-familiarizadas com o modo como as coisas funcionam. 
As vezes, restrições ajudam a prevenir erros. É um balanceamento que uma equipe 
tem que decidir por si própria. 


360 PARTE li • Os PADRÕES 

Controlador de Aplicação (Application Controller) 

Um ponto ccnlmlizndo parn 111a11ip11lar 11avcgnção de tcln 
e o fluxo de 11mn aplicnçiio. 

um controlador 
de entrada 
um comando 
do domínio 
uma vista 
ler comando ' 
request do domínio 1 
executar 

ter llista 

executar 

Algumas aplicações contêm uma quantidade significativa de lógica relativa a telas a 
serem usadas em diferentes pontos, o que pode envolver a chamada de certas telas 
em determinados momentos em uma aplicação. Este é o estilo especialista de interação, 
em que o usuário élevado por meio de uma série de telas em uma determinada 
ordem. Em outros casos, podemos ver telas que só são trazidas sob determinadas 
condições, ou escofüas entre diferentes telas que dependem de entradas anteriores. 

Até certo ponto, os vários contmladores de entrada do Modelo Vista Controlador 

(315) podem tomar algumas dessas decisões, mas, à medida que a aplicação fica mais 
complexa, isso pode levar a código duplicado pois diversos controladores para díferentes 
telas precisam saber o que fazer em uma determinada situação. 
Você pode remover esta duplicação colocando toda a lógica do fluxo em um 
Controlador de Aplicação. Controla.dores de entradas solicitam, então, ao Controlador de 
Aplicação os comandos õpropriados para execução sobre um modelo e a vista correta 
a usar dependendo do contexto da aplicação. 

Como Funciona 

Um Confrolndor de Aplicação tem duas responsabilidades principais: decidir qual lógica 
de donúnio executar e a vista com a quaJ exibir a resposta. Para fazer isso, geralmente 
ele armazena dois conjuntos estruturados de referências de classes, um 
para comandos do domínio executarem na camada do donúnio e um de vistas. (figura 
14.10). 

Tanto para os comandos do domínio quanto para as vistas, o conti·olador de 
aplicação precisa de uma maneira de armazenar algo que possa chamar. Um Comando 
[GangofFour] é uma boa escofüa, já que permite pegar e executar facilmente um 
bloco de código. Linguagens que podemmanipular funções podemarmazenar refe



ÚPÍlULO 14 • PADRÕES DE APRESENTAÇÃO WEB 361 

((metaclasse» 
Vista 

1 

* 

Controlador de Aplicação 

lerComandoDoDomlnio (contexto) 
lerVisão(contexto) 

«metae.lasse» 

1 

Comando 
do Domlnio 

Figura 14.10 Um controlador de aplicação tem dois conjuntos de referências a classes, 
um para a lógica de domínio e outro para as visões. 

rências a elas. Outra opção é armazenar uma string que possa ser usada parn chamar 
um método usando reflexão. 

Os comandos do domiruo podem ser objetos comando que são parte da camada 
do Controlador de Aplicação, ou podem ser referências a um Roteiro de Transação 
(120} ou métodos de objetos do domínio na camada de domínio. 

Se você estiver usando páginas servidoras como suas vistas, pode usar o nome da 
página servidora. Se esHver usando uma classe, um comando ou uma string para uma 
chamada reflexiva faz sentido. Você também poderia usar uma transformação XSLT, 
para a qual o Co11tro/ador de Aplicação pode armazenar uma string como uma referência. 

Uma decisão que você precisará tomar écomo separar o Co11trolador de Aplicação ~ 
do resto da apresentação. A principio, esta decisão se manifesta na forma de se o Controlador 
de Aplicação tem dependências com o mecanismo da interface de usuáJ·io. Talvez 
ele acesse diretamente os dados da sess;io HTTP, passe adiante pl'lrn uma página 
servidora ou chame métodos em uma classe cliente rica. 

Embora eu tenha visto Contro/ndores de Aplicnçiio diretos, minha preferência é 
que os Co11trolndores de Aplicação não tenham conexões para o mecanismo de interface 
de usuMio. Para começar, isso torna possível testar o Co11trolador de Aplicaçiio independentemente 
da interface de usuário, o que é wn grande benefício. Também é importante 
fazer isso se você for usar o mesmo Conlrolndor de Aplicação com diversas 
apresentações. Por esses motivos, muitas pessoas gostam de pensar no Coutrolndor de 
Aplicnçiio como \.lma camada intermediária entre a apresentação e o dominfo. 

Uma apresentação pode ter diversos Controladores de Aplicnçiio para manipular 
cada uma de suas dHerentes partes. Isso permite a você dividir lógica complexa em 
diversas classes. Neste caso, geralmente faço com que o trabalho seja cüvidido em 
áreas gerais da interface do usuário e crio Co11troiflrlorcs de Aplicnçifo separados para 
cada área. Em uma aplicação mais simples, eu poderia precisar de apenas um Co11t1·0lador 
de Aplicaçiio. 

Se você tiver diversas apresentações, como umfront end Web, um cliente rico e 
um PDA, pode ser capaz de usar o mesmo Controlndor de Aplicnção para cada apresentação, 
mas não fique muito ávido. Muitas vezes, diferentes interfaces de usuário 
precisam de um fluxo de tela diferente para obter uma interface de usuário realmente 
utilizável. Contudo, reutilizar um único Controlador de Aplicação pode reduzir o trabalho 
de desenvolvimento, e isso pode valer o custo de uma interface de usuário 
mais complexa. 


362 PARTE li • Os PAORÕES 

Uma maneira comum de pensar em uma interface de usuário é como uma máquina 
de estados, cm que detcrmit'rndos eventos disparam diferentes respostas dependendo 
do estado de determinados objetos ch,we da aplicação. Neste caso, o Co11trolador 
de Aplicação é particufarmcntc acessível ao uso de metadados para representar 
o fluxo de controle da máquina de estados. Os metadados podem ser configurados 
poI chamadas de linguagem de programação (o modo mais simples) ou podem 
ser armazenados em um arquivo de configuração separado. 

Você pode encontrar lógica de domínio específica de uma solicitação localizada 
cm um Controlador de Aplicnçiio (360). Como você pode suspeitar, não sou muito favorável 
a esta noção. Entretanto, o limite entre lógica de domínio e de aplicação fica 
muito obscuro. Dig«mos que eu esteja lidando com aplicações de seguro e precise 
mostrar uma tela separada com perguntas apenas se o requerente for fumante. Isso é 
lógica de aplicação ou lógica de domínio? Se eu tiver apenas alguns casos desse tipo, 
provavelmente posso colocar este tipo de lógica no Controladorde Aplicação (360), mas 
se ele ocorrer em muitos lugares, preciso projetar o Modelo de Dc>mínio (126) de uma 
maneira a conduzir isso. 

Quando Usá-lo 

Se o fluxo e a navegação de sua aplicação forem simples o suficiente para que qualquer 
pessoa possa visitar qualquer tela em qualquer ordem, há pouco valor em um 
Controlador de Aplicaçiio. A força de um Controlador de Aplicação vem de regras definidas 
sobre a ordem na qual págin<1s devem ser visittldas e vistas diferentes, dependendo 
do estado dos objetos. 

Um bom sin<1J para usar um Controlador de Aplicação é se você se encontrar tendo 
que fazer alterações similares em muitos lugares diferentes quando o fluxo de sua 
aplicação muda. 

Leitura Adicional 

A maioria das idéias que baseiam a escrita deste padrão vieram de [Knight and Dai]. 
Embora suas idéias não sejam exatamente novas, considero suas explanações notavelmente 
claras e atraentes. 

Exemplo: Controlador de Aplicação Modelo de Estados (Java) 

Os modelos de estados são um modo comum de pensar em interfaces de usuário. 
Eles são especialmente apropriados quando você precisa reagir de maneira diferente 
a eventos dependendo do est<ldo de algum objeto. Neste exemplo, tenho um modelo 
de estados simples para alguns comandos em um bem (Figura 14.11). Os especialistas 
de leasing da ThoughtWork desmaiariam com o excesso de simplificação virulenta 
deste modelo, mas cle servirá como exemplo de um Contrvlndor de Aplicaçito 
baseado em estados. 

No que se refere ao código, nossas regras são as seguintes: 

• Quando recebemos um comando de retorno e estamos no estado Em Lease, 
exibin1os uma pÃgina para capturnr informações sobre o retorno do bem. 
• Um evento de retorno no estado Em Estoque é um erro, então mostramos 
uma página de ação ilegal. 

CAPiluLO 14 • PADRÕES OE APRESENTAÇÃO WEB 363 

Em Lease 

Em Reparo 

retorno 

Em Estoque i-------dano 

Figura 14.11 Um diagrama de estados simples para um bem. 

• Quando recebemos um comando de dano, mostramos diferentes p~ginas, 
dependendo de se o bem está no estado Em Estoque ou no Em Lense. 
O conlTolador de entrada é w,1 Controlador Frontal (328). Ele serve a solicitação 
desta forma: 

class FrontServlet ... 

public void executarServiço IHttpServletRequest solicitação, HttpServletResponserespcsta) 
thro-~·s IOException, ServletExcept ion 

Controlador~.pl icação contApl =lerconcroladorDeAplicação {solicitação); 
String scrin91)()Comando =-(String) solicitacào.9etPararr.eter(•com1.mdo1 
) ; 
ComandoDeDolrlinio COO'I = 

cont.Apl .lerCOll'.andoOeDo.iúnio(stringDoComando, lerNa9aDeParâmetros(solicitaçâol); 

com. executarOerl-la9aDeParâmetros(solicitação)) ; 

String páginaVisão = 
"/" t contl\pl.lerVisão(stringOoCo:nando, lerMapaDePar&metros(solicitaçãol} + •.jsp•; 
íorward(págir.avisão, solicitaçào1 resposta); 

O fluxo do método de serviço é bastante direto: descobrimos o controlador de 
aplicação correto para uma dada solicitação, solicitamos ao controlador de aplicação 

o comando do domínio, executamos esse comando do domínio, soJicitamos ao controlador 
de aplicação uma vista e, finalmente, passamos adiante para a vista. 
Neste esquema, estou pressupondo um número de Controlndores de Aplicnçiio, os 
quais implementam a mesma interface. 

interface ControladorDeAplicação... 

Coma.ndoDeDoi:ú.nio lerComandoDeOomínio (String stringDoC01Dando, lrlap parâmetros); 
String lerVisào (String stringooco~4ndo, Map parâmetros); 

Para nossos comandos o Co11trole de Aplicação apropriado é um controle de aplicação 
para bens. Ele usa uma classe de resposta para armazenar as referências a vistas 
e comandos de donúnio. Para o comando de domínio uso U01a referência a uma 


3 64 PARTE li • Os PADRÕES 

classe. Para a vista, uso uma string, a qual o controlador de aplicação transformará 
em uma URL para uma JSP. 

class Resposta ... 

private Class co;nandoDeOO.~inio: 
private String UrlOaVisão; 
public Resposta (Class co..andoDeDominio, String UrlDaVisào) 

this.comandoDeDomínio = comandoDeDomínio; 

thís.UrlDaVisào = OrlDaVisão; 

public Coc:andoOeDomínio ler<:omandoDeDomínio( 1 
try 1 

return (COillandoDeDomíniol comandoDeOoaúnio.newlnstance{ ); 
} catch (Exception e) ( thro-, ne~ ApplicationException (e); 
) 

public String lerUrlDaVisão() { 
return UrlDaVisào; 

O controlador de aplicação segura as respostas, usando um mapa de mapas indexados 
pela string do comando e a situação atual do bem (Figura 14.12). 

class ControladorDeAplicaçãoParaBens... 

private Resposta getResponse (String scrindoocomando, SituaçãoDoBem esudo) 
return (Response) lerMapaDeRespostas(strindDoCooando).getlestadol; 

private Map lerMapa.De.Resposcas (Scr:_ng chave) 
return IMap) eventos.get lchavel; 

private Map eventos~ new Has~.Map ( )r 

Ao ser solicitado por um comando do donúnio, o controlador ofüa a solicitação 
para descobrir o ID do bem, vai ao domínio para determinar a situação desse bem, 
procura a classe apropriada do comando do domínio, instancia essa classe e retoma 

o novo objeto. 
class ControladorOe.~licaçãoParaBens... 

public Co..andoOeDomínio ler<:omandoDeDooiínio (Strins strin90oCooando, Map parâmetros) 
Resposta resposta: getResponse (stringDoCon:ando, lerSituaçãoDoBem(parâ~etros)) ; 
return resposta.lerCOOlc1.ndoDeDomínio( ); 

private SituaçãoDoBem lerSituaçãoDoBem (Map parâmetros) 
String id: lerParâmetros('IDdoBem•, parâmetros!; 
Be~ bei = Ban.buscar (id}; 
return bem.lerSituação( ); 

privace String lerParâcetros (String crrave, Map parâmetros) 
retum { <string( ) ) parâtr.etros.get (chave)) [O] i 


CAPilULO 14 • PADRÕES DE APRESENTA<;Ãô WEB 365 

«interface>> 
Controlador 
de Aplicação 

Controlador de 
Aplicação para Bens 

comando 

estado 
1 do bem 1 

1 '/ 

visão 1

--.

Classe --Resposta -String 

1 ~ ~ 
* 

Figura 14. 12 Como o controlador de aplicação para bens armazena suas referências a 
comandos do domínio e visões. 

Todos os comandos de donúnio seguem un"U\ intedace simples que permite ao 
controlador frontal executá-los. 

1nrerface ComandoDeDomínio... 

abstract public void executarlMap parâmetros); 

Assim que o comando do domínio tiver feito o que precisa, o Controlador de 
Aplicação entra em ação novamente quando a vista lhe é solicitada. 

class ControladorDeAplicacàoPara9ens... 

public String lerVisão (String stringDoCcx;iando, Map parâmetros) 
recurn getResponse {stringDoComando, lrP-0siçào00Bem(parâmetros)) .lerorlDaVisào( 1: 

Neste caso, o Co11trolador de Aplicnção não retorna a URL inteira para a JSP. Ele 
retorna uma string que o controlador frontal transforma em uma URL. Paço isso para 
evitar duplicar os caminhos da URL nas respostas. Isso também toma fácil adicionar 
mais indireção, mais tarde, se eu precisar. 


366 PARTE li • Os PADRÕES 

O Controlador de Aplicação pode ser carregado para uso com código. 

class ControladorW.plicaçàoParaBens, .. 

public void adicionarR>esposta (Stnn9 evento. Objeto estado. Class comandoDeDomínio, String •1isàol { 
Resposta novaResposta = new Resposta {comandoDeDominio, visão); 
if í !eventos.containsKey(evento}) 

eventos.put(evento, ne# HashMapl )): 
lerMapaDeRespostas(eventol .putlestado, novaResposta); 

) 

private static void carregarcontrolador!leAplicação(Controlador~.plícaç~oParasens contApl) 
contApl = Controladorl>eAp. icaçãoParaBens.getDefault( ); 
contApl.adicionarResposta(•retomo•, SituaçãoDoBem.El,l_LEASB, 

ComandoJuntarOetalhesDoRetono.class, •retorno'); 
contApl.a<iicionarResposta("retorno•, SituaçàoDoBem.EM_E.STOQUE, 
Cor.iandoBer.ilJUlo.class, •açãoIlegal•); 
contApl.adicionarResposta("recorno•, SituaçãoDoBem.EM_LEASE, 
ComandooanosEstoque.class, •danoLease'); 
contApl .adicionarResposta(retorno•, SituacãoDoBe:i.EM_ESiOQUE, 
Con:andoOanoNoLease.class, •oanoEstoque•); 

Fazer isso a partir de um arquivo .não é muito difícil, mas, mesmo assim, deixarei 
para você. 


CAPÍTULO 1 

5 

Padrões de Distribuição 


368 PARTE li • Os PADRÕES 

Fachada Remota (Remote Façade) 

Fornece 11111n fnchadn de grnnulnridnde nlln sobre objetos 
de gnmulnridadebaixn para melhorar n eficiêncin em 11111n rede. 

Endereço 

Fachada Endereço 

lerRua() 

lerDadosDoEndereço :::,,... lerCidade( ) 

gravarEndereço (rua. cidade, cep) ---------------~ 

lerCep() 

gravarRua(parámetro) 

gravarCidade(parãmetro) 

gravarCep(parâmetro) 

Em um modelo orientado a objetos, você obtém melhor desempenho com objetos pequenos 
que tenham métodos pequenos. Isso lhe dá muitas oportunidades decontrole 
e substituição de comportamento e de usar nomes sugestivos que deixem uma 
aplicação mais fácil de ser entendida. Uma das conseqüências deste comportamento 
de granularidade baixa é que geralmente há bastante interação entre os objetos, e esta 
interação normalmente requer muitas chamadas de métodos. 

Dentro de um espaço de endereçamento único, interação com granularidade 
baixa funciona bem, mas não ocorre quando você executa chamadas entre processos. 
Chamadas remotas são muito mais custosas porque há muito a ser feito: dados 
podem ter que ser preparados, a segurança pode precisar ser verificada, pacotes podem 
necessitar ser roteados por mejo de swifc11es. Se os dois processos estiverem rodando 
em máquinas em lados opostos do globo, a velocidade da luz pode ser um 
fator. A verdade brutal é que qualquer chamada interprocessos é ordem de magnitude 
mais custosa do que uma chamada interna ao processo -mesmo se ambos os 
processos estiverem na mesma máquina. Esse efeito no desempenho não pode ser 
ignorado, mesmo porquem acredita emotimização tardia. 

O resultado é que qualquer objeto o qual se pretenda usar como objeto remoto 
precisa de uma interface de granularidade alta queminimize o número de chamadas 
necessárias para que algo seja realizado. Isso não afeta apenas suas chamadas de métodos, 
como também seus objetos. Em vez de solicitar um pedido e os itens desse pedido 
individualmente, você precisa acessar e atualizar o pedido e seus itens em uma 
única chamada, o que afeta a estrutura inteira do seu objeto. Você desiste da intenção 
clara e do controle de granularidade baixa que obtém com objetos e métodos pequenos. 
Programar se torna mais difícil, e sua produtividade diminui. 

A Fncl1nda Ri:111otn é uma fachada de granularidade alta [Gang oí Pour] em uma 
rede de objetos de granularidade baixa. Nenhum dos objetos de granularidade baixa 
tem uma interface remota, e a Fachada Remota não contém lógica de domínio. Tudo o 
que a Fnclmda Remota faz é traduzir métodos de granularidade alta para os objetos de 
granularidade baixa associados. 

Como Funciona 

A t=nclzndn Remota lida com o problema de distribuição da abordagem 00padrão de 

separnr responsabilidades distintas em diferentes objetos e como resultado tem se 

tomado o padrão mais adotado para este problema. Reconheço que objetos de gra



CAPilUlO 15 • PADRÕES DE 01STRIBUIÇÁO 369 

mtlaridade baixa são a resposta correta para a lógica complexa, então asseguro-me 
de que cada lógica complexa seja colocada cm objetos de granularidade baixa que 
são projetc1dos para colaborar dentro de um único processo. Pai-a permitir acesso remoto 
eficiente a eles, crio um objeto fachada separado que atua como uma interface 
remota. Como o nome sugere, a fachada é meramente uma camada fina que muda de 
uma interface de granularidade alta para uma de granularidade baixa. 

Em um caso simples, como um objeto para endereços, uma Fnclindn Remota 
substituj todos os métodos de gravação e leitura do objeto de endereços normal por 
um método de gravação e tun de leitura, muitas vezes, chamados de métodos de 
acesso abrangentes. Quando um cliente chama um método de gravação abrangente, 
a fachada de endereços lê os dados do método de gravação e chama os métodos de 
ac€Sso individuais no objeto de endereços real (veja a Figura 15.l) e não faz mais nada. 
Dessa forma, toda a lógica de validação e contputação permanece no objeto de 
endereços no qual pode ser fatorada de forma limpa e pode ser usada por outros objetos 
de granularidade baixa. 

Em umcaso mais complexo, turut t'mka Fnclindn Remotn pode atuar como umgotewny 
remoto para muitos objetos de granularidade baixr1. Por exemplo, uma fachada 
para pedidos pode ser usada para obter e atualizar informações sobre um pedido, 
todos seus itens e talvez alguns dados do cUente também. 

Ao transferir dados em volumes como este, você precisa de que eles estejam em 
um formato que possa ser movido facilmente pela conexão. Sesuas classes de granularidade 
baixa estiverem presentes nos dois lados da conexão e forem serializáveis, 
você pode transferi-las diretamente fazendo uma cópia. Neste caso, um método lerDadosOoBndereço 
cria uma cópia do objeto endereço original. O gravarDadosDoBndereço recebe 
um objeto endereço e o usa para atualizar os dados do objeto endereço real. (Isso 
pressupõe que o objeto endereço original precisa preservar sua identidade e, assim, 
não pode simplesmente ser substituído pelo novo endereço.) 

Entretanto, mujtas vezes, você não pode fazer isso. Você pode não querer duplicar 
suas classes de donúnio cm diversos processos, ou pode ser difícil serializar um 
segmento de um modelo do domínio devido a sua estrutura de relacionamentos 

uma fachada 
para endereços 
um e dere o 
lerOadosDoEndereço_ 
lerCidade 
lerEstado 
lerCep 

Figura 15.1 Uma chamada para uma fachada produz diversas chamadas da fachada 
para o objeto do domínio. 


370 PARTE li • Os PADRÕES 

complicada. O cliente pode não querer o modelo inteiro, mas apenas um subconjunto 
simplificado dele. Nestes casos, faz sentido usaJ" um Objeto de Tmnsferéllcin de Dados 
(380) como base da transferência. 

No esboço, mostrei uma Fnclmdn Re111otn que corresponde a um único objeto do 
domínio. lsso não é incomum e é ffkil de entender, mas não é o caso mais comum. 
Uma únicé'l Fachada Remota teria vários métodos, cada um projetado para passar informações 
de dive1·sos objetos. Assim, lerDadosDo6ndereço e gravarDadosDoEndereço seriam 
métodos definidos em uma classe como ServiçoCliente, a qual também teria mé~ 
todos como lerHistóricoDeCompras e atualizarDadosDeCrédito. 

A granularidade é uma das questões mais traiçoeiras em fncltndas Remotas. Algumas 
pessoas gostam de cl'iar Fachadas Remotas razoavelmente pequenas, como 
uma por caso de uso. Prefiro uma estrutura de granularidade mais grossa com muito 
menos Fachadas Remotas. Mesmo para uma aplicaç~o de tamanho moderado eu 
poderia ter apenas uma e, até para uma aplicação grande, posso ter apenas meia dúzia. 
Isso significa que cada Fncl,ada Remota tem muitos métodos, mas já que esses métodos 
são pequenos, não vejo isso como um problema. 

Você projeta uma Fachada Remota baseado nas necessidades de uso de um cliente 
em particular -mais comumcnte a necessidade de visualizar e atualizar informações 
através de uma interface de usuário. Neste caso, você poderia ter uma única Fnchnd11 
Remota para um grupo de telas, para cada uma das quais um método de acesso 
abrnngente transporta e grélva os dado~. Pressionar botões em uma tela, digamos 
para alterar a situ'1ção de um pedido, chama métodos de comando na fach'1da. Muitas 
vezes, você ter~ diferentes métodos na Fncl,nda Re111oln que fazem quase que a 
mesma coisa nos objetos correspondentes. Isso é comum e razoável. A fachada é projetada 
para tornar a vida de usuários externos mais simples, não para o sistema interno, 
então se o processo cliente pensa nele como um comando dHerente, é um comando 
diferente, mesmo se internamente tudo for direcionado para o mesmo comando. 

A Fnclzadn Remota pode manter seu estado ou não. Uma fncllndn Remota sem estados 
pode ser usada na criação de um pool, o que pode melhorar a utilização e a eficiência 
dos recursos, especialmente em uma situação B2C'. Entretanto, se a jnteração 
envolver estado por meio de uma sessão, e1'\tão a Fachada Remota precisa armazenar 
o estado da sessão em algum lugar, usando Estado dn Sessão no Cliente (427) ou 
Estado da Sessão no Banco de Dados {432), ou uma implementação de Estado da Sessão 
110 Servidor (429). Se a Facl,adn Remota tiver que armazenar seu próprio estado, ela será 
facilmente implementável por um Estado da Sessão no Servidor (429), mas isso pode 
levar a questões de desempenho quando você tiver mHhares de usuários simultâneos. 


Assim como fornecer uma jnterface de granularidade alta, diversas outras responsabilidades 
podem ser acrescentadas a uma Fachada Remota. Por exemplo, seus 
métodos são um ponto naturaJ no qual aplicar segurança. Uma lista de controle de 
acesso pode dizer quais usuários podem chamar quais métodos. Os métodos da Fnclmda 
Remota também são um ponto naturnl no qual aplicar controle tnmsacional. 
Um método da Fachada Remota pode começar uma transação, executar todo o trabalho 
interno e, então, confirmar a transação no final. Cada chamada constitui uma 
transação completa porque você não quer urna transação aberta quando o retorno 

• de R. T.: Busine;s toConsumer. 

C'APiWlO 1 S • PADAÔfS oe OtSTAIBUIÇÁO 371 

volta para o cliente, já que transações não são criadas para serem eficientes em casos 
de execução tão longa. 

Um dos maiores erros que vejo em uma Fnchndn Remota é colocar1ógica de domínio 
nela. Repita comigo três vezes: "Fachndn Remota não tem lógica de domínio." 
Qualquer fachada deve ser uma cami\da fina que tenhil apenils responsabilidades 
mínimas. Se você precisar de lógica de domínio para fluxo de trabalho ou coordenação, 
coloque-a nos seus objetos de granularidade baixa ou crie um Roteiro de Trn11saçifo 
(120) separado e não-remoto para contê-la. Você deve poder executar a aplicação 
inteira localmente sem usar as Fnc/mdns Remotas ou ter que duplicar qualquer código. 

Faclznda Remota e Fachada de Sessão Nos últimos anos, o padrão Fachada de Sessão 
[Alur et nl.] tem aparecido na comunidade J2EE. Nos meus primeiros esboços, 
considerei Fachada de Sessão o mesmo padrão de Fachada Rcmola e usei o nome Fachada 
de Sessão. Na prática, entretanto, há uma diferença crucial. rnchada Remota diz 
respeito a ter uma camada fina remota -por esta razão, minha crítica contra lógica de 
domínio nela. Ao contrário, a maior parte das descrições de Fachada de Sessão envolvem 
a colocação de lógica nela, normalmente de um tipo de fluxo de trabalho. 
Uma grande parte disso é devido à abordagem comum de usar session beansJ2EE para 
encapsular entity beans. Qualquer coordenação de entity beans tem que ser feita por 
outro objeto, já que eles não podem ser reentrantes. 

Como resultado disso, vejo uma Fachadn de Sessão como colocar diversos Roteiros 
de Transação (120) em uma interface remota. É uma abordagem razoável, mé\S 
não é a mesma coisa que uma Fachada Remota. De fato, eu argumentaria que, como 
Fachada de Sessão contém lógica de domínio, não deveria ser chamada de fachada! 

Camada de Serviço Um conceito familiar a fachadas é uma Cnmadn de Serviço (141). 

A principal diferença é que uma camada de serviço não tem que ser remota e deste 

modo não precisa ter apenas métodos de granularidade baixa. Ao simplificar o Mo


delo de Domfnio (126), você muitas vezes acaba com métodos de granularidade alta, 

mas isso por dareza, não por eficiência da rede. Além disso, não há necessidade de 

uma camada de serviço usar Objetos de Trausferê11cia de Dados (380). Normalmente, ela . 

pode facilmente retornar objetos do domínio reais para o cliente. 

Se um Modelo do Domfnio (126) for ser usado dentro do processo e também remotamente, 
você pode ter uma Camada de Serviço (141) e colocar uma Fnclmdn Remotn 
separada sobre ela. Se o processo só é usado remotamente, provavelmente é mais fácil 
incluir a Camnda de Serviço (141) na Fndmda Remota, supondo que a Camadade Serviço 
{141) não tenha lógica de aplicação. Se houver alguma lógica de aplicação nela, 
então eu faria da Fnchndn Remota um objeto separado. 

Quando Usá-la 

Use Fachada Remota sempre que precisar de acesso remoto a um modelo de objetos de 
granularidade baixa. Você obtém as vantagens de uma interface de granularidade tllta 
enquanto mantém a vantagem dos objetos de granularidade baixa, dando-U1e o 
melhor dos dois mundos. 

O uso mais comum deste padrão é entre uma apresentação e um Modelo de Domfnio 
(126), onde os dois podem rodar em processos diferentes. Você obterá isso entre 
uma interface de usuário Swing e modelo de domínio 110 servidor oucom um ser



372 PARTE li • Os PAORÕES 

vlet e um modelo de objetos no servidor se a aplicação e os servidores Web forem 
processos diferentes. 

Mais freqüentemente, você se depara com isso com diferentes processos em diferentes 
máquinas, mas o custo de uma chamada entre processos no mesmo contfüner 
acaba sendo suficientemente grande para você precisar de uma interface de granularidade 
alta para qualquer comunicação entre processos, independentemente de 
onde eles estejam. 

Se todo seu acesso estive.e dentro de um único processo, voca não precisa desse 
tipo de conversão. Assim, eu não usaria este padrão para comunicação entre um 
cliente Modelo de Domí11io (126) e sua apresentação ou enn·e um script CGI e um Modelo 
de Domínio (126) rodando em um servidor Web. Você não vê fncl,ndn Remotn usada 
com um Roteiro de Trn11saçiio (120) como regra, já que Roteiro de Transação (120) tem 
inerentemente granularidade r1lta. 

As Fachndns Remotns sugerem um estilo de distribuição síncrono -ou seja, uma 
chamada de procedimento remoto. Muitas vezes, você pode melhorar bastante a capacidade 
de resposta de uma aplicação com comunicação remota assíncrona e baseadr1 
em mensagens. De fato, uma abordr1gem assíncrona tem muitas vantagens atrativns. 
Infelizmente, a discuss;-io de pad.rões assíncronos está fora do escopo deste livro. 

Exemplo: Usando um Ses-sion Bean Java como Fachada Remota (Java) 

Se você estiver trabalhando com a plAtaforma Java Enterprise, uma boa escolha para 
uma fachada distribuída é um sessiou bean, porque é um objeto remoto que pode ter 
ou não estado. Neste exemplo, executarei alguns POJOs (velhos e bons objetos Java) 
dentro de um contáiner EJB e irei acessá-los remotamente através de um sessfon benn 
que é projetado como uma Facl,adn Remota. Session benns não são especialmente complicados, 
então tudo deve fazer sentido mesmo se você nunca tenha trabalhado com 
eles antes. 

Sinto a necessidade de algumas observações aqui. PJimeiro, fuj surpreendido 
pelo 11úmero de pessoas que parecem acreditar que voeª não pode rodar objetos comuns 
dentro de um contãiner EJB em Java. Ouço as pergw,tas "Os objetos do domínio 
são entity beans?". A resposta é que eles podem, mas não precisam sê-lo. Os objetos 
Java simples funcionam bem, como neste exemplo. 

Minha segunda observação é apenas para destacar que esta não é a única maneira 
de usar sessio11 bcans. Eles também podem ser usados para hospedar Roteiros de 
Tr1111snçiio (120). 

Neste exemplo, olharei interfaces remotas para acessar in formações sobre álbuns 
musicais. O Modelo de Domfnio (126) consiste em objetos de granularidade baixa 
que representam um artisté\, álbum e faixas. Em torno disso, estão diversos outros 
pacotes que fornecem as fontes de dados para a aplicação (veja a Figura 15.2). 

Na figura, o pacote otd contém Objetos de Trnnsferêncins de Dados (380) que ajudam 
a mover os dados pela conexão até o cliente. Eles têm comportamento simples 
de acesso simples e também "habilidade de seriaUzar a si mesmos em formato binário 
ou XML textual. No pacote remoto, estão objetos montadores que movem dados 
entre os objetos do domínio e os Objetos de Trn11sferêncin de Dados (380). Se você estiver 
interessado em como isso fw1.ciona, veja a discussão sobre Objetos de Trn11sferêncin 
de Dados (380). 

Para explicar a fachada, irei pressupor que posso mover dados de e para os 
Objetos de Trrmsferêncin de Dndos (380) e concentrnrei nas interfoccs remotas. Um 


CAPh ULO 15 • PADAÔES OE D1STAIBUIÇÁO 373 

único session bem, lógico Java tem três classes reais. Duas delas fazem a API remota 
(e na verdade são interfaces Java). A outra é a classe que implementa a API. As 
duas interfaces são ÃlbumService e o objeto ÁlbumHome. Este objeto l,ome é usado pelo 
serviço de nomeação para obter acesso à fachada distribuída, mas este é um detalhe 
EJB que pularei aqui. Nosso interesse é na própria Fnc/zadn Remota, ÁlbumService. 
Sua interface é declarada no pacote API para ser usada pelo cliente e é apenas uma 
lista de métodos. 

c!ass IJbumService ... 

String tocar (String id) thro~s RemoteException; 
String lerY.mlÁlbum (String id) throws Remotesxception; 
ÃlbumOTD lerÁlbum !String id) throws RemoteException; 
void criarÁlbum (String id, String xml) throws Remote&xception; 
void ctiarÁlhum (String id, Ãlbumaro otd) throws ReMteBxceptíon: 
void atualizarÁlbum (String id, String xml) thro-,s RemoteException; 
void atualizarÃlbum (String id, ÃlbumO'!'D otd) throws ReooteException; 
void adicionarArtistaCh.ar..ado (String id, S:ring nome> throws RemoteException; 
void adicionarArtista (St ring id, String Xlllll throws ReooteExceptíon; 
void adicionarArtista (String id, ~.rtiscaOTD otd) chrows Re:noteException; 
ArtistaOTD 1erArtista {String id) thro-.•s RemoteException; 

Perceba que, mesmo nesse exemplo curto, vejo métodos para duas classes diferentes 
no Modelo de Domínio (126): artista e álbum. Também vejo vru·iações menores 

1 

,------------cliente 

1 

1 
1 

1 

1 
1 
api otd l 
1 

ArtistaOTD

ÁlbumHome 

ÁlbumOTD

ÁlbumService 

FaixaOTD 

1 
1 
1 
1 
1 
1 

domínio

' 

remoto 

11 
11 Álbum 
Artista

ÁlbumServiceBean -------------


Faixa

MontadorOeÁlbum 

Player

MontadorDeArtista ----------------


Registro 

Figura 15.2 Pacotes das interfaces remotas. 


374 PARTE li • Os PADRÕES 

no mesmo método. Os métodos têm variantes que usam o Objeto dt Transferê11cia de 
Dados (380) ou uma strillg XML para mover dados para o serviço remoto. Isso permite 
que o cLiente escolha qual forma usar dependendo da natureza do cliente e da conexão. 
Como você pode ver, mesmo para uma aplicação pequena isso pode levar a 
muitos métodos em ÁlbumService. 

Felizmente, os próprios métodos são muito simples. Aquj estão os métodos para 
manipular álbuns: 

elass ÁlbumServiceBean .. . 

public ÁlbumOTD lerÁlbum(String id) throws Rell'.oteException { 
return new l•!ontadorOeÁlbur.1( ) .gravarO'J'D(Registro.encontrarÃlbum{id)~; 

public String le~XmlÁlbum(String id) throws RemoteException { 
Álbul/lOTD otd : new MontadorDeÁlbum( ) .gravarOTD(Registro.encontrarÁlbua{idJ); 
return otd.toXmlString( }; 

} 

public void criarÁlbum (String id, ÁlbumOTD ocd) throws Retr.0teException { 

new ~ontadorOeÃlbum( ).criarÃlbum(id, otdl; 

} 

public void criarÁlbum (String id, String xmll throws RemoteException f 

ÁlbumOTI> oco: ÁlbumOro.lerStringXml(xml); 

new ~ontadorDeÁlbum( ).criarÁlbum(id, otd); 

) 

public void atualizarÁlblltl (String id, ÃlbwnOTD otd} tbrows Remote8xception { 

new MontadorDeÁlbum( ).atualizarÁlbum(id, otd) 1 

} 

public void criarÃlbum (String id, String xml) throws RemoteSxception { 
ÁlbumOTD otd: ÂlbtmlOTD.lerStringX~l(xmll; 
new ~ontadorDeÁlbUJII( ).atualizarÃlbum(id, otd); 

Como você pode ver, cada método realmente não faz nada mais do que delegar 
a outro objeto, de modo que têm o tamanho de apenas uma linha ou duas. Este 
fragmento ilustra muito bem como uma fachada distribuída deve se parecer: 
uma longa lista de métodos muito curtos com muito pouca lógica neles. A fachada 
então não é nada mais do que um mecanismo de empacotamento, que é como deveria 
ser. 

Iremos terminar com algumas palavras sobre teste. É muito útil poder executar 
tanto teste quanto possível em um único processo. Neste caso, posso escrever testes 
para a implementação do session bann diretamente: estes podem ser executados sem 
djstribuir para o contãiner EJB. 

class testadorxml .. . 

private ÁlbumOTD kob; 

privace ÃlbumOTD novokob; 

private ÁlbumService3ean fachada: new Álbut:tServiceBean( I; 

protected void configurar 1 ) chrows Exception { 

tachada.inicializarParaTeste f) ; 

kob : fachada .lerÁlbumj•kob•) ; 

writer buffer : ne~ StringWriter( )r 


CAPilULO 15 • PADAÓES DE D1STAIBUIÇÁO 375 

kob.toXmlString lbufferJ; 

newkob ~ ÂlownOTO.lerStrin9Xml(new Str1n9Reader(buffer.t0Strin9t ))I; 
} 
publiç void testarArtista() { 

assertBquals(kob.lerArtista( ), newkob.lerArtista( ~); 

Este foi um dos testes JUnit a serem executados na memória. Ele mostrou como 
posso criar uma instância do session bea,1 fora do contfüner e executar testes nele, permitindo 
que o tempo para testes seja mais rápido. 

Exemplo: Serviço Web (C#) 

Estava falando sobre este Livro com Mike Hendrickson, meu cdi torna Addison-Wesley. 
Sempre alerta a novas palavras da moda, ele me perguntou se eu tinha alguma 
coisa sobre serviços Web nele. Sou avesso a sair correndo a cada nova moda -afinal, 
dada a velocidade lenta da publicação de livros, qualquer coisa sobre a qual eu escreva 
classificada como "última moda" parecerá estranha quando você ler. Ainda assim, 
é um bom exemplo de como padrões essenciais mantêm com tanta freqüência seu 
valor mesmo com as últimas mudanças tecnológicas. 

Um serviço Web é basicamente nada mais do que uma interface para uso remoto 
(com um passo lento de análise de st1'i11gs acrescentado como procedimento 
vantajoso). Como tal, o conselho da Fnchndn Remota permanece: construa sua funcionalidade 
de uma maneira que apresente granularidade baixa e, então, coloque 
uma Facl,ada Remota sobre o modelo de granularidade baixa para manipular os serviços 
Web. 

Para o exemplo, usarei o mesmo problema biísico que descrevi anteriormente, 
mas concenh·arei apenas na solicitação de informações sobre um único álbum. A Figu.
ra 15.3 mostra as diversas classes que participam: serviço de álbum, a fac/inda Remota, 
dois Objetos de Trm,sferêncin de Dados (380), três objetos em wn Modelo de Domínio 
(126) e um montador para trazer dados do Modelo de Domínio (126) para os Objetos 
de Ti'n11sferê11cia de Dados (380). 

O Modelo de Domínio (126) é absurdamente simples. De fato, para este tipo de 
problema você está melhor servido usando um Gntewayde Tabelas de Dados {151} para 
criar os Objetos de Transferência de Dados (380) diretamente. Entretanto, isso poderia estragar 
o exemplo de uma Pachada Remota colocada sobre um modelo de donúnio. 

class Âlbure. .. 

public String Titulo; 

public Artista Artista; 

public IList Faixas { 

get (retum ArrayList.ReadOnlyldadosDasFaixasl;} 

/

public void AdicionarFaixa (Faixa arg) 
dadosDasFaixas.Add(arg); 

/

public void RemoverFaixa (Faixa arg• { 
dadosDasFaixas.Remove(arg); 

private IList dadosDasPaixas = new ArrayList( ); 


376 PARTE li • Os PADRÕES 

((serviço Webn 
Álbum Service 

i=======================r---------------,

LerÁlbum (chave: String): ÁlbumOTD ~-----, l 

1 1 
1 1

1 

1 1

1 

1

1 

1 \1/ : 

1 1 
1 Montador de Álbum 1 

1 1 
1 

__, ... "¼____

1 

1 GravarOTD(Álbum): 

1 ÁlbumOTD

1 

1 

1 1 

1 1 

1 1 

1 1 

1 1 

1 1 

t 1 

1 1 

1 1 

l 1 

1 Álbum

\V 


r----

ÁlbumOTO Titulo: String 

Artista: String 1 

Titulo: String 

l t 

* 'I 
* ,, 
*,, 
Faixa
-

FaixaOTD 
~ 
Titulo: String 

Título: String 

Intérpretes: Array of String 

Figura 15.3 Classes do serviço Web para Álbum. 

class Artista.. , 

public String nome; 

class Faixa ... 

public String Titulo; 
public IList Intérpretes ( 
get { return ArrayList.ReadOnly(dadosDoslntérpretes)1 ) 

public void Adicionarlntérprete {Artista arg) 
dadosDoslntérpretes.Add(arg); 

public void Remover!ntérprete (Artista arg) 
dadosDoslntérpretes.Remove(arg)r 

private !Lista dadosDoslntérpretes = mr11 ArrayList ( 1; 

-----------, 

1 
1 
1 
1 
1 
1 
1 
1 
1 
1 
1 

IJ/ 
1 Artista 

-* --Nome: String 

' ' 

* 


CAPi1ULO 15 • PAORÔES oe DtSTRIBUIÇÁO 377 

Uso Objetos de Transferência de Dados (380) para passar os dados através da conexão. 
Estes são apenas armazenadores de dados que aplainam a estrutura para os propósitos 
do serviço Web. 

class ÁlbumOTD... 

public String Título; 
public String Artista; 
public FaixaOTD( l Paixas; 

class FaixaOTD... 

public String Titulo; 
puhlic String( 1 Intérpretes; 

Já que isso é .NET, não preciso escrever nenhum código para serializar e restaurar 
para XML O framework .NET vem com a classe serializadorn apropriada para fazer 
o trabalho. 

Este é um serviço Web, entãopreciso também declarar a estrutura dos Objetos de 
Transferência de Dados (380) em WSDL. As ferramentas do Visual Studio gerarão o 
WSDL para mim, e sou um cara do tipo preguiçoso, então deixarei que ele faça isso. 
Aqui está a definição do Esquema XML que corresponde aos Objetos de Tra11sfcrê11cin 
de Dados (380): 

<s:complex'l'ype name =~.UbumOTD4> 

<S:sequence> 
<S:ele.tent minoocurs: •1• ~occurs: •1• name: "Título' nillable = •true• type = •s:str1ng• /> 
<&,elen:ent m1nOccurs = •1• maxôccurs ='l' name = •Artista• nillable = •true• type = •s :atring• /> 

<s:element minOccurs = •1• inaxOccurs = 'l• name = "Paixas• 
nillaole = rtrue• t ype s •so:•ArrayDeFaixasOTD• /> 
cs/ :seq\lence> 

</S:COillplexType> 

<S:CO'JIPlexType na~e = •ArrayDePaixasOTD'> 
<s:sequence:> 
<s:element minOccurs = •o• 1:1axOccurs =•unbou.'!Oed' narr.e ="Faix<100'01 
nillable = •true• type = 's0:FaixaOTO• /> 

<S/ :sequence> 
</s:complexType> 
<s:complexType narne ='FaixaOTO"> 

<s:sequence> 
cs:elei:ent minOe<:urs = •1• ~Occurs = •1• name = 'Titulo• nillable =•troe• type ~ •s:stnng• /> 
<S:element minOccurs = •1• maxoccurs ~ •1• name = "Intérpretes• 

nillable = •true• type = •so:ArrayDeStrings• /> 

<s/:sequence> 
</s:complexType> 
<s:complexType name = "ArrayDeStrings"> 

<S:sequence> 
cs:element minOccurs = •o• maxOccurs =•unbounded• name =•string• 
nillable = •true• type =•s:string• /> 
<s/:seq\lence> 
c/s:complex'I'tpe> 

Por se tratar de XML, é uma definição de estrutura de dados particularmente 
prolixa, mas ela executa o trabalho. 


378 PARTE li • Os PADRÕES 

Para obter os dados do Modelo do Domi11io (126) para o Objeto de Transferê11cia de 
Dados (380), preciso de um montador. 

class MontadorDeÃlbum... 

public ÁlbumOTD GravarO'l'D fÃlbum sujeito) 
ÁlbumOTO resultado = new ÁlbumOTD( I; 
resultado.Artista= sujeito.Artista.Nome; 
resultado.Título= sujeito.Título; 
ArrayList listaDeFaixas = new ArrayList ( l ; 
Eoreach ( Faixa f in sujeito.Faixas) 

listaDefaixas.Add {GravarFaixa(fl) ; 
resultado.Faixas= (FaixaOTD( )1 liscaDeFaixas,ToArray(typeof(Faixa(J]'[l)); 
return resultado; 

public FaixaOTO GravarFaixa (Faixa sujeito) 
PaixaOTD resultado= new PaixaOTD( ); 
resultado.Titulo= sujeito.Título: 
resultado.Intérpretes= new Stríng(sujeito.Intérpretes.Count); 
ArrayList listaDeintérpreces =new ArrayListl): 
foreach (Artista a in sujeito.Intérpretes) 

listaDelntérpretes.Add (a .Nomel; 
resultado.Intérpretes= [String l )1 listaDeintérprates.ToArray(typeof {String)); 
return resultado; 

A última parte de que predsamos é a própria definição do serviço. Esta vem 
primeiro da classe C#. 

class ÁlbUO!Service... 

l Método'lieb I 

publ ic ÁlbUlllOTO LerÁlbum (St ring chave) { 
Álbu~ resultado:: new BuscadorDeÁlbum( ) (chaveli 
if (resultado=~ nulll 

throw new soapE~cepcion (•não foi possível encontrar uo álbu:n com chave: • + 
chave, SoapException.ClientFaultCode); 
else return new MontadorDeÃlbum( ) .GravarOTOfresultado); 

~ claro que esta não é a definição da interface real -isso vem do arquivo WSDL. 
Aqui estão os pedaços relevantes: 

<porType name = -ÃlbumServiceSoap"> 

<operation name = "LerÁlbum"> 
<input message: "s0:LerÁlbuinSoapin• /> 
<output ~essage ~ •sO:LerÃlbumSoapOut' /> 

</operat ion> 
</portType> 
<message name = "L.erÁlbumsoapln'> 

<part name: •parameters" element = •so:LerÁlbum• /> 
</message> 
<message name = •LerÁlbumSoapOut "> 

<part naJLe = •parameters" elen;ent = "sO:LerR.espostaÁlbum" /> 


CAPilULO 15 • PADRÕES DE D1SlRIBUIÇÁO 379 

</message> 
<s:element name = "LerÃlbu;n: > 
c:s:complexType> 
<S:sequence> 

c:s :eleitent r.únOccu.rs = •1• maxOccurs=•l" naa: = "key• nillable = •troe• cype = •s:string• /> 
c:/s:sequence> 
</s:cOOlplexType> 
</s:element> 
<s:element na~.e: "LerRespostaÃlbum: > 

<S:complexType> 

<s:seçuence> 

<S:e etr,ent minOccurs ="l" max<>ccurs=•l" name = •lerResultado.(lbum• 
mllab1e ="true• type = •sO:ÃlbumOTD• /> 
c:/s:sequence> 

</s:complexType> 

</s:elernent> 

Como esperado, o WSDLé mais tagarela do que a maioria dos políticos, mas ao 
contrário de tantos deles, consegue executar seu trabalho. Posso agora chamat o serviço 
enviando uma mensagem SOAP do formato 

c:?xml version ~ 1.0• encoding ~ •ucf-9'?> 

<Soap:Envelope xmlns:xsi~•http: //~.w3.or9/200l/XMt.Schema-instance• 
xm1ns:xsd=•http: //www.w3.org/ 2001/XM1Schema• 
Xllllns:soap= 'http://schemas.xmlsoap.org/soap/envelope/•> 

<Soap:Bodp 

<LerÁlbwa xmlns= "http: //mart1ntowler.comº> 
<key>umaStringChave</key> 
</LerÁlbum> 

</soap:BodY> 
</ soap:Envelope> 

O importante a ser lembrado a respeito desse exemplo não são as particularidades 
do SOAP e .NET, mas a abordagem fundamental de can1adas. Projete uma aplicação 
sem distribuição e então coloque a capacidade de distribuição sobre ela com 
Fachndns Remotas e Objetos de Transferência de Dados (380). 


380 PARTE li • Os PADRÕES 

Objeto de Transferência de Dados (Data Transfer Object) 

Um objeto que transporta dados entre processos 
para reduzir o mímero de chamadas de métodos. 

Álbum

ÁlbumOTD 

·;, 

...-------título: String 

titulo: String Montador

K-----


artista: String deÂlbum 

* 

~----~ 

paraElementoXml 
i'',',terXml ,, 

1 ' 1 
' ' Artista 

~ 

nome: String 

Quando você está trabalhando com uma interface remota, como uma Facharlr1 Remota 
(368), cada chamada a ela é custosa. O resultado é que você precisa reduzir o número 
de chamadas, o que significa que você precisa transferir mais dados em cada 
chamada. Uma maneira de fazer isso é usar muitos parâmetros. Todavia, muitas vezes 
é complicado de programar-de fato, é freqüentemente impossível com linguagens 
como Java que retornam apenas um único valor. 

A solução é criar um Objeto de Transferência de Dados que possa armazenar todos 
os dados da chamada. Ele precisa ser serializável para passar pela conexão. Normalmente 
um montador é usado no lado servidor para transferir dados entre o OTD e 
objetos do domínio. 

Muitas pessoas na comunidade Sun usam o termo "Objeto Valor" para estepadrão. 
Eu o uso para outra coisa. Veja a discussão na página 454. 

Como Funciona 

De muitas formas, um Objeto de Transferência de Dados é um daqueles objetos que nossas 
mães disseram para nunca escrevermos. ~ freqüentemente pouco mais do que alguns 
campos e os métodos de gravação e de leitura para eles. O valor coisa detestável 
é que lhe permite mover diversos pedaços de informação por uma rede em um;:i única 
chamada -um artifício que é essencial para sistemas distribuídos. 

Sempre que um objeto remoto precisa de alguns dados, pede por um Objetode 
Trnnsferência de Dados apropriado. O Objeto de Trnnsferê11cin de Dados normalmente 
transporta muito mais dados do que o objeto remoto solicitou, mas deve transportar 
todos os dados que o objeto remoto precisará por um certo tempo. Devido c1os custos 
de latência das chamadas remotas, é melhor errar enviando dados demais do que ter 
que fazer diversas chamadas. 

Um único Objeto de Transferência de Dados normalmente contém mais do que 
apenas um único objeto do set'vidor. Ele agrega dados de todos os objetos do servidor 
que o objeto remoto provavelmente irá querer. Assim, se um objeto remoto solicitar 
dados sobre um objeto pedido, o Objeto de Transferência de Dados retomado conterá 
dados do pedido, do cHente, dos itens dos pedjdos e de seus respectivos produtos 
e informações sobre a entrega -todos os tipos de coisas. 


CAPi1UlO 15 • PADRÕES DE 01STAIBUIÇÁO 381 

Você geralmente não pode transferir objetos de um Modelo de Oomfnio (126). lsto 
porque os objetos estão normalmente conectados em uma rede complexa que é difícil, 
senão impossível, serif1Lizar. Além disso, você normalmente não quer as classes 
dos objetos do domínio no cliente, o que é igual a copiar o Modelo de Domínio (126) inteiro 
Já. Em vez disso, você tem que transferir uma forma simplificada dos dados dos 
objetos do donúnio. 

Os campos em um Objeto de Transferência de Dados são razoavelmente simples, 
sendo classes primitivas simples como strings e datas, ou outros Objetos de Transfer~ncia 
de Dados. Qualquer estrutura entre objetos de transferência de dados deve ser grafo 
simples -normalmente uma hierarquia -em oposição às estruturas de grafos mais 
complexas que você vê em um Modelo de Domínio (126). Mantenha estes atributos 
simples, porque eles têm que ser serializáveis e precisam ser entendidos pelos dois 
lados da conexão. O resultado disso éque as classes dos Objetos de Transferência de Dados 
e quaisquer classes que elas referenciam devem estar presentes em ambos os lados. 


Faz sentido projetar os Objetos de Tnmsferência de Dtufos em torno das necessidades 
de um cliente em pmticulm·. É por isso que você muitas vezes os vê correspondendo 
a páginas Web ou telas de interface gráfica com o usuário. Você também pode 
ver diversos Objetos de Transferência de Dados para um pedido, dependendo da tela 
em particular. Éclaro que, se diferentes apresentações solicitarem dados semelhantes, 
então faz sentido usar um único Objeto de Transferêuciade Dados para lidar com todos 
eles. 

U1na questão relacionada a considerar é o uso de um únko Objeto de Transferêncin 
de Dados para uma interação completa contra o uso de diferentes objetos desses 
p;ira cada so1icitação. Ol>jclos de Transferência de Dados diferentes tornam mais fácil 
ver quais dados são transferidos cm cada chamada, mas isso leva a muitos Objetos de 
Tra11sferê11cin de Dados. Um émenos trnba lhoso de escrever, mas torna mais difícil ver 
como cada cl,amada transfere informações. Sou inclinado a usai· apenas um se houver 
muitas coisas em comum nos dados, mas não hesito em usar Objetos de Tmnsfer~
11cia de Dados diferentes se uma solicitação em especial sugerir isso. É wna daquelas 
coisas para as quais você não pode criar uma regra, então eu poderia usar um Objeto 
de Transferência de Dados para a maior patte da interação e usar diferentes Objetos 
de Tm11sferê11cia de Dados para algumas solicitações e respostas. 

Uma questão similar é ter um único Objeto de Transferência de Dados tanto para a 
solicitação quanto para a resposta, ou objetos separados para cada uma. Novamente, 
não há uma regra. Se os dados cm cada caso forem bastante semelhantes, uso Ltm. Se 
forem bastante diferentes, eu uso dois. 

Algumas pessoas gostam de tornar Objetos de Transferência de Dados imutáveis. 
Neste esquema, você recebe um Objeto de Transferência de Dndos do cliente, cria e envia 
de volta um diferente, mesmo se for da mesma classe. Outras pessoas alteram o 
Objeto de Tm11sferâncin de Dados da solicitação. Não tenho uma opinião decidida sobre 
estas maneiras, mas de modo geral prefiro um Objeto de Transferêncin de Dados mutável 
porque é mais fácil inserir os dados gradualmente, mesmo se você criar um novo 
objeto para a resposta. N guns a1·gumentos a favor de Objetos de 'fransfcrêncin de Dados 
imutáveis têm a ver com a confusão de nomes com Objeto Valor (453). 

Uma forma comum de Objeto de Transjerêncin de Dados é aquela de um Conjrmto 
de Registros (473), ou seja, um conjunto de registros tabulares -exatamente o que 
você recebe de volta de uma consulta SQL. De fato, um Conj1111to de Registros (473) 
é o Objeto de Trn11sferê11cia de Dndos para um banco de dados SQL. Arquiteturas fre



382 PARTE li • Os PAORÕES 

qüentemente o usam durante o projeto. Um modelo de domínio pode gerar um 
Conjunto de Registros (473) de dados para transferir para um cliente, o qual o cliente 
trata como se estivesse vindo diretamente do SQL Isto é útil se o cliente tiver ferramentas 
amarradas a csttuturas de Co11j1111to de Registros (473). O Conj11nto de Re~
istros (473) pode ser criado inteirnmente pela lógica do domínio, mas mais provavelmente 
é gerado a partir de uma consulta SQL e modificado pela lógica do domínio 
antes que seja passado para a apresentação. Esta maneira presta-se para Módulo 
Tabela (134). 

Outra forma de Objeto de Tra11sferé11cin de Dados é uma estrutura de dados do tipo 
coleção genérica. Tenho visto nrrays usêtdos para isso, mas desaconselho porque 
os índices do array deixam o código mais obscuro. A melhor coleção é um dicionário, 
porque você pode usar strings significativas como clrnves. O problema é que você 
perde a vantagem de uma interface explicita e tipificação forte. Pode valer a pena usar 
um dicionário para casos ad /roe, quando você não tem um gerador à mão, pois é 
mais fácil manipular um do que escrever um objeto explícito manualmente. Entretanto, 
com um gel'ador, penso que você fica melhor com uma interface expJícita, especialmente 
quando considera que ela está sendo usada como protocolo de comunicação 
entre componentes diferentes. 

Serializando o Objeto de Transferência de Dados Alémdos métodos de gravação 
e leitura, o Objeto de Transferê11cin de Dados normalmente também é responsável por 
serializar a si mesmo em algum formato próprio para transmissão pela conexão. 
Qual formato depende do que está em cada lado dn conexão, o que pode passar pela 
própria conexão e o nível de facilidade da serialização. Várias plataformas fornecem 
serialização embutida para objetos simples. Por exemplo, Java tem um seria1iza. 
ção binária embutida, e .NET tem serializações embutidas binária e XML.Se houver 
serialização embutida, ela normalmente funciona direito porque Objetos de Transfcrê11cia 
de Dados são estruturas simples que não lidam com as complexidades com as 
quais você se depara com objetos em um modelo de domínio. O resultado disso é 
que sempre uso o mecanismo automático se puder. 

Se não tiver um mecanismo automático, geralmente pode criar você mesmo 
um. Tenho visto diversos geradores de código que recebem simples descrições de registros 
e geramclAsses apropriadas para armazenar os dados, fornecer métodos de 
acesso e ler e gravar as seriaüzações de dados. O importante é tomar o gerador não 
mais complicado do que você precisa que ele seja, e não tentar colocar características 
que você apenas acredita que precisará. Pode ser uma boa idéia escrever as primeiras 
classes à mão e então usá-las pari\ lhe ajudar a escrever o gerndor. 

Você também pode usar programação reflexiva para lidar com seriali.zaçiio. 
Dessa maneira, você só tem que escrever as rotinas de serialização e desserialização 
uma vez e colocá-las em uma superclasse. Pode haver um custo de desempenho nisso. 
Você terá que medi-lo para descobrir se esse custo é significativo. 

Você tem que escolher um mecanismo com o qual os dois lados da conexão trabalharão. 
Se controlar os dois lados, pegue o mais fácil, caso contrário, pode conseguir 
fornecer um conector no 1ado que não é seu. Você pode então usar um Objeto de 
Tra11sfer8ncin de Dados simples em ambos os lados da conexão e usar o conector para 
adaptar o componente externo. 

Uma das questões mais comuns com que você se depara com Objetos d,: Transferência 
de Dados é usar uma forma de serialização em modo texto ou binário. As seriéllizações 
em modo texto são fáceis de ler para descobrir o que está sendo comunica



CAPi1ULO 15 • PADAÔES DE D1STAIBUIÇÁO 383 

do. A X!vtL é popular porque você pode obter ferramentas facilmente para criar e 
analisar documentos XML. As grandes desvantagens com o modo texto é que ele 
precisa de mais largura de banda pc1ra enviar os mesmos dados (algo especiéllmente 
verdadeiro sobre XML) e muitas vezes há prejuízo de desempenho, o que pode ser 
bastante sigruficatjvo. 

Um fator importante para seriatização é a sincronização do Objeto de Tmnsferência 
de Dados em cada lado da conexão. Na teoria, sempre que o servidor alterar a definição 
do Objeto de Trnnsferêncin de Dados, o cliente atualiza tam_

bém, mas na prática 
isso pode não acontecer. Acessar um servidorcom um cliente desatualizado sempre 
leva a problemas, mas o mecanismo de serialização pode tornar os problemas mais 
ou menos penosos. Com uma serialização puramente binária de um Objeto de Tra11sfarência 
de Dados, o resultado será que sua comunicação é inteiramente perdida, já 
que qualquer alteração nasua estrutura normalmente causa umerro na desserialização. 
Mesmo uma alteração inofensiva, como a adição de um campo opciona), terá esse 
efeito. O resultado é que a serialização binária direta pode introdLtzir muita fragilidade 
às linhas de comunicação. 

Outros esquemas de serialização podem evitar isso. Um é a serialização XML, 
que pode normalmente ser escrita de uma maneira que torne as classes mais toleran~ 
tesa alterações. Outro é uma abordagem binária mais tolerante, como seriali;,;ar os 
dados usando um dicionário. Embora eu não goste de usar umdicionário como Objeto 
de Tmnsferência de Dndos, pode ser uma maneira útil de executar uma serialização 
binária dos dados, já que isso introduz alguma tolerância na sincronização. 

Montando um Objeto de Tra11s/crê11cin de Dndos a partir de Objetos de Domínio 
Um Objeto de Transferência de Dndos não sabe como se conectar a objetos do domínio, 
porque ele deve ser distribuído nos dois lados da conexão. Por este motivo, não quero 
que o Objeto de Transferência de Dados seja dependente do objeto do do1nmfo. Também 
não quero que os objetos do domínio sejam dependentes do Objeto de Trnnsferêncin 
de Dados, já que a estrutura do Objeto de Transferência de Dados mudará quando eu 
alterar os formatos da interface. Como regra, quero manter o modelo do domínio independente 
das interfaces externas. 

O resultado disso é que gosto de criar um objeto montador separado responsável 
pela criação de umObjeto de Transferência de Dados a partir do modelo do domínio 
e pela ah.talização do modelo a partir dele (Figura 15.4). O montador é um exemplo 
de um Mapeador (442), visto que ele mapeia entre o Objeto de Transferêncin de Dados e 
os objetos do domi'.nio. 

Também posso fazer diversos montadores compartilhar o mesmo Objeto de 
Trnnsferêncin de Dndos. Um caso comum para isso são diferentes semânticas de atualização 
emcenários diferentes usando os mesmos dados. Outra razão para separar o 
montador é que o Objeto de Transferência de Dados pode facilmenteser gerado automc1ticrunente 
a partir de uma descrição de dados simples. Gerar o montador é mais difícil 
e, muitas vez-e-s, impossível. 

Quando Usá-lo 

Use um Objeto de Trnnsferência de Dados sempre que precisar transferir diversos itens 
de dados entre dois processos em uma t'micc1 chélmada de método. 
Há algumas alternativas a Objeto de Trnnsferência de Dados, emborn eu não seja 
fã delas. Uma é não usar um objeto, mas sjrnplesmente um método de gravação 


384 PARTE li • Os PADRÕES 

Objeto de 

Transferência

Objeto do Domínio 

de Dados 

1' 
1' 
serializar 

desserializar 
1 

1 

1 

1 1' 

1 

1 

1 1 

Montador 

1 

1

1 

1

1 

~---1 

l----criarObjetoDeTransferênciaDeOados (ObjetoOoOomínio) 

alualizarObjetoOoOomínio (ObjetoOeTransferênciaOeOados) 

uiarObjetoOoDomln,o (ObjetoDeTransferêndaOeDados) 

Figura 15.4 Um objeto montador pode manter o modelo do domínio e os objetos de 
transferência de dados independentes um do outro. 

com muitos parâmetros ou um método de leitura com diversos parâmetros passados 
por referência. O problema é que muitas Hnguagens, como Java, permitem 
apenas o retorno de objetos, então, embora isso possa ser usado para atualizações, 
não pode ser usado para trazer informações sem correr riscos com chamadas de 
retorno. 

Uma r1lternativa é usar diretamente algum tipo de representação de string, sem 
um objeto atuando como interface para isso. Aqui o problema é que tudo o mais fica 
acoplado à representação da string. É bom esconder a representaç~o exata por trás de 
uma interface explicita. Dessa forma, se você quiser alterar a string ou substituí-la 
por uma estrutura binária, não tem que alterar mais nada. 

Em particular, vale a pena criar um Objeto de Transferência de Dados quando você 
quiser comunicr1r entre componentes usando XML. O DOM XML é difídl de manjpular 
e é muito melhor usar um Objclo de Transfcrencia de Dados que o encapsule, especialmente 
pelo Objeto de Tra11sfarê11cia de Dados ser tão fácil de gerar. 

Outro propósito comum do Objeto de Trnnsferêncin de Dados é atuar como uma 
fonte comum de dados para diversos componentes em camadas diferentes. Cada 
componente faz algumas alterações no Objeto de Transferência de Dados e então o 
passc1 para a próxima camc1da. O uso de Conjunto de Registros (473) em COM e 
.NET é um bom exemplo disso, em que cada camada sabe como manipular dados 
baseados em conjuntos de registros, quer tenham vindo diretamente de um banco 
de dados SQL, quer tenham sido modificados por outras camadas..NET expande 
isso fornecendo um mecanismo embutido para serializar conjuntos de regjstros 
para XML. 

Embora este livro enfoque sistemas síncronos, há um uso assíncrono interessante 
para Objeto de Transferência de Dados. Este é quando você quiser usar uma interface 
tanto síncrona quanto assincronamente. Retorne um Objeto de Trt111:.fcrfl11cin de Dados 
como de costume para o caso síncrono. Para o caso assíncrono, crie uma Carga Tardia 

(200) do Objeto de Transferência de Dndos e a retome. Conecte a Carga Tardia (200) onde 
quer que os resultados da chamada assíncronc1 devam aparecer. O usuário do Objeto 
de Tra11sferêucia de Dados bloqueará apenas quando este tentar acessar os resultados 
da chamada. 

CAPiWLO 1 S • PADRÕES oe 01STRIBUIÇÁO 385 

Leitura Adicional 

lAlur ct ai.) discutem este padrão sob o nome de Objeto Valor, o que eu disse anteriormente 
ser equivalente ao meu Objeto de Trnnsferência de Dados. Meu Objeto Valor (453) 
é um padrão inteiramente diferente. Esta é uma colisão de nomes. Muitas pessoas 
têm usado ''Objeto Valor" no sentido em que eu o uso. Até onde eu saiba, seu uso significando 
o que eu chamo de Objeto de Tra11sferê11cia de Dados ocorre apenas dentro da 
comunidade J2EE. Como resultado, segui o uso mais geral. 

O Moltlndor de Objeto Valor [AJur el n/.]é uma discussão sobre o montador. Decidi 
não torná-lo um padrão separado, emborn use o nome "montador" em vez de um 
nome baseado no Mapcndor (442). 

[Marinescu] discute Objeto de Transferê11cia de Dados e diversas variantes de implementações. 
[Riehle el ai.] djscutem maneiras flexíveis de serializar, incluindo a alternância 
entre diferentes formas de serialização. 

Exemplo: Transferindo Informações Sobre Álbuns {Java) 

Para este exemplo, usarei o modelo do donúnio da Figurn 15.5. Os dados que quero 
transferir são os dados sobre estes objetos vinculados, e a estrutura para os objetos de 
transferência de dados é a da Figura 15.6. 

Osobjetos de transferência de dados simplificam bastante esta estrutura. Os dados 
relevantes da classe Artista são movidos para o Álbum OTD, e os intérpretes de 
uma faixa são representados como um nrmy de strings. Isso é típico da compactação 
de estruturas que você vê para um objeto de transferência de dados. Há dois objetos 
de transferência de dados presentes, um para o álbum e um para cada faixa. Neste 
caso, não preciso de um para o artista, já que todos os dados estão presentes em um 
dos outros dois. Só tenho a Faixa como objeto de trnnsferência porque há diversas 
faixas no álbum e cada uma contém mr1is do que um itemde dados. 

Aqui está o código para gravar um Objeto de Transferência de Dados do modelo 
do domínio. O montador é chamado por qualquer objeto que esteja lidando com a interface 
remota, como uma Fachada Remota (368). 

Álbum 1 Artista 

-

título: String * nome: String 

1 

1 1 
1 

intérpretes

1 
1 

1 

1 

1' 

*' 
VJ 

Faixa * 

1-------1-----------------título:
String 

Figura 15.5 Um diagrama de classes de artistas e álbuns. 


386 PARTE li • Os PADRÕES 

Álbum OTD Faixa OTD 

-

título: String -título: String 
artista: String 1 * intérpretes : Alray of String 

Figura 15.6 Um diagrama de classes de artistas e álbuns. 

class MontadorDeÃlbum... 

public ÁlbumOTD gravaroro /Álbum sujeito) 
Âlbul!lOTD resultado: new ÁlbumOTD( 1; 
r~sultado.gravarTitulo(sujeito.lerTítulol }) ; 
resultado.gravarArtista(sujeito.lerArtista( 1 .lerNoc:el)): 
gravarFaixas(resultado, sujeito); 
return resultado; 

} 

private void gravarPaixas {Álbum<YI'D resultado, Álbum sujeito) 
List novasFaixas = new ArrayList ( ); 
Iterator it = sujeito.lerFaixas( ) .iteratorl); 
while (it.hasNext ( }) ( 

FaixaOTD novOOTO; new FaixaOTO{ l; 
Faixa estaPaixa = (Faixa) it.next( ); 
novoaI'D.gravarTitulo (estaFaixa.lerTitulo( li; 
gravarlntérpretes(novoOTO, estaPaixa}; 
novasFaixas.add{novOOTO); 

resultado.gravarFaixas( (FaixaOTD[ )l novasFaixas.coArray(new FaixaOTD[O])I; 

private void gravar!ntérpretes (Faixa(}l'l} otd, Faixa sujeito} 
List resultado= new ArrayList (); 
lterator ít = S1Ijeito.lerlntérpretes() .iterator( ); 
while (it.hasNext( )) \ 

Artista cada = !Artista) it.next( ): 
resultado.add lcada.lerNome( )); 

otd.gravarlntérpretes ( (String ! J) resultado.toArray(new String!Oll); 

Atualizar o modelo a partir do Objeto de Tra11sferét1cin de Dndos é normalmente 
mais confuso. Para este exemplo há uma diferença entre criar um novo álbum e atualizar 
um existente. Aqui está o código para criação: 

class MontadorDeÃlbum... 

public void criarÁlbum (String id, Ãlb~D fonte) 
Artista artista: Registry. encontrarArtistaChan:ado (fonte.lerArtista ( )~; 
if (artista== null) 

throw ne'ti RuntiCteException (•Henhuc artista chamado• .. fonte.lerArtista( I); 
Álbum álbum= ne~ Álbum (fonte.lerTítulo( ), artista); 
criarFaixaslfonte.lerFaixas( l, álbum); 
Regiscro.adicionarÁlbum(id, álbum); 

} 
private void criarFaixas (FaixaOl'O[ ) faixas, Álbum álbum) 


CAPitULO 15 • PAORÔES DE 01STRIBUICÁO 387 

for (int i = O; i< faixas.length; i+t) { 
Faixa novaFaixa = new Faixaffaixaslil .lerTitulo( )); 
álbur.i.adicionarPaixa(novaFaixa); 
criarintérpretes(novaFaixa, faoxas[i} .lerlntérpretes( )l ; 

private void criarlntérpretes iFaixa nO\•aPaixa, String.[ ) arrayDeintérpretes) { 

for (int i = O; i < arrayDeintérpretes.length; it~) { 
Attista intérprete= Registr~. encontrarArtistaChaw4do (arrayDelntérpretes li) ) { 
if (intérprete== nulll 

throw new RuntimeException l"Nenhum artista chamado• t arrayDeintérpretes li)~ ; 
novaFaixa.adicionarintérprete [intérprete): 

Ler o OTD envolve algumas decisões. Perceptível aqui é como lidar com os nomes 
dos artistas à medida que eles chegam. Meus requisitos são que os artistas já devem 
estar em um Registro(448) quando eu crio o álbum de modo que, se cu não conseguir 
encontrar um artista, isso é um erro. Um método de criação diferente poderia decidir 
criar c1rtistas quando eles forem mencionados no Objeto de Transferência de Dndos. 

Para este exemplo tenho um método diferente para atualizar um álbum existente. 

class ~ontadorDeÁlbum... 

public void atualizarÁlbum (String id, ÁlbumOTD fonte) 

Álbum atual: Registro. encontrarÃlbum (idl ; 

if (atual== nulll 

throw new RuntireeE>:ception (•Álbum não existe: • + fonte.lerTítulo( )); 

if (fonte.lerTitulo( 1 != acual.lerTitulo( )l atual.gravarTítulo(fonte.:errítulo( li; 

if (fonte.lerArtista( ) != atual.lerArcista( }.lerNome{ )) { 

Artista artista : Registro. encontrarArtistaChamado (fonte.lerArtista ( ,1 ; 

if (artista== null ) 

thro~ new RuntímeBXception 1~Nã hâ artista chamado~• fonte.lerArtista( li; 

atual.gravarAttistalartistal ; 

} 

atualizarFaixas(fonte, acuall; 

) 

private void atualizarFaixas (ÁJbumOTD fonte, Ãlbum atual} 

for (int i : O; i < fonte.lerFaixas() .length; i-+) 1 

atual. lerPaixa li) .gravarTítulo(fonte. lerFaixaOTD (i) .lerTitulo( l); 

atual.lerFaixa(i). apagarintérpretes ( ); 

criarintérpretes(atual.lerFaixa!i l, fonte.lerFa1xaOTD(i) .lerlntérpretes( I); 

Quanto a atualizações, você pode decidir atualizar o objeto do domínio existente 
ou destruí-lo e substituí-lo por um novo. A questão aqui é se você tem outros objetos 
se referindo ao objeto que quer atualizar. Neste código, estou atualizando o álbum 
já que tenho outros objetos se referindo a ele e a suas faixas. Entretanto, para o 
título e os intérpretes de uma faixa, apenas substituo os objetos que estão lá. 

Outra questão diz respeito à alteração de artistas. Isso está alterando o nome do 
artista existente ou mudando o artista ao qual o álbum está vinculado? Novamente, 


388 PARTE li • Os PAORô ES 

estas questões têm que ser decididas caso a caso, e estou lidando com ela vinculemdera 
a um novo artista. 

Neste exemplo, usei uma serializaçào binária nativa, o que significa que tenho 
que tomar cuidado para que as classes dos Objetos de Trn11sfer8ncin de Dados em ambos 
os lados da conexão sejam mantidas em sincronia. Se eu fizer uma alteração na estrutura 
de dados do Objeto de Transferência de Dados servidor e não alterar o cliente, terei 
erros na transferência. Posso tornar a transferência mais tolerante usando um mapa 
como minha serializaçâo. 

class FaixaOTD... 

public Map Fpa{) 
Map resultado: new Hasht-!ap ( ); 
resultado.put ('título', título): 
resultado.put (•intérpretes•, intérpretes); 
return resultado; 

public static Faixaoro lerMapa (~.apa arg) ( 
FaíxaOTD resultado= ne~ Faixa OTO( )i 
resultado.titulo= (String) arg.get(•título•); 
resultado.intérpretes= (String [ 11 arg.get l•intérpretes•); 
return resultado; 

Agora, se eu adicionar um campo ao servidor e usar o cliente antigo, embora o 
novo campo não vá ser pego pelo cliente, o resto dos dados serão transferidos corretamente. 


É claro que escrever as rotinas de serialização e desserialização desta forma é tedioso. 
Posso evitar muito desse tédio usando uma rotina reflexiva como esta na Cnmndn 
Supertipo (444): 

class ObjetoDeTransferênciaDeDados... 

public Map gravarMapaReflexão () 
Map resultado = null; 
try f 

Field [) campos= th1s.9etClass( l.getDeclaredFields( l; 
resultado: new HashMap ( ); 
for (int l = O; i< campos.length; i,,I 

resultado.put (campos[i) .getNa~e( ) , campos li] .get(this)); 
} catch (Bxception e) {throw new ApplicationException te>; 
} 
recurn resultado; 

public static FaixaOTD le~MapaComReflxão (Map arg) 
FaixaOTD resultado= new FaixaOTD(); 
try { 

Field( 1 ca~os = resultado.getClass() .getDeclaredFields( ); 
for Cint L= O; i< carnpos.length; i++) 

campos(i] .set(resultado, arg.get{campos[:) .getName( )I; 
} catch (Bxception e) {throw new ApplicationExcepcíon lel; 
} 
return resultado; 


ÚPÍlULO 15 • PADRÕES OE 01STRIBUIÇÁO 389 

Tal rotina irá lidar muito bem com a maioria dos casos (embora você vá ter que 
adicionar código extra para lidai· com prinúlivas). 

Exemplo: Serializando Usando XML (Java) 

Enquanto escrevo isto, a manipulação de XML por Java está em contínua mudança e 
APis, ainda voláteis, estão de modo geral melhorando. Quando você ler, esta seção 
pode estar desatualizada ou completamente irrelevante, mas o conceito básico da 
conversão para XML é quase que o mesmo. 

Primeiro, leio a estrutura de dados do Objeto de Trm1sferê11cia de Dados, então preciso 
decidir como sedalizá-la. Em Java, você obtém sedalização binária simplesmente 
usando uma interface de marcador. Isso funciona de maneira completamente automática 
com wn Objeto de Transferência de Dados, então, é minha primeira escolha. 
Entretanto, muitas vezes, é necessário seria1ização baseada em texto. Para este exemplo, 
então, usarei XML. 

Neste exemplo, estou us<1ndo JDOM, já que isso torna o trabalho com XML 
mwto mais fácil do que usar as interfaces padrão W3C. Escrevo métodos para ler e 
gravar um elemento XML para representar essa classe em cada classe Objeto de Transferência 
de Dados. 

cla&s Ãlbu!!IOTD. .. 

6lement paraBlementoXML ( ) 
Elemenc raiz= new Element (•álbum•); 

raiz.setAttribute (•titulo•, t!tulol; 

raiz. setAttri.bute(•artista•, artista}; 

for (int i = O; i < faixas.length; i H ) 
raiz.addConcent (faixas[il .paraElementoX1'1L( )1 ; 
return rah.; 

l 

static ÁlbumOTD lerXML (Element fonte) ( 
ÁlbumOTD resultado = new ÁlbumOTD( ) ; 
resultado.9ravar'l'itulo(fonte .9etAttributeValue (•t1tulo"); 

resul tado.gravarArtista(fonte.getAttributeValue(•artista•); 

List listaDeFaixas = new ArrayList ( ); 
Iterator it = fonte.getChildren t"faixa•) .iterator( I; 
while (it.l»sNext ( )) 

listaDeFaixa.add(FaixaOTD.lerXML{(Eleaient) it.next( )I); 
resultado.gravarFaixas((FaixaOTD( 1 ) listaDefaixas.toArray(new FaixaOTDIOI)); 
return resultado; 

c!ass FaixaOTD.. . 

Element paraBle~ntoXML ( 1 ( 
Element resultado = new Blemeot (•faixa • 1 ; 
resultado.setAttribute (•titulo•, título); 
for (int i = O; i < intérpretes.length; it•) 

Elew.ent ele;iientolntérprete = new Element ("intérprete•); 
elerr.entotntérprete.setAttributel"nome•, intérpretesliJl ; 
resultado.addContent(ele~encorntérprete); 

} 

return resultado; 


390 PARTE li • 0.s PAORÕES 

scatic Fai.xaOTD lerXml (Element ar9) { 
FaixaOTD resultado = new FaixaOTD ( l ; 
resultado.gravar'l'ítulo(arg.getAttributeValue(•titulo•) r 
Iterator it = arg.getChildren(•intérprete•) .iterator( J1 
List buffer = new ArrayList( ); 
while (it .hasNext( )1 { 

Element cadaElernento = (Blecentl it.nextl ) ; 
buffer.add(cada81e~ento.getAtcributeValue(•nome~) ; 

resultado.gravarintérpretes( (Scring[ 1) buffer.toArray(new String[0l)l; 
return resultado; 

É claro que estes métodos apenas criam os elementos no DOM XML. Para executar 
a serialização, preciso ler e escrever texto. Já que a faixa é transferida apenas no 
contexto do álbum, preciso apenas gravar este código do álbum. 

class ÁlbuQ (71'D... 

public void paraStringX!-11., (Writer saida) 
El ement raiz~ paraElemencoXml( ); 
Document doe= new Document (raiz); 
XMLOutputter gravador= ne.w XMLôutputtet() 1 
try { 

gravador.oucput(doc, saída); 
) catch (IOBxception e) { 
e.printScackTracel ); 

) 
public static Álbur.iOTD lerStringXml {Reader entrada! 

try 1 
SAXBuilder construtor= new SAXBuilder( ); 
Document doe= construtor.build(entrada); 
Element raiz : doc.getRootElement( I; 
Álbu.'!!OTO resultado= lerX~Llraiz); 

return resultado; 

} catch (Bxception e) 1 
e.printStackTrace!) ; 
thow new Runti~eException ( ); 

Embora este não seja um conhecimento sofisticado, ficarei feliz quando JAXB 
tornar este tipo de coisa desnecessário. 


CAPÍTULO 1 

Padrões de Concorrência Offline 


392 PARTE li • Os PADRÕES 

Bloqueio Offline Otimista (Optimistic Offline Lock) 

por Dnvid Rice 

Previne conflitos entre lrnnsnções de negócio co11corre11fes 
detectando 11111 co11jlito e desfnze11do a tm11sação. 

Sessão do Martin Banco de Dados Sessão do David 

1 
1 

1 1

-,-------,--, 

1 1 1 

limite da

1 lerCliente 129 J

1 

Transação 
de Sistema 

1 1 
1 ~eto~n~;cli~~e129--1 /

1 

/

L ------,-


-o/

r--------


1 : lerCliente 129 1 

editar cliente 1 1 
retornar cliente 129 

1 
1L _ _J_______ _J 

1 

1 

editar cliente 

1 ? 

1 I 
1 

I 

I

l

1 t atualizar cliente 129 I 
1 I

1 

I

1

1 I

_J

L---t-------I 

-------+--, I 

atualizar cliente 129 1 1 I 
I 

1 

Limite da 
desfazer falha: versão 1 Transação 
errada do cliente 1 1 de Negócio 

-------,-


1 
1 

MuHas vezes, uma transação de negócio é executada por meio de uma série de transações 
de sistema. Uma vez fora de uma transação de sistema, não podemos contar 
apenas com nosso gerenciador de banco de dados para assegurar que a transação de 
negócio deixará os dados em um estado consistente. A integl"idade dos dados é um 
risco, assim que duas sessões começam a trabalhar nos mesmos registros, e atualizações 
perdidas são bastante possíveis. Além disso, com uma sessão editando dados 
que outra esteja lendo, uma leitura inconsistente torna-se provável. 

O Bloq11eio Offli11e Otimistn resolve esse problema ratificando que as alterações 
a serem gravadas por uma sessão não estejam em conflito com as alterações de ou



CAPiTULO 16 • PADRÕES OE CONCORRÊNCIA 0FFUNE 393 

tra sessão. Uma validação com sucesso antes da confirmação (commit) significa, de 
certo modo, obter um bloqueio indicando que não há problema cm ir cm frente com 
as alternções nos dados dos registros. Enquanto a validação e as atualizações ocorrerem 
dentro de uma única transação de sistema, a transação de negócio exibirá 
consistência. 

Enquanto que o Bloqueio Offline Pessimista (401) pressupõe que a chance de conflito 
na sessão é alta e, portanto, limita a concorrência do sistema, o Bloqueio Offline 
Otimista supõe que a chance de conflito é baixa. A expectativa de que um conflito na 
sessão não seja provável permite que diversos usuários trabalhem com os mesmos 
dados ao mesmo tempo. 

Como Funciona 

Um Bloq11eio Offlinc Otimista é obtido garantindo que, no tempo decorrido desde, 
que uma sessão carregou um registro, outra sessão não o alterou. Ele pode ser obtido 
a qualquer momento, mas é válido apenas durante a transação de sistema na 
qual foi obtido. Assim, para que uma transação de negócio não corrompa dados gravados 
ela deve obter um Bloqueio Offli11e Otimista para cada membro de seu conjunto 
de alterações, durante a trnnsaçilo de sistema na qual ela aplica as alterações no 
banco de dados. 

A implementação mais comumé associar um número de versão com cada registro 
no seu sistema. Quando um registro écarregado, esse número é mantido pela sessão 
;unto com todo o estado dela. Obter o Bloq11eio Offline Otimista é uma questão de 
comparar a versão armazenada nos dados da sua sessão com a versão atual nos dAdos 
gravados. Assim que a vel'ificação tenha sucesso, todas as alterações, incluindo 

o incremento da versão, podem ser gravadas. O incremento da versão é o que evita 
dados gravados inconsistentemente, já que a sessão com uma versão antiga não pode 
obter o bloqueio. 
Com dados em um SGBDR a verificação é uma questão de adicionar o número 
da versão ao critério de qualquer declaração SQL usad<'I para atualizar ou apagar um 
registro. Um.a única declaração SQL pode tanto obter o bloqueio quanto atualizaros 
dados gravados. O passo final é a b·ansação de negócio inspecionar o contador de linha 
retormtdo pela execução do SQL. Um contador de linha igual a um indica sucesso, 
zero indica que o registro foi alterado ou excluído. Com um contador de linha 
igual a zero, a transnção de negócio deve desfazer a transação de sistema parc1 evitar 
que alterações sejam feitas nos dados gravados. Neste ponto, a transação de negócio 
deve abortar ou tentar resolver o conflito e tentar de novo. 

Além de um número de versão para cada registro, armazenar informações sobre 
quem modificou esse registro da última vez e quando isso foi feito pode ser muito 
útil durante o gerenciamento de conflitos de concorrência. Ao informar um usuário 
c1 respeito de uma folha de atualização devido a violação de concorrência, uma 
aplicação correta dfrá quando o registro foi alterado e por quem. É uma idéia ruim 
usar o timestnmp da modHicaçlfo em vez de um contador de versão para suas verificações 
otinústas, porque os clocks dosistema são simplesmente não-confiáveis., especialmente 
se você estiver coordenando por mefo de diversos servidores. 

Em uma implementação alternativa, a cláusula WJ IERE na atualização inclui 
cada campo da linha. A vantagem aqui é que você pode usar essa cláusula sem usar 
algum tipo de campo versão, o que pode ser útil se você não puder adicionar um 
campo versão alterando as tabelas do banco de dados. O problema é que isso com



394 PAATE li • Os PADRÕES 

Sessão Banco de Dados 

1

-,------r 

:_~ ~~~~-----~----um;teda 
1 Transação 
editar I de Sistema 

Cliente 1 
r< 1 

_L_UPDATE-----1 
~Cliente O,_ 

>:1 
1 

1 1 retorna ----~ ~ 

1 1 contador I l -....-----'-----------------


~de linha --------1 UPOATE Cliente 
1 1 1 SET... , versão = (cópia que a sessão possui da versão +1)

1 

1 1 verificar se o contador I WHERE id :: ?ANO versão "' côpia que a sessão possui da versão 

1 de linha é igual a 1 1 I 
1 '< 1 1

L-1 _________J...J 

1 1 

1 1 

Figura 16.1 Verificação otimista de UPDATE. 

plica a declaração UPDATE com uma cláusula WHERE potencialmente grande, o 

que pode também ter umimpacto no desempenho dependendo do quão hábil o ban


co de drldos é em relação ao uso do índice da chave primária. 

Muitas vezes, a implementação do 8/oq11eio Offline Otimistn é feita por meio da 
inclusão da versão nas declari\ções UPDATE e DELETE, porém isso não resolve o 
problema de uma leitura inconsistente. Pense em um sistema de faturas que crie uma 
cobrança e calcule a taxa de venda apropriada. Uma sessão cria a cobrança e então 
procura pelo endereço do cliente para calcular a taxa, mas dw·ante a sessão de geração 
da cobrança uma sessão separada de manutenção de clientes edita o endereço do 
cliente. Como a taxa depende da localização, o valor calculado pela sessão de geração 
da cobrança poderia ser invá1ido, mas já que a sessão de geração da cobrança nãe> 
fez nenhuma alteração no endereço, o conflito não será detectado. 

Não há motivo pélra que o Bloqueio Offli11e Otimista não possa ser usado para 
detectar uma leitura inconsistente. No exemplo acima, a sessão de geração da cobrança 
precisa reconhecer que sua correção depende do valor do endereço do cliente. 
Ela deve, pottanto, executar também uma verificação de versão no endereço, talvez 
adicionando o endereço ao conjunto de alterações ou mantendo uma lista separada 
de itens a terem sua versão checada. Esta última opção requer um pouco mais 
de h·abalho para ser configurada, mas rnsult<'l em código que declara suas intenções 
mais claramente. Se você estiver verificando uma consistência de leitura simplesmente 
relendo a versão em vez de uma alteraç.io artificial, esteja ciente do nível de 
isolamento da sua transação de sistema. A releihtra da versão só funcionará com leituras 
repetíveis ou isolamento maior. Qualquer coisa mais fraca do que isso requer 
umincremento da versão. 

Uma verificação de versão poderia ser demais para determinados problemas de 
leitura inconsistente. Muitas vezes, tLma transação depende apenas da presença de 
um registro ou talvez do valor de apenas um de seus campos. Neste caso, você pode



úJ>itULO 16 • PAORÔES OE CONCORRtNCIA 0FFUNE 395 

ria meU1orar a esperteza de seu sistema verificando condições em vez de versão, já 
que menos atualizações concorrentes resultarão nn falha das tr<1nsaçõcs de negócio 
que estão competindo. Quanto mais você entender os problemas de concorrência, 
melhor poderá gerenciá-los no seu código. 

O Bloqueio de Crm111laridade Alta {412) pode éljudar com aJgumas leituras foconsistentes 
tratando um grupo de objetos como um (mico item bloqueável. Outra opção 
é simplesmente executar todos os passos das h'a.nsações de negócio problemáticas 
dentro de uma única transação longa. A facilidade de implementação poderia 
provar que o benefício de usar algumas transações longas cm algumas ocasiões compensa 
o custo. 

A detecção de uma leitura inconsistente fica um pouco difícil quando sua transação 
é dependente dos resuJtados de uma pesquisa dinâmica em vez da leitura de 
registros específicos. É possível que você tenha que gravar os resultados iniciais e 
compará-los aos resultados da mesma pesquisa na hora da conffrmação como um 
meio de obter um Bloq11eio Offlinc Otimista. 

Assim como com todos os esquemas de bloqueio, o Bloqueio Offli11e Otimistn por 
si só não fornece soluções adequadas para alguns dos problemas mais compücados 
deconcorrência e aJgtms problemas temporais em uma aplicação denegócio. Nunca 
é demais enfatizar que em uma apUcação de negócio o gerenciamento de concorrência 
é tLma questão tanto de domfuio quanto técnica. O cenário do endereço de clicn~ 
te acima é realmente um conflito? Poderia ser admissível que eu tivesse calculado a 
taxa com uma versão mais antiga do cliente, mas qual versão eu deveria realmente 
estar usando? Esta é uma questão de negócio. Ou então considere uma coleção. Se 
duas sessões adicionassem itens simultt1neamente em uma coleção? O esquema de 
Bloq11cio Ofjline Otimista típico não evitaria isso embora pudesse n1uito bem ser ua1a 
violação de regras de negócio. 

Há um sistema usando Bloq11eio Offline Otimista com o qu<1l todos nós deveríamos 
estar famfüarizados: gerenciamento de código fonte (GCF). Quélndo umsistema 
GCF detecta um conflito entre programadores, normalmente pode descobrfr a consolidação 
correta e tentar gravar novamente. Uma boa estratégia de consolidação torna 
o Bloq11cio Ofj1ine Otimista bastante poderoso não apenas porque a concorrência do 
sistema é bastante alta, mas também porque os usuários raramente têm que refazer 
algum trabalho. É claro que a grande diferença entre um sistema GCF e uma aplicação 
corporativa de negócio é que o GCf deve implementarapenas um tipo de consolidação, 
enquanto que o sistema de negócio poderia implementar centenas. Alguns 
poderiam ser de tal complexidade que não valeria o custo da codificação. Outros poderiam 
ser de tal valor para o negócio que a consolidação deveria ser codificada de 
qualquer jeito. Embora sendo feita com pouca freqüência, a consolidação de objetos 
de negócio é possível. Na verdade, consolidar dados de negócio é em si um padrão. 
Pararei por aqui em vez de esgotaro é'\ssunto, mns compreenda o poder que a consolidação 
acrescenta ao Bloq11eio Ofj1ine Otimista. 

O Bloq11eio Offline Otimista só nos informa se uma transação de negócio será realmente 
gravada durante a última transação de sistema. Contudo, ocasionalmente é 
1.Hil conhecer com maior antecedência se oconeu um conflito. Para isso, você pode 
fornecer um método verificarAtual que verifica se mrus alguém atualizou os dados. 
Isso não garante que você não vá ter um conflito, mas pode valer a pena parar um 
processo complicado se você puder perceber de antemão que ele não será gravado. 
Use este verificarAtual sempre que descobrir cedo que uma falha possa ser útil, mns 
len1bre-se de que isso nunca garante que não haverá falha .na hora da gravação. 


396 PARTE li • Os PADRÕES 

Quando Usá-lo 

O gerenciamento otimista de concorrência é apropriado quando a chance de conflito 
entre duas transações de negócio quaisquer for baixa. Quando os conflitos forem 
prováveis, não é razoável anunciá-los apenas quando o usuário tiver concluído seu 
trabalho e estiver pronto pMa a confitmação . No final, ele irá. pressupor a falha das 
transações de negócio e parará de usar o sistema. O Bloqueio Offline Pessimistn (401) é 
mais apropriado quando a chance de conflito for alta ou o custo de um conflito for 
inaceitável. 

Como um bloqueio otimista é muito mais fácil de implementar e não está propenso 
aos mesmos defeitos e erros em tempo de execução do Bloqueio Offline Pessilllista 
(401), considere usá-lo como abordagem padrão de gerenciamento de conflito 
de transações de negócio emqualquer sistema que você construir. A versão pessimista 
funciona bem como um complemento ao seu correlato otimista, então em vez de 
perguntar quando usar uma abordagem otimista para evitar conflito, pergunte quando 
a abordagem otimista sozinha não é boa o suficiente. A abordagem correta para a 
gerência de concorrência maximizará o acesso concorrente aos dados ao mesmo tempo 
em que minimiza os conflitos. 

Exemplo: Camada de Domínio com Mapeadores de Dados (170) (Java) 

O exemplo mais curto de Bloqueio OJfliue Olimistn envolveria apenas uma tabela de 
banco de dados com uma colum, para a versão e declarações UPDATE e DELETE 
que usam essa versão como parte de seu critério de atualização. É claro que ,1ocê criará 
aplicações mais sofisticadas, então apresento a implementação usando um Modelo 
de Domfnio (126) e Mnpcndores de Dndos (170). Isso revelará mais questões que surgem 
comumcnte durante a implementação de Bloqueio Offlinc Otimistn. 

Uma das primeiras coisas a fazer é assegurar-se de que sua Cnmnda Supcrtipo 

(444) do domínio é capaz de armazenar qualquer informação necessária para implementar 
o Bloqueio Offline Otimista -a saber, dados da modificação e da versão. 
class ObjetoDoOominio .. . 

private Timestamp reoóificaôo; 
private St ring ~.odificadoPor; 
private int versão; 

Nossos dados são armazenados cm um banco de dados relacional, então, cada 
tabela deve também armazenar dados sobre versão e modificação. Aqui está o esquema 
para uma tabela cliente assim como o SQL CRUD (criação, leitura, atualização e 
exclusão) padrão necessário para suportar o Bloqueio Offline Otimista. 

tabela cliente ... 

c~eate table cliente (id bigint prirnary key, nocne varchar1 criadoPor varchar, 
criado datetíme, modificadoPor varchar, modificado dateti~e, versão int) 

CRUD SQL cliente ... 

!NSERT rnro cliente VALUES (?., ? ' ? • ? , ? • ? • ?) 
SBLECT • FRO~ cliente iiHERE id = ? 
OPDATE cliente SBT noma = ?, 11\0dificadoPor = ?, codificado=?, versão=? 

WHERE id =? ANOversão~? 
DELETE FROMcliente \'iHERE id a ? AND versão , 


ÜJ'iTULO 16 • PADRÕES OE. CONCORRÊNCIA OFFLJNE 397 

Assim que você tiver mais do que algumas tabelas e objetos do don:únio, irá 
querer introduzir uma Cnmndn S11pertipo (444) para seus Mapeadores de Dados (170) 
que lide com os segmentos tediosos e repetitivos de mapeamento 0/R. lsso não apenas 
economiza muito trabalho durante a escrita de Mnpendores de Dados (170) como 
também permite o uso de um Bloqueio fmplícito (422) para evitar que um desenvolvedor 
estrague uma estratégia de bloqueio esquecendo de codificar uma parte dos mecanismos 
de bloqueio. 

A primeira parte a ser movida para seu mapcador abstrato é a construção SQL. 
fsso requer que você forneça mapeadores com um pouco de metadados sobre suas 
tabelas. Uma alternativa ao mapeador para construir SQL em tempo de execução é 
gerc1-lo com código. Entretanto, deixarei a construção de declarações SQL como um 
exercício para o leitor. No mapeador abstrato abaixo, você verá que fiz algumas suposições 
sobre os nomes das colunas e posições de nossos dados para modificação. 
Isso se torna menos factível com dados legados. O mapeador abstrato irá provavelmente 
requerer que um pouco de metadados de colunas seja fornecido por cada mapcador 
conc1·cto. 

Uma vez que o mapeador abstrato tenha declarações SQL, pode gerenciar as 
operações CRUD. Aqui está como um método de busca é executado: 

class f.!apeadorAbstrato . .. 

public MapeadorAbstrato (String tabela, String () colunas) { 
thie.tabela = tabela; 
this.colunas =colunas; 
criarDeclarações( ); 

public ObjetoDoDominio buscar (Long idl 

ObjetoDoDoolinio obj =GerenciadorDeSessãoDeAplicação.lerSessão{ ).lerHapaDelàentidadel l.ler(1d); 

if (obj == nulll { 

Connection con = null; 

?reparedStacement dec = nul l; 

ResultSet rs = null; 

try ( 

con =connection.".anager,INSTANCE.getconnectionl , : 

dec = con.prepareStatementlSQLCarregar); 

dec.setLong(l, id.longValuel )l; 

rs = dec.executeQuery( ); 

if (rs.next( )l ( 

obj = carregar(id, rsl; 

String modificado?or = rs.getString (colunas.length 4 2); 

Tittesc.mp 00dificado = rs.getTimestarop(colunas.length • 1); 

int versão = rs.getlnt (col unas.length + 4); 

obj.gravacamposSistemaíioodificado, modificadoPor, versão); 

GerenciadorOeSessãoDeAplícaçào.lerSessào( ).lerHapaDeidentidadel ).grava(objl; 

} else ( 

throw new SystemExcept ion (tabela t • • , id t • não existe'); 

} 

} catch (SQLSxception sqlEx) ( 
throw newSystemException(•erro não esperado buscando•+ tabela+• ~ -idl; 
} finally { 
liberaRecursosBD lrs, coo, dec); 


398 PARTE li • Os PADRÕES 

retum obj; 

protected abstract ObjetoDoOOffl!nio carregar ltong id, ResultSet rs) throws SQLException; 

Há alguns itens a perceber aqui. Primeiro, o mapeador verifica um Mapa de 
Identidade (196) para se assegurar de que o objeto já não está carregado. Não usar um 
Mapa de Identidade (196), poderia resultar em versões diferentes de um objeto sendo 
carregadas em momentos diferentes em uma transação de negócio, levando a comportamento 
indefinido na sua aplicação, assim como criando uma confusão em qualquer 
verificação de versão. Assim que o conjunto resultante seja obtido, o mapeador 
transfere pélra um método abstrato de carga que cada mapeador concreto deve implementar 
para extrair seus campos e retornar um objeto ativado. O mapeador chama 
gravarCamposDeSiystema I l para gnwar a versão e os dados de modificação do objeto 
do domínio abstrnto. Embora um construtor pudesse parecer o meio mais apropriado 
de passar estes dados, fazer assim empurraria parte da responsabilidade pelo 
armazenamento da versão para cada mapeador concreto e objeto do domínio e 
dessa forma enfraqueceria o Bloqueio Implícito (422). 

Aqui este\ como um método carregar( ) concreto se parece: 

class MapeadorDeCliente extends MapeadorAbGtrato... 

protecteà ObjetoOoDomínio carregar(Long id, Resu!tSet rs) thro~s SQLException { 
String nome = rs.getString(2); 
return Clíente.ativar(id, OQCte, endereços); 

O mapeador abstrato irá gerenciar de maneira semelhante a execução das operações 
de atualização e exclusão. O trabalho aqui é verificar que a operação do banco 
de dados retorne um contador de linha igual a um. Se nenhuma linha tiver sido 
atualizada, o bloqueio otimista não pode ser obtido, e o mapeador precisa então levantar 
uma exceção de concorrência. Aqui está a operação de exclusão; 

class NapeadorAbstrato ... 

public void apagar(ObjetoDoOomínio objeto) 
GerenciadorDeSessãoOeAplicação.lerSessAol }.lerMapaDe!dentidade() .remove(objeto.lerrd( I); 
Connection con = null; 
PreparedStatement dec = null; 

t:y ( 
con = ConneccionManager,HISTANCE.getConnectionl ); 
d~c = con.prepareStatement{SOLExcluir); 
dec.setLon911, oõjeto.lerld( ) .longValue( li; 
int contLinha = dec.executeOpdate( I; 
if (contLinha = O) ( 
dispararExceçàoDeConcorrência (objeto); 

j 

} catch (SQLBxception e ) { 
throw ne~ SystemException (•erro inesperado na exclusãoft)i 
} finally { 
liberaRecursosBD {con, dec); 


C'.APiTULO 16 • PADRÕES OE CONCORRÊNCIA 0FFLJNE 399 

protecced void dispararExceçãoDeConcorrência (ObjecoDoDocíni.o objeto) chrows SQLException { 

Connection con = null; 

PreparedStatement dec = nu.11; 

ResultSet rs = null; 

try { 

con:: ConnectionManager.INSTANCE.getConnection l l ; 

dec = con.prepareStatement{SQLVerificaVersào); 

dec.setint(l, lint) objeto.lerid( J.longValue( I); 

rs =dec.executeQuery( \; 

H (rs.next ( ) 1 1 

int versão= rs.getlnt(l)i 

String modificadoPor =rs.getString(2); 

1'ímestai:;p modificado = rs.getTímestamp(3}; 

1E (versão> objeto.lerVersãol 1) l 

String quando= DatePormat.9etDat~Ti111elnstance( 1.format(modificado); 

throll' new ConcurrencyException (tabela t • • ➔ objeto.lerldl) 


• ::iodificada por•• modificadoPor ~ •em• 
➔ quando}; 
} else { 
throw new SystemException('erro inesperado ao checar o cimestar..p"); 

l 

} else { 
throll' ne. ConcurrencyBxcception(tabela t • • +objeto.lerid( } • 

• !oi apagado•); 
} 
) finally 1 
liberaRecursosBD (rs, COill, dec); 

A decfaração SQL usada para verificar a versão em uma exceção de concorrência 
também precisa ser conhecida pelo mapeador abstrato. Seu mapeador deveria 
construí-la quando constrói o SQL CRUD. Ela se parecerá com algo assim: 

SQLdeVeri ficaçàoDeVersão. .. 

SELECT versão, modificadoPor, modificado FROM cliente WHERE id ,; ? 

Este código não dá uma idéia perfeita das diversas partes executando por meio 
de diversas transações de sistema dentro de uma única transação de negócio. O mais 
importante a lembrar é que a aquisição de Bloqueios Offline Otimistas deve ocorrer 
dentro da mesma transação de sistema em que ocorre a confirmação das suas alterações 
para manter a consistência dos dados gravados. Com a verüicação embutida 
nas declarações UPDATE e DELETE, isso não será um problema. 

Dê uma olhada no uso de um objeto versão no código exemplo de Bloqueio de 
Grnn11/nridndc Altn (412). Embora Bloqueio de Grmwlnridade Alta (412) possa resolver 
éllguns problemas de leitura inconsistente, um simples objeto versão não compartilhado 
pode ajudar a detectar leituras inconsistentes porque é um lugar conveniente 
para acrescentar comportamento de verificação otimista como incremencar ( ) ou verificarSeAVersàoÉAMaisRecente 
( ) . Aqui está uma Unidade de Trabnlho (187) na qual adicionamos 
verificações de leitura consistente no nosso processo de confirmação de gra~ 
vação, por meio da medida m<1is drástica de incrementar a versão, porque não sabemos 
qual o nível de isolamento: 


400 PARTE li • Os PADRÕES 

class UnidadeDeTrabalho.. . 

private List leituras= new ArrayList l I; 
public void registrarLeitura {ObjetoOoDom!nio objeto) 
leituras.add(objetol; 

public void confirmar < 1 { 

try { 
verificarLeiturasConsistentes( ); 
inserírNovo( ) ; 
excluirRemovido( ); 
atualizarSujol ); 

) catch (ConcurrencyException el { 
desfazTransaçàoDeSistema ( >; 
throw e; 

public void verificarLeiturasConsistentes() 

for (Iterator iterator = leituras.iteratorl I; iterator.hasNext l )) 
ObjetoDoOomínio dependente= IObjetoOoDomínio) iterator.next( ): 
dependence.lerVersàol ).incrementar( I; 

Perceba que a Unidade de Trabalho (184) desfaz a transação de sistema quando 
detecta urna violação de concorrência. Você provavelmente decidiria desfazer a transação 
se houvesse qualquer exceção durante a confirmação. Não esqueça este passo! 
Como alternativa a objetos versão, você pode adicionar verificações de versão à sua 
interface mapeadora. 


C'.APiTULO 16 • PADRÕES OE CONCORRÊNCIA 0FFLJNE 401 

Bloqueio Offline Pessimista {Pessimistic Offline Lock) 

por David Rice 

Pr(!Ui11e co11flitos entre transações de llegócio concorrentes permitindo 
que npenns 11111n lr011snçào de negócio acesse os dados de cada vn.. 

Sessão do Martin Banco de Dados Sessão do David 

r-1---------L.


I lerdiente (129) : 1 

1 1-----~ 1 

Limite da 
1 1 Transação 
1 ------------1 
de Sistema 
l ~tom~clie~129 _ J_ _! ,,/ 
1 ,,/' 
1 /
--;----ó--p 
1 1 
~;;..._-----l 
/ 
/ 
1 lerCliente (129) 

/ 1 
Limite da 1 ler,o: cliente bloqueado 
Transação 1 1 
de Negócio editar cliente ---1------1 
1 
1 
1 
1 
1 
1 
1 

Já que a concorrência offline envolve manipufação de dados para uma transação de 

negócio que perdura por diversas solicitações, a abordagem mais simples pareceria 
ser a de ter uma transação de sistema aberta durante toda a transação de negócio. Infelizmente, 
isso não funciona sempre bem porque sistemas de transações não são • 
equ.ipados para trabalhar com trnns;1ções longas. Por essa razão, você tem que usar 
diversas transações de sistema, em que você fica por conta própria para gerenciar o 
acesso concorrente aos seus dados. 

A primeira abordagem a tentar é o Bloqueio Ofj1ine Otimista (392). Entretanto, esse 
padrão tem seus problemas. Se diversas pessoas acessarem os mesmos dados dentro 
de uma transação de negócio, uma delas confirmará a gravação com facilidade, 
mas as outras entrarão em conflito e falharão. Como o conflito só é detectado no final. 
da transação de negócio, as vítimas farão todo o trabalho da transação apenas para 
descobrir no último minuto que tudo falhará e seu tempo terá sido desperdiçado. 
Se isso acontecer, com muita freqüência em transações de negócio longas, o sistema 
logo se tomará bastante impopular. 


402 PARTE li • Os PAORÕES 

O Bloqueio Offline Pessimista previne conflitos evitando-os completamente. Ele 
força uma transação de negócio a obter um bloqueio sobre um fragmento de dados 
antes de começar a usá-lo, de modo que, m, maior parte do tempo, assim que você 
começa uma transação de 11egócio, pode ter bastante certeza de que irá completá-la 
sem ser interrompido pelo controle de concorrência. 

Como Funciona 

Você implementa o Bloqueio 0/fline Pessimista em três fases: determinando de 
que tipo de bloqueios precisa, criando um gerenciador de bloqueios e definindo procedimentos 
pa_rn umtl transação de negócios pa_ra usar os bloqueios. Além disso, se 
você estiver usando Bloqueio Offline Pessimista como complemento para o Bloqueio OJfline 
Otimista (392), precisa determinM q\tais tipos de registros bloquear. 

Em relação aos tipos de bloqueios, a primeira opção é um bloqueio exclusivo 
de gravação, que requer apenas que uma transação de negócios obtenha um bloqueio 
para editar dados da sessão. Isso evita conflito por não permitir que duas 
b·ansações de negócio façam alterações no mesmo registro, ao mesmo tempo. O que 
este esquema de bloqueio ignora é a leitura dos dndos, de modo que se não for crucial 
que urna sessão de visualização tenha os dados mais recentes, esta estratégia será 
suficiente. 

Se for muito importante que uma tra1,sação de negócio tenha sempre os dados 
mais recentes, independentemente de suas intenções de editá-los, use o bloqueio exclusivo 
de leitura. Este requer que uma transação de negócio obtenha um bloqueio 
simplesmente para carregar o registro. Tal estrRtégia tem claramente o potencial de 
restringir severamente a concorrência de um sistema. Na maioria das aplicações corporativas, 
o bloqueio exclusivo de gravação vai permitir muito mais acesso concorrente 
aos registros do que este tipo de bloqueio. 

Uma terceira esb·atégia combina os dois tipos para fornecer o bloqueio restritivo 
do bloqueio exclusivo de leitura, assim como o c1wnento de concorrência do bloqueio 
exclusivo de gravação. Chamado de bloqueio de leitura/gravação, é um pouco 
mais complexo do que os dois primeiros. O reladonamento dos bloqueios de leitura 
e de gravação é a chave para obter o melhor dos dois mundos: 

• Bloqueios de leitura e de gravação são mutuamente exclusivos. Um registro 
não pode ser bloqueado para grnvação se alguma outra transação de negócio 
possuir um bloqueio de leitura nele. Ele não pode ser bloqueado para gravação 
se alguma outra trMsação de negócio possuir um bloqueio de gravação 
nele. 
• Bloqueios de leitura concorrentes são aceitáveis. A existência de um único 
bloqueio de leitura evita que alguma transação de negócio edite o registro, 
então não há mal cm permitir qut1lquer número de sessões como leitores, 
uma vez que uma delas tenha recebido permissão de leiturn. 
Pemutir diversos bloqueios de lei tum é o que aumenta a concorrência do sistema. 
O aspecto negativo deste esquema é que é um pouco desagradável de implementar 
e apresenta mais desafios para os especialistas no domínio se preocuparem 
quando estiverem modelando o sistema. 

Durante a escolha do tipo correto de bloqueio, pense em maxirnfaar a concorrência 
do sistema, satisfazer às necessidades do sistema e minimizM a complexidade 


CAl'ituLO 16 • PADRÕES OE CONCORR{NCIA ÔFFUNE 403 

docódigo. Tenha em mente também que a estratégia de bloqueio deve sei-compreendida 
pelos analistas e modeladores do domínio. O bloqueio não é só um problema 
técnico. O Hpo errado de bloqueio, simplesmente bloqueando todos os registros, ou 
bloquear os tipos errados de registros pode resultar em uma estrat~gia de Bloqueio 
Offli11e Pessimistn ineficaz. Uma estratégia de Bloqueio Offline P<!ssimisfa iJ,eficaz não 
evita conflitos no começo da transação de negócio ou degrada a concorrência de seu 
sistema multiusuário de tal maneira que ele pareça mais como umsistema monousuário. 
A estratégia de bloqueio errada não pode ser salva por uma implementação 
técnica apropriada. Na verdade, não é uma má idéia incluir o Bloqueio Olfline Pessimista 
noseumodelo de domínio. 

Assim que você tiver decidido seu tipo de bloqueio, defina seu gerenciador de 
bloqueios. O trnbalho do gerenciador de bloqueio é dar ou negar qualquer solicitação 
de uma transação de negócio parn obter ou liberar um bloqueio. Para executar 
seu trabalho, ele precisa saber o que está sendo bloqueado, assim como o pretenden~ 
te a dono do bloqueio -a transaç,io de negócio. É bastante possível que o seu conceito 
de uma transação de negócio não seja alguma coisa que possa Sér identificada de 
forma únka, o que toma um pouco difícil passar tuna transação de negócio para o 
gerenciador de bloqueios. Neste caso, considere seu conceito de uma sessão, já que é 
mais provável que você tenha um objeto de sessão à sua disposição. Os termos "sessão" 
e "transação de negócio" são razoavelmente intercambiáveis. Desde que as 
transações de negócio sejam executadas serial.mente der'ltto de uma sessão, esta sessão 
ficará bem como dona de um Bloqueio Offli11e Pessimista. O código exemplo deve 
lançar alguma luz sobre essa idéia. 

O gerenciador de bloqueios não deve consistir de muito mais do que uma tabela 
que mapeia os bloqueios a seu donos. Um gerenciador de bloqueios simples poderia 
envolver uma tabela hasll na memória ou poderia ser uma tabela de bélnco de 
dados.Não importa qual, mas você deve ter uma e apenas urna tabela de bloqueios, 
então, se ela estiver na memória, assegure-se de usar umsingleton [Gang ofFourJ. Se 

o seu servidor de apJicação for distribuído em clusters, uma tabela de bloqueios na 
memória não funcionará, a menos que seja restrita a uma única instância no servidor. 
O gerenciador de bloqueios baseado embanco de dados é provavelmente mais apropriado 
uma vez que você esteja cm tm, ambiente que use um servidor de aplicação 
distribuído em clusters. 
O bloqueio, quer seja implementado como um objeto ou como um SQL sobre 
uma tabela de banco de dados, deve permanecer privado para o gerenciador de bloqueios. 
Transações de negócio devem interagir apenas com o gerenciador de bloqueios1 
nunca com um objeto de bloqueio. 

Agorn é hora de definir o protocolo de acordo com o qual um;i transação de negócio 
deve usar o gerenciador de bloqueios. Este protocolo deve incluir o que bloquear 
e quando, quando liberar um bloqueio e como agir quando um bloqueio não 
puder ser obtido. 

O que bloquear depende de quando bloquear, então vejamos o quando primeiro. 
Geralmente, a transação de negócio deve obter um bloqueio antes de carregar os 
dados, pois não há por que obter um bloqueio sem uma garantia de que você terá a 
versão mais recente do item bloqueado. JA que estamos obtendo bloqueios dentro de 
uma transação de sistema, há circWlstàncias e.m que a ordem do bloqueio e da carga 
não importará. Dependendo do tipo do seu bloqueio, se você estiver usando transações 
de leitura repeti veis ou serializáveis, a ordem na quaJ você carrega objetos e obtém 
bloqueios pode não importar. Uma opção é executar uma verificação otimista so



404 PARTE li • Os PADRÕES 

bre um item c1pós obter o Bloq11eio Offline Pessimista. Você deve estar bc1stante seguro 
de que tem a versão mais recente de um objeto após tê-lo bloqueado, o que geralmente 
se traduz na obtenção do bloqueio antes de carregar os dados. 

Agora, o que estamos bloqueando? Parece que estamos bloqueando objetos ou 
registros ou apenas quase tudo, ma o quegeralmente bloqueamos é realmente o IO, 
ou a chave primária, que usamos para buscar esses objetos. Isso nos permite obter o 
bloqueio antes de carregá-los. Bloquear o objeto funciona bem desde que não o obrigue 
a quebrar a regra de que um objeto seja a versão mais atual após você obter seu 
bloqueio. 

A regra mais simples para liberar bloqueios é fazê-lo quando a transação de negócio 
for completada. LiberaJ· um bloqueio antes disso poderia ser admissível, dependendo 
do seu tipo de bloqueio e da sua intenção de usar esse objeto novamente 
dentro da transação. Ainda assim, a menos que você tenha uma razão muito específica 
pru·a liberar prematuramente o bloqueio, tal como algum problema especialmente 
desagradável de capacidade de resposta do sistema, continue executando a liberação 
no momento da conclusão da transação de negócio. 

A ação mais fácil para uma transação de negócio que nãoconsiga obter umbloqueio 
é abortá-la. O usuário deveria achar isso aceitável, já que o Bloq11eio Offline l'essimista 
deveria resultar em falha bem antes na transRção. O desenvolvedor e o projetista 
podem certamente ajudar nessa situação, não esperando até tarde na transação 
para obter um bloqueio especialmente disputado. Se for possível, obtenha todos os 
seus bloqueios antes de o usuário começar a trabalhar. 

Parn qualquer determinado item que você pretenda bloquear, o acesso à tabela 
de bloqueios deve ser seriali.zado. Com uma tabela de bloqueios na memória é 
mais fácil serializar o acesso ao gerenciador de bloqueios inteiro com qualquer 
construção que sua Linguagem de programação fornecer. Se você precisar de maior 
concorrência do que isso permite, esteja ciente de que está entrando em um território 
complexo. 

Se a tabela de bloqueios for armazenada em um bí'lnco de dados, a primeira regra, 
é claro, é interagir com ela dentro de uma transação de sistema. Tire todo o proveito 
das capacidades de serialização que um banco de dados fornece. Com os bloqueios 
exclusivo de leitura e exclusivo de gravação, a serialização é uma simples 
questão de fazer o bnnco de dados reforçar uma restrição de unicidade na coluna que 
armazena o 1D do item bloqueável. Armazenar bloqueios de leitura/gravação em 
um banco de dados torna as coisas um pouco mais difíceis, já que a lógica requer leituras 
da tabela de bloqueios além de inserções e desta maneira se torna imperativo 
evitar leituras inconsistentes. Uma transação de sistema com um nível de isolamento 
de scrialização fornece a maior segurança, já que garante que não há leitw-as inconsistentes. 
Usar trnnsações seriaUzáveis por todo o nosso sistema poderia nos trazer 
problcm<1s de desempenho, mas uma tr;rnsação de sistema scrializável separad<1 
pMa obtenção de bloqueios e um nível de isolamento menos rígido para outro uso 
poderia aliviar este problema. Outra opção é investigar se um procedimento armazenado 
poderia ajudar no gerenciamento de bloqueios. O gerenciamento de concorrência 
pode ser difícil, então não tenha receio de transferi-lo para seu banco de dados em 
momentos críticos. 

A natureza serial do gerenciamento de bloqueios anuncia um gargalo de desempenho. 
Uma considernção importante aqui é a grnnularidí'lde do bloqueio, já que 
quanto menos bJoqueios requeridos, menor o gaigalo que você terá. Um Bloqueio de 
Grnn11laridadc Alta (412) podecuidar dí'I disputa pela tabelí'I de bloqueios. 


úJ>ituLO 16 • PADRÕES OE CONCORRÊNCIA ÔFFLJNE 405 

Com um esquema de bloqueio pessimista de transações de sistema, como "SELECT 
FOR UPDATE... " ou EJBs de entidade, deadlocks são uma possibilidade que 
n~o pode ser ignorada, pois estes mecanismos de bloqueio irão esperar até que um 
bloqueio se tome disponível. Pense em um deadlock dessa fotma. Dois usuários precisam 
dos recursos A e B. Se um obtém o bloqueio de A e o outro o de B, ambas as 
transações poderiam esperar para sempre pelo outro bloqueio. Considerando que estamos 
perdw·ando por diversas transações de sistema, esperar por um bloqueio não 
faz muito sentido, especialmente porque uma transação de negócio poderia durar 20 
minutos. Ninguém quer esperar por esses bloqueios. E isto é bom, porque codificar 
uma espera envolve fimeouls e logo se torna complicado. Sjmplesmente faça com que 
seu gerenciador de bloqueios levante uma exceção assim que um bloqueio esteja indisponível. 
Isto elimina o fardo de lidar com dend/ocks. 

Um requisito final é gerenciar ti111eo11ts dos bloqueios de sessões perdidas. Se 
uma máquina cliente pára de funcionar no meio de uma transação, essa transação 
perdjda não consegue ser concluída e nem liberar seus bloqueios obtidos. Isso é algo 
sério em uma aplicação Web na qual sessões são abandonadas regularmente pelos 
usuários. O ideal é você ter um meca,úsmo de ti111eo11f gerenciado pelo seu se,vidor 
de aplicação, em vez de fazer com que sua aplicação trate timeouts. Servidores 
de aplicações Web fornecem uma sessão HTTP para isso. Os fimcouts podem ser 
implementados registrando um objeto utilitário que Ubera todos os bloqueios 
quando a sessão HTTP se torna inválida. Outra opção é associar um timestanip a cada 
bloqueio e considerar inválido qualquer bloqueio mais velho que uma determinada 
idade. 

Quando Usá-lo 

O 8loqueio Ojfline Pessimista é apropriado quando a chance de conflitos entre sessões 
concorl'entes for alta. Um usuário nunca deveria ter que jogar trabalho fora. Bloquear 
também é apropriado quando o custo de um conflito for alto demais independentemente 
de sua probabilidade. Bloquear cada entidade de umsistema quase que certamente 
criará grandes problemas de disputa de dados, então lembre-se de que o Bloqueio 
Offli11e Pessimisfn é bastante complementar ao Bloqueio Offlim: Otimista (392) e só 
use o Bloq11eio Offli11e f>cssimista quando for realmente necessário. 

Se você tiver que usar o Bloqueio Ojflinc Pessimista, deveria também considerar 
uma transação longa. Transações longas nunca são boas, r:nas em algumas situações 
elas podem não ser mais prejudiciais do que o Bloqueio Offline Pessimista e muHo mais 
fáceis de programar. Faça algum teste de cai·ga antes de d~cidir. 

Não use estas técnicas se as suas transações de negócio couberem dentro de 
uma transação de sistema. Muitas técnicas de bloqueio pessimista de transações de 
sistema já estão nos servidores de apliec1ções e de banco de dados que você já está 
usando, entre eles a declaração SQL "SELECT FOR UPOA TE" para bloqueio de banco 
de dados e o 8TBde entidade para bloqueio de servidor de aplicações. Por que se 
preocupar com timeo11ts, visibilidade de bloqueio e coisas desse tipo, quando não há 
necessidade? Compreender esses tipos de bloqueios pode com certeza agregar m uito 
valor à sua implementação de Bloqueio Offline Pessimista. Compreenda, entretanto, 
que o inverso não é verdadeiro! O que você leu aqui não irá lhe preparar para escrever 
um monitor de transações ou gerenciador de banco de dados. Todas as técnicas 
de bloqueio ofjline apresentadas neste livro dependem do seu sistema ter um monitor 
de transações real próprio. 


406 PARTE li • Os PAORÕES 

Exemplo: Gerenciador de Bloqueios Simples (Java) 

Neste exemplo, iremos primeiro construir um gerenciador de bloqueios para bloqueios 
exclusivos de leitura -lembre-se de que você precisa destes bloqueios para 
ler ou editar um objeto. Demonstraremos então como o gerenciador de bloqueios 
poderia ser usado em uma transação de negócios que perdura diversas transações 
de sistema. 

O primeiro passo é definir a interface do nosso gerenciador de bloqueios. 

interface GerenciadorDeBloqueiosExclusivosDeleitura . . . 

public stacic final GerenciadorDeBloqueiosExclusivosDeLeicura !NSTA?lCE = 
(GerenciadorDeBloqueíosExclusivosDeLeítura) 

Plugins.getPlugin(GerenciadorDeBloqueiosExclusivosDeLeitura.class); 
publíc void obterBloqueio (Long bloque~vel, String dono) thro~s ConcurrencyEx~ption; 
public voià liberarBloqueio (Long bloqueável, String dono); 
public void liberatrodosBloqueios (String dono); 

Perceba que estamos identificando bloqueável com o tipo longe o dono como 
sll'i11g. Bloqueável é do tipo long porque cada tabela .no nosso banco de dados usa uma 
chave primária desse tipo que é única em todo o sistema e, desta maneira, serve como 
um bom 1D bloqueável (que deve ser único por todos os tipos manipulados pele\ 
tabela de bloqueios). O 10 do dono é uma string porque o exemplo será uma aplicação 
Web, e o TO da sessão HTTP é um bom dono de bloqueio dentro dela. 

Escreveremos um gerenciador de bloqueios que interage diretamente com uma 
tabela de bloqueios nonosso banco de dados, em vez de com um objeto de bloqueio. 
Perceba que esta é a nossa própria tabela chamada bloqueio, como qualquer tabela de 
aplicação, e não parte do mecanismo interno de bloqueio do banco de dados. Obter 
um bloqueio é uma questão de inserir com sucesso um<1 linha na tilbela de bloqueios. 
Liberá-lo é uma questão de apagar essa Jjnha. Aqui está o esquema para a tabela de 
bloqueios e parte da implementação do gerenciador de bloqueios: 

tabela bloqueio.. . 

create table bloqueio (idBloqueável bigint primary key, ídDono bigint) 

class ImplementaçàoBDGereneiadorDeBloqueiosExclusívosOeLeitura 
implementa GerenciadorDeBloqueiosExclusivos ... 

privace static final String SQL_HISERIR = 

•insert inco bloqueio values(?, ?)•; 
privace static fi.nal String SQL_BXCLU:R_UlHCO = 
"delete from bloqueio where idBloqu.eável =? and id.Dono = ?"r 
private static final String SQL_EXCLUIR_TOOOS = 

•delete from bloqueio where idDono =?•; 
private static final String SQL_VERl FlCAR = 
•select idBloq\leável frOO'I bloqueio ~here idBloqueável =? anà idDono = ?"; 
public void obterBloqueio ILong bloqueável, String dono) throws ConcurrencyException { 
1f (1 tet:\Bloqueio(bloqueável, dono)) { 
Cônnection con = null ; 
PreparedStateirent dec = null; 
try { 

con = Conneetion.~anager.INSTANCE.getConneetion( I; 
det = con.prepareStatement (SQL_INSERIR): 


CAPilULO 16 • PADRÕES OE CONCORRÊNCIA 0FFUNE 407 

dec.setl.ong(l, bloqueável.longValue( )); 

dec.setString(2, dono)1 

dec.executeUpdate() ; 

) catcb {SQLEXception sqlEx) 

thro~ new ConcurrencyExceptíon(•não foí possível bloquear"+ bloqueável!; 

} finally { 

liberaRecursosBD (con, dec); 

public void liberarBloqueio (Long bloqueável, String doru>I 

Connection con: null; 

PreparedStatement dec: null; 

cry { 

con = connectionManager.INSTA.NCE.getConnection( 1; 

dec = con.prepareStatement(SQL_EXCLUIR_UNIOO); 

dec.setl.ong(l, bloqueável.longValue{ )); 

dec.setString (2, dono>; 

dec.executeUpdate t 1; 

} catch (SQLBXception sqlBx) 

thro~ new SystemException(•erro inesperado ao liberar bloqueio sobre •• bloqueável): 

) finally 1 

liberaRecursosBD (con, dec); 

O método público liberarTodosBlogueios( ) e o método privado tetnBloqueio( } 
não são mostrados no gerenciador de bloqueios. O método liberar1'oàos!loqueios ( } 
faz exatamente o que seu nome dá a entender e libera todos os bloqueios de um dono. 
O método temBloqueio( 1consulta o banco de dados para verificar se um dono já 
possui um bloqueio. Não é incomum que um código de sessão tente obter um bloq 
ueio que ele já possui. Isso significa que obterBloqueio( l deve primeiro verificar se o 
dono já não tem o bloqueio antes de tentar inserir a linha de bloqueio. Como a tabela 
de bloqueios é geralmente um ponto de disputa de 1-ecw·sos, estas leituras repetitivas 
podem degradar o desempenho da aplicação. Pode ser necessário que você coloque 
em memória cache bloqueios que já foram obtidos em nível de sessão para verificação 
de propriedade. Tenha cuidado ao fazer isso. 

Agora Íl'emos montar urna aplicação Web simples para realizar a manutenção 
de registros dos clientes. Primeiro, estabeleceremos um pouco de infra-esb."utura para 
facilitar o processamento da transação de negócio. Alguns conceitos de uma sessão 
de usuário serão necessários para as camadas abaixo da camada Web, de modo 
que não poderemos depender apenas da sessão HTTP. Vamos nos referir a essa novn 
sessão como a sessão de aplicação para distingui-la da sessão HTTP. Sessões de aplicação 
armazenarão seus fDs, Ltm nome de usuário e um Mnpn de Identidade (196) para 
colocar emmemória cache os objetos carregados ou criados durante a transação de 
negócio. Eles serão associados à thrend correntemente cm execução para que sejam 
encontrados. 

class SessàoDeAplicação... 

private String usuário; 
private String id; 


408 PARTE li • Os PAORÕES 

privac.e MapaDeidentidade mpidentidade; 

public SessãoDeAplicação !String usuário, String ià, MapaDeidentídaàe ~.pidencidade) { 
this.usuãrío ~ usuário; 
this.mpldentidade = mpidentidade; 
this.id = id; 

class GerenciadorOeSessàoDeAplicaçào. . . 

private static ThreadLocal atual"' new ThreadLocal l )1 
public static SessãoOeAplicaçào lersessão( ) 1 
return (SessàoDeAplicaçào) atual.getl l; 

public static void gravarSessão (SessãoOeApiicaçào sessão) 
atual.set(sessàol; 

Iremos usar um Controlador Frontal (328) para lidar com as solicitações, de modo 
que precisaremos definir um comando. A primeira coisa que cada comando deve 
fazer é indicar a sua intenção de iniciar uma nova transação de negócio ou continuar 
uma que já exista. Isso é uma questão de estabelecer uma nova sessão de aplicação 
ou encontrar a atual. Aqui temos um comando abstrato que fornece métodos con e~ 
1\ientes para estabelecer o contexto da transação de negócio. 

interface COll:ando... 

public void init(HttpServle:Request solicitação, HttpServletResponse resposta); 
public void processar() thro-ds Exception; 

abstract class ComandoDeTransaçãoOelleg6do irr.ple".ents Comando.. , 

public void init (HttpServletRequest solicitação, HttpServletResponse resposta) 
this.solicitação = solicitação; 
this.resposta = resposta; 

protected void iniciarNovaTransaçãoDeNeg6cio () 
HttpSession sessàoHttp = lerSolicitaçào( ).getSession(truel; 
SessàoDeAplicação sessãoDeAplicação = (SessãoOeAplicação) sessãoRttp.getAttributelAPP_SESSION); 
íf (sessãoDeAplicaçào != null) ( 

GerenciadorDeBloqueiosExdusivosDeLeitura.Il!STANCE.liberarTodosBloqueioe 
{sessãoOeAplicaçào.getidl ))1 

sessãoDeAplicação ~ new sessãoOeAplicaçào(lerSolicitação() .gecRemoteOser( ), 

sessàoHttp.getld( ), new MapaDeldentidade( ))~ 
GerenciadorDeSessàoOeAplicaçào.gravarSeseão(sessàoDeAplicação); 
sessãoHttp. setAttr::.bute (APP_SESSIO?I, sessâoDeAplicaçâo); 
sessãoHttp.setAttríbute(U>CK_REMOVER, 

new RerovedorDeBloqueio(sessàoDeAplicação.getlD( J)}; 

} 

protecteâ void continuarTransaçào~legócio( ) ( 
HttpSession sessàoHttp = lerSolicitação() .getSession( 1; 
SessãoOeAplicação sessãoDeAplicaçào = (SessãoDeAplicação) sessãoHttp.getAttributelAPP_SESSIO.~); 
GerenciadorOeSessãoDeAplicação.gravarSessào(sessãoDeAplicação); 

protected HttpServletRequest lerSolicitação () { 
return solicitação; 


CAPilULO 1 6 • PADRÕES OE: CONCORRENCIA 0FFUNE 409 

protecceó HttpServletResponse lerResposta ( 1 ( 
return resposta; 

Perceba que, quando estabelecemos uma nova sessão de aplicação, removemos 
os bloqueios de qualquer uma existente. Também adicionamos um listener para os 
eventos associados à sessão HTTP que removerão quaisquer bloqueios possuídos 
por uma sessão de aplicação quando a sessão HTIP correspondente éxpirar. 

class P.emovedorDeBloqueios imple~ents RttpSessionBindin9~istener... 

private String idSessào; 
public RemovedorDe8loqueios {String idSessão} 
this.idSessão = idSessào; 

public void valorSolto (BctpSeasionBindingEvent evento) 

try ( 
iniciarTransaçàoDeSistema() ; 
GerenciadorDe.BloqueiosExclusivosDeLeitura.INSTANCE.liberarTodosBloqueios(this.idSessâo) ; 
confirmarTransaçãoDeSistema( ); 

) eateh (Bxeeption e) ( 
tratarErrOSério(el: 

Nossos comandos contêm tanto Jógic.a de negócio padrão quanto gerenciamento 
de bloqueio, e cadc1 comando deve ser executado dentro dos limites de urna única 
transação de sistema. Para garantirmos isso, podemos decorá-lo (Gang of Fourl com 
um objeto comando transacional. Assegme-se de que todo o bloqueio e negócio de 
domínio padrão ocorram dentro de uma única transação de sistema. Os métodos que 
definem os limites da transação de sistema dependem do seu contexto de distribuição. 
É obrigatório desfuzer a transação do sistema quando uma exceção de concorrência, 
ou qualquer outra exceção for detectada, pois isso irá evitar que quaisquer alterações 
sejam inseridas nos dados permanentes quando um conflito ocorre. 

class ComandoTransacional implemenrs Canando... 

public ComandoTransacional /Comando irr;pl) 
tbis.impl = impl; 

public void processar( ) thra..s Exception f 
iniciar:TransaçãoDeSistema( ): 
try { 

impl.processar( ); 
confirmarTransaçâoDeSiscema ( ) ; 

) catch (Bxception e) ( 
desfazerTransaçàoDeSiste~af I; 
throw e; 


41 0 PARTE li • Os PAORÕES 

Agora é uma questão de escrever o servlel controlador e os comandos concretos. 
O servlet controlador tem a responsabilidade de encapsular cada comando com um 
controle de transação. Os comandos concretos devem estabelecer o contexto da transação 
de negócio, executar lógica de domínio e obter e liberar bloqueios onde for 
apropriado. 

class Servl!tControlador extends HttpServlet .. . 

protected void doGet (HttpServletRequest solicitação, HttpServletResponse resposta} 
throws ServletException, IOException { 

try ( 
String noreeDoComando solicitação.getParaffieter("comando•) ; 
Comando com = lerC-0mando(noceoocomandol ; 
comando.inic(solicitaçào. resposta); 
comando.processar( 1; 

) catch (Exception e) { 
gravarExceção(e, resposta.getWriter( I); 

private Comando lerComandos (String nort.e) 

try { 
String nomeDaClasse: (String) comandos.get(nome)1 
Comando com: (Cocnando) Class.forNametnomeDaClasse) .oe.•Instance( l; 
return new ComandoTransacional Ccoml ; 

) catch (Exception e) { 
e.printStackTracel) ; 
thrw new SystemException (•não foi possível criar objeto comando para~ • noir.el ; 

class ComandoEditarCliente extends Canando TransaçãoDeNeg6cio.. . 

public void processar () throws Exception { 
iniciarNovaTransacãoDeNegócio( ) ; 
Long idCliente = new Lor.g(lerSolicitação( ) .get?arameter(•i.d_cliente•t; 
GerenciadorDeBloqueiosBxclusivosOeLeitura. INSTAflCE.obterBloqueiol 

idCliente, GerenciadorDeSessãoDeAplicação.lerSessàol l .getld( I) ; 
Mapeador mapeadorDeCliente = RegistroMapeador.INSTAllCE.lerMapeador(Cliente.class): 
Cliente cliente= (Cliente) mapeadorOeCliente.buscar(idCliente); 
lerSolicitação( ).lerSessàol) .setAttribute(•cliente', cliente); 
forward (·/editarcliente. jsp'l ; 

class ComandoGravarCliente extends Coma.,do TransaçãoDeNegócio .. . 

public void processar ( ) throws Exception 1 
continuarTransaçãoDeNegóci-0( ); 
Cliente cliente= (Cliente} lerSolicitaçâo( l.lerSessàol 1 .getAttribute(~cliente~); 
String n001e ~ lersolicitaçào( 1.9ecParamecer1•noe1eDoCliente•) ; 
cliente .gravarHome(noce); 
Mapeador mapeadorDeCliente = Registror~apeador. rnSTAlíCE.lerMapeador(Cliente .class); 
mapeadorDoCliente.atualizar(cliente); 
GerenciadorDeBloqueiosExclusivosDeLeitura.INSTAllCE.liberarBloqueio(cliente.lerIDI 1, 

GerenciadorDeSessãoOeAplicação. lersessão ( ) .get 10 ( ) ) ; 
forward t•/clienteGravado.jsp•); 


CAPilULO 1 6 • PADRÕES OE CONCORRtNCIA ÔFFUNE 411 

Os comandos recém-mostrados evitarão que duas sessões quaisquer trnbalhcm 
com o mesmo cliente ao mesmo tempo. Qualqueroutro comando na aplicação 
que trabalhar com um objeto cliente deve se assegurar de obter o bloqueio ou de trabalhar 
apenas com um clie1'\te bloqueado por um comando anterior na mesma tran• 
sação de negócio. Visto que temos uma verificação temBloqueio( ) no gerenciador de 
bloqueios, poderíamos simplesmente obter o bloqueio em cada comando. Isso poderia 
ser ruim para o desempenho, mas certamente garantiria que temos um bloqueio. 
O Bloqueio lmplfd to (422) discute outras abordagens seguras de mecanismos 
de bloqueio. 

A quantidade de código no Jramework poderia parecer um pouco fora de proporção 
cm relação à quantidade de código de domínio. De foto, o Bloqueio Offline Pessimista 
requer, no mínimo, sincronizar a atuação de uma sessão de aplicação, uma 
tTansação denegócio, um gerenciador debloqueio e uma transação de sistema, o que 
é claramente um desafio. Esse exemplo serve mais como inspiração do que como modelo 
de arquitetura, pois ele sofre de falta de robustez em muitas áreas. 


412 PAATE li • Os PADRÕES 

Bloqueio de Granularidade Alta (Coarse-Grained Lock) 

por David Rice eMntt Foemmel 
Bloqueia 11m conjunto de objetos relacionados 11tilizn11do para isso um IÍnico bloq11eio. 

CJiente 

1 1 
* 
Bloqueio 

Endereço 

Os objetos muitas vezes podem ser editados em grupos. Talvez você tenha um cliente 
e seu conjunto de endereços. Se este for o caso, ao usar a aplicação, faz sentido bloquear 
todos esses itens se você quiser bloquear qualquer um deles. Ter um bloqueio 
separado para objetos individuais apresenta um número de desafios. Primeiro, qualquer 
um que for manipulá-los tem que escrever código que busque a todos para poder 
bloqueá-los. Isso é suficientemente fácil com um cliente e seus endereços, mas fica 
bastante complicado uma vez que se tem mais grupos para bloquear. E se os grupos 
ficarem complicados? Onde fica este comportamento quando seu framl'i.VOrk está 
gerenciando a obtenção de bloqueios? Se a sua estratégia de bloqueios requerer que 
um objeto seja carregado para que seja bloqueado, como com o Bloqueio Offline Otimista 
(392), bloquear um grupo grande afetará o desempenho. Além disso, com o Bloqueio 
Offline Pessimistn (401), um conjunto de bloqueios grande é uma dor de cabeça 
para gerenciar e aumenta a disputa pela tabela de bloqueios. 

Um Bloqueio de Grmwlnridnde Alta é um único bloqueio que cobre muitos objetos. 
Ele não apenas simpliíica o próprio ato de bloquear como também o libera de ter 
que carregar todos os membros de um grupo para poder bloqueá-los. 

Como Funciona 

O primeiro passo na implementação do Bloqueio de Grnnularidnde Alta é criar um único 
ponto de disputa para bloquear um grupo de objetos. Isso faz com que apenas um 
bloqueio seja necessário para bloquear todo o conjunto. Você fornece então o caminho 
mais curto possível para encontrar esse ponto único de bloqueio de modo a núnimizar 
os membros do grupo que devem ser identificados e possivelmente carregados 
na memória no processo de obtenção desse bloqueio. 

Com o Bloqueio Offline Otimista (392), fazer com que cada item do grupo compartilhe 
uma versão (veja a Figura 16.2) cria o ponto único de disputa, o que significa 
compartilhar n mesma versão, não uma versão igual. Incrementar essa versão bloqueará 
todo o grupo com um bloqueio compartilhado. Configure seu modelo para 
indicar cada membro do grupo na versão compartilhada, e você terá certamente mjnimizado 
o caminho para o ponto de disputa. 


ú.PiTULO 16 • PADRÕES OE CONCORRÊNCIA 0FFUNE 413 

.!, 

''" 

Cliente 

1 

1 1 • 

Versão 

lerValor() 
incrementar( ) 

~: ' I 
1 ' 1 

Endereço 

~1: 

{versao = 
cliente. versão} 

Figura 16.2 Compartilhando uma versão. 

Um Bloqueio Offline Pessimistn (401) compartilhado requer que cada membro do 
grupo compartilhe algum tipo de toke11 bloqueável, sobre o qual ele deve então ser 
obtido. Como o Bloqueio Offline Pessimista (401) é muitas vezes usado como um complemento 
do Bloqueio Offline Otimista (392), uma versão de objeto compartilhada é 
uma candidata excelente para o papel de token bloqueável (Figura 16.3). 

Eric Evans e David Siegel (Evans] definem um agregado como um cl11slcr de objetos 
associados que tratamos como uma unidade na hora de alterar dados. Cada 
agregado tem urna raiz que fornece o único ponto de acesso aos membros do conjunto 
e um limite que define o que está incluído no conjunto. As características do agregado 
pedem um Bloqueio de Granularidade Alta, já que trabalhar com qualquer um de 
seus membros requer bloquear todos eles. Bloquear um agregado é uma alternativa 
a um bloqueio compartilhado que eu chamo de bloqueio de raiz(veja a Figura 16.4). 
Por definição bloquear a raiz bloqueia todos os membros do agregado. O bloqueio da 
rniz nos dá um único ponto de disputa. 

Usar um bloqueio de raiz como Bloqueio de Grmwlnritinde Altn toma necessário 
implementar navegação para a raiz no grafo de objetos. Isso permite a um mecanismo 
de bloqueio, quando solicitado a bloquear qualquer objeto no agregado, navegar 

Cliente * 

\ / 1 

1º 

1 1 Bloqueio

Versão 


-Pessimista 

*1 / 

' \ 1 

Endereço 

* 

-

{versao = 
cliente.versão} 

Figura 16.3 Bloqueando uma versão compartilhada. 


414 PARTE li • Os PAORÕES 

---------------~ 

/ 1 

1 .-------, 1 

1, 1

1 1 

I Cliente Bloqueio 
1

1 
1 ,/ 1 

1 / 1 

Cf--........

1/ 

: l.,..._fr<-on-t-ei-ra----..~ 

1raiz 

1

Endereço 

1 

1 ,._______.., 1 

1 1

, _______________) 

Fígura 16.4 Bloqueando a rajz. 

até a raiz e bloqueá-la em vez do objeto. Esta navegação pode ser realizada de algumas 
formf\s, Você pode manter uma navegação direta para a raiz em cada objeto no 
agregado, ou pode us,u· uma seqüência de relacionamentos intermediários. Por 
exemplo, em uma hierarquia a raiz óbvfa éo ancestral no topo, ao qual você pode conectar 
os descendentes diretamente. Alternativamente, você pode dar a cada nó uma 
conexão ao seu ancestral imedfato e navegar nessa estrutura para alcançar a raiz. Em 
um grafo grande, esta última estratégia poderia causar problema de desempenho, já 
que cada ancestral deve ser carregado para determinar se ele próprio também tem 
um ancestral. Assegure-se de usar uma Cnrgn Tnrdio {200) ao carregar os objetos que 
constituem o cantinho para a sua raiz. Jsso não apenas evita que os objetos sejam carregados 
antes de serem necessários como evita um laço de mapeamento infinito 
quando você mapeia um relacionamento bidjredonal. Esteja alerta para o fato de que 
Cnrgns Tardias (200) para um único agregado podem ocorrer por diversas transações 
de sistema e, deste modo, você pode acabar com um agregado construído com pMtes 
inconsistentes. É claro que isso não é bom. 

Perceba que um bloqueio compartilhado também funciona pc1ra bloqueio de 
agregados, já que bloquear qualquer objeto no agregado irá simultaneamente bloquear 
a raiz. 

As implementações do bloqucio compartilhado e do bloqueio da raiz do Bloqueio 
de Gm1111laridade Alta têm ambos seus compromissos. Ao usar um banco de dados 
relacional, o bloqueio compartilhado carrega o fardo de que quase todas as suas 
seleções irão requerer um join com H t<1bela versão. Contudo, carregar objetos "º navegar 
para a raiz pode causar um problema de desempenho também. O bloqueio da 
raiz e o Bloq11eio Offliue Pessimista (401) talvez sejam uma combinação estranha. 
Quando você navega para a raiz e a bloqueia, pode precisar recarregar alguns objetos 
para garantir que estejam atualizados e, como sempre, construir um sistema sobre 
dados legados colocará numerosas restrições sobre sua escolha de implementação. 
Implementações de bloqueios existem em abundância, e as sutilezas são até 
mais numerosas. Assegure-se de chegar a uma implementação que satisfaça a suas 
necessidades. 


CAPiTULO 16 • PADRÕES OE (ONCORRENCIA 0FFLJNE 41 5 

Quando Usá-lo 

A razão mais óbvfa para usar um Bloqueio de Gm11ularídnde Alta é para satisfazer requisitos 
de negócio. Este é o caso ao bloquear um agregado. Considere um objeto leasing 
que possua uma coleção de bens. Provavelmente não foz sentido para o negócio 
que um usuário edite o objeto de leasing e outro usuário edite simultaneamente um 
bem. Bloquear um bem ou o lensi11g deveri<'I resultar no bloqueio do leasing e de todos 
os seus bens. 

Uma conseqüência mui to positiva de usar o Bloqueio de Grn,111/nridade Alfa é que 
obter e liberar bloqueios é menos custoso. Esta é certamente uma motivação legítima 
para usá-los. O bloqueio compartilhado pode ser usado além do conceito do agregado 
íEvans], mas seja cauteloso ao trabalhar com requisitos não.funcionais como desempenho. 
Cuidado com a criação de relacionamentos não-natw·ais entre objetos para 
facilita.-o Bloq11eio de Grn,wlnridade Alta. 

Exemplo: Bloqueio Offline Otimista (392) Compartilhado (Java) 

Para este exemplo temos um modelo de domínio com uma Cnmadn Supertipo (444), 

um banco de dados relacional como nosso armazenamento persjstente e Mapeadores 

de Dndos (170). 

A primeira coisa a fazer é criar uma. tabela e uma classe de versão. Para manter 
as coisas simples, criaremos uma clnsse de versão bastante versátil que irá não apenas 
armazenar seu valor, mas também terá um método estático de busca. Perceba 
que estamos usando um mapa de identidade para colocar em memória cache versões 
para uma sessão. Se os objetos compartilharem uma versão, é crucial que todos 
apontem para exatamente a mesma instância dela. Como a classe de versão é uma 
parte do nosso modelo de domínio, é provavelmente uma forma pobre colocar código 
de banco de dados nele, de modo que deixarei a versão com separação de código 
de banco de dados na camada de mapeamento como um exercício para você. 

tabela versão... 

create table versão (id bigint primary key, valor bigint, 
modificadoPor varchar, modificado datetime) 

class Versão... 

pri•,ate Long ió; 
private long valor; 
private String modíficadoPor; 
private Timestemp modificado; 
private boolean bloqueado; 
pri·:ate boolean éNova; 
private static final String SQL_ATUALlZAR = 

ftUPDATE versão SET valor =?, modificadoPor = ?, modificado=?, • 
"WHERE id = ? AlID valor = ?*; 
private static final String SQL_EXCLUlR = 
~oELE'lE FROM versão WHBRE id o ? AHD valor : ?"; 
private st atic final String SQL_IHSBRJR : 

•msBRT llITO versão VALUBS (?, ? , ? , ?1": 
private static final String SQL_CARREGAR= 
"SBLECT i d, valor, modificadoPor, modificado f'RO.\I versão WHERE id : ? •; 
publ ic static versão buscar(Long idl { 


416 PARTE li • Os PADRÕES 

Versão versão= GerenciadorDeSessãoDe.~.phcação.lerSessãol l .lerHapaDeident1dade( ) . lerVersão(ld): 
if (versão~= null) { 
versão= carregar(id); 

return versão; 

private static Versão c~rregar(Long id) 

ResultSet rs =null; 
Connection con = null; 
PreparedStatement dec =null; 
Versão versão= null; 
try 1 

con =ConnectionManager.INSTANCE.getConnection( ); 
dec =con.prepareStatement (SQL_CARR.BGAR); 
dec.setLong(l, id.longvalue( )I; 
rs = dec.executeQuery( ); 
if (rs.next l )1 ( 

long valor= rs.getLong(21; 
String mod.ificadoPor =rs.gecString (3); 
Timestai:\f) tr.Odificado = rs.getTimestam?(4); 
versão= new versão(id, valor, modificadoPor, n:odificado); 
CerenciaâorDeSessãoDe>.plicação. lerSessâo ( ) . lerl-lapaDe.Identidade ( ) . gravarVersâo(versão}; 

1else { 
throw ne~ OCncurrencyExcepcion (•versão • • id ~ • não encontrada.•l; 
l 

} catch (SQLException sqlBxl { 
throw new SysteaException (•erro de sql inesperado ao carregar a versão•, sql2x); 
f inally l 
liberarRecursosBD(rs, con, decl; 

retum versão; 

A versão também sabe como criar a si mesma. A inserção no banco de dados é 
separada da criação para permitir o adiamento da inserção até que pelo menos um 
dono seja inserido no banco de dados. Cada um dos nossos Mapeadores de Dados (170) 
do domínio pode chamar a inserção na versão com segurança durante a inserção do 
objeto do domínio correspondente. A versão executa um rastreamento verificando se 
ele é novo para se assegurar de que será inserido apenas uma vez. 

class Versão ... 

public static Versão criar () ( 
Versão versão = new Versão (GeradorDeid. INST~JICS.pr6xima!ó( ) , o. 

GerenciadorDeSessàoDeAplicação.lerSessãol ) .lerUsuário( ), now ( I); 
versão.éllova =true; 
return vers~o; 

public void inserir () 

ifI éNova l 1 ) { 
Connection con ~ null; 
PreparedState~ent dec =null; 
try { 

con = ConnectionMana9er .INSTANCE.getConnectionj ) ; 


CAPilULO 16 • PADRÕES OE CONCORRÊNCIA 0FFUNE 417 

dec: con.prepareStatement (SQL_INSERIR); 

dec.setUlng{l, this.lerld( ).longValue( )) ; 

dec.setUlng(2, this.lerValor( I) ; 

dec .setString{3, this.lerMcdifícadoPor( ) l; 

dec.setTilr.estamp(4, chis.lerMOdificado( )I ; 

dec.executeUpdate( ) ; 

GerenciadorDeSessãoDeAplicaçào.lerSessãol J.lerMapaDetàentidade( ).gravarVersãolthisl; 

éNova = false; 
} catch (SQLException sqlExl ( 

thrcw new SystenException !"erro de sql inesperado ao inserir versão•, sqlélxli 
} finally { 

cleaoupDBResources(con, dec); 

A segLÚr, temos um método incrementar( ) que incrementa o valor da versiio na 
linha correspondente no banco de dados. É provável que ruversos objetos em um 
conjunto de alterações compartilhem a mesma versífo, de modo que a versão primeiro 
se assegura de que já não esteja bloqueada antes de incrementar a si mesma. Após 
chamar o banco de dados, o método incrementar 1 ) deve verificar se a linha da versão 
foi realmente atualizada. Se este método retomar um contador de linha igual a zero, 
ele detectou uma violação de concorrência e levanta uma exceção. 

class Versão.. . 

public void incrementar ( 1 thro~s ConcurrencyExceptíon { 

if (l estáBloqueado( )l { 
Connection con = null; 
PreparedState~ent dec = null; 
try { 

con: Connection.Y.anager.INSTANCE.getConnection{ ); 
dec = con.prepareStatement (SQL_ATUAL!ZAR); 
dec.setUlng(l, valor t 1), 
dec.setString(2, this.lerModificadoPor( ll; 
dec.setTireestamp(J, this.lerModificado( li ; 
dec.setLong(4, id.longValuel )l ; 
dec.setLong(S, valor); 
int contadorDeLinha = dec.executeUpdate( ); 
if (contadorDeLinha == O) { 

levantarExceçàoDeConcorrência! ); 
) 
valor H; 
bloqueado= truei 
} catch (SQLException sql8xl 

thrO'• new Syste:nExceptio~ (•erro de sql inesperado ao incrementar versão•, sqlExl; 
) éinally { 
liberarRecursosBD(oon, dec); 

private void levantarExceçàoDeConcorrência( > 
Versão versãoAtual = carregarlthis.lerid( )) ; 


418 PARTE li • Os PADRÕES 

tbro~ new ConcurrencyException 1 
~versão modificada por• + versãoAtual .modificadoPor t •em• t 
DateFori:-.at. getDate'ii~Instance ( 1 . fo~t lversãoAtual. lerl'.odif1cadoCl 1 1 ; 

Com este código assegure-se de chamar incrementar apenas na transação de sistema 
na qual você confirmar sua transação de negócio. O flng estáBloqueado faz isso de 
modo que incrementar em transações anteriores resultará em obtenção falsa de bloqueio 
durante a trans;ição de confirmação. Tsso não é problema, porque toda a questão 
de um bloqueio otimista é que você apenas obtém o bloqueio quando confirma a 
gravação (commif). 

Quando você usa este padrão, pode querer ver se os seus dados ainda estão 
atuais com o banco de dados em uma transação de sistema anterior. Você pode fazer 
isso acrescentando um método verificar Atual na classe versão que simplesmente 
verifique se um Bloq11eio O!Jline Otimista (392) está disponível sem realizar nenhuma 
atualização. 

O método de exclusão que executa o SQL p;ira remover a versão do banco de 
dados não é mostrado. Se o contador de linha retornado for zero, uma exceção de 
concorrência é levantada. Acontece assim, porque o Bloqueio Offli11e Otimista (392) 
provavelmente não foi obtido durante a exclusão do último dos objetos usando esta 
versão. fsso nunca deveria acontecer. O verdadeiro truque é saber quando não há 
problema em excluir uma versão compartilhada. Se você estiver compartilhando 
uma versão por um agregado, simplesmente apague-a após você apagar a raiz do 
agregado. Ouh·os cenários tomam as coisas muito mais problemáticas. Uma possibilidade 
é que o objeto versão mantenha um contador de referência de seus donos e 
apague a si próprio quando o contador chegar a zero. Esteja avisado de que isso poderia 
contribuir para um objeto versão bastante sofisticado. Assim que sua versão ficar 
complicada, você poderia considerar tomá-la um objeto de domínio pleno. fsso 
faz sentido, mas, é claro, seria um objeto de dom(nio especial sem uma versão. 

Agora vamos ver como usamos a versão compartilhada. A Cnmadn Supertipo 

(444) do domínio contém um objeto versão, em vez de um contador simples. Cada 
Mapendor de Dndos (170) pode gi·avar a versão ao carregar o objeto do domínio. 
class ObjetoDQDoclinio... 

private Long id; 
private Timestamp r..odificado; 
pri,ac~ String modiEicadoPor; 
privat~ Versão versão; 
public void gravarCamposDeSister:ia (Versão versão. Timestamp modificado, String nodificadoPorl { 

this.versão =versão; 
this.modificado =i;odificaão; 
this.lllOdificadoPor = modificado~or; 

Para a criação, vamos olhar um agregado que consiste em uma raiz cliente e 
seus endereços. O método de criação do cliente criará a versão compartilhada. Clientes 
terão um método acrescentarEndereço( l que cria um endereço passando a versão 
do cliente. Nosso mapeador abstrato de banco de dados inserirá a versão antes de inserir 
os objetos de domínio correspondentes. Lembre-se de que a versão garantirá 
que será inserida apenas uma vez. 


CAPiTULO 16 • PADRÕES OE CONCORRENCIA 0 FFUNE 419 

class Cliente extends ObjetoDoDo:ninio... 

public scatic Cliente criar (String nome) 
return new Cliente(GeradorDelà.nlSTPJ/CE.próximaid{ l, Versão.criar( J, nome, new ArrayList( )} ; 

class Cliente excends ObjetoDoDo~ínio ... 

public Endereço acrescentarEndereço(String linhal, String cidade, String estado) { 
Endereço endereço = Endereço.criarlthis, lerVersão( ), linhal, cidade, estado); 
endereços.add(endereço); 
return endereço; 

class Endereço extends ObjetoOODomínio... 

public static Endereço criar (Cliente cliente, Versão versão, 
String linhal, String cidade, Strill<J estado) 1 
return ne·11 Endereço (GeradorDeld. l!!STAMCE.próximaid( ) , versão, cliente, 

linhal, cidade, estado); 

class MapeadorAbstrato ... 

public void inserir (ObjetoDoDomínio objeto) 
objeto.lerversào( ),inserir() : 

O incremento deveria ser chamado em uma versão pelo Mnpeador de Dados (165) 
antes que eJe atualize ou exclua um objeto. 

class MapeadorAbstrato ... 

public void atualizar !ObjetoDoDomínio objeto) { 
objeto.lerversão() .incrementar() ; 

class MapeadorAbstrato ... 

public void excluir (ObjetoDo~nio objeto) 
objeto.lerVersão( >.incrementar() ; 

Como este é um agregado, excluímos os endereços guando excluímos o cliente. 
Isso nos permite excluir a versão imediatamente após. 

class 1-!apeadorDeCliente extends MapeadorAbstrato.. . 

public void excluir (ObjetoDoDominio objeto) 1 
Cliente cli = (Cliente! objeto; 
for (Icerator iterator = cli.lerEndereçosl) .iteratorl 1; iterator.hasNext( };) 

Endereço endereço = (Endereço) iterator.next( }; 
RegistroMapeador.lerMapeador! Endereço.classl .excluirlendereço); 

super.excluir(objeto); 
cli.lerVersão{ ).excluir(); 


420 PARTE li • Os PAORÕES 

Exemplo: Bloqueio Offline Pessimista (401) Compartilhado (Java) 

Precisamos de algum tipo de toke11 bloqueável que possamos associar a todos os objetos 
no conjunto reladom1do. Como discutido anterjormente, usaremos Bloqueio 
Offli11e Pessimista (401) como um complemento do Bloqueio Offline Otimistn (392), a 
fim de que possamos usar como loken bloqueável a versão compartilhada. Usaremos 
todo o mesmo código para chegar a uma versão compartilhada. 

A única questão é que alguns dos nossos dados devem ser carregados a fim de 
obter a versão. Se obtivermos o Bloqueio OJJl.ine Pessimista (401) após carregarmos 
seus dados, como saberemos que os dados são os atuais? Algo que podemos fazer facilmente 
é incrementar a versão dentro da transação de sistema na qual obtivemos o 
Bloqueio Offli11e Pessimista (401 ). Assim que essa transação de sistema for confirmada, 
nosso bloqueio pessimista é válido, e sabemos que temos a cópia ma.is recente de 
qualquer dado compartilh,mdo ess<1 versão, independentemente de onde carregamos 
dentro da transação de sistema. 

class ComandoCarregarCliente... 

try { 
Cliente cl lente "' (Cliente) RegistroMapeador. ler~lapeador(Cliente .classl .buscar ( idl : 
GerenciadorDeSloqueiosBxclusivosDeLeitura.lNSTAliCE.obterBlogueio 

(cliente.lertd( l, GerenciadorDeSessãoOeAplicação.lerSessào( ).1er!dl J); 
cliente.lerVersão( 1,incrementar( J; 
GerenciadorDeTransações.lNSTANCE.confírinar( I; 

} catch (Bxceptíon e) ( 
GerenciadorDeTransações.HISTANCE.desfazer( ); 
throw e; 

Você pode ver que o incremento da versão poderia ser algo que você iria querer 
construir no seu gerenciador de bloqueios. Pelo menos você quer decorar [Gang of 
Four] seu gerenciador de bloqueios com código que incremente a versão. Seu código 
de produção irá, é claro, requerer a manipulação de exceções e o controle de transações 
mais robustos do que o exemplo mostra. 

Exemplo: Bloqueio Offline Otimista (392) de Raiz (Java) 

Este exemplo faz a maioria das mesmas suposições dos exemplos anteriores, incluindo 
uma Camada Supertipo (444) e Mapeadores de Dados (170) de domínio. Há um objeto 
versão, mas neste caso ele não será compartilhado. Ele simplesmente fornece um 
método incrementar() conveniente para permitir mais facilmente a obtenção do Bloq\
teio Offline Otimistn (392) fora do Mapendor de Dndos (170). Também estamos usando 
uma Unid<1de de Trabalho (187) para rastrear nosso conjunto de a.Iterações. 

Nosso agregado contém relacionamentos pai-filho, de modo que usaremos navegação 
filho-para-pai para encontrar a raiz. Precisaremos acomodar isso nos nossos 
modelos de domínio e de dados. 

claas ObjetoDoDominio... 

private Long idi 
private ObjetoDoOOOtínio pai; 
publíc Ol>JetoDo~ínio (Long id, ObjetoDoDominio pai) 


CAPiTULO 16 • PADRÕES OE CONCORRENCIA 0FFUNE 421 

this.id =id; 
this.pai =pai; 

Assim que tivermos nossos donos, podemos obter nossos bloqueios de raiz antes 
de confirmarmos a gravação da Unidnde de Trnbnlho. 

class UnidadeDeTrabalho... 

public void con!irn4r 1 ) thro11•s SQLException { 

Eor (Iterator iterator = _objetosModificados.iterator( ); iterator.hasNext( );l 
ObjetoDoDominio objeto~ (ObjetoDoDominio) iterator.nextl ) ; 
for(ObjetoDoDor:lÍ.nio dono= objeto; dono!= null; -dono= dono.lerPais( li 

dono.lerVersão( ).increcentar( ); 

} 

for (Iterator iterator = _objetosModificados.iterator( ); iterator.hasNext( ); 1 { 
ObjetoDoDominio objeto: (ObjetoDoDominio) iterator.nextl ! ; 
Mapeador mapeador = Registr<flapeador. lerl-!apeador (objeto.gettlass( ) > ; 
mapeador.atualizar(objetol ; 


422 PARTE li • Os PADRÕES 

Bloqueio Implícito (lmplicit Lock) 

po,· Dauid Rice 

Permite no código de uma camada s11pertipo 
011 de wnfrn111ework obter bloq11cios offlinc. 

Transação Gerenciador 
de Negócio 1 Framewom 1 de Bloqueios 

1 
1

carregar cliente 

1 

bloquear cliente 

1 1 
1 sucesso 1

1<--------------1 

1 1

retornar cliente 

1 1 

!E,----------, 1 

1 

1 

1 
1 

A chave de qualquer esquema de bloqueio é que não haja lé,cunas no seu uso. Esquecer 
de escrever uma única linha de código que requeira um bloqueio pode produzir 
todo um esquema de bloqueio offli11e inútil. Falhar na recuperação de um 
bloqueio de leitura em que outras transações usam bloqueios de gravação significa 
que você poderia obter dados de sessão não-atualizados. Falhar no uso apropriado 
de um contador de versão pode resultar na gravação não-intencional por 
cima das alterações de alguém. Geralmente, se um item pode ser bloqueado cm 
qualquer lugar, deve ser bloqueado em todo lugar. Ignorar a estratégia de bloqueio 
da sua aplicação permite a uma transação de negócio criar dados inconsistentes. 
Não liberar bloqueios não irá corromper seus dados, mas acabc'lrá trazendo sérios 
prejuízos à produtividade. Devido ao fato de o gerenciamento de concorrência offline 
ser difícil de testar, tais erros poderiam não ser detectados por todos os seus 
conjuntos de testes. 

Uma solução é não permitir que os desenvolvedores cometam esse erro. As tarefas 
de bloqueio que não podem ser negligenciadas não deveriam ser manipuladas 
explicitamente pelos desenvolvedores, mas implicitamente pela aplicação. O fato de 
que a maioria das aplicações corporativas faz uso de alguma combinação deframework, 
Cnmnda Superfipo (444) e geração de código nos fornece uma vasta oportunidade 
para facilitar o Bloqueio Implícito. 

Como Funciona 

Implementar Bloqueio Implícito é uma questão de fatorar seu código de modo que 
qualquer mecanjsmo de bloqueio que realmente não possa ser pulado possa ser executado 
pelo seu frnmezuork da aplicação. Pela falta de uma palavra melhor usaremos 


CAPi'íULO 16 • PAORÕE:S OE CONCORRiNCIA ÔFFLJNE 423 

"fmmework" significando uma combinação de Cmnadns S11pertipo (444), clélsses deframework 
e qualquer outro código auxiliar. Ferramentas de geração de código são uma 
outra via para forçar o bloqueio apropriado. Percebo que isso de forma alguma sigr\
ifica uma idéin inovadora. É muito provável que voe~ siga esse caminho, assim que 
tiver codificado o mesmo mecanismo de bloqueio algumas vezes pela sua aplicação. 
Ainda assim, tenho visto isso não muito bem feito com freqüência suficiente para 
que ele mereça uma breve olhada. 

O primeiro passo é montar uma lista de quais tarefas são obrigatórias para que 
uma transação de negócio 'trabalhe dentro da sua estratégia de bloqueio. Para o Bloqueio 
Offlinc Otimista (392), essa lista conterá itens como armazenar um contador de 
versão para cada registro, incluindo a versão no critério de atualiznção SQL, e armazenar 
uma versão incrementada ao alteraro registro. A lista do Bloq1teio Offline Pessimistn 
(401) incluirá itens junto com as linhas para obter qualquer bloqueio necessário 
para carregar uma certa quantidade de dados -normalmente o bloqueio exclusivo 
de leitura ou a parte de leitura do bloqueio de leitura/gravação-e Libenu todos os 
bloqueios quando a transação de negócio ou sessão for completada. 

Perceba que a lista do Bloqueio Offline Pessimista (401) não inclui a obtenção de 
qualquer bloqueio necessário apenas para editar uma determinada quantidade de 
dados-ouseja, bloqueio exclusivo de gravação e a piwte de gravação do bloqueio de 
leitura/gravação. Sim, esses são obrigatóriosse sua transação de negócio quiser editar 
os dados, mas obtê-los implicitamente apresenta, se os bloqueios estiverem indisponíveis, 
algumas dificuldades. Primeiro, os únicos pontos nos quais poderíamos 
obter implicitamente um bloqueio de gravação, como no registro de um objeto sujo 
dentro de uma Unidade de Tl'nbnlllo (187)1 não nos oferecem nenhuma garantia de que, 
se os bloqueios estiverem disponíveis, n transação irá abortar assim que o usuário comece 
a trabalhar. A aplicação não consegue descobrir por si mesma quando é um 
bom momento para obter esses bloqueios. Uma transação que não falhe rapidamente, 
conflita com um dos objetivos de um Bloq11eio Offline Pessimista (401) -que um 
usuário não tenha que executar o mesmo trabalho duas vezes. 

Segundo, e também importante, é que esses tipos de bloqueio limitanl muito a 
concorrência do sistema. Evitar um Bloqueio Implícito aqui nos ajuda a pensar sobre 
como afetamos a concorrência tirando ésta questão da área técnica é colocando-a no 
donúnio do negócio. Ainda assim, temos que nos assegurar de que os bloqueios necessários 
para a gravação sejam obtidos antes que as alterações sejam confirmadas. 
O que o seufrnruework pode fazer é assegurar que um bloqueio de gravação já tenha 
sido obtido antes de confirmar qualquer alteração. Não ter obtido o bloqueio até o 
momento da confirmação é um erro de prog1·amação, e o código deve pelo menos levantar 
uma falha de asserção. Aconselho pular a declaração e levantar umn exceção 
de concorrência aqui, já que você não quer tais erros no seu sistema de produção 
quando as asserções são desativadas. 

Uma palavra de precaução sobre o uso de Bloqueio Implícito. Embora ele pemuta 
aos desenvolvedores ignorar muito dos mecanismos de bloqueio, não lhes permite 
ignorar as conseqüências. Por exemplo, se os desenvolvedores estiverem usando 
Bloqueio Implícito com um esquema de bloqueio pessimista que espere pelos bloqueios, 
eles flinda precisam pensar sobre as possibilidades de deadfock. O perigo do 
Bloqueio Implícito é que as transações de negócio podem falhar de maneiras inesperadas 
assim que os desenvolvedores pararem de pensar sobre bloqueio. 

Fazer o bloqueio funcionar é uma questão de determinar o melhor modo de fazer 
com que seu frnmework execute implicitamente os mecanismos de bloqueio. Veja 


424 PARTE li • Os PADRÕES 

em Bloqueio Offline Olimistn (392) exemplos de manipulação implícita desse tipo de 
bloqueio. As possibilidades de uma implementação de Bloqueio Implícito de qualidade 
sifo numerosas demais para demonstrá-las todas aqui. 

Quando Usá-lo 

O Bloqueio lmplfcito deve ser usado em todas as aplicações não-triviais que não tenham 
o conceito de Jramework. O risco de um único bloqueio esquecido é grande 
demais. 

Exemplo: Bloqueio Offline Pessimísta (401) Implícito (Java) 

Vamos considerar um sistema que usa um bloqueio exclusivo de leitura. Nossa arquitetura 
contém um Modelo de Domínio (126) e estamos usando Mnpendores de Dados 

(170) para realizar a mediação entre nossos objetos de domínio e nosso banco de dados 
relacional. Com o bloqueio exclusivo de leitura, o frn111ework deve obter um bloqueio 
sobre um objeto de domínio antes de permitir a uma transação de negócio fazer 
qualquer coisa com ele. 
Qualquer objeto de domínio usado em uma transação de negócio é localizado 
pelo método buscar( l em um mapeador. Isso é verdadeiro se a transação de negócio 
usar o mapeador diretamente chamando busc.ar ( } ou indiretamente navegando pelo 
grafo de objetos. Agora é possível para nós decorar [Gang of Four] nossos mapeadores 
com a funcionalidade de bloqueio requerida. Escreveremos um mapcador de bloqueio 
que obtém um bloqueio antes de tentar encontrar um objeto. 

:nterface Mapeador... 

public ObjetoDoDomínio buscar (Long id}; 
public void inserir(ObjetoOODominio obj); 
public void ac.ualizar(ObjetoDoDocínio obj) 1 
public void excluir (ObjetoDoDominio obj); 

class MapeadoroeBloqueio implenents ~.apeador... 

private Mapeador i~pl; 
public MapeadorDeBloqueio (Mapeador irr.pl) 
this.impl = impl; 

public ObjetoDoDominio buscar (Long id) 
GerenciadorDeBloqueioSxclusivosDeLeitura.INSTANCB.obterBloqueio( 
id, GerenciadorDeSessãoDeAplicação.lerSessão( l .lerrd ( )); 
return impl.buscar(id); 

public void inserir (ObjetoDoOO!lúnio obj ) 
impl.inserir (obj} ; 

} 

publíc void atualizar (Objet0Dol>o!1ínio obj l 
impl.atualizar(obj); 

public void excluir (ObjetoDoDolllínio obj) 
i.mpl.excluir(obj); 


CAl'ilULO 16 • PADRÕES OE CONCORRtNCIA 0FFUNE 425 

Por ser muito comum procurar por um objeto mais de uma vez em \1ma sessão, 
para que o código acima funcione, o gerenciador de bloqueio deve verificar primeiro 
se a sessão já não tem o bloqueio antes que ele obtenha um. Se estivéssemos usando 
um bloqueio exclusivo de gravação em vez de um bloqueio exclusivo de leitura, 
escreveríamos um decorador para mapeador que verificasse a obtenção prévia de 
bloqueios na atualização e exclusão, em vez de realmente obter um bloqueio. 

Uma das coisas boas relacionadas a decoradores é que o objeto sendo envolvido 
nem sabe que sua ftmcionalidade está sendo aumentada. Aqui podemos envolver 
os mapeadores no nosso registro: 

RegistroDeMapeador!leBloqueios ir:iplements Registro~apeador... 

private Map mapeadores = new HashMap( ); 
public void r.apeadorDeRegistro (Class classe, ►lapeador mapeadorl 
mapeadores.put(classe, new MapeadorDeSloqueio(mapeadortl ; 

1 

public Mapeador leN1apeador {Class classe) { 

return (11.apeador) mapeadorea.get(classe); 

Quando a transação de negócio põe su<1s mãos em um mapeador, pensa que está 
para chamar um método de atualização padrão, mas o que realmente acontece é 
mostrado na Figura 16.5. 

Iraru.àçâ_Q um Mapeador Mapeador o Gerenciador 
!ie_Edkão de Blo ueio de Cliente de Blo ueios 

1

1

1 carregar cliente 1 
➔I 1

1 1 

obter bloqueio 

1 1 
1 

1 carregar cliente 1 
1 !>1 
1 retornar cliente 1

!<-----------~

1 1 

Figura 16.5 Mapeador de bloqueio. 


CAPÍTULO 17 

Padrões de Estado de Sessão 


CAPÍTULO 17 • PADRÕES OE ESTADO DE SESSÃO 427 

Estado da Sessão no Cliente (Client Session State) 

Armazena o estado da sessão no cliente. 

Como Funciona 

Até mesmo os projetos mais orientados a servidor prcàsam de pelo menos um pequeno 
Estado da Sessão no Cliente, no mínimo para armazenar um identificador da 
sessão. Em algumas aplicações você pode considerar a colocação de todos os dados 
da sessão no cliente. Neste caso, o cliente envia todo o conjunto de dados de sessão 
em cada solicitação, e o servidor os envia de volta a cada resposta. Isso permite um 
servidor completamente sem estado. 

Na maior parte do tempo você irá querer usar um Objeto de Trnnsferência de Dados 
(380) para tratar a transferência de dados. O Objeto de Trn11sferência de Dados (380) 
pode serializar a si próprio através da conexão pernútindo assim que até mesmo dados 
complexos sejam transmitidos. 

O cliente também precisa armazenar os dados. Se for uma aplicação com cliente 
rico, ele pode fazer isso dentro de suas próprias estruturas, como os campos na sua 
interface-embora eu preferisse beber Budweiser a ter de fazer isso. Um conjunto de 
objetos não-visuais são, muitas vezes, uma escolha melhor, tais como o próprio Objeto 
de Trnnsfcrência de Dados (380) ou um modelo de domínio. De uma maneira ou de 
outra, isso normalmente não é um grande problema. 

Com uma interface HTML, as coisas ficam um pouco mais complicadas. Existem 
três maneiras usuais de implementar o Estado da Sessão 110 Cliente: parâmetros 
URL, campos ocuJtos e cookies. 

Os parâmetros URL são os mais fáceis de trabalhar, parn uma quantidade pequena 
de dados. Essencialmente, todas as URLs, em qualquer página de resposta, 
trazem o estado da sessão como um parâmetro. O limite claro desta técniccl é que o 
tamanho máximo de uma URL é limitado, mas se você tiver apenas alguns poucos 
itens de dados ela hmciona bem, sendo por isso uma escolha popularpara algo como 
uma identidade de sessão. Algumas plataformas fazem automaticamente a reescrita 
da URL para adicionar uma identidade de sessão. A alteração na URL pode ser 
um problema com bookmnrks, de modo que este é um argumento contra o uso de parâmetros 
URL para sites de consumidores. 

Um campo oculto é um campo enviado parn o navegador que não é mostrado 
na página Web. Você o obtém com uma tag na forma dNPUT type = ~hidden">. Para fazer 
um campo oculto funcionar, você, quando constrói uma resposta, serializa nele o 
estado da sessão e o lê de volta em cada solicitação. Você precisará de um formato 
para colocar os dados no campo oculto. AXMLé uma escolha óbvia, mas é claro que 
ela é bastante prolixa. Você pode tambémcodificar os dados com algum esquema de 
codificação baseado em texto. Lembre-se de que um campo oculto é oculto apenas 
para a página exibida. Qualquer lLm pode ver os dados olhando o código fonte da 
página. 

Tome cuidado com um site confuso que tenha páginas velhas ou que tenham 
sido consertadas. Você pode perder todos os dados da sessão se navegar até essas 
páginas. 

A (1ltima, e algumas vezes controversa, escolha são os cookies, os quais são enviados 
de um lado para o outro automaticamente. Assim como com um campo oculto, 
você pode usar umcookie serializando nele o estado da sessão. Você fica limitado 


428 PARTE li • Os PAORÕES 

ao tamanho máximo que o cookit' pode ter. Além disso, muitas pessoas não gostam de 
cookies e os dcsntivam. Se eles fizerem isso, seu site irá parar de funcionar. No entanto, 
c\tualmente, cada vez mais sites são dependentes de cookies, de modo que esse problema 
deverá ocorrer cnda vez com menos freqüêncin. Além disso, isso certamente 
não é um problema para um sistema puramente interno à empresa. 

Perceba que os cookies não são mais seguros que quaisquer das alternativas, e,1tão 
tenha em mente que podem ocorrer bisbilhotices de todo tipo. Além disso, os 
cookies só funcionam dentro de um único nome de domínio, de modo que se o seu 
site estiver disperso cm diferentes nomes de donúnio, os cookies não serão movidos 
entre eles. 

Algumas plataformas conseguem detectar se os cookies estão habilitados e, se 
não estiverem, podem usar a reescrita de URL. Isso pode tomar o Estado dn Sessão 110 
Cliente bastante fácil para pequenas quantidades de dados. 

Quando Usá-lo 

O Estado dn Sessão no Cliente tem uma série de vantagens. Em especial, ele suporta 
bem objetos servidores sem estado com máxima d usterização e resiliência a falhas. É 
claro que, se o cliente falhar, tudo está perdido, mas isso, muitas vezes, já é esperado 
pelo usuário. 

Os argumentos contrários ao Estado da Sessão no Cliente crescem muito com a 
quantidade de dados envolvida. Com apenas alguns poucos campos, tudo funciona 
muito bem. Com grandes quantidades de dados, as questões sobre onde armazenar 
os dados e o custo do tempo de transferência em cada solicitação tornam-se proibitivos. 
Isso é especialmente verdadeiro se sua constelação incluir um cliente http. 

Existe também a questão da segurança. Qualquer dado enviado para o cliente é 
vulnerável a ser visto e alterado. A criptografia é a (mica maneira de evitar isso, mas 
criptografar e decriptografar a cada solicitação é uma sobrecarga para o desempenho. 
Sem criptografia, voeª tem que estar seguro de que não está enviando algo que 
preferiria esconder de olhos intrometidos. Os dedos podem também bisbilhotar, então, 
não pressuponha que o que foi enviado é o mesmo que foi recebido. Qualquer 
dado voltando precisará ser completamente revalidado. 

Quase sempre, você tem que usar o Estado da Sessão 110 Cliente para identificação 
de sessão. Felizmente, isso deve ser apenas umnúmero, o qual não será um fardo para 
nenhum dos esquemas acima. Você deve ainda se preocupar com o roubo da sessão, 
que é o que ncontece quando um usuário malicioso aJtera a sua identificação de 
sessão para tentar entrar m, sess~o de outra pessoa. A maioria das plataformas, para 
reduzir esse risco, incorpora uma identificação de sessão randômica. Se este não for 

o caso, gere uma identificação simples de sessão por meio de um hnsh. 

CAPÍTULO 17 • PAORÕES OE ESTADO OE SESSÃO 429 

Estado da Sessão no Servidor (Server Session State) 

Mantém oestado da sessão serinlizndo no servidor. 

Como Funciona 

Na forma mais simples deste padrão, um objeto de sessão é am1a7,.cnado na memória 
em umservidor de aplicação. Você pode ter algum tipo de mapa na memória que 
armazene estes objetos de sessão usando como chave uma identificação de sessão. 
Tudo o que o cliente precisa fazer é fornecer essa identificação e, então, o objeto de 
sessão pode ser trazido do mapa para processar a solicitação. 

Este cenário básico pressupõe, é claro, que o servidor de aplicação tenha memória 
suficiente para executar esta tarefa. Ele pressupõe também que haja apenas um 
servidor de aplicação -isto é, que não se estejam utilizando clusters -e que, se o servidor 
de aplicação falhar, seja apropriado que a sessão seja abandonada e todo o trabalho 
feito até o momento seja perdido. 

Para muitas aplicações este conjunto de suposições não é de fato um pmblema. 
Enb·etanto, parn outras, pode ser problemático. Existem formas de lidar com os casos 
em que as suposições não sejam válidas, e estes introduzem viuiações comuns que 
acrescentam complexidade a um padrão essencialmente simples. 

A primeira questão é A manipulação dos recursos de memória mantidos pelos 
objetos de sessão. De fato, esta é a objeção mais comum ao Cstndo dn Sessão tto Servidor. 
A resposta, é claro, é não manter recursos na memória, mas, em vez disso, serializar 
todo o estado da sessão em um memento [Gang of Fourl parn um armRzenamento 
persistente. rsso apresenta duas questões: em que formato você persiste o Estado 
da Sessão no Servidor, e onde você o persiste? 

O formato a ser usado é normalmente o formato mais simples possível, já que a 
marca do Estado da Sessão no Servidor é sua simplicidade de programação. rnversas 
plataformas fornecem um mecanismo de serialização binária simples que permitem 
facilmente serializar um grafo de objetos. Outro caminho é serializru· em algum outro 
formato, tal como texto-tão moderno quanto um arquivo XML. 

O formato binário é normalmente mais fácil, uma vez que requer pouca programação, 
enquanto que a forma textual requer, geralmente, ao menos um pouco de cóctigo. 
Serializações binárias também requerem menos espaço em disco. Ainda que o 
espaço total em disco raramente seja um probJema, grandes grafos de objetos serializados 
demorarão mais tempo para serem ativados na memória. 

Existem dois problemas recorrentes com a seríalização binária. Em primeiro lugar, 
a forma serializada não é legível por um ser humano -o que é wn problema se as pessoas 
quiserem lê-lo. Segundo, pode haver problemas com o controle de versões. Se você 
modifiCélr umn classe, digamos, acrescentando um campo após tê-la serializado, poderá 
não conseguir lê-la novamente. Éclaro que não é provável que muitas sessões convivam 
com um.a atualização do software do servidor, a menos que este seja um servidor 24/7 no 
qual você pode ter um cluster de máquinas rodando, algumas atualizadas e outras não. 

lsso nos remete à questão de onde armazenar o Estado da Sessão 110 Servidor. 
Uma possibilidade óbvia é armazená-lo no próprio servidor de aplicação, no sistema 
de r1tquivos ou em um br1nco de dados local. Este é um caminho simples, mas pode 
não suportar a utilização eficiente de clusters ou a recuperação automática de falhas. 
Para suportar estas características, o Cstndo da Sessão no Servidor precisa estar em algum 
lugar acessível de modo geral, tal como um servidor compartilhado. Isso irá su



430 PARTE li • Os PAORÕES 

portar a utilização de clusters e a recuperação automática de falhas ao custo de um 
tempo maior necessário para ativar o servidor -ainda que a utilização de uma memória 
cache possa diminuir bastante esse custo. 

Esta linha de taciocinio pode levar, ironicamente, ao armazenamento do Estado 
dn Sessão nó Servidor serializado no banco de dados, usando uma tabela de sessões 
indexada pelo lD da sessão. Essa tabela iria requerer um LOB Serializndo (264) 
para armazenar o Estado da Sessão no Servidor serializado. Quando se trata de manipular 
objetos grandes, o desempenho do banco dedados pode variar muito, então, 
os aspectos de desempenho desta alternativa são bastante dependentes do banco 
de dados utilizado. 

Neste ponto estamos exatamente na fronteira entre o Estado da Sessão no Servidor 
e o Estado da Sessão 110 Banco de Dados (432). Esta fronteira é completamente arbitrária, 
mas tracei a linha no ponto onde você converte os dados no Estado dn Sessão no Servidor 
para um formato tabular. 

Se você estiver armazenando o Estado dn Sessão 110 Servidor em wn banco de dados, 
você terá de se preocuparcom o tratamento de sessões que desaparecem,, especialmente 
em uma aplicação voltada aos consumidores. Um caminho é ter um dm:111011 
que procure sessões antigas e asexclua, mas isso pode levar a uma grande contenção 
na tabela de sessões. Kai Yu me falou sobre uma abordagem que ele usavc'I 
com sucesso: dividir a tabela de sessões em doze segmentos no banco de dados e, a 
cada duas horas, rodar ossegmentos, apagando tudo no segmento mais antigo e, então, 
direcionando todas as inserções para ele. Embora signifique que qualquer sessão 
que permanecer ativa por vinte e quatro horas será sumariamente jogêlda fora, isto é 
suficientemente raro para não se constituir em umproblema. 

Todas essas variações custam mais e mais trabalho para serem implementadas, 
mas a boa noticia é que os servidores de aplicação vêm, cada vez mais, suportando 
estas capacidades automaticamente. Assim, pode bem ser que estas passem a ser 
preocupações exdusivamente dos vendedores de servidores de aplicação. 

Implementação Java 

As duas técnicas mriis comuns para o Estado da SeSStio 110 Servidor ão u ar a essão 
http e usar um scssio11 l1ea,1 com estado. A sessão http é o caminho mais simples e 
faz com que o$dados da sessão sejam (lrma,:em,dos pelo servidor Web. 1 a maioria 
dos casos, isto leva à afinidade com o servidor, e não é possível lidar com a recuperação 
automática de falhas. Alguns vendedores vêm impleme,\tando uma sessão 
http compi!rtilhada que pern1ile armazenar os di!dos da sessão http em um banco 
de dados disponível para todos os servidores de aplicação. {Você também pode fazer 
isso mé\nualmente, é claro.) 

O outro caminho usual é através de um sessio11 bea11 com estado, o que requer 
um servidor EJB. O contêiner EJB trata a persistêncía e a passivação'", d~ modo que 
isso o toma muito fácil de programar. A principal desvantagem é que a especificé\ção 
não exige que o servidor de aplicação evite a afinidade com um servidor. Algw'\
S servidores de aplicação, no entanto, fornecem esta capacidade. Um deles, o 
WebSpherl! da IBM, pode Sf.!rializar um srs..Mo11 lu>tw com l!Stado em um BLOB no 
D82, o que permite que múltiplos servidores de aplicação acessem este estado. 

Várias pessoas dizem que, uma vez que os sessio11 /Jea11s sem estado tém um 
desempenho melhor, você deveria empre usá-los em wz d~ usar bem1s com 15tc1do. 

~ N. de R. T.: Apassivação éo ato deseparar a inst~ncia de um bra11 comestado deseu objeto EJB e S11lvar() seu estado. 


CAPITULO 17 • PAORÕES DE ESTAOO DE SESSÃO 431 

Francamente, isso é conversa fiada. Primeiro, faça um teste de carga com o seu atnbiente 
para ver se a diferença de velocidade entre bea11s com estado e úea11s sem estado 
faz alguma diferença para a sua aplicação. A ThoughtWorks tem feito testes 
de carga em aplicações com algumas centenas de usuários concorrentes e não encontrou 
nenhwn problema de desempenho devido à utilização de bea11s com estado 
para tal nível de carga de usuário. Se o ganho de desempenho não é significativo 
para a sua êlpHcação, e beans com estado são mais fáceis, então você deveria usálos. 
Há outras razões para ser cauteloso com bea11s com estado -a recuperação automática 
de faU1c1s pode ser mais problemática dependendo do ·eu vendedor, mas 
a diferença de desempenho só aparece sob carga pesada. 

Uma alt~rnaliva l! usar um c11lity bean. Em geral, não tenho dado muita ahm• 
ção a enlily bra11s, mas você pode usar um para armazenar um LOB Seríalizarfo (264) 
de dados de sessão. Isso é bastante simples e é pouco provável que dê margem à 
ocorrência de alguns dos muitos problemas que geralmente envolvem a utfüzação 
de mtily bem1s. 

Implementação .NET 

O Esftido da Sessifo 110 Servidor é fácil de implementar com a capacidade embutida 
do estado de sessão. Por meio de defa11/t.NE1, armazena os dados da sessão no próprio 
processo servidor. Você pode ainda acomodar o armazenamento usando um 
serviço de estado, o qual pode residir na máquina local ou em ql•alquer outra máquina 
na rede. Com um serviço de estado separado, você pode reinicializar o servidor 
Web t! ainda assim reter o estado da sessão. Você faz a escolha entre u t!Stado 
de sessão embutido no processo e o serviço de estado em um arquivo de configuração, 
de modo que você não tem que alterar a aplicação. 

Quando Usá-lo 

A grande atração do Csfndo da Sessão no Servidor é a sua simplicidade. Em vários casos 
você não tem que executar nenhuma programação para fazê-lo funcionar. Se ele 
Vé'li ou não resolver seu problema, depende de você conseguir resolver a implementação 
em memória ou, em caso contrário, do rúvel de suporte que sua plataforma sel'vidora 
de aplicação U'1e dá. 

Mesmo sem isso você bem pode descobrir que o esforço de que precisa é pequeno. 
Serializar um BLOB para uma tabela de banco de dados pode acabar exigindo 
muito menos esforço do que converter os objetos servidores para o formato tabular. 

Onde o esforço de programação entra cm cena é na manutenção da sessão, especialmente 
se você tiver que prover seu próprio suporte para permitir a utilizc1ção 
de clusters e a recuperação automática de falhas. Pode ocorrer de isso ser mais problemático 
do que as outras opções, especialmente se você não tiver muitos dados de 
sessão para tratar, ou se seus dados de sessão podem ser facilmente convertidos para 
o formato tabu.lar. 


432 PARTE li • Os PADRÕES 

Estado da Sessão no Banco de Dados {Database Session State) 

Ar111nze11a dados de sessão como dados gravados 110 btmco de dados. 

Como Funciona 

Quando uma chamada sai do cliente para o servidor, o objeto servidor primeiro traz 
do banco de dados os dados solicitados pela requisição. Em seguida, executa o trabalho 
necessário e salva novamente todos os dados solicitados no banco de dados. 

Para trazer as informações do banco de dados, o objeto servidor precisará de algumas 
informações sobre a sessão, o que requer que, ao menos, um número identificador 
da sessão seja armazenado no cliente. Normalmente, contudo, esta informação 
não é nad<l m<lis do que o conjunto apropriado de chaves necessárias para encontrar 
a quantidade apropriada de dados no banco de dados. 

Os dados envolvidos são geralmente uma mistura de dados de sessão, que são 

locais apenas para a interação corrente, e dados gravados, que são relevantes para to


das as interações. 

Um dos aspectos-chave a considerar aqui é o fato de que os dados de sessão são 
geralmente considerados locais à sessão e não deveriam afetar outras partes do sistema 
até que a sessão como um todo seja grnvada no banco de dados. Assim, se você 
estiver trabalhando em um pedido em uma sessão e quiser gravar seu estado intermedü\
rio no banco de dados, normalmente precisa tratá-lo de forma diferente de um 
pedido que é confirmado ao final da sessão. Isso se deve ao fato de que você não quer 
que pedidos pendentes apareçam em consultas ao banco de dados, buscando coisas 
como djsponibilidade de livros e receita diária. 

Então, como você separa os dados de sessão? Adicionar um campo a cada linha 
do banco de dados que possa ter dados de sessão é um caminho. A maneira 
mais simples disso requer apenas um campo booleano estáPendente. No entanto, 
uma maneira melhor é armazenar uma identificação de sessão como um campo 
pendente, o que toma muito mais fácil encontrar todos os dados de uma determinada 
sessão. Todas as consultas que querem apenas dados permanentes precisam 
ser modificadas com uma cláusula IDdaSessão is not HULL, ou precisam de uma visão 
que filtre esses dados. 

O uso de um campo contendo a identificação da sessão é uma solução muito invasjva, 
porque todas as aplicações que acessam o banco de dados precisam conhecer 

o significado do campo para evitar obter dados de sessão. As Visões, algumas vezes 
resolvem esse problema,. mas elas freqüentemente impõem seus próprios custos. 
Uma segunda alternativa é separar conjuntos de tabelas pendentes. Assim, se 
você já tiver tabelas para pedidos e para itens de pedidos no seu banco de dados, você 
simplesmente adicionaria tabelas para pedidos pendentes e itens de pedjdos pendentes. 
Dados pendentes de sessão seriam armazenados nas tabelas pendentes. 
Quando eles se tornarem .registros permanentes, você os grava nas tabelas reais. Isso 
remove muita da invasividade. No entanto, você precisará acrescentar ao seu código 
de mapeamento de banco de dados a lógica apropriada para a seleção de tabelas, o 
que certamente adicionará algumas complicações. 

Freqüentemente, os dados permanentes terão regras de integridade que não se 
aplicam a dados pendentes. Neste caso, as tabelas pendentes Lhe permitem abrir mão 
das1·egras, quando não as quiser, mas forçar o seu uso, quando isso for conveniente. 
Regras de validação geralmente também não são aplicadas ao salvar dados penden



CAPÍTULO 17 • PADRÕES DE ESTADO OE SESSÃO 433 

tes. Você pode se deparar com diferentes regras de validação, dependendo de onde 
você estiver na sessão, mas isso geralmente aparece na lógica do objeto servidor. 

Se você usar tabelas pendentes, elas devem ser clones exatos das tabelas renis. 
Dessa forma, você pode manter sua lógica de mapeamento tão parecida quanto possível. 
Use o mesmo nome de campo nas duas tabelas, mas adicione um campo de 
identificação da sessão nas tabelas pendentes de modo que você possa encontrar facilmente 
todos os dados de uma sessão. 

Você precisará de um mecanismo para limpar os dados de sessão se uma sessão 
fot cancelada ou abandonada. Usando um identificador de sessão, você pode encontrar 
todos os dados relacionados à sessão e apagá-los. Se os usuários abandonarem a 
sessão sem lhe informar, você irá precisar de algum tipo de mecanismo de timeout parn 
lidar com essa situação. Um dae111011 que rode a cada poucos minutos pode procurar 
por dados de sessões antigos. Isso requer uma tabela no banco de dados que registre 
a hora da última interação do usuário com a sessão. 

As atualizações tomam o processo de desfazer uma transação (rollúack) muito 
mais complicado. Se você arualiza um pedido existente em uma sessão que permite o 
rollbnck de toda a sessão, como você executa esse rollbnck? Uma opção é não permitir o 
cancelamento de uma sessão assim. Quaisquer atualizações em registros permanentes 
existentes tomam-se parte dos dados permanentes ao final da solicitaçno. Isto é 
simples e freqüentemente se encaixa na visão de mundo dos usuários. A alternativa é 
complicada, quer você use campos pendentes, quer use tabelas pendentes. É fácil copiar 
todos os dados que podem ser modificados para tabelas pendentes, lá modificálos 
e gravá-los de volta nas tabelas permanentes ao final da sessão. Você pode fazer isso 
com um campo pendente, mas somente se o identificador da sessão for parte da 
chave. Dessa forma, você pode manter juntos, na mesma tabela e ao mesmo tempo, 
identificadores de sessi=io novos e antigos, o que pode ser bastante confuso. 

Se você for usar tabelas pendentes separadas que são lidas apenas pol' objetos 
que tratam a sessão, então pode haver uma motivação pequena para colocar os dados 
em uma forma tabular. É melhor usar um LOB Serinlizndo (264). Neste ponto, cruzamos 
a fronteira para o Estado dn Sessão no Servido,. (429). 

Você pode evitar toda essa confusão de dados pendentes simplesmente não tendo 
nenhLLrn dado pendente. Isto é1 você projeta o seu sistema de modo que todos os 
dados sejam considerados dados permanentes. Isso, é claro, nem sempre é possível, 
e, ainda que seja, pode ser tão complicado que os projetistas fariam melhor se pensassem 
sobre dados pendentes explícitos. Ainda assim, e você tiver esta opção, isso 
torna muito mais fácil trabalhar com o Estado da Sessão 110 Banco de Dados. 

Quando Usá-lo 

O Estndo dn Sessão no Banco de Dndos é uma das alternativas para tratar o estado da 
sessão. Ele deve ser comparado ao Estado dn Sessiio no Servidor (429) e ao Estado da Sessão 
no Cliente (427). 

O primeiro aspecto a considerar neste padrão é o desempenho. Você ganhará 
usando objetos sem estado no servidor, possibilitando assim a utilização da técnica 
de pooling e a fácil utilização de cl11slers. No entanto, você pagará um preço pelo tempo 
necessário para trazer os dados do banco de dados e para o banco de dados a cada 
solicitação. Você pode reduzir este custo colocando o objeto servidor em mem6rfa 
cache, de modo que você não tenha que ler os dados do banco de dados quando estes 
estiverem no cache. No entanto, você ainda terá de pagõt pelos custos de escrita. 


43-4 PARTE li • Os PAORÕES 

A segunda questão importante diz respeito ao esforço de programAção, a maior 
parte do qual está relacionada ao tratamento do estado da sessão. Se você não tiver 
estado de sessão algum e puder grnvar todos os seus dados como registros permanentes 
n cada solicitação, este padrão é uma escolha óbvia porque voe«? não perde nada, 
quer seja em esforço, quer seja em desempenho (se você colocar em cache seus 
objetos servidores). 

Em uma escolha entre o Estado da Sessão no Banco de Dados e o Estado da Sessão no 
Servido,, (429), a questão mais importante pode ser o quão fácil é suportar a adoção 
de c/11sters e a recuperação automática de falhas com o Estado da Sessão 110 Servidor 

(429) no seu servidor de aplicação. A utilização de cl11slers e a recuperação automática 
de falhas com o Estado dn Sessão 110 Banco de Dados, são geralmente mais claras, pelo 
menos com as soluções normais. 

CAPÍTULO 18 

Padrões Básicos 


436 PARTE li • Os PADRÕES 

Gateway 

Um objeto que encapsula oacesso n 11111 sistema0 11 recurso externo. 

Cliente 

~-------------,

-----~-1 

.____L_ea_s_e _ _ ____. --------_ . _ ~ ~atewayde 
o_e_te_r~m-in_a_çª-º
~ de Preços 
Pacote de 
Determinação 
de Preços 
1 
1 
ªem -1------------


O software interessante raramente vive isolado. Até mesmo o sistema orientado a 
objetos mais puro muitas vezes tem que lidar com coisas que não são objetos, como 
tabelas de bancos de dados relacionais, tJansações CICS e estruturas de dados 
XML. 

Ao acessar recursos externos como esses, você geralmente obterá APls para 
eles. Entretanto, estas APis naturalmente serão um pouco complicadas porque elas 
levam em consideração a natureza do recurso. Qualquer pessoa que precise entender 
urn recurso precisa entendersua API -sejam JDBC e SQL pMa bancos de dados relacionais 
ou W3C ou JDOM para XNfL.Isso não apenas tornél o software mais difícil de 
entender, como trunbérn muito mais difícil de alterar se você precisar trocar alguris 
dados de um banco de dados relacional para uma mensagem XML cm algum ponto, 
no futuro. 

A resposta é tão comum que mal vale a pena dizer. Encapsule todo o código especial 
de API em uma classe cuja interface se pareça com um objeto normal. Os out1:
os objetos acessam o rectlrso através deste Gntcway, que traduz as chamadas simples 
de métodos na apropriada API especializada. 

Como Funciona 

Na verdade, este é um padrão muito simples de encapsulamento. Pegue o recurso 
externo. O que a aplicação precisa fazer com ele? Crie uma API simples para seu uso 
e use o Gateway para traduzir para a fonte externa. 

Um dos usos-chave de uma Gnlewny é como um bom ponto no qual aplicar um 
Stub de Serviço (473). Você pode muitas vezes alterar o projeto do Gateway para tornar 
mais fáciJ a aplicação de um Slub de Serviço (473). Não tenha medo de fazer isso -
Stubs de Serviço (473) bem-colocados podem tornar um sistema muito mais fácil de 
testar e, assim, muito mais fácil de escrever. 

Mantenha um Gntcway tão simples quanto possível. Enfoque os papéis básicos 
da adaptação do serviço externo e do fornecimento de um bom ponto para stub. O 
Gntewny deve ser tão mínimo quanto possível e ainda assim capaz de lidar com essas 
tarefas. Qualquer lógica mais complexa deve ficar nos clientes do Gnteway. 


CN>huLO 18 • PADRÕES BAsrcos 437 

Muitas vezes, é uma boa idéia usar geração de código para criar Gateways. Definindo 
a estrutura do recurso externo, você pode gerar uma classe Gnf<!'lvny para encapsulá-
lo. Você poderfa usar meradados relacionais para criar uma classe que encapsule 
uma tabela relacional, ou um esquema XML ou DTD para gerar código para 
um Gnttnvny para XML. Os Got<!'lvays resultantes são burros, mas resolvem o problema. 
Outros objetos podem executar manipulações mais complicadas. 

Às vezes, uma boa estratégia é criar um Gatewny em termos de mais de um objeto. 
O formato óbvio é usar dois objetos: um frontal e um na retarguarda (Jro11t e11d, 
bnck e11d). O da retaguarda age como uma camada mínima para o recurso externo e 
absolutamente não simplifica a API do recurso. O front<1l então transforma essa 
APJ complicada em uma mais conveniente para sua aplicação usar. Esta abordagem 
é boa se o encapsufamento do serviço externo e a adaptação às suas necessidades 
forem razoavelmente complicados, porque cada responsabilidade é manipulada 
por urna única classe. De modo inverso, se o encapsulamento do serviço externo 
for simples, uma classe pode lidar com ele e com qualquer adaptação que for 
necessária. 

Quando Usá-lo 

Você deve considerar um Gntewny toda vez que tiver uma interface complicada para 
algo que parece externo. Em vez de deixar a complicação se espalhar pelo sistema inteiro, 
use um Gatewny para contê-la. Quase nunca há aspectos negativos na criação do 
Gateway, eo código, em algum outro lugar do sistema, torna-se muito mais fácil de ler. 

Os Gateways geralmente tornam um sistema mais fácil de testar, dando a você 
um ponto claro no qual distribuir Stubs de Serviço (473). Mesmo se a interface do sistema 
externo for boa, um Gatewny é útil como um primeiro movimento na aplicação 
de um Stub de Serviço (473). 

Um benefício claro do Catcrwny é que ele também torna mais fáciJ para voce 
trocar algum tipo de recurso por outro. Qualquer alteração nos recursos significa 
que você só tem que alterar a classe Gafewny-a alteração não se propaga pelo resto 
do sistema. O Gateway é uma forma simples e poderosa de variação protegida. 
Em muitos casos argumentar sobre esta flexibilidade é o foco do debate sobre o uso 
do Gatewny. Todavia, não se esqueça de que, mesmo que você não pense que orecui
·so vai ser alterado, pode se beneficiar da simplicidade e da testabilidade que o 
Gntewny lhe dá. 

Quando você tem alguns subsistemas como este, outra escolha para desacoplálos 
é um Mnpe11dor (442). Contudo, o Mnpendor (442) é mais complicado do que o Gntewny. 
Como conseqüência, uso Gnteway para a maioria dos meus acessos a recw·sos 
externos. 

Devo admitir que relutei um pouco entre fazer deste um novo padrão, em vez 

de referenciar padrões existentes como Fachada e Adaptador fGang of Four]. Decidi 

separá-lo desses outros padrões porque acho que há uma distinção útil a ser feita. 

• P.n1bora a Fachnd-11. simplifique uma APr mais complexa, isso gerç1Jmente é feito 
por quem escreve o serviço de uso geral. UmGaleway é escrito pelo cliente 
para seu uso particular. Além disso, uma Fachada sempre significa uma interface 
diferente para o que ela está cobrindo, enquanto que um Gn/1.'lvny pode 
copiar inteiramente a fachada env0Jvida1 sendo usada para substituição 
ou testes. 

438 PARTE li • Os PADRÕES 

• Os Adnpfadores alteram a interface de wna implementação para que se ajuste 
a outra interface com a qual você precisa trabalhar. Com o Gatewny, geralmente 
não há uma interface exjstente, embora você possa usar um adaptador 
para mapear uma implementação para a interface de um Gntewny. Neste caso, 
o é\daptador é parte da implementação do Gatewny. 
• O Mediador geralmente separa djversos objetos de modo que eles não conheçam 
uns aos outros, mas conheçam o mediador. Com um Gnteway, geralmente, 
há apenas dois objetos envolvidos, e o recurso que está sendo envolvido 
não conhece o Gateway. 
Exemplo: Um Gateway para um Serviço de Mensagens Proprietário (Java) 

Estí:\Va falando sobre este padrão com meu colega, Mike Retting, e ele me descreveu 
a forma como costuma usá-lo em interfaces com software do tipo Enterprise Application 
Integration (EAI). Decidimos que isso seria uma boa inspiração para um exemplo 
de Gnteway. 

Para manter as coisas no nível costumeiro de enorme simplicidade, criaremos 
um gatewny para uma interface que apenas envia uma mensagem usando o serviço 
de mensagens. A interface é élpenas um único método. 

~nt enviar (String tipoDaMensagem, Object l I parãmetros); 

O primeiro parâmetro é uma string indicando o tipo da mensagem. O segundo 
são os parâmetros di'I mensagem. O sistema de mensagens lhe permite enviar qualquer 
tipo de mensagem, então ele precisa de uma interfac,e genérica com esta. Quando 
você configura o sistema de mensagens, especifica os tipos de mensagens que o 
sistema enviará e o número e tipo de parâmetros para eles. Assim, poderíamos configw
·ar a mensagem de confirmação com a string "CNPRM'' e ter parâmetros para um 
número de identificação como uma stri11g, uma quantidade inteira e uma string para 

o código do registrador. O sistema de mensagens verifica os tipos dos parâmetros para 
nós e gera um erro se enviarmos uma mensagem errada ou a mensagem certa com 
os parâmetros errados. 
Isso é louvável, e provê a necessária flexibilidade, mas a interface genérica é 
compUcada de usar porque não é explícita. Você não pode perceber olhando a interface 
qurus são os tipos legais de mensagens ou quais parâmetros são necessários para 
Ltm determinado tipo de mensagem. O que precisamos em vez disso é de uma interface 
com métodos como este: 

public void enviarConfirmação (String !DdoPedido, int quantia, String símbolo); 

Desta maneira, se quisermos que um objeto do domínio envie uma mensagem, 
ele-pode fazer isso desta forma: 

class Pedido ... 

public void confirtr~r ( 1 { 
if (~Validol ))Ambiente.lerG.ate'líayDeMensagens() .enviarConfimaçào(id, quantia, sí~.bolo); 

Aqui o nome do método nos diz qual mensagem ele está enviando e os parâmetros 
são tipados e recebem nomes. Este é um método muito mais fácil de chamar do 


CAPITULO 18 • PADRÕES BÁSICOS 439 

que o método genérico. É papel do gateway criar uma interface mais conveniente. isso 
significa, porém, que cada vez que adicionarmos ou alterarmos um tipo de mensagem 
no sistema de mensagens, precisamos alterar a classe gateway, mas teríamos 
que alterar o código da chamtlda de qualquer maneira. Pelo menos, dessa forma, o 
compilador pode nos ajudar a encontrar os clientes e a verificar erros. 

Há outro problemé'I. Quando ternos um erro com esta interface, ela nos informa 
retornando um código de erro. Um zero indica sucesso, qualquer outi·a coisa indica 
uma falha, e números diferentes indicam diferentes erros. Esta é uma maneira natural 
de um programador C trabalhar, mas não é a maneira pela qual Java faz as coisas. 
Em Java, você levanta uma exceção para indicar um erro, então, os métodos do Gatcway 
devem levantar exceções em vez de retornar códigos de erros. 

A faixa completa de erros possíveis é algo que iremos naturalmente ignorar. Focarei 
apenas dois: enviar uma mensagem com um tipo desconhecido de mensagem 
e enviar uma mensagem em que um dos parâmetros é nulo. Os códigos de retorno 
são definidos na interface do sistema de mensagens. 

public static final int P~.P.ÂMBTRO_NULO" ·l; 
public static final int TIPO_DESCONHECIDO_OE_MENSAGEM " -2; 
public static final int SOCBSSO = O; 

Os dois erros têm uma diferença significativa. O erro referente ao tipo desconhecido 
de mensagem indica um erro na classegnte1ony.Já que qualquer cliente está 
apenas chamando um método completamente explícito, este erro nunca deveria ser 
gerado. Entretanto, eles poderiam passar um nulo e assim ver o erro do parâmetro 
nulo. Este erro não é uma exceção verificada já que indica um erro do programador 
-não é algo para o qual você escreveria um manipulador específico. O gatl•way, cm 
verdade, poderia ele mesmo verificar os nulos, mas se o sistema de mensagens for levantar 
o mesmo erro, isso provavelmente não valerá a pena. 

Por essas razões, o gatewt1y tem que traduzir da interface explícita para a interface 
genérica e traduzir os códigos de retomo em exceções. 

class CatewayDeMensagens... 

protected static final String CONFIRMAR" "CNFRM'; 

private RernetenteDeMensagens remetente; 

public void enviarConfirmaçào (String IDdoPedido, int quantia , String símbolo) ( 

Object f I parâi:tetros =new Object () { lDdoPedido, new Integer(quantia), síl!lbolol; 

enviar (CX)NFIRMAR, parâmetros); 

private void enviar(String mensagem, Object 11 parâmetros) { 

int cõdigoDeRetomo = executarlsnvio(mensagem, parârcetros); 

if (códigoDeReromo == ReoetenteDeMensagens.PARÂMBTRO NULO) 

throw new NullPointerException (•?arã:netro nulo passado para tipo de mensagem: • t mensagem); 

if (códigoOeRetorno I= Re::ietenteDeMensagens.SUCESSO) 

thrO't new 111egalStateBxception ( 

•Erro inesperado do sistema de mensagens~: • • códigoDeRecorno) 
protecced int executarEnvio !String mensagem, Objecc l I parâmetros! { 
Assert.notNull(remetente); 
return reiretente.enviar(Qensage.:i, parâ~etros); 


440 PARTE li • Os PAORÕES 

Até aqui é difícil ver o propósito do método executar&nvio, mas ele está lá por outro 
papel-chave de um gnteway -o teste. Podemos testar objetos que usam o gateway 
sem o serviço de envio de mensagens estar presente. Para fazer isso, precisamos criar 
um St11b de Seroiço (473). Neste caso, o st11b do gateway é uma subclasse do gateway real 
e sobrescreve o método executarEnvio. 

class StubDoGacewayDe~lensagens ... 

protecteâ int executarEnvio (String tipoDaMensagem, Object 1 1 parâmetros) 
ínt códigoDeRetorno : éMensagemVálida (tipoDaMensagem, parâmetros); 
if (cõdigoDeRetorno :: Re::ietenteDeMensagens.SOCESSO) { 

mensagensEnviadast•; 

} 

retum oódigoDeRetomo; 

privace inc é~ensagemVilida (String tipoDaMensagem, Object 1 1 parâmetros) ( 
if (toàasAsMensagensOevem.Falhar) return -999; 
if (! tiposVálidosDeMensagens( 1.contains(tipoDaMensage~)l 

return RemetenteDe.~ensagens.TIPO_DBSCOllHECIDO_DE_MENSAGEM; 

for (int i: O; i < parãmetros.length; i+,) { 
Object parâmetro : parâraetroslil; 
if (parâmetro:: null) 1 

return RemetenteDeMensagens.~ARÃMETRO_NULO; 

return RemetenteDeMensa~ens.SUCSSSO; 

public statie L1st tiposVál idosMensagens l > { 
List resultado= new ArrayList ( l ; 
resultado.add(CONFIRMAR); 
return resultado; 

private boolean t.odasAsMensagensDevemFalhar = false: 
public void falharTodasAsMensagens ( ) [ 
toôasAsMensagensDevemFalhar = true; 

public int. lerllúmeroDeHensagensEnviadas 1 1 { 
return mensagensEnviadas; 

Capturar o número de mensagens enviadas é uma maneira simples de nos ajudar 
a testar se a porta funciona corretamente com testes como estes. 

class TestadorOOGateway.. . 

public void testarEnvioDeParân:etroliulo ( ) { 

try { 
porta( ).enviareonfinnação(null, s, •vs•); 
falhar("Nâo detectou parâmetro nulo"); 

} catch (tíullPointerException esperada) ( 
) 
assertEgua!slO, portal ) .le.rHGmeroDeMensagenstnv~das( )): 

) 
private StubDoGate11·ayDeMensa9ens porta ( 1 { 


CAPílULO 18 • PADRÕES BÁSICOS 441 

recuro (StubDoGatewayDeMensagensl i.mbiente.lerGacewayDeMensagens( l: 

protected void configurar( l chro~s Excepcioo { 
Ambiente.cestarlnicia!izaçâol l: 

Você geralmente configura o Gatcway de modo que as classes possí'lm encontréllo 
a partir de um lugaJ bem conhecido. Aqui usei uma interface de ambiente estática. 
Você pode trocar entre o serviço real e o stub em tempo de configuração usando 
um Plugin (465), ou pode fazer as rotinas de configuração de teste inicializarem o ambiente 
para usar o St11b de Serviço (473). 

Neste caso, usei uma subclasse do gateway para servir de stub para o serviço de 
mensagens. Outro caminho é criar uma subclasse do próprio serviço ou reimplementá-
lo. Para tesrar, você conecta o gnteway no St11b de Serviço (473) remetente. Isso funciona 
se reimplementar o serviço não for muito difícil. Você sempre tem a escolha de 
fazer um st11b para o serviço ou para o gateway. Em alguns casos, é até útil fazer para 
os dois, usando o do gatcway para testar clientes do gnteway e o do serviço para testar 

o próprio gntewny. 

442 PARTE li • Os PADRÕES 

Mapeador (Mapper} 

Um objeto que estabelece 11111n co111w1icaçiio entre dois objetos i11depe11de11tes. 

Cliente

----___ __,r ----------i 

r 
r 
Gatewayde 

Pacote de 
.___ _L_ea_s_e_ _,-----------D-et_e~rm_i_"ªç__ã_º-Determinação

-. _ de Preços 

de Preços 

1

' 

L----ª e_m_ _ 

~r------------l 

Às vezes, você precisn estabelecer comunicações entre dois subsistemas que ainda 
assim precisam ignorar um dooutro. Isso pode acontecer porque você não pode modificá-
los, oupode, mas não quer criar dependências entre os dois ou até mesmo entre 
eles e o elemento isolante. 

Como Funciona 

Um mapeador é uma camada isolante entre subsistemas. Ele controla os detalhes da 
comunicação entre eles sem que nenhum desses subsistemas tenha ciência disso. 

Um mapeador, muitas vezes, leva dados de uma camada para outra. Uma vez 
ativrtdo para esse transporte, é bastrtnte fácil ver como ele funcionrt. A parte complicada 
de usar um mapcadoré decidircomo invocá-lo, já que ele não pode ser .i.nvocrtdo 
diretamente por nenhum dos subsistemrts entre os quais ele está mapeando. Às 
vezes, um terceiro subsistema conduz o mapeamento e também invoca o mapeador. 
Uma alternativa é fazer do mapeador um observador [Gang ofFour] de um ou outro 
subsistema. Dessa maneira, ele pode ser ativado escutando os eventos cm um deles. 

O funcionamento de um mapeador depende do tipo de Cat')1adas que ele estiver 
mapeando. O caso mais comum de um mapeamento de camadas com que nos deparamos 
é umMnpendor de Dados (170)1 então, veja lá mais detalhes sobre como umMapendor 
é usado. 

Quando Usá-lo 

Basicamente, um Mt1peador desacopla diferentes partes de um sistema. Quando você 
quiser fazer isso, tem que escolher entre um Mnpcndor e um Gntewny (436). O Gnteway 
(436) é de longe a escolha mais comum, porque ele é muito mais simples de 
usar um Cnteway (436) do que um Mnpendor, tanto na escrita do código quanto no 
seu uso posterior. 

A conseqüência disso é que você deveria usar um Mapendor somente quando 
precisar se assegurar de que nenhum subsistema tem uma dependência em relação à 
esta interação. A única ocasião em que isso é realmente importante é quando a inte



CAPÍTULO l 8 • PADRÕES BAsrcos 443 

ração entre os subsistemas é especialmente complicada e, de alguma forma, independente 
do propósito principal de ambos os sistemas. Assim, cm aplicações corporativas, 
na maior parte das vezes, encontramos um Mapeador usado para interações com 
um banco de dados, como num Mapeador de Dados (170). 

O Mnpendor é semelhante ao Mediador [Gang of Four] visto que ele é usado para 
separar elementos diferentes. Entretanto, os objetos que usam um mediador estão 
cientes disso, mesmo se não estiverem cientes uns dos outros. Os objetos que um Mnpendor 
separa não estão nem mesmo cientes do mapeador. 


444 PARTE li • Os PADRÕES 

Camada Supertipo (Layer Supertype} 

U111 tipo que alua como o s1tperlipo pnrn todosos tipos e111 s11a cnmndn. 

Não é incomum que todos os objetos em uma camada tenham métodos que você não 

quer ter duplicados por todo o sistema. Você pode mover todo este comportamento 

para uma Cm11ndn Supertipo compartilhada. 

Como Funciona 

A Camada S11pertipo é uma idéia simples que leva a um padrão bastante curto. Tudo 

o que você predsa é de uma superclasse para todos os objetos em uma camada~ por 
exemplo, uma superclasse Objeto do Domínio para todos os objetos do domínio em 
um M odelo de Domf11io (126). Características comuns, como o armazenamento e a 
manipulação de Campos lde11tidnde (215), podem estar lá. De modo similar, todos os 
Mnpendores de Dados (170) na camada de mapeamento podem ter uma superclasse 
que conte com o fato de que todos os objetos do domínio têm uma superclasse em 
comum. 
Se você tiver mais de um tipo de objeto em uma camada, é útil ter mais do que 
uma Cnmnda S11pertipo. 

Quando Usá-la 

Use uma Camada Supertipo quando você tiver características comuns a todos os objetos 
em uma camada. Eu freqüentemente foço isso automaticamente, porque uso muito 
características comuns. 

Exemplo: Objeto do Domínio (Java) 

Os objetos do domínio podem ter uma superclasse comum para manipulação da 
identidade. 

class ObjetoOo!looínic... 

private Long ID; 
public Long ler!O( 1 
retum rD; 

public void 9ravarID(Lon9 ID) 
Assert.notNull(•Não posso configurar Ut1 !D nulo•, 10); 
this. [D = lD: 

public ObjetoOoOomínio (Long lD) 
this. lD = ID; 

public ObjetoDoOominiol ) 

} 


CAPITULO 18 • PADRÕES BAsrcos 445 

lnterface Separada (Separated lnterface) 

Define uma interface em 11111 pacote separado dn s11n it11pleme11taçào. 

domínio 

<1interface» 

Unidade 
de Trabalho 

mapeador de dados 1 

1 

1 

1 

Implementação 
da Unidade 
de Trabalho 

Implementação da Unidade de Trabalho 

À medida que você desenvolve um sistema, você pode melhorar a qualidade do seu 
projeto, reduzindo o acoplamento entre as partes dele. Uma boa maneira de fazer isso 
é agrupar as classes em pacotes e controlar as dependências entre eles. Você pode 
então seguir as regras sobre como classes em um pacote podem chamar classes em 
outro -por exemplo, uma que diz que classes na camada do domínio não podem 
chamar classes no pacote de apresentação. 

Entretanto, você poderia precisar chamar métodos que contradizem a estrutura 
geral de dependência. Se isso for verdade, use uma /11te1face Separada para definir 
uma interface em um pacote, mas implementá-la em outro. Dessa maneira, um cliente 
que precisa da dependência com a interface pode ficar completamente ignorante a 
respeito da implementação. A Interface Sepnrndn fornece um bom ponto de conexão 
para o Gnlc.>rony (436). 


446 PARTE li • Os PADRÕES 

Como Funciona 

Este padrão é muito simples de empregar. Basicamente, ele tira proveito do fato de 
que uma implementação é dependente de sua interface, mas o contrário não é verdadeiro. 
Isso significa que você pode colocar a interface e a implementação em pacotes 
separados, e o pacote da implementação tem uma dependência em relação ao pacote 
da interface. Outros pacotes podem depender do pacote da interface sem depender 
do pacote da implementação. 

É claro que, em tempo de execução, o software não funcionará sem alguma implementação 
da interface. Isso pode se dar tanto em tempo de compilação, usando 
um pacote separado que ligue os dois, quanto em tempo de configuração, usando 
um L'lugin (465). 

Você pode colocar a interface no pacote do cliente (como no esboço) ou cm um 
terceiro pé!cote (Figura 18.1). Se houver apenas um cliente para a implementaÇ<io, ou 
todos os clientes estiverem no mesmo pacote, então você poderia também colocar a 
interface com o cliente. Uma boa maneira de pensar nisso é que os desenvolvedores 
do pacote cliente são responsáveis pela definição da interface. Basicamente o pacote 
cliente indica que ele trabalhará com qualquer outro pacote que implemente a interface 
que ele define. Se você tiver diversos pacotes clientes, um terceiro pacote de interface 
é melhor. Ele também é melhor se você quiser mostrar que a definição da interface 
não é a responsabilidade dos desenvolvedores do pacote cliente. Este seria o 
caso se os desenvolvedores da implementação fossem responsáveis por isso. 

Você tem que considerar que característica da linguagem usar para a interface. 
Para Hnguagens que suportam a idéia de interfaces, comoJava e C#, a palavra-chave 
interface é a escolha óbvia. Entretanto, ela pode não ser a melhor. Uma classe absfI·ata 
pode ser uma boa interface, porque nela você pode ter implementações de comportamento 
comuns, mas opcionais. 

Uma das coisas compliCéldas a respeito de interfaces separadas é como instanciar 
a implementação. Isso geralmente requer conhecimento da classe da implementação. 
A abordagem comum é usar um objeto fábrica separado, em que nov<'!mente 
há uma Interface Scpnmdn para a fábrica. Você ainda tem que ligar uma implementação 
à fábrica, e o P/11gin (465) é umn boa maneira de fazê-lo. Isso não significa flpenns 

pedidos 1 ________._, UtilltáriosDeOados 
Cliente Unidade de Trabalho 
Pedido ~--------


1 
1 
1 
1 

1 
1 

1 

1 

Mapeador de Dados1 

lmplementaçãoDa


UnidadeDeTrabalho 

Figura 18.1 Colocando a Interface Separada em um terceiro pacote. 


CAPITULO l 8 • PADRÕES 8ÃSICOS 447 

que não há dependência, mas também adia a decis~o sobre a classe da implementação 
para o tempo de configuração. 

Se você não quiser ir até o fim com um Plugin (465), uma alternativa mais simples 
é deixar que um outro pacote, que conheça tanto a interface qunndo a implementação, 
instancie os objetos corretos no inicio da apLicação. Qua_isquer objetos que 
usem uma InterfaceSeparada podem, eles mesmos, serem instanciados ou ter fábricas 
instanciadas no início da aplicação. 

Quando Usá-la 

Você usa uma l11tcrfnce Separada quando precisa quebrar a dependência entre duas 
partes do sistema. Aqui estão alguns exemplos: 

• Você construiu algum código abstrato para casos comuns em um pacote framework 
que precisa cham<1r algum código específico dn aplicação. 
• Você tem algum código em LLma camada que precisa chamar código em outra 
camada que ele não deveria ver, tal como código de domínio chamando 
um Mapendor de Dados (170). 
• Você precisa chamar funções desenvolvidas por outro grupo de desenvolvimento, 
mas não quer uma dependência com suas APis. 
Deparo-me com muitos programc1dores que têm interfaces separadas para cada 
classe que escrevem. Considero que isso é excessivo, especialmente para o desenvolvimento 
de aplicações. Manter separadas interfaces e implementações é um trabalho 
extra, especialmente porque, freqüentemente, você precisa também de classes fábricas 
(com interfaces e implementações). Para aplicações, recomendo o uso de wna interface 
separada apenas se você quiser quebrar umdependência ou quiser ter djversas 
implementações independentes. Se você colocar a interface e a implementação 
juntas e precisar separá-las mais tarde, esta é uma refatoração sjmples que pode ser 
adiada até que você precise fazê-la. 

Existe um ponto em que esta forma diligente de gerenciamento de dependências 
pode se tornar um pouco tola. Ter apenas uma dependência para criar um objeto 
e, é'I partir daí, usar apenas a interface, é normalmente suficiente. O problema vem 
quando você quer reforçar regras de dependência, como fazer uma vel'ificaçno de dependência 
eo, tempo de construção. Então, todas as dependências têm que ser removidas. 
Para um sjstema menor reforçar regras de dependência é um problema menor, 
mas para sistemas maiores é uma disciplina que vale muito a pena. 


448 PARTE li • Os PADRÕES 

Registro (Registry) 

Um objeto conliecirlo que os outros objetos podem usar 
pnrn e11co11frar objelos e serviços comuns. 

Registro 1 

lerPessoa(id} 
adicionarPessoa(Pessoa) 

Quando você quer encontrar um objeto, você normalmente começa com outro objeto 
que tenha uma associação com ele e usa essa associação para navegar até ele. Assim, 
se você quiser encontrar todos os pedidos de um cliente, comece com o objeto 
cliente e use um método nele para chegar aos pedidos. Entretanto, em alguns casos, 
você não terá um objeto apropriado com o qual começar. Você pode saber o número 
do ID do cliente, mas não ter uma referência para ele. Neste caso, você precisa de algum 
tipo de método de busca -um buscador -mas a questão permanece: Comovocê 
chega até o buscador? 

O Regisi ro é basicamente umobjeto global, ou pelo menos ele se par-ece com um 
-mesmo se ele não for tão global quanto possa parecer. 

Como Funciona 

Como com qualquer objeto, você tem que pensar no projeto do Registro em termos de 
interface e implementação. Como muitos objetos, as duas são bastante diferentes, 
embora, muitas vezes, as pessoas cometam o erro de pensar que elas devam ser o 
mesmo. 

A. primeira coisa na qual pensar é a interface e, para os Registros, minha interface 
preferida são os métodos estáticos. Um método estático em uma classe é fácil de 
encontrar em qualquer lugar da aplicação. Além disso, você pode encapsular qualquer 
lógica que quiser dentro do método estático, incluindo delegação para outros 
métodos, quer sejam estáticos, quer de instâncias. 
Entretanto, só porque seus métodos são estáticos, isso não significa que seus dados 
devam estar em campos estáticos. De fato, quase nunca uso campos estáticos a 
menos que eles sejam constantes. 

Antes que você decida sobre como armazenar seus dados, pense no escopo 
dos mesmos. Os dados de um Registro podem variar com diferentes contextos de 
execução. Alguns deles são globais por todo o processo; alguns, globais em uma 
J/,read; e alguns, globais em uma sessão. Escopos diferentes pedem implementações 
diferentes, mas não pedem interfaces diferentes. O programador da aplicação não 
tem que saber se uma chamada a um método estático produz dados cujo escopo é 

o processo ou a thrend. Você pode ter diferentes Registros para diferentes escopos, 
mas também pode ter um único Registro no qual diferentes métodos têm diferentes 
escopos. 
Se os seus dados forem comuns a todo um processo, um campo estático é uma 
opção. Entretanto, raramente, uso campos estáticos mutáveis, porque eles não per



CAPhULO 18 • PADRÕES BAsrcos 449 

mitem a substituição. Pode ser extremamente útil ser capaz de, com alguma finaLidade 
especifica, substituir um Registro, especialmente para testes (o Plugi11 (465) é uma 
boa maneira de fazer isso). 

Dessa forma, para um Registro com escopo de processo, a opção usual é umsingleton 
[Gang ofPour). A classe Registro contém um único campo estático que c1rma"ena 
uma instância do Registro. Quando as pessoí'ls usam um singleton, elas freqüentemente 
obrigamo cliente a explicitamente acessar os dados subjacentes (Registro. iostânciaúnica 
( UerBobo( ) ) , mas eu prefiro um método estático que esconda o objeto 
singleton de mim (Registro. lerBobo( ) ) . Isso funciona especialmente bem, já que as linguagens 
baseadas em C permitem aos métodos estáticos acessar dados privados de 
instâncias. 

Os Si11gleto11s são largamente utilizados em aplicações com uma única thread, 
mas podem ser um problema em aplicações com diversas delas. Isso ocorre porque é 
mtJito fácil acontecer de diversas tlrrends manipularem o mesmo objeto de formas imprevisíveis. 
Você pode conseguir resolver o problema com sincronização, mas a dificuldade 
de escrever o cóctigo de sincronização provavelmente o levará a um hospício 
antes que você consiga eliminar todos os erros. Por esta razão, não recomendo o 
uso de um si11gleto11 para dados mutáveis em um ambiente de 11111/ti-tl1re11d. Isso fnnciona 
bem com dados imutáveis, já que qualquer coisa que não possa ser alterada 
não ter" problcmns causados pelo choque de tlzrcnds. Assim, algo como uma lista de 
todos os estados dos Estados Unidos é uma boa candidata para um Registro comescopo 
de processo. Tais dados podem ser carregados, quando um processo inicia, e 
nunca precisam de alteração, ou podem ser atualizados raramente com algum tipo 
de interrupção do processo. 

Um tipo comum de dados de Registro são dados com escopo de tl1rend. Um bom 
exemplo é uma conexão a um banco de dados. Neste caso, muitos ambientes lhe dão 
algum tipo de armazenamento específico de tl1rend, como a tl1read local de Java. Outra 
técnica é um dicionário no qual chave é uma tl1read cujo valor é um objeto de dados 
apropriado. Uma solicitação de uma conexão resulta em uma busca nesse dicionário 
pela thread corrente. 

O importante a lembrnr sobre dados com escopo de tl1rend é que eles não parecem 
diferentes dos dados com escopo de processo. Ainda posso usar um método como 
Registro.lerConexãoBD1 ) , que é a mesma forma de quando estou acessando dados 
com escopo de processo. 

Uma busca no dicionário também é uma técnicê\ que você pode usar para dados 
com escopo de sessão. Aqui você precisa de uma identificaçfio de sessão, mas ela pode 
ser colocada em um registro com escopo de tlire«d quando uma soliáti\ção tem inicio. 
Quaisquer acessos subseqüentes aos dados da sessão podem procurar os dados 
em um mapa cujas chaves são sessões usando a identificação da sessão mantida no 
armazenamento específico de thread. 

Se você estiver usando um Registw com escopo de flzrend com métodos estáticos, 
pode ter problemas de desempenho com diversas thrends passando por estes métodos. 
Neste caso, o acesso direto à instância da tJ,rend evitará o gargalo. 

Algumas aplicações podem ter um único Registro; outras podem ter vários. Os 
Registros são normalmente classificados pela camada do sistema ou pelo contexto de 
execução. Minha preferência é classificá-los pelo modo como são usados, e não pelô 
sua implementação. 


450 PARTE li • Os PADRÕES 

Quando Usá-lo 

Apesar do encapsulamento de um método, um Registro consiste ainda de dados globais 
e, como tal, é algo com o que não me sinto confortáve1. Quase sempre vejo alguma 
forma de Registro em uma aplicação, mas sempre tento acessar os objetos por 
meio de referências normais inter-objetos. Basicamente, você só deve usar um Registro 
como último recurso. 

Existem t1lternativas ao uso de um Rc,~isll'o. Uma épassar por parâmetros quaisquer 
dados necessários em vários pontos da aplicação. O problema é que os parâmetros 
têm de ser adicionados a chamadas de métodos em que eles não são necessários 
ao método invocado, mas a algum outro método que é chamado diversas camadas 
abaixo na árvore de chamadas. Passar um parâmetro adiante quando, durante 90% 
do tempo ele não é necessário, é o que me leva a usar um Registro. 

Uma êllternativa que tenJ,o vjsto ao uso do Rcgisfro é adicionar aos objetos, no 
momento cm que eles são criados, uma referência aos dados comuns. Embota isso leve 
a um parâmetro extra em um construtor, ele pelo menos é usado apenas por esse 
construtor. Ainda assim, é mais trabalho do que muitas vezes vale a pena, mas se você 
tiver dados que são usados apenas por um subconjunto das classes, esta técnica 
permite a você restringir as coisas deste modo. 

Um dos problemas com um Registro é que ele tem que ser modificado cada vez 
que você adiciona novos dados. É por isso que algumas pessoas preferem usar um 
mapa como seu armazenador de dados globais. Prefiro a classe explicita porque ela 
mantémos métodos explícitos, de modo que não há confusão sobre qual chave você 
usa para encontrar alguma coisa. Com uma classe explícita, você pode apenas olhar 

o código fonte ou a documentação gerada para ver o que está disponível. Com um 
mapa você tem que encontrar lugares no sistema onde os dados são lidos ou gravados 
no mapa para descobrir qual chave é usada, ou depender da documentação que 
rapidamente se torm, desatualizada. Uma cif!sse explícita também permite a você 
manter a segurança de tipos cm uma linguagem estaticamente tipada, assim como 
encapsular a estrutura do Registro, de modo quevocê possa refatorá-lo à medida que 
o sistema cresce. Além disso, um mapa simples não é encapsulado, o que toma mais 
difícil esconder a implementação. Isso é especiêllmente complicado se você tiver que 
alterar o escopo de execução dos dados. 
Assim, existem situações em que é correto usar un, Registro, mas lembre-se de 
que quaisquer dados globais são sempre culpados, até que se prove o contnirio. 

Exemplo: Um Registro Singleton (Java) 

Considere uma aplicação que leia dados de um banco de dados e, a seguir, faça modificações 
nestes dados para transformá-los em informações. Bem, imagine um sistema 
razoavelmente simples que use Gafl"ivays de Linhas de Dados (158) para o acesso n 
dados. Este sistema tem objetos de busca para encapsular as consultas ao banco de 
dados. Os buscadores ficam melhor em instâncias porque, desta forma, podemos 
substittú-los para criar umSt11b de Serviço (469) com o propósito de testes. Precisamos 
de um lugar para colocá-los. Um Registro é a escolha óbvia. 

Um registro singleton é um exemplo muito simples do padrão Singleton IGang 
of Pour]. Você tem uma variável estática para a instância única. 

class Regis,:.ro... 

private static Registro lerrnstância 1 1 


CAPÍTULO 18 • PADRÕES BÁSICOS 451 

recurn únicalnstância; 

private static Registro únicalnstância = new Registro ( ); 

Tudo que é armazenado no registro é armazenado na instância. 

class Registro... 

protected Buscador:>ePessoa buscadorDePessoa = new BuscadorDePessoa ( ); 

No entanto, para tornar o acesso mais fácil, torno os métodos públicos estáticos: 

class Registro... 

public static BuscadorDePessoa buscadorDePessoa 1 ) ( 
return lerlnstância( ) .buscadorDePessoa; 

Posso reinicializar o registro simplesmente criando uma nova instância única. 

class Registro... 

public static void inicializar ( ) 
únicalnstância = new Registro( t; 

Se eu qwser usar Stul>s de Serviço (469) para testes, uso em vez disso uma subclasse. 


class StubDoRegistro extends Registro... 

public StubDoRegistro 1 1 { 
buscadorOePessoa = new StubDoBuscadorDePessoa( I; 

O buscador do Stub de Serviço (469) apenas retoma instâncias codificadas expUcitamente 
do Gntcwny de Linhas de Dndos (158) da pessoa. 

class StubDoBuscadorDe?essoa ... 

public Pessoa buscar{long id) 
if (id == 1) ( 
return new Pessoa(•Fowler•, •Mar~in•, 10) i 

throw new !llegalArgumentRxception("Não foi possível encontrar :.d: • + String.·,alucOf (íd) 1; 
) 

Coloco um método no registro para inicializá-lo no modo st11b, mas, mantendo 
todo o comportamento do stub na subclasse, posso separar todo o código necessário 
para testes. 

class Registro... 

public static void inicializarstub 1 ) ( 
únicalnstância = ne~ StubDoRegistro ( ); 


452 PARTE li • Os PAORÕES 

Exemplo: Registro à Prova de Thread (Java) 

Mntt Foemmel e Mnrtin Fow/er 

O simples exemplo anterior não funcionará em uma aplicação 11wlti-t!,read na qual as 
diferentes lhrcnds precisam de seu próprio registro. Java fornece o mecanismo devariáveis 
de armazenamento específicas de tlzrend [Schmidt], que são locais a uma 
t11read, apropriadamente, chamadas de variáveis locais de tlirends. Você pode usá-las 
para criar um registro que seja ímico para uma tlrread. 

class RegistrooeThreadLocal ... 

prívate static ThreadLocal instâncias= oe~ ThreadLocal l ►; 
public static RegistroDeThreadLocal lerinstância ( 1 { 
return (RegistroDeThreadLocal) instâncias.geei >1 

O Registro precisa ser configurado com métodos para a obtenção e liberação 
deste registro. Normalmente, você faz isso no contexto de uma transação ou chamada 
de sessão. 

class P-egistroDeThread1ocal... 

public static voi<l início() { 
Assert.isTrue(instâncias.getl 1 =· null) ; 
instâncias.set(new RegiscroDeThread!.ocal ( )); 

) 

9ublic static void fim ( 1 { 
Assert.notNull(lerinstância ( ))r 
instâncias.set lnulll; 

Você pode então, como antes, armazenar buscadores de pessoas. 

class RegistroDeThreadLocal ... 

private BuscadorDePessoa buscadorDePessoa = new BuscadorDePessoa f) ; 
public stacic BuscadorDePessoa buscadorlle?cssoa 1 ) ( 
return lerlnstància( J.buscadorDePessoa; 

As chamadas de fora encapsulam o seu uso de um registro nos métodos inicioe fim. 

t:ry{ 
RegistroDerhreadLocal.inicio( ) : 
BuscadorOePessoa bl = RegistroDeThreadLocal.buscadorDePessoa ( 1; 
Pessoa martin = bl.buscar(l) ; 
assertEquals t• Fowler•, martin.lerSobrenorne{ 1 ) 1 

} rinally {RegistroDeThreadLocal.fiml ); 
) 


CAPITULO 18 • PADRÕES BÁSICOS 453 

Objeto Valor (Value Object) 

Um objeto pequeno e simples, como dinheiro 0 11 11ma faixa de datas, 

cuja igualdade não ébnsendn 11n identirlnde. 

Com sistemas de objetos de vários tipos, descobri que é útil rustinguir entre objetos 
referência e Objetos Valor. Dos dois, um Objeto Valor é geralmente o menor. Ele é scmeUlante 
aos tipos primitivos encontrados em muitas linguagens que não são puramente 
orientadas a objetos. 

Como Funciona 

Definir a diferença entre um objeto referência e um Objeto Valor pode ser um pouco 
complicado. De maneira geral, gostamos de pensar que Objetos Valor são pequenos 
objetos, tais como um objeto dinheiro ou uma data, enquanto que objetos referência 
são grandes, tais como um pedido ou um cliente. Tal definição é útil, mas irritantemente 
informal. 

A principal diferença entre objetos de referência e objetos valor reside em como 
eles lidam com a igualdade. Um objeto referência usa a identidade como base para a 
igualdade -talvez a identidade dentro do sistema de programação, tal como a identidade 
embutida das linguagens de programação 00, ou talvez algum tipo de número 
de identificação, como a d1ave primária em um banco de dados relacional. Um 
Objeto Valor baseia sua noção de igualdade em valores de campos dentro da classe. 
Assim, dois objetos data podem ser o mesmo objeto se seus valores de dia, mês e ano 
forem os mesmos. 

Essa diferença se expressa na maneira como você lida com elas. Uma vez que 
Objetos Valor são pequenos e facilmente criados, eles freqüentemente são passados 
por valor em vez de por referência. Você não se importa realmente com quantos objetos 
18 de março de 2001 existem no seu sistema. Tampouco se importa se dois objetos 
compartilham o mesmo objeto data físico ou seeles têm cópias diferentes, porém 
iguais. 

A maioria das liJ\gttagens não têm facilidades especiais pnra objetos valor. Parn 
que os objetos valor funcionem apropriadamente nestes casos, é uma boa idéia 
torná-los jmutáveis-ou seja, uma vez criados nenhum de seus campos muda. Arazão 
para isso é evitar problemas com apelidos (aliasing}. Tais problemas podem 
ocorrer quando dois objetos compartilham o mesmo objeto valor e um dos donos altera 
os valores nele. Assim, se Martin foi contratado no dia 18 de março e sabemos 
que Cindy foi contratada no mesmo dia, podemos estabelecer a data de contratação 
de Cindy como sendo a mesma de Martin. Se, a seguir, Martin é,ltera o mês da sua 
data de contratação para maio, a data de contratação de Cindy muda também. Quer 
seja correto1 quer não, não é o que as pessoas esperam. Normalmente, com valores 
pequenos como este as pessoas esperam alterar uma data de contratação substituindo 
o objeto data existente por um novo. Tomar os Objeto Valor imutáveis satisfazesta 
expectativa. 

Os Objetos Valor não devem ser persistidos como registi·os completos. Em vez 
russo, use um Valor Embutido (261} ou um LOB Serializado (264). Uma vez que os Objetos 
Valor são pequenos, um Vnlor Embutido (261) é geralmente a meJhor escolha porque 
ele também permite consultas SQL usando os dados em um Objeto Valor. 


454 PARTE li • Os PAORÕES 

Se você estiver executando uma quantidade grande de serialização binária, pode 
descobrir que otimizar a serialização dos Objetos Valor pode melhorar o desempenho, 
especialmente em linguagens como Java que não tratam Objetos Valor de modo 
especial. 

Para um exemplo de um Objeto Valor, veja Dinheiro (455). 

Implementação .NET 

.NET tem um tratamento de primeira classe para Objetos Valor. Em C# um objeto é 

marcado como um Objeto Valor declarando-o como uma struct em vez de como 

uma classe. O ambiente então o trllta com semântica de valor. 

Quando Usá-lo 

Trate algo como um Objeto Valor quando estiver baseando as igualdades em algo que 
não seja uma identidade. Vale a pena considerar isso para qualquer objeto pequeno 
que seja fácil de criar. 

Colisões de Nomes Tenho visto o termo Objeto Valor usado para este padrão já há algum 
tempo. Infelizmente, vi recentemente a comunidade J2EE [Alur et al.Jusar o termo 
"objeto valor" para significar um Objeto de Transferência de Dados (380), o que causou 
uma tempestade em um copo d'água na comunidade de padrões. Esta é apenas 
uma daquelas colisões sobre nomes que acontecem o tempo todo neste negócio. Recentemente 
[Alur ef nl.] decidiram usar o termo objeto de transferêncín. 

Continuo usando Objeto Vnlol' desta maneira, neste texto. Senão por nenhum 
outro motivo, ele me permite sêr consistente com meus escritos ,mteriores! 


CAl>fiULO 18 • PAORôES BÁSICOS 455 

Dinheiro (Money) 

Representa 11111 valor monetário. 

Dinheiro 

quantia 
moeda 

+,-, • 
alocar 

>, <, <"", >=, = 

Uma grande proporção dos computadores no mundo manipulnm dinheiro, então 
sempre me intrigou que dinheiro não seja realmente um tipo de dados de primeira 
classe em nenhuma das principais linguagens de programação. A falta de um tipo 
causa problemas, os mais óbvios envolvendo moedas. Se todos os seus cálculos forem 
feitos em uma única moeda corrente, este não é um grande problema, mas uma 
vez que você envolva diversas moedas, você quer evitar adicionar seus dó.lares aos 
seus ienes sem levar as diferenças de moeda em consideração. O problema mais sutil 
é com o arredondamento. Cálculos monetários são muitas vezes arredondados para 
a menor unidade da moeda. Quando você faz isso, é fácil perder alguns centavos 
(ou o seu equivalente local) devido aos erros de arredondamento. 

O bom a respeito da programação 01·ientada a objetos é que você pode consertar 
estes problemas crja_ndo uma classe Dinheiro que lide com eles. Éclaro que ainda 
é surpreendente que, cm verdade, nenhuma das bibliotecas principais de classes básicas 
faça isso. 

Como Funciona 

A idéia básica é ter uma classe Dinheiro com campos para a quantidade numérica e 
a moeda corrente. Você pode armazenar a quantidade como um tipo inteiro ou um 
tipo decimal fixo. O tipo decimal é mais fácil para algumas manipulações, o integral 
para outras. Você deve evitar completamente qualquer tipo de ponto Autuante, pois 
isso introduzirá o tipo de problemas de arredondamento cuja finalidade de Dinheiro 
é evitar. Na maior parte do tempo, as pessoas querem valores monetários arredondados 
para a menor unidade da moeda, como os centavos no dólar. Entretanto, há vezes 
em que unidades fracionárias são necessárias. É importante deixar claro com que 
tipo de dinheiro você está trabalhando, especialmente em uma aplicação gue usa ambos 
os tipos. Faz sentido ter diferentes tipos para os dois casos, pois eles se comportam 
de forma bastante diferente no que dii respeito à aritmética. 

O dinheiro é um Objeto Valor (453), então deve ter suas operações de igualdade 
e código hash sobrescritas para serem baseadas na moeda coJTente e na quantia. 

O dinheiro precisa de operações aritméticas, de modo que você possa usar objetos 
desse tipo tão facilmente quanto usa números. Contudo, operações aritméticas 
com dinheiro têm algumas diíerenças importantes em relação às operações com dinheiro 
em números. A mais óbvia, qualquer adiçiiio ou subtração precisa ter ciência 
da moeda, de modo que você possa reagir se tentar adicionar diferentes tipos de 
moedas. A resposta mais simples, e mais comum, é tratar a adição de moedas incom



456 PARlE li • Os PAORÕES 

patíveis como um erro. Em algumas situações mais sofisticadas, você pode usar a 
idéia de Ward Cunningham de um saco de dinheiro. Esse é um objeto que contém 
moedas de tipos diferentes juntas em umobjeto. Este objeto pode então participar de 
cálculos como qualquer objeto dinheiro. Ele também pode ser avaliado em uma moeda 
em particular. 

A multip1icação e a divisão acabam sendo mais complicadas devido a problemas 
de arredondamento. Quando você multiplica cünheiro, faça isso com uma grandeza 
escalar. Se você quiser adicionar uma taxa de 5% a uma conta, multiplique-a 
por 0,05, de modo que você se preocupe apenas com a multiplicação por tipos numéricos 
normais. 

A complicação vem com o arredondamento, especialmente ao alocar dinheiro 
entre lugares diferentes. Aqui está o simples enigma de Matt Foemmel. Suponha que 
eu tenha uma regra de negócio que diga que tenho de alocar a totalidade de uma importância 
em dinheiro entre duas contas: 70% para uma e 30% para outra. Tenho 5 
centavos para alocar. Se eu fizer o cálculo matemático, acabo com 3,5 centt1vos e 1,5 
centavo. Não importa de que maneira eu arredonde essas quantias, arrumo um problema. 
Se eu fizer o arredondamento costumeiro para o mais próximo, então 1,5 vira 
2 e 3,5 vira 4. Assim eu acabo ganhando 1 centavo. Arredondar para baixo me dá 4 
centavos e arredondai· para cima me dá 6. Não há um esquema geral de arredondamento 
que eu possa aplicar que tanto evite a perda quanto o ganho de 1 centavo. 

Tenho visto diversas soluções para esse problema. 

• Talvez a mais comumseja ignorá-lo -afinal, é apenas 1 centiwo aqui e ali. Entretanto 
isso tende a deixar os contadores compreensivelmente nervosos. 
• Ourante a alocação você sempre executa a última alocação subtrnindo do que 
você já alocou até o momento. Isso evita a perda de centavos, mas você pode 
ter o acúmulo de uma quantia significativa de centavos na última alocação. 
• Permita aos usuários de uma classe Dinheiro declarar o esquema de arredondamento 
quando eles chamam o método. Isso permite a um programador dizer 
que o caso dos 70% arredonda para cima e o dos 30% para baixo. As coisas 
ficam mais complicadas quando você tem de fazer a alocação por dez 
contas em vez de duas. Você também tem que se lembrar de arredondar. Para 
encorajar as pessoas a lembrar, tenho visto algumas classes Dinheiro forçarem 
a existência de um parâmetro para arredondamento na operação de 
multiplicação. Isso não apenas obriga o programador a pensar sobre qual arredondamento 
precisa, mas também poderia lembrá-lo dos testes a escrever. 
Entretanto, isso se torna confuso se você tiver muitos cálculos de taxas que 
sejam todos arredondados da mesma maneira. 
• Minha solução favorita: tenha uma função de alocação na classe Dinheiro. O 
parâmetro para o alocador é uma lista de números, representando a proporção 
a ser alocada (ele se pareceria com algo como umDinheiro.alocar[7,3))). O 
alocador retoma uma lista de objetos dinheiro, garantindo que nenhum centavo 
seja perdido espalhando-os pelos objetos dinheiro alocados de um modo 
que, de fora, pai;ece pseudo-randômico. O alocador tem suas faU1as: você 
tem que se Jembrar de usá-lo e quaisquer regras precisas sobre para onde devem 
ir os centavos são difíceis de impingir. 

CAPITULO 18 • PADRÕES BÁSICOS 45 7 

A questão fundamental aqui é entre usar multiplicação para determinar o valor 
de uma cobrança proporcional (como um imposto) e usá-la para alocar uma soma de 
dinheiro em ctiversos lugru·es. A muJtiplicação funciona bem no primeiro caso, mas 
um alocador f1.i.nciona melhor para este último. O importante é considerar sua intenção 
ao usar mufüplicação ou divisão em um valor monetário. 

Você pode querer converter de um tipo de moeda para outro com um método 
como umDinheiro.converterPara{Moeda .OOLLARS). O modo óbvio de fazer isso é procurar 
urna taxa de câmbio e multiplicar por ela. Embora funcione em muitas situações, há 
casos em que não funciona -novamente devido ao arredondamento. As regras de 
conversão entre as moedas européias tinham arredondamentos específicos aplicados 
que faziam uma simples multiplicação não funcionar. Assim, é sensato ter um objeto 
conversor para encapsuhtr o ;ilgoritmo. 

As operações de comparação permitem-lhe ordenar objetos de dinheiro. Assim 
como a operação de adição, as conversões precisam ter ciência da moeda. Você pode 
escolher ou levantar uma exceção ao comparar moedas diferentes ou fazer uma conversão 
entre elas. 

Uma classe Dinheiro pode encapsular o comportamento de impt-essão. Isso torna 
muito mais fácil fornecer uma boa apresentação em interfaces com o usuário e relatórios. 
Uma classe Dinheiro também pode analisar uma slring para fornecer um 
mecanismo de entrada que conheça moedas, o que, novamente, é muito útil para a 
interface como usuário. Aqui, as bibliotecas da sua plataforma podem ajudar. Cada 
vez mais as plataformas fornecem suporte à globalização com formatadores de números 
explícitos para países específicos. 

Armazenar um objeto Dinl,eiro em um banco de dados sempre traz um problema, 
uma vez que os bancos de dados também não parecem entender que dJnheiro é 
importante (embora seus vendedores entendam.) O caminho óbvio a tomar é usar 
um Vnlor Embutido (261), o que resulta em armazenar uma moeda para cada objeto 
dinheiro. Isso pode ser exagerado quando, por exemplo, uma conta possa ter todos 
os seus lançamentos em libras. Neste caso, você pode armazenar a moeda na conta e 
alterar o mapeamento do banco de dados para trazer a moeda da conta sempre que 
você carregar os lançamentos. 

Quando Usá-lo 

Uso Dinheiro para quase todo cálculo numérico em ambientes orientados a objetos. A 
razão principal é encapsular a manipulação do comportamento de arredondamento, 

o que ajuda a reduzir os problemas de erros de arredondamento. Outrr1 razão para 
usar Dinheiro é tornar muito mais fácil o trabalho com diversas moedas. A objeção 
majs comum a Dinheiro é o desempenho, embora raramente eu tenha ouvido falarde 
casos em que ele fez qualquer ctiferença perceptível, e mesmo nesses casos o encapsulamento, 
muitas vezes, torna mais fácil a otimização. 
Exemplo: Uma Classe Dinheiro (Java) 

por Mntt Foemmcl e Mnrti11 Fowler 

A primeira decisão é que tipo de dados usar para a quantia. Se alguém precisar ser 

convencido de que um número de ponto fluhmnte é uma má idéia, peça a ele para 

rodar este código. 


458 PARTE li • Os PADRÕES 

double val = O.OO; 

for (1nt i =O; i< 10; i+~) val ~• 0.10; 

System.out .println(val == 1.00) 1 

Com os números em ponto flutuante descartados, a escolha fica entre inteiros e 
decimais de ponto fixo, o que em Java se resume a BigDecimal, Biglnteger e long. Usar 
um valor inteiro de fato torna a matemática interna mais fácil, e se usarmos long podemos 
usar primitivas e, assim, ter expressões matemáticas legíveis. 

class Dinheiro... 
private long quantia; 
private CUrrency moeda; 

Estou usando uma quantia inteira, ou seja, a quantidade da menor unidade básica 
da moeda, a quaJ chamo de centavos no código porque este é umnome tão bom 
quanto qualquer outro. Com um lipo long obtemos um erro de estouro (overflow) se o 
número ficar grande demais. Se você nos der $92.233.720.368.547.758,09 escreveremos 
para você uma versão que use Bigintegers. 

É útil fornecer construtores de diversos tipos numéricos. 

public Dinheiro (double quantia, CUrrency moeda! { 
this.moeda =moeda; 
this.quancia = Math.round(quantia • fator-Centavos( 1); 

public Dinheiro (long quantia, Cunency moeda) 
this.moeda = moeda; 
tbis.quantia =quantia * facorCentavos( l; 

private static final int! l centavos= ne~ intl l {1, 10, :oo, 1000}; 
privace int fatorCentavos { ) { 
retum centavos(moeda.getOefaultFract1onDigits( )1: 

Diferentes moedas têm diferentes quantias fracionárias. A classe. Currency de 
Java 1.4 lhe informará o número de dígitos fracionários em uma classe. Podemos determinar 
quantas unidades menores há em uma unidade maior elevando dez à potência, 
mas isso é tão trabalhoso em Java que o nrrny é mais fácil (e provavelmente 
mais rápido). Estamos preparados para aceitar o fato de que este código fall1a se alguém 
usar quatro dígitos fracionários. 

Embora, na maior parte do tempo, você vá querer usar diretamente as operações 
na classe dinheiro, há ocasiões em que você precisará acessar os dados encapsulados. 


class Dinheiro ... 

public BigDecimal quantia 1 ) 
return BigOecimal.valueOf(quantia, moeda.getDefaultFraccionDigits( I) ; 

publ ic Currency moedA ( l 
return moeda; 


CAPITULO 18 • PADRÕES BÁSICOS 459 

Você deve sempre questionar seu uso de métodos de acesso. Quase sempre há 
uma maneira melhor que não quebrará o encapsulamento. Um exemplo que não poderfomos 
evitar é o mapeamento de banco de dados, como em Vnlor Embutido (261 ). 

Se você usar muito freqüentemente uma moeda para quantias literais, um construtor 
auxiliar pode ser útil. 

class Dinheiro... 

public static Dinheiro dólares (double quantia) ( 
return oew Dinheiro (quantia, Currency.USDl ; 

Como Dinheiroé um Objeto Vnlor (453), você precisará definir equnls. 

class Dinheiro... 

public boolean equals IObject outro) 
return (outro inscanceof Dinheiro) && equals l \DinheiroJoucro); 

) 

public boolean equals !Dinheiro outro) { 
return inoeda.equals(outro.moeda) &.& (quantia •= outro.quantia) i 

E sempre que houver um método equnls deveria haver um lms/J. 

class Dinheiro. , . 

public int hashCode() 
retu.."11 (inc) (quantia A (quantia >>> 321); 

Começaremos pela aritmética com a adição e a subtração. 

c!ass Dinheiro... 

public Dinheiro adicionar(Dinheiro outro) 
asserçâoMesr.iaMoedaQue (outro) i 
return novoDinheiro !quantia+ outro.quantia); 

private void asserçàoMesmaMoedaQJe lDinheiro parãir.etro) 
Assert.equals (•erro de co:nparacão de moedas•, moeda, parâ~etro.moeda); 

private Dinheiro novoDinheiro(long quantia> 
Dinheiro dinheiro= ne~ Dinheiro( ); 
dinheiro.moeda= this.moeda; 
dinheiro.quantia= quantia, 
return dinheiro; 

Perceba aqui o uso de um método fábrica privado que não faz a conversão 
usual para a quantia baseada em centavos. Usaremos isso algumas vezes dentro do 
próprio código da classe Dinheiro. 

Com a adição definida, a subtração é fácil. 


460 PARTE li • Os PADRÕES 

class Dinheiro... 

public Dinheiro subtrair(Oinheiro outro) 
asserçãoMesmaMoedaQue(outro); 
return novoDínheiro(quantia -outro.quantia); 

O método base para a comparação é compararCom. 

class Dinheiro... 

public int comparatComfObjeco outto) 
return oompararCo.~((Dinheiro) outro}; 

public int compararCom(Oinheiro outro) { 
asserção~!esoaMoe<laQue (outro!; 
íf (quantia< outro.quantia) return -1; 
else if (quantia== outro.quantia) return O; 
else retum 1; 

Embora, atualmente, isso seja tudo o que você consegue na maioria das classes 
Java, achamos que o código fica mais legível com os outros métodos de comparação 
tais como estes. 

class Dinheiro... 

public boolean maiorDoQue(Dinheiro outro) 
retum fcompararCom(outrol > O) ; 

Agora estamos prontos para olhar a multiplicação. Estamos fornecendo um 
modo de arredondamento padrão, mas você pode também configurar o seu próprio. 

class Dinheiro.. . 

public Dinheiro ~ultip)icar\double quantia) 
return multiplicar(new Bi9Decimal (quantia)); 

public Dinheiro oultiplicar{BigDecimal quantia) { 
return multiplicar)quantia, BigDecimal.ROUND_HALF_BVENI; 

public Dinheiro ~ultiplicar{BígDeci~al quantia, int modoDeArredonàar.entol 
return new Dinheiro{quantial ) .rwltiplicar(quantia), moeda, modoDeArredondamento); 

Se você quiser alocar uma importância em dinheiro entre muitos destinatários 
e não quiser perder centavos, irá precisar de um método de alocação. O mais simples 
deles aloca a mesma quantia (quase) entre vários destinatários. 

class Dinheiro. .. 

public Dinheiro( l alocar(int n) 
Dinheiro resultadcBaixo = novoDinheiro(quantia / n); 
Dinheiro resultadoAlto ~ novoOinheiro(resultadoBaixo.quancía ,1); 


CAPÍTULO 18 • PADRÕES BÁSICOS 461 

Dinheiro( 1 resultados= ne~ D.inheiro(nl; 
int resto= (int) quantia\ n; 
for (int i = O; i < resto; i••l resultados(il : resultadoAlto; 
for (int i = resto; i < n; i••) resultados(i] = resultadoBai.xo; 
return resultados; 

Um algoritmo de aJocação mais sofjsticado pode Lidar com qualquer razão. 

class Dinheiro... 

public Dinheiro( l alocar (lon9l ] razões) ! 
long total=-O; 
for (ínt i: O; i < razões.length; i~+l total+= ra2õeslil; 
long resto = quantia; 
Dinheiro ( l resultados= new Dinheiro(razões.length]; 
for (int i = O; i< resultados.length; it~I { 

resultados[il = novoDinheirolguantia • razõeslil / total); 
resto-= resultados li) .quantia; 

for (int i = O; i < resto; i+~) 
resultadosfi] .guantia+t; 

return resultados; 

Você pode usar isso pai-a resolver o Enigma de Foemmel. 

class Dinheiro... 

public void tésteAlocar2( ) { 
long[ l alocação= {3,7}; 
Dinheiro( J resultado= Dinheiro.dólares(0.05) .alocar(alocaçào): 
assertEquals(Oinheiro.d6lares(0.02), resultado[OI); 
assertEquals(Dinheiro.dólares(0.03), resultadollll; 


462 PARTE li • Os PADRÕES 

Caso Especial (Special Case) 

Umn subclasse q11e fornece compol'tfllllento especial 
pnra casos particulares. 

Cliente 

Cliente Cliente 
Não Encontrado Desconhecido 

Os nulos são coisas complicadas em programas orientados a objetos porque eles 
frustram o polimorfismo. Normalmente, você pode invocar o método bobo livren1ente 
em un1a variável que seja uma referência para um determinado tipo sem se preocupar 
se o item pertence a este tipo ou uma subclasse. Com uma linguagem fortemente 
tipada, você pode até mesmo fazer o compilador verificar sea chamada é correta. 
Entretanto, já que uma variável pode conter um nuJo, você pode se depan,r com 
um erro cm tempo de execução ao invocar uma mensagem sobre um nulo, o que lhe 
dará um belo e amigável rastreamento de pilha. 

Se for possível que uma variável seja nula, você tem que lembrar de cercA-la 
com código para testar a condição nula, de modo que você possa fazer a coisa certa 
se um nulo estiver presente. Mttitas vezes, a coisa certa é a mesma em muitos contextos, 
então você acaba escrevendo código sinular cm muitos lugares -cometendo o 
pecado da duplicação de código. 

Os nulos são um exemplo comum de tais problemas, e outros aparecem regularmente. 
Em sisten1as numéricos você precisa lidar com o infinito, que tem regras 
especiais para coisas, como a adição, que quebram as invariantes costumt?iras dos 
números reais. Uma das minhas primeiras experiências em sof tware de negócio foi 
com um cliente de um serviço que não era completamente conhecido, referido como 
"ocupante." Todos estes sugerem a alteração do comportamento usual do tipo. 

Em vez de retornar nulo, ou algum valor estranho, retorne um Cnso Especínl que 
tenha a mesma interface da que o solicitante espera. 

Como Funciona 

A idéia básica é criar uma subclasse para tratar o Cnso Especial. Assim, se você tiver 
um objeto Cliente e quiser evitar verificações de nulos, cria um objeto Cliente nulo. 
Pegue todos os métodos do Cliente e sobrescreva-os no Caso Especial para fornecer algum 
comportamento inofensivo. Então, sempre que você tiver um nuJo, coloque 
uma instância do cliente nulo no seu lugar. 

Geralmente, não existe nenhumn razão para distinguir entre inst~ncias diferentes 
do cliente nulo, de modo que, freqüentemente, você pode implementar um Caso 
Especial com um peso-mosca [Gang of Four). Você não pode fazer isso todo o tempo. 


CAPITULO 18 • PAORôES BÁSICOS 463 

Para um serviço, você pode acumular débitos de um ocupante, mesmo que você não 
possa sempre entregar a conta, de modo que é importante manter os ocupantes separados. 


Um nulo pode significar coisas diferentes. Um cliente nulo pode significar a nãoexistêncict 
de um diente ou pode significar que existe um cliente mas não sabemos 
quem ele é. Em vez de usar somente um cliente nulo, considere ter Casos Especiais separados 
para clientes ausentes ou desconhecidos. 

Um modo comum de um Caso Especial sobrescrever métodos é retomar outro 
Caso Especial, então, se você pedir a um cliente desconhecido a sua última conta, pode 
bem obter uma conta desconhecida. 

A aritmética de ponto flutuante CEEE 754 oferece bons exemplos de Casos Especiais 
com infinito negativo, infinito positivo e não-é-um-número (NaN). Se você dividir 
por zero, em vez de obter uma exceção a qual terá de tratar, o sistema simplesmente 
retorna NaN, e NaN participa de expressões aritméticas como qualquer outro 
número de ponto flutuante. 

Quando Usá-lo 

Use o Caso Especial sempre que, em diversos lugares do sistema, você tiver o mesmo 
comportamento após uma verificação condicional da ocorrência de uma instância 
particular de uma classe, ou o mesmo comportamento após uma verificação da ocorrência 
de nulos. 

Leitura Adicional 

Ainda não vi o Caso Especial escrito como um padrão, mas o Objeto Nulo foi descri


to em [Woolf]. Se você perdoar o trocadilho irresistível, vejo o Objeto Nulo como um 

caso especial do Caso Especial. 

Exemplo: Um Objeto Nulo Simples (C#) 

Aqui está um exemplo simples de um Caso Especial usado como um objeto nulo. 
Temos um empregado regular. 

class Empregado ... 

9ublic virtual String Nome l 
get{return _nome;} 
set(_noree = valor); 

private String _nome; 
public virtual llecimal TotalAtéOM~nto ( 
get{ret~rn calcularTotalDoPerioâo(0J;l 

public virtual Contrato contrato ( 
get{return _contrato;) 

pri,ate Contrato contratoi 

As características da classe poderiam ser sobrescritas por um empregado nulo. 


464 PARTE li • Os PADRÕES 

class ElnpregadoNulo: El!;pregado, lNUll ... 

public override String No:ne { 
get (return •E~.pregado Nulo•;} 
set ( ) 

} 
public override Decimal TotalAtéOiY,omento { 
gec{return Om;} 

) 

public override Contrato Contrato! 
get{return contrato.NULL;} 

Perceba que quando você pede a um empregado nulo seu contrato, obtêm de 
volta um co.ntrnto nuJo. 

Os valores padrão aqui evitam muitos testes para a verificação de nulos se eles 
acabam com os mesmos valores nulos. Os valores nulos repetidos são manipulados 
pelo objeto nulo por defn11lt. Você também pode testar a ocorrência de nulos explicitamente 
dando ao cliente un1 método éNulo ou usando uma verificação de tipo para 
uma interface de sinalização. 


CAPhULO 18 • PADRÕES 8ÃSICOS 465 

Plugin 

por David Rice e Mal/ Foemmcl 
Co11ectnclasses durante a confígurnçno l>/11 vez de 11a compilação. 

Objeto do «interface» 

?

Domínio ~--------Gerador de 10 • 

A lnterfnce Separada (445) é freqüentemente usada quando o código da aplkação roda 
em múltiplos ambientes de execução, cada um deles requerendo implementações djferentes 
de um comportamento especifico. A maioria dos desenvolvedores fornece a 
implementação correta escrevendo um método fábrica. Suponha que você defina seu 
gerador de chave primária com uma Interface Separada (445), de modo que você possa 
usar um contador simples em memóriê'l parn testes de unidade, mas uma seqüência 
gerenciada pelo banco de dados para código de produção. Seu método f~brica 
conterá provavelmente uma declaração condicional que olha uma variável de ambiente 
local, determina se o sistema está em modo de teste e retorna o gerador de 
chaves correto. Uma vez que você tenha algumc1s fábricas, tem uma bc1gunça nas 
mãos. Estabelecer uma nova configuração de distribuição -digamos "execute testes 
de urúdade contra a base de dados na memória sem contmle de transações" ou" execute 
no modo de produção cm um banco de dados 0B2 com controle de transações 
integral" -requer editar declarações condicionafa em várias fábricas, reconstruir e redistribufr. 
A configuração não deveria ser dispersa por toda a sua aplicação, nem deveria 
requerer uma reconstrução ou redistribuição. Um Plugin resolve ambos os problemas 
fornecendo a configuração em tempo de execução e centralizada. 

Como Funciona 

A primeira coisa a fazer é definfr com uma lnfcrface Sepamdn (445) quaisquer comportamentos 
que terão implementações diferentes baseadas no ambiente de execução. 
Além disso, usamos o padrão fábrica básico, apenas com alguns requisitos especiais. 
A fábrica Pl11gin requer que suas instruções de conexão sejam declaradas em um único 
ponto externo para que a configuração possa ser gerenciada com facilidade. Adicionalmente, 
a conexão com as implementações devem ocorrer dinamícamente em 
tempo de execução, em vez de durante a compilação, de modo que a reconfiguração 
não irá requerer uma reconstrução. 

Um arquivo texto funciona bastante bem corno meio de declaraçiio de regras de conexão. 
A fábrica Plugin irá simplesmente ler o arquivo texto, buscar uma entrada especificando 
a implementação de uma interface requerida e retomar essa implementação. 

O Pfllgin funciona melho.r em uma linguagem que suporte reflexão porque a fábrica 
pode construir implementações sem dependências de tempo de compilação. 
Ao usar reflexão, o arquivo de configuração deve conter os mapeamentos dos nomes 
na interface para os nomes na classe de implementação. A fábrica pode permanecer 
independentemente em um pacotefrnmework e não precisa ser alterada quando você 
adiciona novas implementações às suas opções de configuração. 

Mesmo quando você não estiver usando uma Linguagem que suporte reflexão, 
ainda vc1le a pena estabelecer um ponto central de con.figurnção. Você pode até mes



466 PARTE li • Os PADRÕES 

uma uma 
solicitante fábrica 
pfügín 
coatigyrasão 
e eug_m 
lerPlugin 
1 
1-.-
1 
1 
1 
procurarPluginPeloTipo 1 
-1-u 
novo 1 
1 
1 --
umelugJn 
1 
T 1 
1 1 
1 1 

Figura 18.2 Um solicitante obtém uma implementação Plugin de uma interface separada. 

mo usar um arquivo texto para estabelecer as regras de conexão, com a única diferença 
de que sua fábrica usc1rá lógica condicional para mapear uma interface para a implementação 
desejada. Cada tipo de implementação deve ser contemplada na fábrica 
-na prática, isso não é nada demais. Apenas acrescente outra opção dentro do método 
fábrica sempre que você adicionar uma nova implementação ao código base. 
Para forçar as dependências de camada e de pacote com uma verificação em tempo 
de construção, coloque esta fábrica no seu próprio pacote para evitar interromper 
seu processo de construção. 

Quando Usá-lo 

Use Plugin toda vez que tiver comportamentos que requeiram implementações diferentes 
baseadas no ambiente de execução. 

Exemplo: Um Gerador de Identidades (Java} 

Como discutido acima, a geração de chave ou JDs é uma tarefa cuja implementação 
poderia variar entre ambientes de distribLtição (Fi.gura 18.3). 
Primeiro, escreveremos a Interface Separada (445) GeradorOeJd assim como 
quaisquer implementações necessáiias. 

1nte.rface GeradorOeld ... 

public Long próximatd() 1 

class GeradorDeldOracle in:plei::ents GeradorOeld.. . 

public Geradoroerdoracle () { 
this.segúência= Environn:ent.getProperty(•id.sequence•); 
this.fontededados = Environment.getPropertyl•id.source•) ; 

No GeradorDeidOracle, próximold( ) seleciona o próximo número disponível de 
uma seqüência definida de uma fonte de dados definida. 


CAPITULO 18 • PADRÕES BÁSICOS 467 

«interface» 
Gerador de 1D 

Objeto do 
Domínio 
próximafd 
1 
l 
1 
1 
l 
1 
1 
1 
1 
1 
Oracle 
Gerador de 1D 
Contador 
1 
1 
1 
próximald próximald 
1 
1 
1 
Plugins 
1 
1 

______________________________J

1 

carregarlnstãncia 

\ 
\ 
\ 
\ 
\ 
\ 
\ 
\ 

if (em Teste) return new Contador 
if (em Produção) return new GeradorDeldOracle 

Figura 18.3 Múltiplos geradores de identidade. 

class Contador i~ple~ents GeradorDeid ... 

private long contador: O; 
public synchronized Long pr6'-Jmold() 
return ne~ I.ong(concador++); 

Agora que temos algo parn construir, vamos escrever a fábrica pl11gi11 que realizará 
os mapeamentos correntes da interface para a implementação. 

class FábricaPlugin.. . 
private static Properties props = new Propertiesl 1; 

static { 

try { 
String arquivoDePropriedades = System.gecProperty("plugins•); 
propriedades. load (ne11• FilelnputStream(arquivoDePrcpr:edadesl) 1 

) catch (Exception ex) { 
thro·, oe·,; ExceptionintnitializerBrror(ex); 

public static Object lerPlugin {Cl ass iface) 
String naneDalmplementação: propriedades.getProperty(iface.getNamel )I ; 
if (nomeDaimplementação := nulll { 

thro" nE!lt Runcime8xception (•itt;plei:entação não especiéicada para " i 


468 PARTE li • Os PAORÕES 

iface.getHan:e( 1 • • nas propriedades da FáhricaPlugin.•); 
l 
try { 
return Class.forName(nomeDalmplementaçãol .ne"Ainstancel I; 
) catch {Sxception ex) l 
thro~ ne~ Runti~eBXception{"fábrica incapaz de criar instância de•• 
iface.getName( )I; 

Perceba que estamos carregando a configuração procurando por um.a propriedade 
de sistema chamada p/11gi11s que localizará o arquivo contendo nossas instruções 
de conexão. Existem muitas opções para definir e armazenar instruções de conexão, 
mas achamos que um simples arquivo de propriedades é a mais fáàl. Usar a 
propriedade de sistema para encontrar o arquivo, em vez de olhar no classpatlz, torna 
simples especificar uma nova configuração em qualquer lugar da sua máquina. Isso 
pode ser muito conveniente ao mover construções (builds) entre c1mbientes de desenvolvimento, 
teste e produção. Aqui está como dois arquivos diferentes de configuração, 
um parn teste e um para produção, poderiam se parecer: 

ai:quivo de configuraç~o teste.propriedades... 

#configuração para teste 

GeradorDeid; GeradorDeidTeste 

arquivo de configuração produção.propriedades... 

#configuração para produção 

GeradorDeid ; GeradorDeidOracle 

Vamos voltar à interface GeradorDeld e adicionar um membro estático INSTANCE 
que é configurado por uma chamada à fábrica Plugin. Ela combina o Pl11gi11 com opadrão 
si11gleto11 para fornecer uma chamada extremamente simples e legível para obter 
um 1D. 

interface GeradorDeid... 

public static final Geradorlleld INSTAfiCIA: 
(GeradorDeidl FábricaPlugin.lerPluginlGeraàorDeld.classl; 

Podemos agora fazer essa chamada sabendo que obteremos o 1D correto para o 
ambiente correto. 

class Cliente extends ObjetoDoDo:ninio ... 

privac:.e Cliente {String nome, Long idl 
superhdl; 
this.noo.e • noir.e; 

public Cliente criar (String nome) 
Long novaldDoObjeto; GeradorOeid.INSTANCIA,próxifflaid( l; 
Cliente obj = newCliente(ncxne, novaldDoObjeto) 1 
obj.marcarNovo(); 
return obj; 


CAPhULO 18 • PAORôES BAstCOS 469 

Stub de Serviço {Service Stub) 

por David Ricc 
Remove depcndéncin de serviços problemáticos durn11le os testes. 

WSDL 

Serviço de Impostos ACME~Oobte,lnfonnaçáoSob,elmpo>to 

Interface 
Gerador Serviço de Impostos 
de Contas ~---~·~-----------! .......... 
obterlnf ormaçãoSobrelmposto .............. 
...., Classe 
Stub de Serviço de Imposto 
obterlnformaçàoSobrelmposto 

Sistemas corporntivos, muitas vezes, dependem do acesso a serviços de terceiros, tais 
como pontuação de crédito, busca por valores de taxas e mecanismos de determinação 
de preços. Qualquer desenvolvedor que já tenha criado tais sistemas pode falM 
de1 frusb·ação de depender de recursos completamente fora de seu controle. A entrega 
dessas características é imprevisível, e como esses serviços são muitas vezes remotos, 
a confiabilidade e o desempenho podem sofrer também. 

Esses problemas, no mínimo, diminuem a velocidade do processo de desenvolvimento. 
Os desenvolvedores ficam esperando pelo serviço voltar a operar ou talvez 
coloquem algo no código para compensar por características ainda por s~r~m entregues. 
Muito pior, e bastante provável, tais dependências levarão a vezes em que os 
testes não poderão ser executados. Quando os testes não podem ser executados, o 
processo de desenvolvimento é interrompido. 

Substituir durante os testes o serviço por um Stub de Serviço que rode em memória, 
rápida e localmente melhora a sua experiência de desenvolvimento. 

Como Funciona 

O pdmeiro passo é definir o acesso ao serviço com um Cnteway (436). O Gnteway (436) 
não deve ser uma classe, mas sim uma Jntcrfncc Scpnrndn (445) de modo que você possa 
ter uma implementação que chame o serviço real e, pelo menos, uma que seja apenas 
um Stubde Serviço. A implementação desejada do Gatewny (436) deve ser carregada 
usando um Plllgin (465). A chave para escrever um Stub de Serviço é que você o 
mantenha tão simples quanto possível -a complexidade frustrará o seu intento. 

Vamos investigar o prncesso de criar um st11b pare1 um serviço de impostos sobre 
vendas que, dado um endereço, tipo do produto e quantia vendida, fornece os 
valores e faixas dos impostos estaduais sobre vendas. A maneira mais simples de fornecer 
um Stub de Serviço é escrever duas ou três linhas de código que usem um valor 
de tributação simples que satisfaça todas as solicitações. 

As leis sobre impostos não são tão simples, é claro. Determim,dos produtos são 
isentos de impostos em certos estados, então confiaremos que o nosso serviço real de 
impostos saiba quais combinações de esrndo e produto são isentas. Entretanto, mui



470 PARTE li • Os PAORÕES 

to da funcionalidade da nossa aplicação depende de se os impostos s~o cobrados, então 
precisamos acomodar a isenção de impostos no nosso Stub de Serviço. O meio 
mais simples de adicionar este comportamento ao st11b é por meio de uma declarnção 
condicional que isente uma combinação específica de endereço e produto e, a seguir, 
use esses mesmos dados em quaisquer casos de teste relevantes. O número de linhas 
de código no nosso stub pode ainda ser contado com uma única mão. 

Um St11b de Serviço mais dinânúco mantém uma lista de combinações isentas de 
produtos e estados, permitindo aos casos de teste acréscimo a essa lista. Mesmo aqui 
temos em tomo de 10 linhas de código. Estamos mantendo as coisas simples dado 
nosso objetjvo de aumentar a velocidade do processo de desenvolvimento. 

O Stub de Serviço dfoâmico traz uma questão interessante relacionada à dependência 
entre ele e os casos de teste. O St11b de Serviço depende de um método de configuraç,
io para. adicionar isenções que não estejam na interface Gatewny (436) original 
de serviço de impostos. Para tirar proveito de um Plugin (465) para carregar o Stub de 
Serviço, este método deve ser adicionado ao Gntewny (436), o que é bom, pois ele não 
acrescenta muito ruído ao seu código e é feito em nome dos testes. Assegure-se de 
que a implementação do Gateway (436) que chama o serviço real levante faU1as de asserção 
dentro dos métodos de teste. 

Quando Usá-lo 

Use o Stub de Serviço sempre que descobrir que a dependênc.ia de um determinado 
serviço esteja retardando seu desenvolvimento e testes. 

Muitos t1deptos da Programt1ção Extrema usam o termo Objeto Falso p!'lra um 
Stub de Serviço. Permanecemos com St11b de Serviço porque ele tem estado em uso há 
mais tempo. 

Exemplo: Serviço de Impostos Sobre Vendas (Java) 

Nossa aplicaç-ão usa um serviço de impostos que é ctistribuído como un1 serviço Web. 
O primeiro item do qual cuidaremos é definir um Gnteway (436), de modo que nosso 
código do domínio não seja forçado a lidar com os mistérios dos serviços Web. O Gatewny 
(436) é definido como uma interface para facilitar a carga de quaisquer Stubsde 
Serviço que viermos a escrever. Usaremos um Pl11gi11 (465) para carregar a implementação 
correta do serviço de impostos. 

interface ServiçoDeimpostos ... 

public statk final ServiçoDelmpostos INSTMICIA : 
(ServiçoDeimpostos) PábricaPlugin.lerPlugin(ServiçoDel~postos.classl; 
public InformaçàoSobrelmposto obterlnfonnaçãoSobrel~stoSobreVendas 
(String códigoDoProduto, Enàereço endereço, Dinheiro quantiaVendidal; 

O Stub de Seruiço para um cálculo simples de tributação se pareceria com: 

class ServicoDeimpostosTaxaPlana 1mplements Serviçooermpostos... 

pri~ate static final BigDecimal TAXA_PLANA= new BigDeciina! (•o.osoo•); 
publ ic lnformaçãoSobrelmposto obterlnformaçàoSobre!apostoSobreVendas 
(String códigoDoProduto, Endereço endereço, Dinheiro quantiaVendidal 
return new JnformacãoSobrelmposto ITAXA_PLANA. quantiaVendida.multiplíca(TAXA_PLANA)); 


CAPITULO18 • PADRÕESBÁSICOS 471 

Aqui está um Stub de Serviço que fornece isenções de impostos para uma combinação 
específica de endereço e produto: 

class ServiçoDeimpostosProdutolsento implementa ServiçoDelmpostos... 

private static final BigDecical TAXA_lSENTO = new BigOecimal (•0.0000°) , 

private static final BigDecical TAXA_PLANA: new BigDecimal (•o.osoo•) ; 

private static final String ESTADO_ISEf;'l'() ="lL"; 

private static final String PRODUi'O_ISE!ITO= "12300"; 

public InfomaçãoScbrelmposto obterlnforrnacãoSobrelmpostOSobreVendas 

(String códigoDoProduto, .Endereço endereço, Dinheiro quantiaVendida) 

if {códigoDoproduto.equals(PROooro_rSENTO) && 

endereço.lerC6digoDoEstadol ).equals{ESTM>O_ISENTOl) { 

recuro ne~ lnformaçàoSobreimposto (TAXA_rsirnro,quantiavendida.rr.ultiplica (TAXA_ISEN'IO)1; 

} else { 

retum new lnformaçãoSobrelmposto(TAXA_PL.~.. guantiaVendida.rultiply(TAXA_PI.JI.NA)); 

Agora aqui está um Stub de Serviço mais dinâmico, cujos métodos permitem que 
um caso de teste adicione e remova combinações com isenção. Uma vez que achemos 
necessário adicionar estes métodos de teste, predsamos voltar e adicioná-los aos nossos 
Stubs de Serviço mais simples assim como à implementação que chama o serviço 
Web real para o cálculo de impostos. Os métodos de teste não usados deveriam todos 
causar falhas de asserção. 

class TesteDeServiçoOelmpostos irr.plemencs Sel'.',içoOelrepostos... 

private static Set isencões ~ new HashSet () ; 

publíc In[ormaçàoSobreimposto obterinformaçâoSobrelcpostoSobr~Vendas 

(String códigoDo?roduto, Endereço endereço, Dinheiro quantiaVendidal 

Bi9Decimal taxa= ler1'axa(c6digoDo?roduto, endereço); 

return new InformaçãoSobreimposto (taxa, quantiavendida.multiplica(taxa)) ; 

public scatic void adicionarisenção(String c6digoDoProduco, String códigoDoEscado) 

isenções.add( 1erchaveDaIsenção(códigoDoProduto, códigoDoEstado) ) ; 

public static void zerar( ) l 
isençtes.clear( ); 

private static BigOecical le!'I'axa(String códigoDoProduto, Endereço endereço) { 
iÍ(isenções.contains(lerChaveDalsençâo(c6di90Doproauto, endereço.lercódigoDoEstado( ))li 
recum V.xA_ISENTO; 
Jelse { 
retum TAXA_PWíh; 

Não é mostrada a implementação que chama o serviço Web que fornece os dados 
reais sobre os impostos, a qual a configuração do Pl11gi11 (465) de produção ligaria 
a interface do serviço de impostos. As configurações do nosso Pl11gi11 (465) de teste 
apontariam para o Stub de Serviço apropriado acima. 


472 PARTE li • Os PADRÕES 

Finalmente, qualquer solicitante do serviço de impostos deve acessar esse serviço 
atrav6s do Gntewny (436). Temos aqui um gerador de contas que cria contas padrão 
e então cham;i o serviço de impostos para criar quitisquer impostos correspondentes. 

class GeradorDeConta, .. 

public Conta{ J calcularContas (ProgramaçãoDePaturamento programação) 
List contas: ne•• ArrayList 1 1; 
Conta contaBásica = new Conta(programaçào,lerQuantiaPaturadal 11 false); 
contas.add (contaBásica); 
InfonnaçãoSobreimposto informação= 

ServiçoDelcpostos.INSTA!lCIA.obterlnformaçàoSObrelmpostoSobreVendasl 
programação. lerProduto( I , programação. lerBndereço1 ) , 
programaçào.lerQUantiaFaturadal }I; 

1fl infomação. JerTaxaEstadual ( ) .c<xapareTo(new BigDeciinal fO)) > O) 
Conta impostoDaConta: new C-0nta(informaçào.lerQuantiaDoEstado( l, truel ; 
contas.add (impostoDaConta); 

return (Contai J) contas.to~rray(new Cont.afcontas.sizel Ili; 


CAPhULO 18 • PAORôES BÁSICOS 473 

Conjunto de Registros {Record Set) 

Uma representação em 111e1116ria dr dados tab11/nres. 

Linha 

Conjunto -


Tabela 

de Regis1ros -•


* 

Coluna 

Nos últimos vinte anos, o modo dominante de representar dados em um banco de 
dados tem sido a forma relacional tabular. Apoiado pelas grandes e pequenas companhfas 
de banco de dados e uma li11guagem de consultas razoave1mente padrão, 
quc1se todo novo desenvolvimento que vejo usa dados relacionais. 

Al<5m disso., tem surgido uma profusão de ferramentas para a construção rápida 
de interfaces com o usuário. Esses fmmeworks baseiam-se no fato de que os dados 
correspondentes são relacionais, e eles fornecem controles conectados aos dados (data 
aware) de vários tipos para a interface com o usuário. Tais controles permitem a visualização 
e manipulação desses dados quase que sem programação. 

O lado ruim destes ambientes é que, embora tornem a exibição e as atualizações 
simples de dados ridiculamente fáceis, elas não oferecem um bom lugar onde colocar 
a lógica de negócio. Quaisquer validações além de ''estíl é uma dr1ta válida?", e 
quaisquer cálculos ou regras de negócio não têm i1m bom local para ir. Elas ficam ou 
jogadas no banco de dados como procedimentos armazenados ou mistmadas com o 
código da interface com o usuário. 

A idéia do Co11ju11to de Registros é dar a você o bolo e deixá-lo comer, fornecendo 
uma estrutura em memória que se pflreça exatamente com o resultado de uma 
pesquisa SQL, mas que possa ser gerada e manipulada por outras partes do sistema. 

Como Funciona 

Um Cc>11junfo de Registros é geralmente algo que você não irá construir sozinho, sendo 
fornecido pelo vendedor da plataforma de software com a qual você está trabalhrmdo. 
Exemplos incluem o conjunto de dados do ADO.NET e o conjunto de linhas 
doJDBC2.0. 

O primeiro elemento essencial de um Conj1111to de Registros é que ele se parece 
exatamente com o resu1té1do de uma consulta a um banco de dados. Isso significa 
que você pode usar a abordagem clássica em duas camadas de emitir uma 
consulta e jogar os dados diretamente em uma interface com o usuário diretamente 
conectada aos dados (data awnre) com toda a comodidade que essas ferramentas 
de duas camadas lhe dão. O segundo elemento essencial é que você mesmo 
pode criar facilmente um Conj11nlo de Registros ou pegar um que tenha resultado 
de uma consulta ao banco de déldos e manipulá-lo facilmente com código de 
lógica de domínio. 


474 PARTE li • Os PADRÕES 

Embora as plataformas, muitas vezes, füe dêem um Conj1111to de Registros, você 
mesmo pode criar um. O problema é que não há muito sentido nisso sem as ferramentas 
pilra as interfaces com o usuário conectadas aos dados (dntn nwnre) que, neste 
caso, voca mesmo precisaria criar. De qualquer forma é razoável dizer que criar 
uma estrutura de Co11ju11to de Registros como uma lista de mapas, o que é comum em 
linguagens de scripts dinamicamente tipadas, é um bom exemplo deste padrão. 

A habfüdade de desconectar um Co11j11nto de Regisfl'os de sua conexão à fonte de 
dados é bastante valiosa. Isso lhe permite passar o Conj1111fo de Registros adiante em 
uma rede sem ter que se preocupar com as conexões ao banco de dados. Além disso, 
se você puder scrializar facilmente o Co11j11nlo de Regislros, ele pode tambématuarcomo 
um Objeto de Tmnsferênâa de Dados (380) para uma aplicação. 

A desconexão traz a questão do que acontece quando você atualiza o Co11j1111l0 
de Registros. Cada vez mais, as plataformas estão permitindo que o Conjunto de Registros 
seja uma forma de Unidade de n-abnllto {187), de modo que você pode modificá-lo 
e então retorná-lo à fonte de dados para que seja gravado. Uma fonte de dados pode 
tipicamente usar um Bloqueio Offli11e Otimista (392) para verificar seexiste algL1n1conflito 
e, em caso contrário, gi-avar as alterações no banco de dados. 

Interface Explícita A maioria das implementações de Collj1t11tos de Regisfros usam 
uma interface implícita. Isso significa que, para extrair informações do Co11j11nto de 
Registros, você invoca um método genérico com um argumento para indicar qual 
campo você deseja. Por exemplo, para obter o passageiro de uma reserva de passagem 
aérea, você pode usar uma expressão como umaReserva("passageiro"]. Uma interface 
explícita requer uma classe Reserva real com métodos e propriedades definidos. 
Com uma reserva explícita, a expressão para o passageiro poderia ser umaReserva.
passageiro. 

As interfaces implícitas são flexíveis, visto que você pode usélr um Conjunto de 
Registros genérico para qualquer tipo de dados. Isso lhe poupa de ter que escrever 
uma nova classe cada vez que definir um novo tipo de Co11junlo de Registras. Em gerat 
no entanto, considero interfaces implícitas uma Coisa Ruim. Se estou programando 
uma reserva, como sei como obter o passageiro? A string apropriada é "passageiro" 
ou "convidado" ou ''viajante"? O único modo pelo qual posso descobrir é andar 
pelo código base tentando encontrar onde as reservas são criadas e usadas. Se eu tiver 
uma interface explícita, posso olhar a definição da reserva para ver a propriedade 
de que preciso. 

Este problema é exacerbado em linguagens tipadas estaticamente. Se eu qu.iser 

o sobrenome do passageiro, tenho que recorrer a alguma expressão horrível tal como 
((PessoalumaReserva !-passageiro'•)) .sobrenome, mas então o compifador perde toda a informação 
sobre os tipos e tenho que entrnr mar,ualmcnte com ela pata obter a informação 
que quero. Uma interface explícita pode manter a informação sobre os tipos, 
então posso usar umaReserva.passageiro. sobrenome. 
Por esses motivos, geralmente franzo as sobrancefüas para interfaces implícitas 
(e também para seu primo malvado, passar dados em dicionários). Também não sou 
muito fã deles com Co,ijuntos de Registros, mas o que se salva aquj é que o Co11ju11to de 
Registros geralmente carrega nele informação sobre ascolunas válidas. Além disso, os 
nomes de colunas são definidos pelo SQL que cria o Co11j1111to de Registros, então não 
é mtúto difícil encontrru· as propriedades quando você precisa delas. 

Contudo, é bom dar um pélsso adiante e ter uma interface explícita. ADO.NET 
fornece isso com seus conjuntos de dados fortemente tipados, classes geradas que 


CAPITULO 18 • PADRÕES BÁSICOS 475 

fornecem uma interface explicita e completamente tipa da para um Conjunto de Registros. 
Já que um conjunto de dados ADO.NET pode conter muitas tabelas e os relacionamentos 
entre eléls, conjuntos de dados fortemente tipados também fornecem propriedades 
que podem usar essas informações sobre relacionamentos. As classes são 
geradas a partir do XSD da definição do conjunto de dados. 

As interfaces implícitas são mais comuns, então usei conjuntos dedados não-tipados 
nos exemplos deste livro. Para código de produção em ADO.NET, todavia, sugiro 
o uso de conjuntos de dados que sejam tipados. Em um ambiente diferente do 
ADO.NET, sugiro o uso de geração de código para seus próprios Conj1111tos de Registros 
explícitos. 

Quando Usá-lo 

Na minha opinião, o valor de um Conj1111to de Registros vem de se ter um ambiente 
que se baseia nele como uma forma comum de manipular dados. Várias fen-amentas 
de interface com o usuário usam Conjuntos de Registros, e esta é uma razão convincente 
para usá-los você também. Se você tiver um desses ambientes, deve usar um Módttla 
Ta/Jela (134) para organizar a sua lógica de domínio: Obtenha um Co11j1mto de Registros 
do banco de dados, passe-o para um Módulo Tnbela (134) para calcular informações 
derivadas, passe-o para uma interface com o usuário para exibi-lo e editar 
seus dados e passe-o de volta para um Módulo Tabela {134) para validação. A seguir 
grave as atualizações no banco de dados. 

De diversas maneiras, as ferramentas que tornam o Conjunto de Registros tão 
valioso apareceram devido à onipresença dos bancos de dados relacionais e SQL e à 
ausência de quaisquer alternativas reais de estrutura e linguagem de pesquisa. Agora, 
é claro, existe o XML, que tem uma estrutura amplamente padronizada e uma 
linguagem de pesquisa em XPath, e acredito ser provável que venhamos a ver ferramentas 
que usem uma estrutura hierárquica da mesma forma que as ferramentas 
atuais usam Conj1mlos de Regislros. Talvez isso seja na verdade um caso particular de 
um padrão mais genérico: algo como Estrut11rn de Dados Genérica. Mas deixarei de 
pensar nesse padrilo até lá. 


Referências 

[Alexander el al.] 

Alexander, et ai. A Paliem umgunge. Oxford, 1997. 
Uma inspiração para muitas pessoas no movimento de padrões. Sou menos fascinado por ele do 
que a maioria, mas penso que vale a pena daruma olhada para entender uma abordagemde onde 
tantos extraem tanto. 

[Alpert et ai.] 

Alpert, Brown and Woolf. Desig11 Pnllems S111nlllnlk Co111pn11io11. Addison-Wesley, 1998 
Pouco conhecido fora da comunidadeSmalltalk, este livro espande eexplica muitos dos padrões 
clássicos. 

[Alur et ai.] 

Alur, Culpi and Malks. Core f2EE Pnllems: Besl Prnclices n11d Design Slrnlegies. Prentice Hall, 2001. 
Pertence à nova onda de livrossobre padrões que dão nova vida àárea. Embora os padrõessejam 
expressos especificamente para a plataforma J2EE, a maioria deles também íaz sentidoem outros 
lugares. 

[Ambler] 

http: / /www.ambysoft.com/ mappingObjetct.html 
Uma fonte de idéias úteis a respeito do mapeamento objeto-relacional. 

[Beck XP 2000] 

Beck, Extreme Progrn111111i11g Explni11ed ... Addison-Wesley, 2000. 
O manifesto da Programação Extrema. Deve ser lido porqualquer pessoa interessada em processosde 
S-Oftwnre. 

[Beck PatternsJ 

Beck. S111nlltnlk Best Prnclice Pnttems. Prentice Hall, 1997. 
De forma injusta, é pouco lido devido à sua base Smalltalk. Tem mais bons conselhos para outras 
linguagens 00doque a maioria dos livros ques.ioescritos especificamente para elas. O único aspecto 
negativo é que você vai perceber o quanto todos nós perdemos por não programar em 
Smalltalk. 

• . de R. As obras assinc1ladas nesta lista foram publicadas no Brasil pelil Bookman Editora. 

478 REFERÊNCIAS 

[Bcck TOO) 

13eck. Tesl-Drilie11 Develop111e11I: By Example. Addison-Wesley, 2003. 
Deve ser lançado no mesmo dia deste livro. IDO é o guia do Kent para o apertado ciclo de teste e 
refatoração que pode envolver um projeto. 

[Bernstein e Newcomer] 

Bemstein and Newcomer. Pri11ciples o/Tm11saclio11 Processi11g. Morgan Kaufmann, 1997. 
Uma excelente introdução ao complicado mundo das transações. 

[Brown et al.) 

Brown et ai. E11terprise Java Progra111111i11g wifh IBM Webspltere. Addison-Wesley, 2001. 
Embora dois terços deste livro sejam um manual de software, o outro terço contém uma quantidade 
maior de bons conselhos sobre projeto do que a maioria dos livros inteiros dedicados ao assunto. 


[Brown and Whitenack] 

http://111e111bers.aol.co111/kgb1001001/0,as111s.l1t111I 

Um dos primeirose melhores artigos sobre mapeamento objeto-relacional. 

[Cockbum UC) 

Cockbum. Wrili11g Effective Use Cases•. Addison-Wesley, 2001. 
De longe a melhor referência sobre casos de uso. 

lCockbum PioPJ 
Cockburn, "Prioritizing Forces in Software Design," in [PLoPD 2]. 
Uma discussãosobre as fronteiras de uma aplicação. 

[Coleman et ai.) 
Coleman, Arnold and Bodoff. Object-Orie11ted Ol'Velop111e11t: The F11sio11 Method, Seco11d Edition. Prentice 
Hall, 2001. 

Embora muito deste livro pré-UML seja principalmente de interesse histórico, sua discussão do 
modelo de interface é muito útil para quem esteja projetando uma camada de serviço. 

[Evans and Fowler] 

ltt t p://marti11Jowler.co111/aps11pp!spec.pdf 

Uma discussãosobre o padrão Especificação. 

[Evans] 

Evans. D0111ni11 Driven. Addison-Wesley, em preparação. 
Um livro sobre o desenvolvimento de modelos de dommio. Embora eu normalmente não goste 
de referenciar livros ainda não publicados, o manuscrito promete uma discussão fascinante sobre 
um aspecto importante e difícil do desenvolvimento de aplicaçõescorporativas. 

[Fowler Temporal Patterns) 

ht I p://mnrti1,fowler.co111/n1,2/timeNarrnlive.hl1111 
Padrões que lidam com histórias de objetos que mudam com o tempo. 

[Fowlcr AP) 

Fowler. Padrões de A11tflise. Addison-Wesley, 1997. 
Padrões para o modelo de domínio. 

[Fowler Refactoringl 

Fowler, Refaclori11g+. Addison-Wesley, 1999. 
Uma técnica para aperfeiçoaro projeto de uma base de código existente. 

[FowlerCI) 

/1ft p://111nrl i1,fowler.co111/nrlicles/conIi1111011s/11tegmIio11.!,/ 111I 
Um ensaio que explica corno criar software, automaticamente, diversas vezes por dia. 


REflA~NCIAS 479 

(Gang of Fourl 

Gairutta, Hclm, Johnson e Vlissidcs. Design Pnlterus.• Addison-Wcslcy, 1995. 
O livro seminal sobre padrões. 

(Ha.y) 

Hay. Dnln Modl'I JlnUm1s. Dorset House, 1995. 
Padrões de modelos conccítuais a partirde uma perspectiva rch1cional. 

IJacobson et al.) 

Jacobson et ai. Objecl-Relationnl Sofl1~v,rr E11g('lleeri11g. Addison-Wcslcy, 1992. 
Um dos primeiros livros sobre o projeto 00. lntroduz casos de uso ea abordagem de proj1?to interface-
co ntrolador.entidade. 

(Keller and Coldeway] 

hltp://www.objeclnrcl1itects.dt'/ObjeclArcllilecls/orpntt1•n1s/i11dex.l1tm 

Uma referência excelente sobre mapeamento objeto-relacional 

(Kirtland) 

Kirtland. Desig11i11g Co11111011mt-0nsed Ap/tlicntions. Microsoft Press, 199& 
Descrição da arquitetura D A. 

(KJ1ight and Dai] 

Knightand Dai. "Objects and tire Web." IEE.E Software, Mt1rch/April 2002. 
Um excel~n~ artigo sobre o padrão modelo-vista-controle, sua evolução e usoem aplicações Web. 

ILarman] 
Larman. Awlyi11g UMLnnd Pallems, Seco11d Edition.' Prenlice Hall, 2001. 
Atualmente meu favorito para um;, introdução ao projeto 00. 

[Leal 
l ca. Conc11rre111f'rogra111111i11g i11 fm--a, Secoll(I ütition.. Addíson-Wcsley, 2000. 
Se você quiser programar com múltiplas lltr,·a,fs, precisa enhmder este livro primeiro. 

lMarinescuJ 
Marinescu. tJB Design J>nfkms.• New York:Jolm Wiley, 2002. 
Um livro recente sobre padrõe$ para Java Ef6s. 

(Martin and Odell) 

Mnrtin and ()deli. Object Or1e11ted Mi•lhotk A Fmmdntio11 (UML Etfitio11). Prentice Hall, 1998. 
Modelagem de objetosde uma perspectiw, conceituai, assim como uma investigação sobre osfundamentos 
de que trata a modelagem. 

(Nilsson) 
Nilsson . .NET Enlerprise Design wíllr Vis11nl Bnsic .NETa11d SQL Server 2000. Sams, 2002. 
Um livro sólido sobre arquitetura p.ira a plataforma da Micro:.oft. 

(PLoPD2) 

Vlissides, Coplien and Kerth (eds.). Pnllem Limgungcs ofProgrnm Design 2. Addison-Wesley, 1996. 
Compêndio de artigos sobre padrõt..>s. 

(PloPD3] 

Martin, Buschmnnn and Rielhe {eds.). Paliem l.1111g11nges ofProgra111 Des,g11 3. Addison-Wesley, 1998. 
Compêndio de artigos sobre padrões. 

lPOSAJ 
Buschmann et .it. Paltem-Orient,·d Softwnre /\rcl1itect11r1·. Wiley, 2()()0. 
O melhor livro sobre padrões de arquitetura mais amplos. 


480 REFERENCIAS 

[Rielhe atai.) 

Rielhe, Siberski, 13aumer, Megert and ZuUighoven. "Serializer," in [PLoPD 3). 
Descrição detalhada das estruturas de serialização de objetos, especialmente quando você precisa 
serializá-los em diferentes formas. 

[Schnúdt) 

Schmidt, Stal, Rohnert and Buschmann. Pallern-Orie11ted Software Archilecl11re, Vo/11111e 2. Ncw York: John 

Wiley, 2000. 
Padrões para sistemas concorrentes e distribuídos. Mais para pessoasque projetam servidores de 
aplicação do que para aquelas que os usam, mas é bom ter algum conhecimento destas idéias 
quando você usa os resultados. 

[Snodgrassl 
Snodgrass. Developi11g Ti111e-Orie11ted Database Applicntio11s i11 SQL. Morgan-Kaufmann, 1999. 
Como lidar com o rastreamento de informações históricas cm bancos de dados relacionais. 

[Struts) 
hII1,://jaknrta.apache.org/slrt1 Is/ 
Umframework para a construção de aplicações Web em Java que vem crescendo empopularidade. 

[Waldo et al.) 
Waldo, Wyant, Wollrath and Kendall. A Note 011 Distrib11ted Co111p11li11g. SMLI TR-94-29, http://research.
s1111.co111/tech11icn/-reports/1994/s111/i_tr-94-29.pdf, Sun Microsystems, 1994. 

Um artigoclássico sobre porque "objetos distribuídos transparentes" são um paradoxo perigoso. 

[wiki) 

htlp://c2.co111/cgi/wiki 
O wiki web original, desenvolvido por Ward Cunningham. Um site Web sinuoso, porém fascinante, 
onde todosos tipos de pessoas compartilham todos os tipos de idéias. 

(Woolf] 

Woolf. " ull Object," in [PLoPD 3]. 
Uma descrição do padrão Objeto ulo. 

(Yoder) 

hl I p://unvw.joeyoder.co111/Research/objecl111appi11gs 

Uma boa fonte de padrões objeto-relacionais. 


A 

ACrD (atomicidade, consistência, isolamento e durabilidade), 
85-90 
recursos transacionais, 86-87 
reduzindo o isolamento da transação para melhorar 
a capacidade de resposta, 86-88 
transações de sistema e de negócio, 87-90 
Afinidade, servidor, 96-97 
Álbuns, transferindo informações sobre, 385-389 
Álbuns e faixas Qava), 257-260 
Aplicações corporativas, evolução das camadas, 3840 
Apresentação 
camadas, 108-110 
lógica, 39-40 
Web, 71-77 
Apresentação Web, Padrões de, 314-366 
Controlador de Aplicação, 360-366 
Controlador de Página, 318-327 
Controlador Frontal, 328-332 
MVC (Modelo Vista Controlador), 315-317 
Vista de Transformação, 343-346 
Vista em Duas Etapas, 347-359 
Vista Padrão, 333-342 
Armazenador de dados para objeto de domínio Oava), 
163-164 
Armazenador de valor, usando, 204-206 
Armazenados, Procedimentos, 111-113 
ASP.NET, página servidora (C#), 339-342 
Assemelhados, jogadores e, 277-282 
Atualizações perdidas, 79 

, 

lndice 

B 

Banco de Dados, estado da sessão no, 432-434 
como funciona, 432-433 
quando usá-lo, 433-434 
Bancos de dados 
carregando objetos do, 271-275 
mapeando para bancos de dados relacionais, 52-70 
conexões a bancos de dados, 67-69 
criando mapeamento, 64-67 
lendo dados, 58-60 
padrões arquiteturais, 52-57 
padrões para mapeamento estrutural, 59-65 
problema comportamental, 56-58 
questões diversas, 68-70 
usando metadados, 66-68 
Bloqueando 
otimista, 81-82 
pessimista, 81-82 
Bloqueio, gerenciador simples, 405-411 
Bloqueio Implícito, 422-425 
como fonciona, 422-424 
exemplo 
l3loqueio Off1ine Pessimista implícito Oava), 423425 
quando usá-los, 423-424 
Bloqueio Off1i11e Otimista, 392-400 
como funciona, 392-396 
exemplo 
camada de domínio com Mapeadores de Dados 
Oava), 396-400 
quando usá-lo, 395-397 


482 ÍNDICE 

Bloqueio Offli11e P imi ta implícito, 423-425 
BI qu i Otimi ta, 1-2 
Bloqueios 

Ofjli11c Otimista compartifüado, 414-420 
Offli11e Otimista d raiz, 420-421 
Ojfli11e P imista c mpartilhado, 419-421 

Bloqllei d Granularidad Alta, 412-421 
como funci na, 412-415 

mpl 
Offline Otimi ·ta c mpartilhado, 414-420 
Offline Otimi ta d raiz Ga a), 420-421 
Offli11e Pe imista compartilhad Uava), 419


421 
quand li -to , 414-415 

81 quei Offli11e Pe imi ta, 4 1-411 
como funciona, 401-406 
exemplo 

g r nciador simpl d bloqueio Ga a), 405411 


quando u á-lo, 405-406 
Br wn, camadas d , 113-114 
Busca em diversa tabela ·, 239-240 

e 

C# 
chave int gral, 219-221 
c I ção de referência , 240-243 
empr gad e habilidad , 245-249 
Gat way P a, 152-155 
jogadores concreto , 2 5-290 
j gad r a m lhado , 277-2 2 
lançamento d receita com lódulo Tabela, 137


140 
manipulador de página com códig por trás, 324327 


bjeto nlll impl , 463-464 
pá0 ina servidora ASP.NET, 339-342 
serviço W b, 374-37 
tabela única para jogad res, 270-272 

usando conjunt de dado ADO. T, 154-157 
u ando fanta mas, 205-213 
Camada d domínio com apeador d Dado Oaa), 
396-400 
Camada Supertip , 444 
com nmciona, 444 
exemplo 
bj t d d míni ija a), 444 
quand li á-la, 444 
Camada 
apr ntaçã , 10 -110 
bá ·ica J2 E, 113-114 
8r wn, 113-114


começand e ma camada de domínio, 106-107 
decidindo onde rodar sua , 41-44 
descendo para a fonte de dado , 106-110 

camada de apr entaçào, 10 -110 

fonte de dados M dulos Tabela, 107-10 
f nt d dados para M dei d D mini , 107109 
fonte de dado para Roteiro de Tran ação, 106


10 
arine cu, 113-115 
icr ft D A, 113-11 
ilsson, 114-115 

S r iço, 49-51 

trAs princip, i , 39-42 
Camada , evoluçã da , 3 -4 
Camada , erviço, 141-148 

e m funci na, 141-145 
e mplo 

lançamento de receitas, 145, 147-148 
l irura adicional, 144-145 
quand u á-la, 144-145 

Camadas d Dado , d cendo para a , 106-110 
camadas de apr s ntação, 108-110 
fonte de dados Módulos Tabela, 107-10 
font d dad para od los d D mínio, 107


109 
fonte de dado para R teiro d ran ação, 106


108 
Camada d d míni , e m çando c m, 106-107 
Camada D A,Micr ft,113-115 
Campo , Identidade, 215-232 

e mo .funciona, 215-219 

exempl 
chave int gral (C#), 219-221 
u ando cha e e mposta Ua a), 222-232 
u ando tab la d chave Oava), 220-223 

leitura adiei nal, 219-220 
quando u á-los, 218-220 
Capacidad der posta, 79-O 

reduzind is lamento para aumentar a, 6Carga, 
flutuação de, 201-202 
Car a Tardia, 2 0-213 

como funciona, 200-203 

e emplo 
inicialização tardia Oava), 202-203 
pron; virtual Oa a), 202-205 
usando armazenador de valor Oava), 204-206 
u and fanta ma (C#), 205-213 

quand u á-la, 202-203 

Ca o E p dai, 462-464 
e mo .funà na, 462-463 
exemplo 

bj t nulo impl (C#), 4 3-4 4 
leitura adicional, 462-463 
quando u á-lo, 462-463 

Chave e mpo ta Ua a), 222-232 

Chave estrangeira, mapeamento de, 233-243 
como funciona, 233-236 
exemplo 

bu ca m div rsa tabelas (Ja a), 23 -2 O 
e leção de referência (C#), 240-243 


ÍNDICE 483 

ref rência d ator único Ga a), 23 -24 
quando usá-lo, 235-237 

Chaves 
compo tas, 222-232 
integrai , 219-221 

Chav , tab la d , 220-223 
Cla se Dinheir , 457-4 1 
Cla e Tabela, Herança de, 276-2 2 

e mo funciona, 276-277 
exemplo 

j ad r e a -m lhad (C#), 277-2 2 
leitura adicional, 277-279 
quand u --la, 276-27 

Cliente, tad da ã n , 427-42 
como funciona, 427-42 
quando u á-lo, 27-42 

rnpartilhado, 81 queio Offiiue Otimi ta Oava), 
414-42 
Compartilhado, Bloqueio Offiiue Pessimista Uava), 
419-421 

C ncorrência, 78-92 
cone rrência em ·ervidor de aplicação, 91-92 
cont ·tos de e ecução, 79-1 
controles de concorrência ot:i.m.ista e pessimi ta, 

1-5 
i olam nt imutabilidad , 80-2 
offii11e, 78-79, -9 
padrõe d e ntrole de concorrência offli11e, 89-91 
problema de concorrAncia, 79-80 

ervidor d aplicação, 91-92 
C ncorrência, controles de 
Offii11e, padrõ para, -1 
timi ta e pe imi ta, 1-85 
ACTD (atomicidade, con i t~ncia, i olamento e 

durabilidade), 85-O 
deadlock , 84-5 
evitando 1 itura incon istent , 2transações, 
85 

Concorrência offli11e, padrões de, 391-425 
Conexõe de banco de dado , 67-69 
Confirmada (co111111iled), 1 itura, 6-7 
C njunto de dado ADO. ET, 1 -157 
Conselhos e pecíficos para determinadas tecnolo


gia , algun , 109-113 
Ja a eJ2EE, 109-111 
, 110-112 
procedimento annazenad , 111-113 

erviç • W b, 112-113 
C nt xto de x cuçã , 7 -1 
Controlador de Aplicação, 360-366 

como funciona, 36 -362 
exemplo 
Controlador de Aplicação modelo de estado 

Uava), 362-366 
leitura adicional, 362-363 
quando usá-lo, 361-363 

C ntr lad r de página, 318-327 
como funci na, 1 -319 
e mplo 

exibição simple com controle serolet (Java), 319


322 
exibição sim pie com vi ta J P Oava), 319-322 
manipulador de página com código p r trá 

(C#), 324-327 
usand JSP como manipulad r Oava), 321-325 
quando u á-1 , 318-320 

C ntrolador fr ntal, 32 -332 
como funciona, 32 -330 
e empl 

xibiçã impl (Java), 330-332 
leihira adid nal, 330-331 
quando li á-lo, 32 -33 

Controlador 
Aplicação de modelo de tad s, 3 2-36 
exibição imple com, 319-322 
usando JSP como vista com controladores separa


do , 337-340 
Control 
de concorrência otimi ta e pes imista, 81-5 
ACID (atomicidad , consistência, isolam nto e 

durabilidade), 85-90 
dendlo ks, evitando 
leitura inconsistentes, 82-84 
tran aç , 5 

p, drôes para c ncorrência offliue, 89-91 
C rr ção, 7 -O 
Cu tomizada , JSP e tags, 355-359 

D 

Dado 
imutáv i , 1-2 
lend , 5 -60 
registro de, 95 

Dados, Map ador de, 170-185 
camada de domúlio com, 96-400 
como funciona, 170-175 
e mplos 

criando bj to vazio Oa a), 183-1 5 

mapead r simple de bane de dados (Java), 
175-1 1 
ep m 'todo d bu ca (Ja a), 1 0-1 

qu lo, 174-176 
Dendlo 5 
Dependente· d uma pe a, enc ntrando , 311


313 
Dinheiro, 455-461 
como funciona, 4 5-457 
mplo 
classe dinheiro (Java), 457-461 

quando li á-lo, 45 -45 
Dinh ir , ela s Ua a), 457-461 
Distribuição, e traté ia de, 9 -104 


484 ÍNDICE 

interfaces para di tribuição, 103-104 
int rfac r m ta I cai , 100-102 
O fascínio dos objetos distribtúdos, 99-100 
ond ocê tem que dí tribuir, 101-103 
trabalhando com fronteira d di tribuição, 102


104 
Distribuição, interface para, 103-104 
Oi tribuição, padrõ de, 367-390 

Fachada Rem ta, 36 -379 

Objeto de Tran ferência de Dad , 380-390 
Div r a tab la , bu ca m Oava), 239-2 O 
Diverso empregado , u ando uma única bu ca pa


ra, 251-255 
D míni , 1 gica de, 40 

or anizando, 45-51 
Camada d Ser iço, 4 -51 
fazend e c lhas, 4 -50 

padrõ , 11 -14 

amada de r iço, 141-148 
Modelo d Domínio, 126-133 
Módulo Tabela, 134-140 
RoteirodeTransaçã , 120-125 

Domínio, mod l d , 126-133 
como funciona, 126-129 
x mpl 

lançamento der c ita Oava), 129-133 
fontededad para, 107-10 
leitura adid nal, 12 -131 
quando li á-1 , 128-129 

Dua tapa , Vi ta m, 347-359 
como fund na, 347-34 , 350 

mpJ 
JSP tn s customizada Qava), 355-359 
XSLTemdua etapa (X LT),352-355 

quando usá-lo, 348, 350-353 
Dua etapa , XSLT m, 352-355 

E 

EAI (Integração de Aplicações Corporativas), 43743 
Empr gado , u ando uma únic, con ulta para díver


s, 251-255 
Empr gados e habilidad (C#), 245-249 
Entrada, padrõe -de controlador de, 75-77 
Esp cial, Ca o, 462-464 

como funci na, 462-463 
mplo 
bjet nulo ímple (C#), 463-464 

leitura adiei nal, 462-463 

quando li á-lo, 462-463 
E ·quema d camada variado ·, 112-115 
E tado 

da ses ão, 93-9 
maneiras de annaz nar o tado da ão, 5Estad 
s, Contr lador de Aplicação model d Uava), 
362-366 

Estratégias 

d di tribuição, 99-104 
fascínio dos objetos distribuídos, 99-100 
interfaces para di tribuição, 103-104 
interface remotas e locais, 100-102 

nd cê t m que di tribuir, 101-103 
trabalhando com fr nt ira d distribuição, 
102-104 
tr cando do R po itório, as, 312-313 

E truturai , bjeto-relacionai , padrõe ·, 214-275 
Camp Identidade, 21 -232 
Herança de Cla e Tabela, 276-2 2 
H rança d Tab la Concr ta, 2 3-2 O 
H rança d Tab la ' nica, 269-275 
LOB (objeto randes) ·eriaHzado , 264-268 

apeador de Herança, 291-293 
apeamento de Chave E trangeira, 233-243 
apcam nto de Tabela de As ociação, 244-255 
apeamento Dependente, 256-260 

Valor mbutido, 261-263 

strutural, padrõ de map am nto, 59-65 
herança, 62-65 
map ando r !acionam ntos, 5 -64 

Execução, contexto de, 79-81 

x mpl , 
álbun e fai a Oa a), 257-260 
armazenador de dad para obj t de d minio 

(Java), 163-164 
BI queio Offli11e Otimi ta compartilhad Oava), 
414-42 
Bl queio Offlí11e Otimí ta de raiz Oa a), 420-21 

Bl qu io Offli11e P imi ta compartilhado Oa a), 
41 -421 
Bloquei Offli11e P imi ta implícito Oa, a), 423425 


busca em diversa tabela Oava), 23 -240 

chav int gral (C#), 21 -221 

ela e dinh ir Oava), 457-461 

coleção de referências (C#), 240-243 

C ntrolador d Aplicação de m d lo de tados 
Oava), 62-366 

mpr gado habiLidad (C#), 245-249 

encontrando os dependentes de uma pe ·soa Oaa), 
311-313 
ibição impl Oa a), 330-332 

xibição imple com controlador d ervlel Oa a), 

319-322 

ntewny para um ·erviço de men agen proprietá


ri Oa a), 437-441 

Gateway Pe oa (C#), 152-155 

G rador d id ntidad (Ja a), 466-4 

g renciad r d bl qu io simple Oava), 405-11 

inicialização tardia (Java), 202-203 

j gadores concretos (C#), 285-290 

jogadores e as emelhados (C#), 277-282 

lançam nto d r c ita Oava), 129-133, 145, 147


148 


ÍNDICE 485 

lançamento de receita com Módulo Tab la (C#), 
137-140 
mapeador ·imples de banco de dados (Java), 1751 
1 
método para Mapa de Identidade Ua a), 198-199 
Objeto de P qui a impl s (Ja a), 305-30 
bj t de domínio Ua a), 444 
bjeto nulo impl (C#), 463-464 
bj to ai r simpl Uava), 262-263 
página ervidora A P.NET C#), 339-342 
p a impl ija a), 166-169 
proxy irtual O ava), 202-205 
r ferência com ai r único O ava), 23 -240 
regi tr a prova de tltrends Oava), 451-452 
re i tr pe oa Oava), 159, 161-164 
r gi tro singleton Ga a), 450-452 
eparando método de bu ca Oava), 1 0-184 
serializando hjerarquia de d partamentos em 
XML Oa a), 265-268 
crializando usando XML Oava), 3 -3 O 
serviço d impo tos sobr v ndas Oava), 469-472 
serviço Web (C#), 374-379 
tabela única para jogador (C#}, 270-272 
transferindo i.túormações sobre álbuns Qava), 3853 
9 
tran formaçã impl Oava), 344-346 
trocando e tratégia de Rep itório Oava), 312313 
nidade de Trabalho com regi tro de bjeto Oaa), 
192-195 
li ando armazenador de valor Qava), 204-206 
u ando chav c m.p ta Oava), 222-232 
u ando c njunt d dad DO. (C#), 154157 
usando fantasmas (C#), 205-213 
u ando J P como manipuladora Uava}, 321-325 
LI ando m tadad ser f1 ão (Java), 2 7-3 3 
usando ession bea11s Java como Fachada Remota 
(Java), 371-375 
li ando SQL direto (Ja a), 248-252 
LI ando tab Ia d cha, (Java), 220-223 
u ando uma única c n ulta para diverso empregados 
(Java), 251-255 
XSLT m dua tapa (XSLT), 352-355 
Exibição imple ·, 330-332 

F 

Fachada rem ta, 36 379 
como funciona, 36 -372 
exemplo 
·erviço Web (C#), 374-37 
usando se-sion benn Java como Fachada R mota 
Qava), 371-375 
quando usá-la, 371-372 
Faixas, álbun e, 257-260 
Fanta mas, -7, 201-202, 205-213 

Fomentadores, Complexidade, 43-44 
F nt d Dados 
ló,.ica, 40 
ódulos ab la, 107-10 
padrões arqLúteturais, 150-185 
Gat way d inha de Dad s, 1 8-164 
Gateway d Tab la de Dado , 151-157 
Mapeador de Dados, 170-185 
R gi tro tivo, 165-169 
para Model •de D mínio, 107-109 
para Rot ir d Tran açã , 9 -10 
Font de dad , de cendo para a camada de, 106110 
r ntal, Contr lad r, 32 -332 
como funciona, 32 -330 
e mplo 
exibição imple Oava), 330-332 
1 itura adiei nal, 330-331 
quando u á-Jo, 329-330 
Fronteira , trabalhando com di tribuição, 102-104 
Fronteiras d distribwção, traballlando c m, 102-104 

G 

Gat way, 436-441 
como funciona, 436-437 
ex mplo 
gatewny para s rviço de men agen proprietári 
(Java), 437-441 
P a, 152-155 
quando u á-la, 436-43 
Gat way, Linha de Dado , 15 -164 
como funciona, 158-159 
e mplo 
armazenador de dados para objeto de donúnio 
Oa a), 1 3-164 
r gi tr p oa (Ja a), 15 -164 
quando usá-la, 15 -159 
Gat way, ab la de Dado , 151-157 
como funciona, 151-152 
e emplos 
Gateway P oa (C#), 152-155 
usando c njunto de dado ADO. T (C#), 154157 
leitura adicional, 152-153 
quando u á-Ja, 151-153 
Gateway para serviç de mensagem proprietário Oava), 
437-441 
erad r de id ntidade, 66-4 
Gerenciador impl de bloquei , 405-411 
Ger nciam nt d c rug font (SCM), 395-3 
ranularidade Alta, Bloqueio de, 412-421 
como funciona, 412-415 
e emplos 
81 queio Offli11e Otimi ta compartilhado Oa a), 
41 1-420 
Bloqueio Offli11e Otimi ta de raiz (Java), 420-421 


486 ÍNDICE 

Bloqueio Offline Pe imi ta compartilhado (Java), 
41 -421 
quando usá-lo, 414-415 
G (Identificador Globalm nt ' nico), 217-21 

H 

Habilidad , empregad e, 245-249 
Herança, 62-65 
Herança, Cla Tab la, 276-2 2 
como funciona, 276-277 

• mplo 
j gador •e ·eu· parente (C#), 277-282 
leitura adicional, 277-27 
quando usá-lo, 276-279 
Herança, ap ador s de, 291-319 
como hmciona, 291-293 
quando usá-los, 292-293 
Herança, Tabela Concreta, 283-290 
como funciona, 2 3-2 
e mpl 
jogad r c ncr t (C#), 2 -290 
quand u á-la, 2 -287 
H rança, ab la ' nica 
carr gand objeto d banco d dado , 271-275 
como funci na, 2 9-270 
e emplo 
tab la única para jogadores (C#), 270-272 
quand u á-la, 269-271 
Hierarquia de departamento , erializando, 265-26 
Hierarquia do departamento, serializando, 265-26 

identidade, Campo de, 215-232 
c m funci na, 215-219 
e emplo 
chave integral (C#), 219-221 
u ando chave c mposta Oava), 222-232 
usand tab la de chav Oava), 220-223 
leitura adicional, 21 -220 
quando usá-lo, 21 -220 
Identidade, gerador de Oava), 466-468 
fd ntidad , Mapa de, 1 6-1 9 
como funci na, 196-19 
e empl 
métodos par, Mapa de ldentidade (Java), 198199 
m 't do para, 1 
quand u á-los, 19 -19 
Identificador Gl balm nt Único (G 10), 217-21 
Implícito, Bloqueio, 422-425 
como funci na, 422-424 
exemplo 
Oloqu io Offliue P s iaústa implícito Oa a), 423425 
quando u á-lo, 423-424 

Implícito, Bloqueio >ffli11e Pe ·simista Oava), 423-425 
Impost br v ndas, rviç d , 469-472 
Imutabilidade, isolamento e, 80-82 
Imutá i , dados, 81-2 
Inconsistente , leituras, 79 
itand , 2-4 
Inicialização tardia, 202-203 
Int graçã de Aplicaçõ Corporati a (EAI), 43743 
Integral, cha e (C#), 219-221 
lnt rfac 
para distribtúção, 103-104 
r m ta I cai , 1 0-102 
eparada ·, 445-447 
como funci na, 445-447 
quando usá-la, 445-447 
Isolam nto 
e imutabilidade, O-2 
reduzindo o isolamento da transação para aumentar 
a capacidad de resposta, 6-8 

J 

J2 E, Java e, 10 -111 
J2EE, núcl da camadas, 113-114 
Java 
álbun e faixa , 257-260 
am1azenad r de dad s para bjeto de domíni , 
163-164 
81 queio Offli11e Otimi ta c mpartilhado, 414-420 
81 queio Offli11e Otimi ta de raiz, 420-421 
81 quei Offli11e Pe imi ta c mpartilhad , 419421 
busca m diver a tab la , 239-240 
camada de domÚlio com Mapeadores de Dados, 
3 6-400 
ela e dinheiro, 457-461 
Controlador de Aplicação modelo de estado, 362366 
criand bjetos vazi , 1 3-185 
J2EE, 109-111 
encontrando o dependentes de pessoas, 311-313 
xibição impl s, 330-332 
exibição ·imple com controlador ervlet, 319-322 
ibiçã impl c m i ta JSP, 319-322 
ntewny para er iço de men agens proprietári , 
437-441 
G rad r de identidade, 466-68 
JSP e la cu tomizada , 355-35 
lançamento de receita, 122-125, 129-133, 145, 14714 
mapeador simpl d banco d dados, 175-1 1 
métodos para apa de Identidade, 19 -199 
Objeto d quisa simpl s, 305-316 
obj to de donúnio, 4 4 
obj to valor ·imples, 2 2-263 
pe s a imples, 166-169 


ÍNDICE 487 

refer~ncia de valor único (Ja a), 236-240 
r gi tro à prova d thrcad, 451-452 
registro pessoa, 15 , 161-164 
r gi tro singleto11, 450-452 
s parando método de busca, 180-184 

erializand hierarquia de d partam nt m 
XML, 265-26 
erializando usando XML, 3 -390 

s iço d impo to br v nda , 469-472 
tran ferindo informaçô ·obre, lbun ·, 385-389 
tran f rmaçã impl , 344-346 
trocando e tratégia de Rep it rio, 312-313 

nidad de rabalh c m r gi tr d bj t , 1 2


195 
u ando armazenador de valor, 204-206 
u ando cha e campo ta , 222-232 
u ando J P como manipulador, 321-325 
u ando JSP como ista com controlador eparado 

337-340 
u ando mctadado e reflexão, 2 7-303 
u and e si011 bea11s Java como Fachada Remota, 

371-375 
u ando SQL dir to, 248-252 
usando tabela de chaves, 220-223 
u and uma única c n ulta para div r mpr • 

gado , 251-255 
Java e io11 bea11, u ando c m Fachada R mota (Jaa), 
371-375 

Jogadore 
concret , 2 -290 
tabela única para, 270-272 

J gad r e ncr t (C#), 2 5-290 
J gad r e ass melhados (C#), 277-2 2 
JSP 

usando como manipulador, 321-325 

usando como i ta, 250-253 
JSP, exibiçã simpl c m i ta, 319-322 
JSP e ta s customizadas, 321-325 
Juntando tudo, 10 -115 

alguns conselhos p cífic para determinada 

t enol gia , 109-113 
começando com a camadas de domínio, 106-107 
descendo para as camadas de dados, 106-110 

qu ma de camada ariado , 112-115 

L 

L itura 
ü,c n i t nt , 79 
r petf 1, 6-7 

Leitura confirmada, 6-87 

Leitura não-e nfirmada, 87-88 
inira 
e, itando leituras inconsistentes, 2-84 
nã -r p tí 1, 6-7 
suja , 7-88 
Temporais, 3


Linha de Dado , ateway de, 15 -164 
como funci na, 15 -15 
e emplos 

annaz nador d dados para objeto d domínio 
Oava), 163-164 
r gi tr d p • oa (Ja a), 159, 161-164 
quando u á-1 , 15 -159, 161 

LOBs (objet s grandes), serializados, 264--268 
com ftmciona, 264-265 
exemplo 

rializand hi rarquia d d paxtament m 
L Oa a), 265-26 

quand u á-1 , 265-2 
L cai erem ta ,interfac , 100-102 
Ló ·ca 

apr ntação, 3 -40 
de domíni , 40 
de negócio, 40 
fonte de dado , 40 
organizando lógica do domínio, 45-51 

Camada de s r iç s, 19-51 
faz ndo e ·colhas, 4 • O 

ógica d domínio, padrões de, 119-14 
Camada de Serviço, 141-148 
M d I d D mínio, 126-133 
M dul Tabela, 134-140 
Roteir de Tran ação, 120-125 

L gica de neg ci , 40 
Longa·, tran ·açõe , 86 

M 

Manipuladore • 
de pá ina, 324-327 
u and JSP e mo, 321-325 

Mapa, Id ntidade, 1 6-1 
como funci na, 1 6-198 
exemplo 

métodos para Mapa de Identidade Oa a), 1 8199 
quando u á-lo, 19 -199 

Mapeador, 4 2-443 
como funciona, 442 
quando u á-1 , 442-443 

Mapeador de banco· de dad s sim pie , 175-181 
ap ador d Dado , 170-185 
c mo funci na, 170-175 

mpl 
criand bj t vazi Ua a), 1 3-1 
mapcador imple de banco de dad Oa a), 

175-1 1 
·eparando métod •de bu ·ca Oava), 1 0-184 

quando u á-lo, 174-176 
Mapeador simples de banco de dados, 175-1 1 
Map adore , camada de domínio e m mapeadores 

de dad , 396-400 
Mapcadores, Herança, 2 1-293 


488 ÍNDICE 

como funciona, 2 1-293 
quando u á-los, 292-293 
apeamento, criando, 64-67 
apeamento, padrões de 

trutural, 5 -65 
h rança, 62-65 
map ando relaci nament , -64 

metadado objeto--r laci nai , 294-313 
Map amcnt m tadad , 2 -303 
Objeto de P qui a, 304-308 
Repo itório, 30 -313 

apeamento, padrões de mapeamento de metada


do objcto-r !acionai , 2 4-313 
Mapeamento em letadados, 295-303 
Objeto de Pe quisa, 304-30 
Repositório, 309-313 
ap am nt , Tab la d A ciaçã , 244-255 
c m funci na, 244-245 
exempl 

empregad habilidade (C#), 245-249 
usando Q dir t Oa a), 24 -252 
u and uma única con ulta para di em-

pre ado Oava), 251-255 
quando li á-lo, 244-245 

lapeament d Chave trang ira, 233-243 
c mo funci na, 233-236 
e emplo 

busca em di er a tabela 0ava), 239-240 
coleçã de referência (C#), 240-243 
referência de valor único Oa a), 236-240 

guand u á-lo, 235-237 
apeamento de chave estrangeira , 23 -243 
ap am nt d m tadad 
como funciona, 295-297 
e mplo 

usando metadados e reflexão Oa, a), 2 7-303 
quand usá-lo, 296-2 8 
apeament de Tabela de A ·· dação, 244-255 
c mo funciona, 244-245 
exemplos 

mpr gad habilidad {C#), 245-249 
li ando SQL diret Oava), 248-252 
u ando uma única consulta para di er m-

pregado Qava), 251-255 
guand u -lo, 244-245 
apeamento Dependente, 256-260 
como funciona, 256-257 
exemplo 

álbuns faixas Oava), 257-260 
quando usá-lo, 256-258 
ap am nto m etadados, 295-303 
como funciona, 295-297 

mplo 

usando metadado e reflexã Uava), 297-303 
quando u á-lo, 296-29 
ap ando para banco de dado r laci nai , 2-7 

c nexões a banco de dado , 67-69 
criando mapea m nt , 64-67 
lendo dados, 58-60 
padrõ s arqu.iteturai , 52-57 
padr·e d map amento trutural, 5 -6 
problema comp rtamentaJ, 56-5 
qu t-div r a , 70 
u ando metadado , 66-6 

Mapeand relacionament , 5 -64 
Marinescu, camada d , 113-115 
Mensagen , nfewny para enriço de, 437-441 
Metadados, usand , 66-68 
M tadado e r flexão, usando, 297-303 
M ' t do d bu ca, eparando, 1 0-184 
Micr oft, amada D A, 113-115 
Mi ração, ses ão, 96-97 
Modelo de Domúuo, 126-133 

como funciona, 126-129 
e emplo 

lançamento de receitas Oava), 129-133 
leitura adicional, 128-131 
quand li á-lo, 12 -12 

Modelo Vista Controlador (MVC), 315-317 
Modelos, fonte de dados para modelos de domínio, 
107-109 

Módulo Tabela, 134-140 
com funci na, 134-137 
e emplo 

lançament de receita c m ódulo ab la 
(C#), 137-140 

quand u á-lo, 136-137 
Módulo abela, fonte de dados, 107-108 
MVC (Modelo Vista Controlador), 315-317 

como funciona, 315-317 
quand u á-1 , 31 -317 

N 

ão-confirmada, leitura, 87ão-
repetíveis, l ituras, 86-87 
T, 110-112 
il --on, camadas de, 114-115 

o 

Objeto de Pesqujsa, 304-30 
c mo funciona, 304-305 
mplo 

bj to de Pe ·qui ·a ·imple • Qava), 305-30 
leih1ra adicional, 305-306 
quando li á-lo, 304-306 

Objeto de Pesqui a simple , 305-30 

Objet de ransf rência de Dad , 3 0-390 
como funciona, O-4 
exemplos 

serializando u ando ML 0a a), 3 8-390 


tran ferindo informaçõ obr álbun (la a), 

3 5-3 

leitura adicional, 3 5 
quando usá-lo, 383-3 
Objeto Valor, 453-454 
como funci na, 53-454 
qu, ndo u -lo, 453-4 
Objet -r laci nai , padrõe e mp rtamentai , 186-213 
Carga ardfa, 200-213 
Mapa de Identidade, 196-199 
njdad d rabaUl , 1 7-195 
Objeto-relacionai , padrões de mapeamento de metadado 
, 2 4-313 
Mapeamento d Metadados, 295-303 
Objet de P qui a, 304-30 
R p sitório, 309-313 
bjeto-relacionais, padrões ·truturai , 214-275 
Campo Tdentidad , 215-232 
Herança de las e Tabela, 276-282 
Herança de Tabela Concreta, 2 3-2 O 
Herança de Tabela Única, 269-275 
LOBs (objetos >-randes) erializados, 264-26 
Mapeador de erança, 291-293 
Mapeamento de Cha e Estrangeira, 233-243 
Map , m nt d Tab la de As ciaçã , 244-255 
Mapeam nto D pend nt , 256-260 
Valor Embutido, 261-263 
Objet 
carr gando do banco d dado , 271-275 
criando obj t vazio , 1 3-1 
de domínio, 444 
d alor impl , 262-263 
nul simple , 463-464 

o fascínio do objeto di tribuíd , -100 
Objeto , registro de, 188-189 
bjet , Unidade de rabalho com registro de, 1 21 
5 
Objetos de domínio Oa a), 444 
Objeto de Domínio, armazcnadorc de dados para, 
163-16 
Obj t d Tran ~ rência de Dado , 3 -390 
como fonciona, 3 0-3 
exemplos 
rializand u ru1d L (la a), 38 -3 O 
tran ferindo informaçõ ·obre álbun Oa a), 
3 5-3 9 
leitura adicional, 385 
quand u -•-1 , 3 3-384 
Objeto di tribuído , fa cíni d , 99-10 
Objet • nulos, simples, 463-464 
Ofj1i11e, 13loqu io Otimista, 392-4 O 
como funciona, 392-396 
exemplo 
camada de domínio com Mapeador de Dados 
(Java), 39 -40 
quando u á-lo, 395-397 
Ofj1i11e, Bloqueio Otimista compartilhado, 414-420 

ÍNDICE 489 

Offlille, Bloqueio Otimista de raiz, 420-421 
Off1i11e, 81 queio P ssi mi ·ta, 401-411 
como funciona, 401-406 
exemplo 
g r nciador d bl qu ios simpl Oava), 405-411 
quando usá-lo, 405-406 
Offli11e, Dloqueio P irn.ista compartilhado, 41 -421 
Ofj1i11e, Bloqueio Pessimista implícito, 423-425 
Offlí11e, Cone rrência, 7 -79, Offli11e, 
padr· d cone rrência, 391-425 
BI quei de Granularidade Alta, 412-421 
IH queio Implícito, 422-425 
Bloquei Off1i11e Otim.i ta, 392-400 
Ili u i Off1i11e P imi ta, 401-411 
Offli11e, padrõ para contr lede e ncorrência, 991 
Ondulaçã de carga, 201-202 
rganizando em camada , 37-44 
decidindo onde rodar suas camadas, 1-44 
esquemas, 112-115 
olução da camada m apücaçõ e rporati a , 
3 -40 
três camada principai , 39-42 
Otimi ta, Bloqueio Ofj1i11e, 392-400 
como funciona, 392-396 
compartilhad , 414-420 
de raiz, 420-421 
mplo 
camada de donúni e m ap ador d Dad 
Oava), 3 6-4 O 
quando u á-lo, 395-397 
Otirni ta e pes imi ta, controles de concorrência, 185 


p 

Padrã , Vi ta, 333-342 
como funciona, 333-337 
e mplos 
página servidora A P. ET (C#), 339-342 
u ndo JSP como i ta com controlador eparado 
Oa a), 337-340 
quando u á-la, 336-33 
Padrões 
apre entação Web, 31 -366 
Controlador de Aplicaçã , 360-366 
Contr lad r de Página, 31 -327 
C ntr lad r Fr ntal, 32 -332 
MVC ( dei i ta C ntr lad r), 31 -317 
Vi ta de Tran formação, 343-346 
Vista em Dua tapa , 347-359 
Vi ·ta Padrão, 333-2 
arqtúteturai , 52-57 
arquiteturais de fonte de dados, 150-185 
Gat way d inha de Dad , 15 -164 
Gat way d abela de Dado , 151-157 
Mapeador de Dados, 170-1 5 


490 ÍNDICE 

Regi tro A ti o, 165-1 
bá icos, 435-475 
Camada Supertip , 444 
Caso Especial, 462-464 
Conjunto de R gi tr , 473-475 
Dinh iro, 455-461 
Gateway, 43 -441 
Int rfac Separada, 445-447 
Mapeador, 442-443 
Obj t Va I r, 453-454 
Plugin, 465-46 
Registro, 448-452 
tub de Serviço, 46 -472 
comportamentai objeto-relacionais, 1 6-213 
Car •a Tardia, 200-213 
apa d Id ntidad , 196-199 
Unidad de Trabalho, 1 7-195 
controlad r d entrada, 75-77 
de cone rrência Offli11e, 391-425 
Oloqueio d Granularidad Alta, 412-421 
Biaguei lmpücit , 422-425 
Oloqu io Offliue Otimi ta, 392-40 
Bloqueio Offliue Pe • ·imista, 401-411 
de mapeam nto de metadados obj to-relacionais, 
2 4-313 
Map arnento em tadados, 295-303 
Objeto de Pesquisa, 304-308 
R po itório, 30 -313 
de mapeamento estrutural, 59-65 
h rança, 2-65 
mapeando relaci namentos, 59-64 
di tribuição, 367-390 
Fachada Remota, 368-379 
Obj t d Tran f r~ncia d Dad , 3 -3 
estado da essão, 426-434 
Estado da Sessão no Banco de Dado , 432-434 
E tado da e ã no liente, 427-428 
E tado da e ão no ervid r, 42 -431 
estmturais objeto-relacionais, 214-275 
Campo de ld ntidad , 215-232 
Herança de Cla ·e Tabela, 276-282 
H rança d abela C ncreta, 2 3-29 
Herança de Tabela ' nica, 269-275 
LOB (obj t grand ) rializad , 264-26 
Mapeador de Herança, 291-2 3 
ap ament de Chav trangeira, 233-243 
Mapeamento de Tabela de A sociação, 244-255 
Map ament D p nd nt , 256-260 
Valor Embutido, 261-263 
lógica de domínio, 119-14 
vista, 74-76 
P, drõ s arquiteturai , 52-57 
Padrões arquiteturai , fonte de dado , 1 0-185 
Gat way d inha d Dado , 15 -164 
Gatewa de Tabela de Dado , 151-157 
Map ad r d Dad , 170-1 5 

Regi tro Ativo, 165-16 
Padrõ bá ic , 43 -475 
Camada Supertipo, 444 
Ca o E pedal, 462-464 
C njunto d Regi tro , 473-475 
Dinh iro, 455-461 
Gatewa , 436-441 
lnterface Separada, 445-447 
Mapeador, 442-443 
Obj t alor, 453-454 
Plu rin, 465-46 
Registro, 44 -452 
Stub de Serviço, 46 -472 
Padrõ s Comportamentai , bj to-relacionais, 1 6


213 
Carga ardia, 200-213 
Mapa de Identidade, 196-199 
UnidadedeTrabalh , 1 7-195 
Padrõe de controle, entrada de, 75-77 
Página, Controlador de, 52-61 
com funci na, 318-319 
e mplo 
exibição sin1ple • com controlador erolet Gava), 

319-322 
exibição simple com vista J P Uava), 319-322 
manipulador d página com códi o p r trá 

( #), 324-327 
usando JSP como manipulador 0ava), 321-325 
quando u á-lo, 31 -320 
Página, anipulad r d página e me dig p r trá , 

324-327 
Perdida , atualizaçõ , 79 
Pe qui a, u and uma única, 251-255 
Pe qui a imple , Objet de, 30 -O 
Pessimi ta, Bloqueio, 81-82 
Pes imi ta, Bloqu io Offli11c, 401-411 
como funci na, 401-406 
comparti1J1ado, 41 -421 
exemplo 
gerenciador de bloqueios simples 0a a), 405-411 
implícito, 423-425 
quand u á-1 , 405-4 
Pes ·imi ta e otimista, controles de concorrência, 81-85 
P a, nc ntrand d p nd nt , 31 -313 
Pe" a, ateway (C#), 152-15 
P a, R gi tro Ga a), 159, 161-164 
Pe soa simples, 166-169 
Plugin, 465-46 
como funciona, 465-466 
e emplo 
Gerador de Identidade 0ava), 466-468 
quando u á-lo, 465-466 
POJOs (velho b n bj t Java), 371-372 
Problema e mp rtamental, 56Problema 
comp rtamentai , 6-5 


ÍNDICE 491 

de concorrência, 7 -O 
Proc diment armaz nad , 111-113 
Proce so por ses ão, 91 
Proces o por olicitação, 91 
Proc o definido , 80-81 
Proxy virtual, 202-205 

R 

Raiz, 81 queio Offli11e Otimista de Ua a), 420-421 
R ceita , lançam to com ódul ab 1, (C#), 137140 
R ceita , lançament de Ua a), 122-125, 129-133 
Rec ita , pr blema d lançament de, 121-123 
Recur transaci nais, 6-87 
R f r"ncia 
coleção de, 240-243 
de valor único, 236-240 
Reflexão, usando metadado e, 297-303 
Regi tro 
objeto de, 1 8-1 9 
nidade de Trabalho com objeto de, 192-195 
R gistro, 448-452 
à prova de lhrend, 451-452 
com funciona, 44 -450 
e emplos 
regi troa pro a de thrend Oa a), 451-452 
registro si11gleto11 Qava), 450-452 
quando u • -lo, 449-451 
i11gleto11, 450-452 
Regi tro Ativo, 165-169 
c mo funciona, 165-166 
e emplo 
uma pe oa imple Oava), 166-169 
quand u á-lo, 165-167 
Regi tro de dado , 95 
Regi tr , conjunto de, 473-475 
como funciona, 473-475 
quando u á-lo , 474-475 
Relacionai , map ando para bancos de dados, 52-70 
conexões a banco de dados, 67-69 
criando mapeamento, 64-67 
lendo dados, 5 -60 
padrõ arquit turais, 52-57 
padrõe de mapeamento estruh1ral, 59-65 
problema comportam ntal, 56-5 
que tões di ersa , 6 -70 
u nd m tadad , 66R 
lacionament , mapeand , 59-64 
Remota, Fachada, 36 -37 
e m funciona, 3 -372 
exemplo 
enriço Web (C#), 374-37 
usand se io11 beans Java como Fachada Remota 
Ua a), 371-375 
quand us -la, 371-372 

Remota, u ando e ion bea11 Java com.o fachada, 

371-375 
Remotas locai , interface·, 100-102 
Repetível, leitura, 6-7 
R posit rio, 30 -313 
como funciona, 309-311 
rnplo 
encontrando os dependentes de uma pessoa Oava), 
311-313 
tr cand as estratégia de R p 

312-313 
l itura adicional, 311-312 
quando u á-1 , 31 -312 
R t iro d Tran açã , 120-125 
como funciona, 120-121 
exemplo 
lançament der e ita Oava), 122-125 
problema do lançam nto de receita, 121-123 
quando u á-lo, 12 -122 
Roteiros de transação, fonte de dados para, 106-10 

s 

CM (gerenciamento de código fonte), 395-396 
S gurança, 79-O 
Sem estado, ervidores, 93-94 
Separada, Interface, 445-447 
como funciona, 445-447 
quand u á-la, 446-447 
parad , u ando JSP com vi ta com Contr lador, 

337-340 
rializad , LOD ( bj t grande), 264-26 
como funciona, 264-265 
exemplo 
erializando hierarquia de departamentos em 
XM Oa a), 2 5-26 
quando u á-1 , 265-2 
Serializando usando XML (Ja a), 3 -390 
Serializáveis, transaçõ são, 6-7 
Serviço, camada de, 49-51, 141-148 
como funciona, 141-145 
e emplo 
lançam nto der ceita Oava), 145, 147-14 
1 itura adiei nal, 144-145 
quando u ·á-la, 144-1 5 
S rviço, Stub d , 469-472 
como funciona, 469-470 
e mplo 
er iç de imp t obre venda Oa a), 469472 
quand usá-1 , 46 -47 
en iço de impo ·to ·obre enda • Oava), 469-472 
rviço de men agen propri tário , gnteway para, 

437-441 
rviço Web, 112-113, 374-37 
Servidor, afinidade com, 6-7 


492 ÍNDICE 

ervidor, tado da ão no, 42 -431 
como funci na, 429-431 
quando li á-lo, 430-431 

S rvidor de aplicação, concorrêncja, 91-92 
Servidora, página ASP. ET, 33 -342 
Servid r de Aplicação, e nc rrência, 91-92 

ervid r m e tad , 93-94 
Servlet, exibição imple com e ntr lador, 319-322 
S ã , tado da, 93-94, 95-9 

ão, e tado da 

no Bane d Dad , 432-434 
e m hmciona, 432-433 
quand u á-1 , 43 -434 

n Client , 27-42 
e mo funciona, 427-42 
quando u á-lo, 427-42 

no rvid r, 429-431 
como funciona, 42 -431 
quando usá-lo, 430-431 

Sessão, e tado da 
man ira d armaz nar, 95-98 
valor da ausência de ·tad , 93-9 

Sessão, migraçã d , 96-97 
Sessão, padr-es de estado da, 426-434 

tad da ã n Bane d Dad , 432-434 
ã n Cli nt , 427-42 
E tado da ão no Servidor, 429-431 

õe d finida , 80-81 

imple , exibição Ua a), 330-332 
Simpl , p oa Ga a), 16 -169 
Simples, transformação Uava), 344-346 
Singl t n, r gistr Oa a), 450-452 
Si tema e negóci , tran çõ s d , 87-90 
Solicitação, tran açõe por, 6 
Solicitações, 79-80 

QL, u ando direto, 24 -252 

Stub d S rviç , 46 -472 
como hmciona, 469-470 
exemplo 

erviç de impo t s bre v ndas Ua a), 469-472 
quand li á-1 , 469-470 

T 

Tabela Concreta, Herança de, 283-290 

e mplo 
e mo funciona, 2 3-2 5 
j gad r -e ncr t (C#), 2 -290 
quand u á-la, 2 -2 7 

Tabela de A ociação, Mapeam nto de, 244-255 
como funci na, 244-245 
exemplo ' 

mpregado habilidad (C#), 245-249 
usando SQL direto ijava), 248-252 
usando wna única e n ulta para div r o m


pr gado Uava), 251-255 
quando u á-lo, 244-245 

Tabela de Clas ·e ·, Herança de, 276-2 2 

Tabela ' nica, H rança d , 
carre ando objeto· do banco de dados, 271-275 
como funciona, 269-270 
exemplo 

tab la única para j gad res (C#), 270-272 
quand u á-la, 269-271 

Tabelas, Módulos 134-140 
como funciona, 134-137 
exemplo 

lançam nt de receita com ódulo Tab la 

(C#), 137-1 O 
f nt d dad , 1 7-10 
quand u·á-1 , 136-137 

Tabela de d,aves, 220-223 
ab la de Dado, Gat wa d , 151-157 
como funci na, 151-152 

xempl 
Gateway Pessoa ( #), 152-155 
u ando conjuntos de dado ADO. T (C#), 154


157 
leitura adicional, 152-153 
quando usá-la, 151-153 

Tngs customizadas, JSP e, 355-359 

Tardia, Carga, 200-213 
e m funci na, 200-202-203 
exemplo 

inicializaçf o tardia Oa a), 202-203 
proxy irtual Qava), 202-205 
u ando armaz nador d valor Gava), 204-20 
usando fanta ma {C#), 205-213 

quand u á-la, 202-203 
Tardia, inicializaçã Oava), 202-203 
Tardia , tran açõ , 86 

enologia , alguns con 
minada , 10 -113 
Ja a eJ2 , 10 -111 

. ·T, 110-112 
procedimento armazenado , 111-113 
s rviço W b, 112-113 

Ti mp rai , Leitura , 3Tlirend, 
Regi troa prova d Oava), 451-452 
Thrends 

d finidas, O-1 
i olada , O-1 
Trabalho, Unidade de, 1 7-19 
e mo funci na, 187-192 
x mpl 
nidad d Traballl e m r gi tro d bj t Gava), 
192-195 

quando u á-lo, 191-193 
Tran ação, f nt d dad para Roteir d , 106-108 
Tran ação, roteiro de, 120-125 

como funciona, 120-121 
exemplo 
lançam nto d rec itas Oava), 122-125 
problema do lançamento de receitas, 121-123 


ÍNDICE 493 

quando usá-lo, 120-122 
Transacionais, recursos, 86-87 
Transações, 80-81, 85 
de negócio e de sistema, 87-90 
de sistema, 87-90 
longas, 86 
solicitação de, 86 
tardias, 86 
Transações, reduzindo o isolamento para aumentar a 
capacidade de resposta, 86-88 
Transações de sistema e de negócio, 87-90 
Transformação, Vista de, 343-346 
exemplo 
transformação simples (Java), 344-346 
quando usá-la, 343-345 
Transformação simples, 344-346 
Tudo, juntando, 105-115 
alguns conselhos específicos para determinadas 
tecnologias, 109-113 
começando com as camadas de domínio, 106-107 
descendo para as camadas de fontes de dados, 
106-110 
esquemas variados de camadas, 112-115 

u 

Única, Herança de Tabela, 
carregando objetos de ban cos de dados, 271-275 
corno funciona, 269-270 
exemplo 
tabela única para jogadores (C#), 270-272 
quando usá-la, 269-271 
Unidade de Trabalho, 187-195 
corno funciona, 187-192 
exemplo 
Unidade de Trabalho com registro de objetos 
Oava), 192-195 
quando usá-la, 191-193 
Unidade de Trabalho com registro de objetos (Java), 
192-195 

Valor, Objeto, 453-454 
como hmciona, 453-454 
quando usá-lo, 453-454 
Valor, Objeto simples, 262-263 
Valor, usando um armazenador de, 20-t-206 
Valor Embutido, 261-263 
como funciona, 261 

exemplo 
objetos valor simples Oava), 262-263 
leitura adicional, 262-263 
quando usá-lo, 261-262 
Velhos e bons objetos Java (POJOs), 371-372 
Virtual, proxy Oava), 202-205 
Vista, Padrões de, 74-76 
Vista de Transformação, 343-346 
como htnciona, 343-344 
exemplo 
transformação simples (Java), 344-346 
quando usá-la, 343-345 
Vista em Duas Etapas, 347-359 
como funciona, 347-348, 350 
exemplos 
JSP e tngs customizadas Oava), 355-359 
XSLTem duas etapas (XSLT), 352-355 
quando usá-lo, 348, 350-353 
Vista JSP, exibição simples com, 319-322 
Vistas Padrão, 333-342 
como funciona, 333-337 
exemplos 
página servidora ASP.NET (C#), 339-342 
usando JSP como vista com controlador separado 
Qava), 337-340 
quando usá-la, 336-338 

w 

Web, apresentação 71-77 
padrões de controle de entrada, 75-77 
padrões de vista, 74-76 
Web, padrões de apresentação, 314-366 
Controlador de Aplicação, 360-366 
Controlador de Página, 318-327 
Controlador Frontal, 328-332 
MVC (Modelo Vista Controlador), 315-317 
Vista de Transformação, 343-346 
Vista em Duas Etapas, 347-359 
Vista Padrão, 333-342 
Web, serviço (C#), 374-379 
Web, serviços, 112-113 

X 

XML 
serializando hierarquia de departamentos em, 
265-268 
serializando usando, 388-390 
XSLT em duas etapas, 352-355 


Lista de Padrões 

Bloqueio de Granularidade Alta (Coarse-Grained Lock) (412): Bloqueia um conjunto de objetos relacionados 
utilizando para isso um único bloqueio. 
Bloqueio Implícito (Implicit Lock) (422): Permite ao código de uma camada supertipo ou de umframework 
bt r bloqu io offline. 
Bloqueio Olfli11e Otimista (Optimistic Offline Lock) (392): Pre ine conflito entre transaçõ d negócio 
concorrente dete tando um conflito e de faz ndo a trnn ação. 
Bloqueio Offli11e Pessimista (Pessimistic Offline Lock) (401): Pr ine conflito ntre tran açõe de 
ne ócio concorrente permitindo que apenas uma transação de ne ócio aces e os dado de cada ez. 
Camada de Serviço (Service Layer) (141): D fine a fronteira de uma aplicação com uma camada de 
ser iços que estabelece um conjw1to de operações disponí eis e coordena a resposta da aplicação em 
cada op ração. 
Camada Supertipo (Layer Supertype) (444): m tipo qu atua como o upertip para todo o tipo 
n ta camada. 
Campo Identidade (Identity Field) (215): uarda o campo 10 de um banco d dad em um objeto 
para manter a identidade entre um objeto na memória e uma linha do banco de dados. 
Carga Tardia (Lazy Load) (200): Um objeto que não cont m todos o dado d que você precisa, ma 
que sabe como obtê-los. 
Caso Especial (Special Case) (462): ma ubcla qu forn c comportamento pedal para ca os 
particular . 
Conjunto de Registros (Record Set) (473): Uma r pr ntação mm mória d dado tabular . 
Controlador de Aplicação (Application Controller) (360): Um p nto c ntralizad para manipular a 
na egação de tela e o fluxo de uma aplicação. 
Controlador de Página (Page Controller) (318): Um objeto que trata urna requi ição para urna pági


na ou ação específica em um site Web. 
Controlador Frontal (Front Controller) (328): m controlador que trata toda as requi içõe para um 
site W b. 
Dinheiro (Money) (455): R pr nta um valor mon tário. 
Estado da Sessão no Banco de Dados (Database Session State) (432): Armaz na dado d ão no 

banco de dado . 
Estado da Se são no Cliente (Client Session State) (427): Armaz na tado da ão no cli nte. 
Estado da Sessão no Servidor (Server Session State) (429): ant'm o e tado da se são m um siste


ma ervidor de forma serializada. 

Fachada Remota (Remote Façade) (368): Fornece uma fachada de granularidade alta sobre objetos de 
granularidade baixa para melhorar a eficiência em uma rede. 
Gateway (436): Um objeto qu ncap ula o ace o a um i t ma ou r cur o ex t mo. 
Gateway de Linha de Dados (Row Data Gateway) (158): Um obj to qu atua como um at way 

(4 6) para um único regi troem uma f nte de dado . E i te uma in tância por linha. 
Gateway de Tabela de Dados (Table Data Gateway) (151): Um obj to qu atua corno um at way 
(436) para uma tabela de um banco de dado . Uma instância lida com toda a linhas na tabela. 
Herança de Tabela Concreta (Concrete Table Inheritance) (283): Representa um hierarquia de herança 
de classes com uma tabela por classe concreta na hierarquia. 
Herança de Tabela de Classes (Class Table Inheritance) (276): R pre enta urna hierarquia de h rança 
de ela e com uma tabela por ela e. 
Herança de Tabela Única (Single Table lnheritance) (269): R pre nta uma hierarquia de h rança de 
ela como uma única tabela que t rn coluna para t do o campo da di er a ela 
Interface Separada (Separated Interface) (445): Define uma interface em um pacote separado de sua 
irnpl m ntação. 
LOB Serializado (Serialized LOB) (264): rava um grafo de objetos serializando-os em um único obj 
to grand {LOB -Large OBject), o qual é armazenado em wn campo do banco de dado . 

Mapa de Identidade (ldentity Map) (196): Garante qu cada obj to ja carr gado ap na uma z 
mantendo cada objeto carregado m um mapa. Procura p lo objeto u and o m, pa, quando há uma 
referência para el s. 
Mapeador (Mapper) (442): m objeto qu e tabel ce uma comunicação ntre dois obj tos ind pendentes. 


Mapeador de Dados (Data Mapper) (170): Uma camada d Mapeadore (442) que move dados entre 
objeto eumbancodedado enquanto mantémindependente un do utro edopr'priomapeador. 
Mapeadores de Herança (Inheritance Mappers) (291): Uma e trutura para organizar mapeador de 
bancos de dado qu tratam hierarquia d herança. 
Mapeamento de Chave Estrangeira (Foreign Key Mapping) (233): Mapeia uma a ociação ntr objetos 
para uma referência de chave e tran eira entre tabelas. 

Mapeamento Dependente (Dependent Mapping) (256): Faz uma class executar o map amento no 
banco de dado de uma ela e filha. 
Mapeamento em Metadados (Metadata Mapping) (295): Armaz na detaJh do mapeamento objeto-
relacional m metadad . 
Mapeamento de Tabela Associativa (Association Table Mapping) (244): Gra a uma a oc,açao como 
uma tabela com cha es e trangeiras para as tabelas qu stejam vinculadas pela a ociação. 

Modelo de Domínio (Domain Model) (126): m modelo de objetos do domínio que incorpora tanto 

o comportamento quanto os dados. 
Modelo Vista Controlador (Model View Controller) (315): Oi ide a interação da interface com o 
u uário m trê papéi di tinto . 
Módulo Tabela (Table Module) (134): ma in tância única que trata a lógica de negócio para toda 
a linha d uma tab la ou i ão m um banco d dado . 
Objeto de Pesquisa (Query Object) (304): m obj t quer pr nta uma con ulta ao bane d dado . 
Objeto de Transferência de Dados (Data Transfer Object) (380): m obj to que tran porta dado entr 
prece sos de modo a r <luzir o número d chamadas de método . 
Objeto Valor (Value Object) (453): Um objeto pequeno e simples, como dinheiro ou um inter alo de 
data , cuja igualdad não bas ada em identidade. 
Plugin (465): Conecta ela durant a configuração, em v z de na compilação. 
Regi tro (Registry) (448): Um objet conhecido que outro objet podem u ar para ncontrar bj to 
erviço comun . 
Registro Ativo (Active Record) (165): m objeto que encap ula uma linha, em uma tabela ou visão 
de um banco de dado e o ace o ao banco de dado e adiciona lógica de domínio a e s dado . 
Repositório (Repository) (309): Faz a mediação entre as camadas de domínio e de mapeamento de 
dados u ando uma interface do tipo coleção para aces ar os objetos do domínio. 
Roteiro de Transação (Transaction Script) (120): Organiza a lógica de negócio em procedimentos em 
qu cada proc dim nto trata uma única olicitação da apr ntação. 
Stub de Serviço (Service Stub) (469): R mo a d p nd Ancia d rviço probl mático durant o 
te te . 
Unidade de Trabalho (Unit of Work) (187): antém uma li ta de objeto af tado por uma tran ação 
de negócio e coordena a gravação das alterações e a resolução de problemas de concorrência. 
Valor mbutido (Embedded Value) (261): apeia um objeto em di ersos campos da tabela de outro 
objeto. 
Vi ta de Transformação (Transfonn View) (343): Uma i ão que prece a dado do domínio elemento 
p r e! m nto o tran forma m HT L. 
Vista em Duas Etapas (Two Step View) (347): Tran forma dado do d mínio em HTML m dua etapa 
: prim ir , formand algum tip d página lógica e, depoi , r pre ntando e a página lógica em 

HTML. 
Vista Padrão (Template View) (333): Repre enta informações em HTML in erindo marcadores em 
uma página HTML. 


Cola 

Aviso: Esta discussão de questões está muito simplificada! 

Como estruturo minha lógica de domínio? 

A lógica é simples ➔ Roteiro de Transação (120) 
A lógica é complexa 
➔ Modelo de Domínio (126) 
A lógica é moderada e há boas ferramentas para um Conjunto de Regi tro (473) ➔ Módulo Ta


bela (134) 

Como disponibilizo uma API distinta para minha lógica de domínio? 

➔ Cmnada de Serviço (141) 
Como estruturo uma apresentação Web? 

➔ Modelo Vi ta Controlador (315) 
Como organizo meu processamento de solicitações HTTP? 

T◄ nho um fluxo d aplicação impl , m ua maioria URL clir ta ➔ Controlador de Página 

(318) 
Tenho um fluxo complicado ➔ Controlador Frontal (328) 
T◄ nho n c idad d int macionalização ou d política fl xí is d gurança ➔ Contro


lador Frontal (328) 

Como controlo a formatação das minhas páginas Web? 

Go to de editar a página e colocar gancho para dado dinâmico ➔ Vi ta Padrão (333) 
Vejo a página como uma tran formação de dado do do.oúnio -pr vavelm nt em XML 
➔ 

Vista de Transformação (343) 
Preciso fazer alterações gerais na aparência do meu site 
➔ Vista em Duas Etapas (347) 
Preci o de múltiplas apresentações para o mesmo formato lógico de tela ➔ Vista em Duas 

Etapas (347) 

Como controlo um fluxo de aplicação complexo? 

➔ Controlador de Aplicação (360) 
Como interajo com o banco de dados? 

tou usando um Roteiro de Tran ação (120) ➔ Gateway de Linha de Dado (15 ) 
stou usando um Roteiro de Transação (120) e minha plataforma tem um bom suporte para 
um Conjunto de Registro (473) ➔ Gateway de Tabela de Dados (151) 
T◄ nho um Modelo de Domínio (126) qu tem forte corr pondAncia com minhas tabela d 
banco d dado ➔ Regi tro Ativo (165) 
T◄ nho um Modelo d Domínio (126) rico 
➔ Mapeador de Dado (170) 

Como posso assegurar que não atualizarei os mesmos dados do banco de dados em diferentes 
lugares da memória? 

➔ Mapa de Identidade (196) 
Como mantenho meus objetos de domínio conectados a registros do banco de dados? 

➔ Campo Identidade (215) 
Como minimizo o código para mapear meus dados de domínio para o banco de dados? 

➔ Mapeamento de Metadado (295) 

Como posso pesquisar o banco de dados em termos do meu Modelo de Domínio (116)? 

➔ Objeto de Pesquisa (304) 
Como armazeno associações entre os objetos no banco de dados? 

Ti nho uma única r f rAncia para um obje 
to 
➔ Mapeamento de Chave E trangeira (233) 

Tenho um conjwlto de bjeto ➔ Mapeamento de Chnve E trangeira (233) 

1i nho um r }acionam nto muito para muito ➔ Mnpenmento de Tnbeln de A ocinção (244) 

Tenho uma coleção de objetos que não são compartilhado com outros 
➔ Mapeamento De


pendente (256) 

Tenho um campo que é um Objeto Valor (453) ➔ Valor mbutido (261) 

Tenho uma rede compl xa de objeto que não ão u ados por outra part s do banco de da


do ➔ LOB Serializado (264) 

Como evito carregar todo o banco de dados na memória? 

➔ Cnrgn Tnrdia (200) 
Como armazeno estruturas de herança em um banco de dados relacional? 

➔ Herança de Tabela Única (269) 
Uma única tabela agirá como um gargalo em acessos ao banco de dados ➔ Herança de Tabela 
de Cln e (276) 
Uma única tabela d perdiçará e paço no banco d dado ➔ Herança de Tabela de Cla e 
(276) 
11 r i muita m mo a im não qu r uma tab la única ➔ Hernnçn d Tabela Concretn 
(283) 

Como mantenho registro dos objetos que li ou alterei? 

➔ Unidade de Trabalho (187) 
Como posso confirmar (commit) minhas alterações no banco de dados dentro de uma única 
requisição do cliente? 

➔ Bloqueio Offline Otimista (392) 
ão po o d ixar um u uário perder s u trabalho 
➔ Bloqueio Offline Pe imi tn (401) 
Como posso bloquear (lock) um conjunto de objetos relacionados usando um único bloqueio? 

➔ Bloqueio de Crnn11/nridade Alta (412) 
Como posso evitar comprometer minha estratégia de bloqueio? 

➔ Bloqueio Implícito (422) 
Como posso acessar remotamente objetos de granularidade baixa? 

➔ Fncl1adn Remotn (368) 

Como passo dados de muitos objetos em uma única chamada remota? 

➔ Objeto de Transferêncin de Dndos (380) 
Como armazeno estado no meio de uma transação de negócio com estado? 

➔ ão há muito estado ➔ E fado da Se ão no Cliente (427) 
➔ Exi tem muit tad ➔ E tado da Se ão no Servidor (429) 
➔ Po o gravar o trabalho rn progr no banco d dado ➔ E fado dn Se ão no Bnnco de 
Ondas (432) 

