Bibliografia Universitária Pearson 


ARQUITETURA DE SOFTWARE 



ARQUITETURA DE SOFTWARE 

Organizador 
Giocondo Marino Antonio Gallotti 
Mestre em gestão e empreendimentos pela Universidade Cidade de São Paulo (Unicid) 
Especialista em Redes de Comunicação de Dados pela Universidade de Brasília (UnB) 
Professor na Universidade São Judas Tadeu (USJT) nos cursos de engenharia e sistemas de 
informação e professor convidado da pós-graduação lato sensu nos cursos de redes 
de computadores, telecomunicações e engenharia de redes 

O Pearson abdr + 

Respeite o direito autora! 



O 2016 by Pearson Education do Brasil 

Todos os direitos reservados. Nenhuma parte desta publicação poderá 
ser reproduzida ou transmitida de qualquer modo ou por qualquer outro 
meio, eletrônico ou mecânico, incluindo fotocópia, gravação ou qualquer 
outro tipo de sistema de armazenamento e transmissão de informação, sem 
prévia autorização, por escrito, da Pearson Education do Brasil. 

Gerente editorial: Thiago Anacleto 
Supervisora de produção editorial: Silvana Afonso 
Coordenação de produção editorial: Jean Xavier 
Editor: Casa de Ideias 
Editor assistente: Marcos Guimarães 
Redação: Rodrigo da Costa 
Projeto gráfico e diagramação: Casa de Ideias 

Dados Internacionais de Catalogação na Publicação (CIP) 
(Câmara Brasileira do Livro, SP, Brasil) 

Arquitetura de software / organizador Giocondo Marino Antonio Gallotti. — São Paulo : 
Pearson Education do Brasil, 2016. 

Bibliografia. 
ISBN 978-85-430-1735-8 

1. Arquitetura de software 2. Software — Desenvolvimento 1. Gallotti, Giocondo 
Marino Antonio. 
16-00385 CDD-005.1 
Índice para catálogo sistemático: 
1. Engenharia de software : Computadores : Programação : Processamento de dados 005.1 

Direitos exclusivos cedidos à 
Pearson Education do Brasil Ltda., 
uma empresa do grupo Pearson Education 
Avenida Santa Marina, 1193 
CEP 05036-001 -São Paulo -SP -Brasil 
Fone: 11 2178-8609 e 11 2178-8653 
pearsonuniversidadesQ pearson.com 



SUMÁRIO 

Apresentação Vil 
Prefácio IX 
Unidade 1 Conceitos arquiteturais, componentes, 
conectores e configurações 1 
Conceitos arquiteturais 4 
Software 4 
Função e desempenho 5 
Fases do desenvolvimento do software 6 
Componentes e conectores 10 
Conceituando a arquitetura de software 
Os elementos da arquitetura de software... 
Configurações e padrões arquiteturais.... .14 
Arquitetura MVC 15 
Arquitetura em camadas 17 
Arquitetura de repositório 20 
Arquitetura cliente-servidor 22 
Arquitetura de duto e filtro 24 

Unidade 2 Modelagem e análises arquiteturais..................... 

Modelagem de sistemas 
Modelos de contexto 
Modelos de interação 
Modelos estruturais 
Modelos comportamentais 

Análise arquitetural 
Arquitetura de aplicações 
Arquitetura de sistemas confiáveis 
Arquitetura mestre-escravo para sistemas distribuídos 
Arquitetura cliente-servidor multicamadas a 
Arquitetura de componentes distribuídos ...............eersesmmss 

Unidade 3 Projetando e implementando arquiteturas .......69 
Plataforma de software 70 
Testes de defeitos e debugging 73 


vi) ( irquitetura de software 

Modelos de contexto e modelos de interação......................... 73 
Modelo de arquitetura de alto nível 75 
Identificação dos objetos de classe 77 
Modelos de projeto 80 
Modelos de projeto ou modelos de sistema.................eereeremss 80 
Especificações de interface 84 
Padrões de projeto 86 
Implementação: questões de implementação.......................... 90 
Reúso 91 
Gerenciamento de configuração 93 
Desenvolvimento host-target 95 

Unidade 4 Frameworks e projetos de requisitos formais 
e não formais 101 
Frameworks de aplicações existentes...................mesrereememes 102 
Linhas de produto de software 106 
Projetando requisitos não funcionais........................mues 109 
Engenharia de requisitos 109 
Documento de requisitos de software....................... 119 
Especificações de requisitos 122 
Processos de engenharia de requisitos.................mmeseesseea 128 

Referências 135 


APRESENTAÇÃO 

Nos catálogos de livros universitários há vários títulos cuja pri-
meira edição saiu há 40, 50 anos, ou mais. São livros que, graças à 
identificação da edição na capa (e somente a ela), têm sua idade re-
velada. E, ao contrário do que muitos podem imaginar, isso não é um 
problema. Pelo contrário, são obras conhecidas, adotadas em diversas 
instituições de ensino, usadas por estudantes dos mais diferentes per-
fis e reverenciadas pelo que representam para o ensino. 

Qual o segredo de sucesso desses livros? O que eles têm de 
diferente de vários outros que, embora tenham tido boa aceita-
ção em um primeiro momento, não foram tão longe? Em poucas 
palavras, esses livros se adaptaram às novas realidades ao longo 
do tempo, entendendo as mudanças pelas quais a sociedade — e, 
consequentemente, as pessoas — passava e as novas necessidades 
que se apresentavam. 

Para que isso fique mais claro, vamos pensar no seguinte: a 
maneira como as pessoas aprendiam matemática na década de 
1990 é igual ao modo como elas aprendem hoje? Embora os ali-
cerces da disciplina permaneçam os mesmos, a resposta é: não! 
Nesse intervalo de tempo, ocorreram mudanças significativas — a 
Internet se consolidou, os celulares se popularizaram, as redes so-
ciais surgiram etc. E todas essas mudanças repercutiram no modo 
de vida das pessoas, que se tornou mais rápido e desafiador, trans-
formando os fundamentos do processo de ensino/aprendizagem. 

Foi com base nisso que nasceu a Bibliografia Universitária 
Pearson (BUP). Concisos sem serem rasos e simples sem serem 
simplistas, os livros que compõem esta série são baseados na 
premissa de que, para atender sob medida às necessidades tan-
to dos alunos de graduação como das instituições de ensino — 
independentemente de eles estarem envolvidos com ensino presen-
cial ou a distância —, é preciso um processo amplo e flexível de 
construção do saber, que leve em conta a realidade em que vivemos. 

Assim, as obras apresentam de maneira clara os principais 
conceitos dos temas propostos, trazendo exatamente aquilo que 

o estudante precisa saber, complementado com aprofundamentos 

vin) ( irquiterura de software 

e discussões para reflexão. Além disso, possuem uma estrutura didática que propõe uma 
dinâmica única, a qual convida o leitor a levar para seu dia a dia os aspectos teóricos apre-
sentados. Veja como isso funciona na prática: 

A seção “Panorama” aprofunda os tópicos abordados ao mostrar como eles funcionam 
na prática, promovendo interessantes reflexões. 

Panorama 

A era do raciocínio artificial 

Ninguém sabe muito bem do que se trata, mas, sobre as necessidades do usuário, para oferecer 
como disse recentemente Scott Prevost, diretor uma experiência personalizada, mais produtiva e 

de desenvolvimento do site de busca Bing, da intuitiva. 

Microsoft, “seja o que for, a Web 3.0 já está aqui”. A Web semântica — como os especialistas definem 

Ainda nem bem começamos a entender o que essa rede dinâmica e pensante. Imagine que o 

é a Web 2.0, e "gurus”, tecnólogos, cientistas e texto, os gráficos e as fotos que vemos no nave-

Ao longo do livro, o leitor se depara com 
vários hipertextos. Classificados como “Saiba 
mais”, “Exemplo”, “Fique atento” e “Link”,

memo) Dum 

esses hipertextos permitem ao aluno ir além em 
suas pesquisas, oferecendo-lhe amplas possibi-

lidades de aprofundamento.

Introdução 

de, vamos nos dedicar basicamente a dois conceitos de arqui 
ares mod e analise arquitetural Para começarmos a 
, responda oq vem à sua cabeça quando pensa na pala 

A linguagem dialógica aproxima o es-

r"? Geralmente, lunos respor m a essa pergunta dizendo 

tudante dos temas abordados, eliminando 

am algo como ar com mas: la ou a im material 
desse tipo, e também que w a mente a ideia de “fazer moldes! 

qualquer obstáculo para seu entendimento 
e incentivando o estudo. 

A diagramação contribui para que o estu-
dante registre ideias e faça anotações, intera-
gindo com o conteúdo. 

Todas essas características deixam claro 
que os livros da Bibliografia Universitária 
Pearson constituem um importante aliado 
para estudantes conectados e professores ob-
Jetivos — ou seja, para o mundo de hoje — e 
certamente serão lembrados (e usados) por 

Função e desempenho muito tempo. 

Boa leitura! 



PREFÁCIO 

Na área da informática, a engenharia de software é tratada 
como uma área do conhecimento voltada à especificação, ao de-
senvolvimento e à manutenção de sistemas de software aplicando 
tecnologias e práticas da ciência da computação e da gerência de 
projetos, visando organização, produtividade e qualidade. 

É nos alicerces científicos da engenharia de software que en-
contramos o uso de modelos abstratos e precisos, os quais per-
mitem ao profissional especificar, projetar, implementar e manter 
sistemas de software, com a finalidade de avaliar e garantir sua 
qualidade. 

Iniciaremos nosso estudo tratando dos princípios da arquitetu-
ra de software, procurando esclarecer as fases para o desenvolvi-
mento de um programa, os elementos encontrados nas arquiteturas 
e os padrões arquiteturais básicos. Em seguida, veremos os tipos 
básicos de modelagem e como fazer uso dos diferentes tipos de 
diagramas utilizados para a modelagem. Conheceremos as arqui-
teturas de aplicações e onde utilizá-las, bem como implementar 
arquiteturas de sistemas ditos confiáveis. Por fim, estudaremos os 
processos de projeto, os modelos e, além disso, conheceremos os 
conceitos gerais para sua implementação. 

Bons estudos! 



UNIDADE 

Conceitos arquiteturais, 
componentes, conectores e 
configurações 

ze Objetivos de aprendizagem 

Dominar os princípios da arquitetura de software. 
Entender as fases para o desenvolvimento de um programa. 
Saber quais são os elementos de uma arquitetura. 
Conhecer os padrões arquiteturais básicos. 

Fa Temas 

B 1 -Conceitos arquiteturais 
Vamos começar esta unidade entendendo o que são softwares, 
quais seus conceitos fundamentais e também quais as fases do seu 
desenvolvimento. 

B 2-Componentes e conectores 
Seguindo nosso estudo, vamos entrar especificamente na arquitetu-
ra de software, entendendo seus conceitos e conhecendo seus prin-
cipais elementos. 

B 3-Configurações e padrões arquiteturais 
Fechando a primeira parte do nosso curso, você vai conhecer os pa-
drões básicos de arquitetura de software. 

Introdução 

Vivemos a era do software. Nos últimos dois séculos, a humanidade de-
senvolveu e se apropriou de tecnologias de um modo sem precedentes 
na história. De modo geral, passamos séculos sem ressignificar os recur-
sos que foram descobertos ou criados a partir da Pré-História, como o 


2) ( arquitetura de software 
fogo, a roda, a cerâmica, a agricultura, a domesticação de animais e 
a forja dos metais, quando nossas fontes de energia ainda estavam 
baseadas em forças naturais em sua forma bruta, como a água, o 
Sole o vento. 
Para um exemplo prático, vamos pensar nas duas grandes guerras 
protagonizadas em boa parte do século XX. Ou, mais especificamen-
te, nas tecnologias empregadas nelas. Em 1914, o kit básico de qual-
quer soldado ainda era composto por uma espada, que foi criada na 
Idade dos Metais, e o uso de cavalos, seja para locomoção ou para 
tração, continuava fundamental. As armas de fogo, utilizando a pólvo-
ra trazida da China, permaneciam pouco precisas, práticas e mesmo 
confiáveis. Eram frequentes os acidentes com os primeiros fuzis, que 
explodiam nas mãos dos soldados. Isso porque estamos falando de 
armas, sem considerar, por exemplo, que ainda não existiam os 
antibióticos farmacológicos, podendo um simples corte no arame far-
pado custar a vida de um combatente. 
Contudo, em 1945, ou seja, apenas 31 anos depois, o ponto final da 
Segunda Guerra foi dado por duas bombas atômicas. Houve um gi-
gantesco salto tecnológico; em pouquíssimos anos (não só entre, 
como durante os conflitos), desenvolvemos e aprimoramos aviões, 
submarinos, tanques, sem falar nos materiais, nos combustíveis, nas 
fontes de energia, no desenvolvimento da medicina e, é claro, na tec-
nologia da informação. Em guerras daquelas proporções, com tama-
nho equilíbrio de forças, mais do que a coragem, a bravura, ou mesmo 

o aparato bélico, o que poderia fazer diferença entre a vitória e a der-
rota em uma batalha era a informação. 
Por anos contamos a história dos conflitos a partir dos feitos nos cam-
pos de batalha, mas cada vez mais temos descoberto que nos momen-
tos decisivos o grande diferencial foi a informação. Seja a capacidade de 
obtê-la do inimigo, seja a de evitar que ele a tivesse. Nos anos seguin-
tes, com o desenrolar da Guerra Fria, o investimento maciço em tec-
nologia da informação nos levou a criar os primeiros computadores, 
máquinas ainda muito incipientes antes da metade do século, e redes 
de comunicação como a ARPANet, a mãe da Internet. A corrida espa-
cial levou ao desenvolvimento de satélites artificiais e novas tecnolo-
gias de transmissão. 

Conceitos arquiteturais, componentes, conectores e configurações (3 

Por outro lado, com a atividade econômica cada vez mais racionaliza-
da pelo capitalismo, as tecnologias da informação se tornaram im-
prescindíveis para otimizar a produção, a distribuição eo planejamento. 
Você consegue imaginar como era uma bolsa de valores antes dos 
computadores e da Internet? E um banco, então? 
O ponto no qual estamos querendo chegar aqui é que, através da 
convergência de uma série de fatores, estabelecemos um modelo de 
civilização que é insustentável sem as atuais tecnologias de informa-
ção. Imagine o que aconteceria se, apenas por uma semana, todos os 
satélites, computadores e a Internet do mundo inteiro parassem de 
funcionar. Pense no caos que seria gerado, nas perdas materiais e ima-
teriais. A tecnologia está no nosso modo de ser atual. Pergunte para 

um adolescente de hoje se ele é capaz de imaginar como seria o 

mundo sem celulares, tablets, redes sociais, sem o Google. E observe 
que estamos pensando em coisas que são amplamente difundidas há 
apenas algo em torno de 10, 15 anos. 
Vivemos na era do software pelo fato de que ele é um elemento pre-

ponderante para a existência do nosso atual modo de vida. Não ape-
nas no plano pessoal, o modo como as pessoas se utilizam dele no 
cotidiano, mas, sobretudo, pelo fato de que a organização da nossa 
existência — social, econômica, política e cultural -passa hoje indisso-
ciavelmente pela tecnologia do software. Ele é a tecnologia que inte-
gra todas as outras; ele permite que as tecnologias sejam controladas, 
coordenadas e eficientes. Ele integra as intenções e necessidades hu-
manas diretamente com os recursos, rompendo com os limites de 
espaço e tempo como nós os conhecíamos. Ele se ocupa de procedi-
mentos específicos para que possamos operar de maneira cada vez 
mais ampla e complexa. Pense que, por trás da praticidade de mandar 
um e-mail ou utilizar um caixa eletrônico, existe uma infinidade de 

procedimentos técnicos pelos quais o software se encarrega para que 
essas atividades sejam realizadas. 

Enfim, é aqui que chegamos ao ponto decisivo. Qual o propósito da 
arquitetura de softwares? Criar soluções. Soluções cada vez mais sim-
ples, rápidas e eficientes. Não somente resolver problemas, mas pre-
venir a ocorrência deles, e otimizar ainda mais soluçõesjá existentes. 

Não há limites para o que os softwares possam fazer, e temos a sensa-
ção — até pelo relativamente curto período da história em que nós os 
dominamos — de que estamos só no começo. 


4) Arquitetura de software 
Hoje, difícil mesmo é imaginar um futuro sem softwares, um “futuro 
pós-softwares” Por que não? Porque, basicamente, temos a consciên-
cia de que eles são a chave para o futuro. 
Mas você pode estar pensando: qual o propósito de eu estar estudan-
do arquitetura de softwares? O seu objetivo aqui é dominar elemen-
tos complexos para fazer que eles estejam na vida das pessoas de 
maneira simples. 

Conceitos arquiteturais 

Software 

Para começo de conversa, perguntamos a você: o que é um 
software? 

Dentre muitas respostas possíveis, podemos dizer que software é 

o elemento que faz a mediação entre as pessoas e a máquina. Para 
isso, ele se utiliza de dados. Esses dados podem ser de qualquer 
origem, armazenados em qualquer mídia, e tudo se torna “proces-
sável” por softwares desde que seja capaz de ser convertido em 
dados que ele consiga entender. Por exemplo, podemos utilizar 
um software para calcular valores existentes em uma planilha. 
Nesse caso, ele processa dados que já estão em uma linguagem 
própria empregada por computadores. Mas, também, podemos 
usar softwares para processar fotos, vídeos ou a nossa própria 
voz, desde que esses dados sejam convertidos em linguagem 
processável. 
A relação direta entre a pessoa e o computador é intermediada 
por algo que chamamos de interface homem-máquina. É através 
dela que damos os comandos de entrada e recebemos as informa-
ções de saída. Por sua vez, o software opera internamente atra-
vés de uma série de outras interfaces, até chegar à linguagem de 
máquina, baseada em códigos binários. Por exemplo, você pode 
utilizar um software aplicativo, como um editor de texto (o Micro-
soft Word, sem dúvida, é o mais conhecido e utilizado), e a partir 
da sua interface dar comandos de entrada, como digitar no teclado 
e clicar em ícones da interface. Ele processará e dará a você in-
formações de saída por intermédio da tela do monitor, ou mesmo 
pelas caixas de som ou pela impressora. 



Conceitos arquiteturais, componentes, conectores e configurações) 

Porém, o editor de texto não se comunica diretamente com o 
processador do seu computador. Ele atua por meio de uma inter-
face interna com o software base ou básico, também chamado de 
sistema operacional. No caso, poderia ser o Windows em uma 
de suas muitas versões. O software, por sua vez, utilizando-se de 
tradutores, converte os dados em linguagem de máquina. Confor-
me esses dados vão sendo processados, eles seguem o caminho 
inverso até chegar à interface e, portanto, em você, que está diante 
da tela do computador. 

O software trabalha e opera executando algoritmos. Os algo-
ritmos são uma série de instruções (steps) que devem ser seguidas 
em sequência para que uma função seja atendida. 

Saiba mais 

Atualmente, a grande maioria dos algoritmos se baseia em dados numéri-
cos e não numéricos, estruturados de modo que os steps, loops e condições 
já são definidos antecipadamente, e o software só os executa. Mas saiba 
que estão sendo desenvolvidos e aplicados novos tipos de algoritmos de 
processamento que buscam se assemelhar ao modo como um cérebro hu-
mano trabalha ao diagnosticar e resolver problemas. Eles são chamados de 
softwares de sistema especialista. Existem também as chamadas redes neurais 
artificiais, que, como o próprio nome deixa claro, buscam se aproximar da 
fisiologia do cérebro humano e têm como expectativa o desenvolvimento. 
da capacidade mais avançada de reconhecer, assimilar e aplicar padrões. Em 
outras palavras, um sistema que seja capaz de aprender. 
Uma rede neural artificial é composta por várias unidades de processamen-
to, cujo funcionamento é bastante simples. Essas unidades, geralmente, são. 
conectadas por canais de comunicação que estão associados a determinado 
peso. As unidades fazem operações apenas sobre seus dados locais, que são 
entradas recebidas pelas suas conexões. O comportamento inteligente de 
uma rede neural artificial vem das interações entre as unidades de proces-
samento dela. 

Função e desempenho 

Para entendermos como se organiza um software, pense-
mos que ele se divide em dois elementos: função e desempe-
nho. Os dois são aplicados ao software desde a sua concepção e 



6) (irquiterura de software 
desenvolvimento, e estão diretamente relacionados. Contudo, essa 
relação varia de acordo com o caso. 

A função é basicamente um conjunto de formas de manipu-
lação de dados a partir da execução de um processo sequencial. 
Aqui, o desempenho não tem tanta importância assim, concen-
trando-se basicamente na eficiência com que a execução do pro-
cesso é feita — quanto mais rápido, menos recursos da máquina 
utilizar e mais preciso for, melhor. 

Porém, a função de um software também pode ser o controle 
e a coordenação de processos internos que estão concorrendo en-
tre si pelos mesmos recursos da máquina. Aqui, o desempenho já 
se torna um fator fundamental do software, sendo a resposta e 
os tempos de espera (wait times) determinantes para a eficiência 
do programa. 

No processo de desenvolvimento do software, devemos es-
tabelecer e/ou adquirir componentes de software para equilibrar 
e otimizar a relação entre função e desempenho. Enquanto no 
hardware os componentes são normalmente padronizados (em 
geral, quanto mais padronizado for o hardware, melhor para o 
desenvolvimento do software), os componentes do software em 
geral devem ser específicos, customizados, para atender às ne-
cessidades especiais do que está sendo criado. 

Fases do desenvolvimento do software 

Agora que relembramos o básico sobre o que é um software e 
nos atentamos aos conceitos de função e desempenho, começare-
mos a pensar diretamente no desenvolvimento do software. Para 
que fique bem claro para você neste início de conversa quais os 
elementos envolvidos nesse trabalho, vamos dividi-lo em fases. 
Essas fases serão: 

1. Definição. 
2. Desenvolvimento. 
3. Verificação, liberação e manutenção. 
Fase de definição 

Como estamos lidando com coisas tão complexas como 
softwares, planejamento é algo que não pode faltar. Ora, ninguém 
vai sair desenvolvendo um programa de qualquer jeito, e no meio 
do caminho pensar em para que ele servirá ou do que ele precisará 



Conceitos arquiteturais, componentes, conectores e configurações) (7 

para ser desenvolvido. É evidente que imprevistos vão ocorrer no 
meio do caminho, e isso só reforça ainda mais a necessidade do 
planejamento bem feito. 

A fase de definição se baseia na elaboração do plano de pro-
jeto de software. Você se lembra de que dissemos na introdução 

que softwares servem para resolver problemas ou criar novas 

facilidades? Na fase inicial do desenvolvimento de um software, 

a primeira coisa a se fazer é definir, então, qual a finalidade do 

software. Ou seja, em linhas gerais, estabelecer a que ele se pro-

põe, e como. O que ele vai fazer que outros ainda não façam, ou 

melhor que os já existentes. Um software também pode ser desen-

volvido por encomenda, e, nesse caso, a etapa de definição deve 

considerar também quais as necessidades específicas que deverão 

ser atendidas. 

Como todo empreendimento, desenvolver um software impli-

ca em riscos. Assim, a segunda etapa da fase de definição é consi-

derar no plano de projeto de software quais os riscos envolvidos e 

fazer uma análise deles. 

Por ser um projeto, ele deve levar em conta quais os recursos 

que serão necessários. Nessa terceira etapa, devem ser observa-

dos os recursos humanos, mas também os recursos materiais, e os 

custos que serão estimados. Também são considerados os prazos 

previstos para a execução do projeto. 

O objetivo geral do plano de projeto de software é fornecer 

uma perspectiva geral que permita analisar a viabilidade da sua 

execução. De maneira geral, é pensar mesmo em uma relação 

custo/benefício. Tendo em mente um trabalho encomendado, ela 

também serve como base de cálculo para saber quanto será cobra-

do pelo desenvolvimento do produto. Geralmente, o responsável 

pelo plano é o gerente de projetos, que o coordena e o revisa. 

Criado o primeiro esboço do projeto, passamos para a fase 

seguinte, que é o detalhamento dos requisitos de software. Se 

no início foi elaborado um panorama geral, agora serão pensa-

dos e analisados os elementos específicos que deverão compor 

o programa. Nessa etapa, são estabelecidos modelos de fluxo 
dos dados e da estrutura, de modo a formar o padrão específico 
daquele software. Isso pode ser feito por meio de diagramas 
e/ou pseudocódigo. 
Um protótipo do software pode ser desenvolvido nessa etapa. 
Ele deverá ser avaliado pelo cliente com os desenvolvedores para 



8) (trauretura de software 
confirmar se as necessidades estão sendo basicamente atendidas; 
em outras palavras, constatar que cliente e desenvolvedores estão 
compartilhando as mesmas ideias sobre o que deve ser criado, e se 
estão no caminho correto. 

O resultado da análise dessa etapa feita com o cliente resulta 
em um novo documento, chamado de especificação dos requisitos 
de software. Esse documento será revisto pelo cliente e pelos de-
senvolvedores, e serão definidos os requisitos desejáveis e aceitá-
veis, assim como os não aceitáveis e não desejáveis. 

A versão revisada da especificação dos requisitos de software 
será então utilizada para a revisão do plano de projeto de software, 
com este se tornando mais detalhado e preciso. O produto que é 
fruto da fase de definição será a base para o início do trabalho na 
etapa seguinte: a fase de desenvolvimento. 

Fase de desenvolvimento 

A fase de desenvolvimento começa com a análise dos docu-
mentos gerados na etapa de descrição. Em seguida, começamos 
a escrever o algoritmo, criando uma estrutura modular, definindo 
as interfaces e estabelecendo uma estrutura de dados. O plano de 
projeto de software é utilizado constantemente como parâmetro 
de qualidade. 

Tudo que passa a ser criado na fase de desenvolvimento é rela-
tado em um documento chamado de especificação de projeto. Nele 
são listadas as configurações do software que está sendo desenvolvi-
do, assim como os procedimentos utilizados para os módulos. Cada 
novo detalhe é relatado e acrescentado à especificação do projeto. 

Concluído o projeto, entramos finalmente na etapa da codifi-
cação. Utilizando uma linguagem de programação ou uma ferra-
menta CASE (computer-aided software engineering), o programa 
finalmente é gerado por meio da escrita final do conjunto do seu 
código. Como você pode perceber até aqui, um bom código é sem 
dúvida a consequência de um bom projeto. O código deve ser re-
visado para que tenha estilo e clareza, mas também para se avaliar 
se está compatível com as especificações do projeto. 

A fase de desenvolvimento se encerra quando geramos uma 
listagem da linguagem-fonte. Ela é feita de modo bem detalha-
do e organizado, dividida por componente modular do software 
desenvolvido. 



Conceitos arquiteturais, componentes, conectores e configurações) (o 

Fase de verificação, liberação e manutenção 

Esta é a etapa mais pesada de testes. Assim que o código-fonte 
é gerado, ele passa por uma bateria de verificações que busca en-
contrar erros — tanto em sua função como em seu desempenho. 
Aqui elaboramos mais um documento: o plano e procedimento de 
testes. Nele são relatados os testes que serão realizados e os seus 
respectivos resultados — tudo bem detalhado. 

Durante os testes, verificam-se os módulos individualmente, 
e em seguida começam os testes de integração. Estes analisam o 
modo como os módulos atuam em conjunto, as funções e as inter-
faces. E, por fim, o teste de validação confere se todos os requisi-
tos foram atendidos. Caso erros sejam encontrados — normalmente 
isso acontece —, é necessário fazer o debugging. O debugging é 
um teste que revela os defeitos do programa que devem ser resol-
vidos, ou seja, ele diagnostica e corrige os erros do código. 

Agora é o momento de liberar o software? Ainda não! Antes 
de disponibilizar para os testes dos usuários, é feito um con-
trole de qualidade a fim de conferir se está tudo certo com os 
registros e documentos internos, se eles foram corretamente 
catalogados, assim como a checagem para constatar se os con-
troles de configuração foram apropriadamente estabelecidos, 
e também cuidar para que tenha sido desenvolvida uma docu-
mentação de alta qualidade para usuários. 

Então, finalmente, o software é liberado para usuários finais. 
Mas não é aqui que o trabalho dos desenvolvedores termina. Se 
antes a preocupação era construir, agora se torna manter e atuali-
zar. Possíveis erros devem ser corrigidos, e o software precisa ser 
adaptado a mudanças nos hardwares ou em outros softwares que 
possam interagir com eles. Da mesma forma, novas necessidades 
e possibilidades podem surgir, e, nesse sentido, novas funções de-
vem ser incorporadas (podendo significar uma revisão detalhada 
no software, o que, como você deve imaginar, reinicia o ciclo de 
buscas por erros e suas correções). 

Segundo Pressman (2006), essa etapa consome de 50 a 70% 
do orçamento das organizações que produzem softwares. Pode 
não parecer, mas ela é a mais trabalhosa; considerando que o 
seu produto já está nas mãos dos consumidores, então os pro-
blemas devem ser resolvidos da forma mais rápida e eficiente 



10) ( irquitetura de software 
possível. Qualquer modificação não implica apenas em alte-
rar o código, mas também todo o banco de registros e outros 
dados necessários para o funcionamento do programa, o que 
na prática, para o desenvolvedor, significa mudar também 
todos os documentos produzidos nas fases de definição e de 
desenvolvimento. 

Componentes e conectores 

Conceituando a arquitetura de software 

Até agora praticamente não utilizamos o termo “arquitetu-
ra” de software, mas acreditamos que, entendendo o básico do 
processo de desenvolvimento, esse termojá deve estar fazendo 
sentido para você. Para não deixar dúvidas, quando falamos 
de arquitetura de um software estamos nos referindo à estru-
tura interna do seu sistema. Basicamente, ela explica a forma 
como um software se organiza e funciona, além do seu modo 
de implementação. 

Nesse sentido, podemos dizer que, quando um software so-
fre alterações, a sua arquitetura muda. Aliás, a sua arquitetura 
evolui gradualmente durante o seu processo de desenvolvimento. 
Os feedbacks recebidos, os erros encontrados, as soluções, a in-
corporação de novas funções, tudo isso acarreta em mudanças no 
projeto e, portanto, na arquitetura do software. 

Por mais que esse ciclo pareça complexo, e que a cada etapa 
mais elementos sejam acrescentados, o objetivo do projeto de um 
software é justamente fazer sua arquitetura ser cada vez mais cla-
ra e, no limite do possível, simples. Mas essa evolução do projeto 
também busca tornar o software flexível, extensível, portável e reu-
tilizável. Vamos entender o que isso significa? 

A arquitetura de um software ser flexível quer dizer que ela 
permite mudanças necessárias para o seu aprimoramento e adap-
tação. Isso permite fazer alterações graduais sem que seja neces-
sário refazer partes significativas do projeto. As mudanças devem 
ser objetivas, e, portanto, a arquitetura deve ser estruturada de 
modo que permita essas alterações — que inevitavelmente deverão 
ser feitas. 

Uma arquitetura extensível é aquela que consente com faci-
lidade que novos elementos sejam incorporados, possibilitando 
que a estrutura como um todo se estenda. É uma característica 



Conceitos arquiteturais, componentes, conectores e configurações) (1 1 

importante para sistemas que lidam com exigências cada vez 
maiores. Como exemplo, vamos pensar que você está desenvol-
vendo um software para controlar um conjunto de transmissores 
e receptores de um sistema de antenas espaciais. Muita responsa-
bilidade, não é mesmo? Esse sistema tem a característica de ter 
novos elementos adicionados para que sejam controlados. Uma 
arquitetura extensível muito comum para softwares controlado-
res é baseada no direcionamento por intermédio de tabelas. Des-
se modo, para adicionar um novo elemento é necessário apenas 
acrescentar uma entrada na tabela do controlador — ele não precisa 
ser inteiramente reestruturado. 

Já quando falamos de uma arquitetura de software portátil, es-
tamos pensando naquelas que tornam o software possível de ser 
executado em diferentes plataformas. Para esse atributo, é muito 
comum a referência ao sistema em linguagem Pascal UCSD, que 
consegue traduzir para máquinas hipotéticas pequenos programas 
em p-code, sendo necessário apenas escrever um interpretador de 
p-code para elas. 

O UCSD p-System foi o sistema operacional escrito em Pascal da 
Universidade da Califórnia (University of California Software Dis-
tribution — Pascal System). Consistia em um sistema operacional 
que executava programas em pseudocódigo, chamados de p-
-code, em uma máquina virtual previamente escritos em Pascal. 
Era um sistema operacional muito popular no início da criação dos 
computadores pessoais, por volta do final de 1970 e início de 1980 
(UCSD P-SYSTEM, 2015). 

E, finalmente, uma arquitetura reutilizável diz respeito âque-Link 
las que podem ser tiradas de um software e — com algumas pou-O artigo "Foundations 
cas e inevitáveis adaptações — ser utilizadas em outro. Isso fica for the Study of 
mais simples quando os softwares são desenvolvidos utilizando Software Architecture”, 

escrito por Perry e Wolf,

padrões de arquitetura (que você conhecerá no próximo tema). Se 

pode ser acessado pelo

considerarmos que a estrutura de um software é definida por suas 

link: <users.ece.utexas.

interfaces (portas de entrada e saída), podemos então dizer que 

edu/-perry/work/

elas fornecem as bases para que a arquitetura seja reutilizada em 

papers/swa-sen.pdf>. 

outros softwares. 

Os elementos da arquitetura de software 

Sem dúvida, o mais conhecido modelo utilizado para descre-
ver arquiteturas de software é o proposto por Dewayne E. Perry e 



1 2) ( arquitetura de software 
Alexander L. Wolf em um artigo de 1992 intitulado “Foundations 
of the Study of Software Architecture” (“Fundamentos para o estu-
do da arquitetura de software”). Perry e Wolf propõem uma fórmu-
la para o entendimento da arquitetura de software que consiste em: 

Arquitetura = (Elementos + Organização + Decisões) 
Nessa definição, ao mesmo tempo simples e abrangente, Perry 
e Wolf colocam que a arquitetura se baseia na forma como os ele-
mentos que a compõem se organizam e operam. Essa composição 
é orientada por decisões tomadas pelos desenvolvedores para al-
cançar objetivos e obedecer a parâmetros. 
Mas quais elementos seriam esses? Perry e Wolf definem os 
elementos de uma arquitetura em três tipos: 

1. Elementos de processamento — são eles que operam os 
dados, transformando suas entradas em saídas logicamente 
necessárias. 
2. Elementos de dados — os dados que serão a matéria-prima a 
ser utilizada pelo sistema e processada. 
3. Elementos de conexão — “amarram” os elementos na es-
trutura. Eles conectam qualquer forma de elemento entre 
si, de modo a formar um conjunto funcional operante. 
A organização da arquitetura estabelece os padrões para que 
os elementos se relacionem entre si. Ela pode restringir as inte-
rações, e normalmente estabelece prioridades para que o sistema 
atenda suas funções com um bom desempenho. Como exemplo, 
na Figura 1.1 vemos um sistema de informação com dois grandes 
objetivos: gerenciar o processo de locação via Web de vídeos e 
proporcionar a infraestrutura de software para realizar streaming de 
vídeos também via Web. É um sistema fictício baseado na Netflix 
e na iTunes Store. 

Na Figura 1.2, como exemplo mais específico, vamos pensar 
na forma de uma URL (uniform resource locator — localizador 
de fonte uniforme) que, como você sabe, é o modelo utilizado 
para que o navegador encontre endereço de servidores na world 
wide Web. Nessa simples linha de comando podemos observar 
vários elementos de arquitetura presentes. Acompanhe a Figura 

1.2 a seguir. 
No Quadro 1.1, você pode conferir uma lista de elementos ar-
quiteturais comumente utilizados: 



Concertos arquiteturais, componentes, conectores e configurações (1 3 

r 
| 
— + cadastrode usuários 
o— as 
RE 
Ve T) 
I 
|-— 4] 
| 
I 
1| 
I 
Loo 
L—4 
cadastrode filmes 
lógica de negócio 
aluguel de filmes 
| 
—-
de 
| 
4 
a! 
pt 
!pt 
Es 
1 
AN 
usuários 
L 
streaming de filmes --4 
== == > NE? / 
a 

q Fonte. Barbosa (2009, p. 84). 

T. Figura 1.2 Elementos de arquitetura presentes em uma URL. TN 
Browser de texto da Web (Elementos de processamento) 
Comando 
Conectores 

(d / Para 

http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/Docs/whats-new.html 
(Dados) 
Nome da máquina Nome do 
arquivo 

Nomes de diretórios 


14) ( irquitetura de software 
A Quadro 1.1 Exemplo de elementos comuns em arquiteturas. 

Arquitetura Exemplos de arquiteturas 

Elementos Uniform resource locator Pacote de aplicação: Conjunto de 
(URL). Microsoft Word. ferramentas gráficas: 
Mathematica. 

Componente(s) Método de acesso: Ortografia, gramática, Plot [2D plot] Axeslabel 

de processamento | FTP (programa de dicionário de Gridlines PlotRange 
transferência de arquivos); sinônimos, personalizar, | GraphicsArray. 
file (o mesmo que ftp); contagem de palavras. 
http (identifica o site da Web); 
telnet (conecta ao m/0). 

Dados Nome da máquina; nome do | Nome de arquivo. Expressão(ões). 
diretório; nome do arquivo. Exemplo: Seno [x(2]. 

Conector(es) :// (anterior ao nome do m/0); | Botão de comando de | > 
/ (anteriorao diretório ou menu suspenso PlotRange > 
nome do arquivo). (0-3,5) 

q Fonte: Peters (2001, p. 182) 

) 

Configurações e padrões arquiteturais 

Agora, vamos conhecer alguns padrões arquiteturais bas-
tante utilizados. Para começo de conversa, tenha em mente que 
Fique atento cada padrão tem uma forma diferente, além de seus prós e con-
tras. Por isso que os desenvolvedores precisam ter muita cla-

A descrição de um 

reza sobre o que estão buscando para o software a fim de saber

padrão deve ter 

a qual padrão recorrer. Aqui nós os apresentaremos a você de

informações sobre 

maneira geral, e para conhecê-los a fundo e saber implementá-

quando sua 

-los é importante estudar os manuais que são publicados sobre

implementação é 

cada um deles.

mais adequada, seus 

Um padrão arquitetural descreve uma relação entre organização

pontos fortes e fracos, 
vantagens e 

e elementos que já deu certo em sistemas que foram desenvolvidos 
desvantagens. 

outras vezes. A descrição de um padrão é bem geral e abstrata, e 

A mostra um estilo recorrendo a tabelas e diagramas. É importante 
que fique bem claro para você que padrões não são simplesmente 
“teorias”, e sim o resultado prático de experimentos feitos em dife-
rentes ambientes e sistemas. 



Conceitos arquiteturais, componentes, conectores e configurações) (1 5 

Arquitetura MVC 

Como exemplo, vamos começar pelo padrão MVC (model-
-view-controller — modelo-visão-controlador). Em geral, podemos 
dizer que em sistemas baseados em Web ele é usado como a base 
do gerenciamento de interação. Observe que a descrição estili-
zada que utilizaremos aqui vai seguir o modelo de descrição de 
padrões arquiteturais. Portanto, vai conter uma descrição concisa 
(com um modelo gráfico associado) e citar como exemplo em que 
tipo de sistema esse padrão está presente — sem esquecer, é claro, 
de apontar vantagens e desvantagens. 

Acompanhe atentamente a descrição do padrão MVC no Qua-
dro 1.2. Na Figura 1.3, temos uma visão conceitual do padrão, e 
na Figura 1.4, o exemplo mais prático do seu uso em uma hipo-
tética arquitetura run-time, na qual o MVC é usado em sistemas 
baseados em Web para gerenciar interações. 

( Quadrouadro 1.2 Padrãoadrão MVC. N 
Nome MVC (modelo-visão-controlador) 
Descrição Separa a apresentação e a Interação dos dados do sistema. O sistema 
é estruturado em três componentes lógicos que interagem entre si. O 
componente modelo gerencia o sistema de dados e as operações associadas 
a esses dados. O componente visão define e gerencia como os dados são 
apresentados ao usuário. O componente controlador gerencia a interação do 
usuário (por exemplo, teclas, cliques do mouse etc.) e a passa para a visão e o 
modelo. Veja a Figura 1.3. 
Exemplo A Figura 1.4 mostra a arquitetura de um 
organizado pelo uso do padrão MVC. 
sistema aplicativo baseado na Internet 
Quando é usado | É usado quando existem várias maneiras de se visualizar e interagir com dados. 
Também quando são desconhecidos os futuros requisitos de interação e 
apresentação de dados. 
Vantagens Permite que os dados sejam alterados de forma independente de sua 
apresentação, e vice-versa. Apoia a apresentação dos mesmos dados 
de maneiras diferentes, com as alterações feitas em uma representação 
aparecendo em todas elas. 
Desvantagens Quando o modelo de dados e as interações 
adicional e complexidade de código. 
são simples, pode envolver código 
q Fonte: Sommerville (2011, p. 109). 


16) (prquiterura de software 
1 Figura 1.3 Organização do MCV. 

Controlador 
Mapeia ações de usuário 
para atualizar modelo. 

Seleciona visões. 

Mudança 

de estado 

Na 
Na 
Fonte. Sommerville (2011, 

Aa Figura 1.4 Arquitetura 

Controlador 

Processamento de 
solicitação HTTP. 

Seleção 

de visão 

Eventos 
de usuário 

Notificação 
de mudança 

Modelo 

Encapsula estado 

de aplicação. 

Notifica visão de 

mudanças de estado. 

p. 109). 

de aplicações Web utilizando o padrão MCV. 2 N 

Browser 

Formulário 
para mostrar 

e 

Lógica específica de aplicação Eventos 
Validação de dados. do usuário 

Notificação 
de mudança

Solicitação 
de atualização 

Modelo 

Lógica de negócios. 
Banco de dados. 

N 
N 
Fonte: Sommerville (2011, p. 110). 

Visão. 

Modelos renders. 

Solicita atualização 

de modelo. 

Envia eventos de usuário 

para controlador. 

Consulta 
de estado 

J 

Visão 

Página dinâmica. 
Geração. 
Gerenciamento 

de formulários. 

Solicitação de 
refrescamento 


Conceitos arquiteturais, componentes, conectores e configurações) (1 7 

Arquitetura em camadas 

É muito comum que dividamos o trabalho complexo entre pes-
soas ou grupos para que haja maior eficiência. Pense, por exem-
plo, que você precisa comer, de roupas para vestir, de lugar para 
morar, de medicamentos, de combustível, e assim por diante, mas, 
em geral, o seu trabalho consiste em fazer apenas uma parte de 
uma das coisas de que a sociedade precisa, receber por ele e tro-
car esse pagamento pelo que outras pessoas produziram. Imagine 
como seria o mundo se todas as pessoas fossem juntas para o cam-
po plantar e colher, depois todas juntas produzissem roupas... Não 
seria muito produtivo, certo? 

Estamos recorrendo a um exemplo genérico para pensar que 
a mesma coisa pode ser aplicada a uma arquitetura. Não só a sua 
divisão por produtividade, mas também para evolução. Tenha 
em mente que separação e independência são conceitos essen-
ciais para uma boa arquitetura, e, nesse sentido, fica muito mais 
prático para os desenvolvedores atuarem sobre partes, sem pre-
cisar refazer sempre o código como um todo. 

O padrão arquitetural MVC, que você conheceu no tópico 
anterior, aplica a divisão dos elementos na estrutura, e com isso 
eles podem ser alterados pelos desenvolvedores. Mas ele não é 
único! O padrão de arquitetura em camadas (Quadro 1.3) é outra 
forma muito conhecida de prezar por independência e separação 
em um software. 

Como falar em “independência” dentro de uma arquitetura é 
algo bem relativo, pense então na forma como uma camada de-
pende e interage com as outras. Nesse padrão, cada camada sujeita-
-se somente a recursos da que está logo abaixo dela — formando 
uma espécie de cadeia que se incrementa. Isso torna essa arqui-
tetura “incrementável”, ou seja, um software pode ser atualizado 
por meio do envio aos usuários de uma camada adicional. 

Lembrando-nos das características desejáveis de uma arqui-
tetura, das quais falamos no tema “Componentes e conectores”, 
além de ser portável, flexível e reutilizável, esse padrão se destaca 
pela sua extensividade. Uma camada pode também ser simples-
mente substituída por outra, sem alterar a sua interface. E, mesmo 
quando a camada de interfaces muda, somente a camada paralela 
deve sofrer alterações. 



18) ( irquitetur de software 
(TT Quadro 1.3 Padrão em camadas. E 

Nome Arquitetura em camadas 

Descrição Organiza o sistema em camadas com a funcionalidade relacionada associada a cada uma 

delas. Uma camada fornece serviços à camada acima dela; assim, os níveis mais baixos 

de camadas representam os principais serviços suscetíveis de serem usados em todo o 
sistema. Veja a Figura 1.5. 

Exemplo Um modelo em camadas de um sistema para compartilhar documentos com direitos 
autorais, em bibliotecas diferentes, como mostrado na Figura 1.6. 

Quando é É usado na construção de novos recursos em cima de sistemas existentes; quando o 
usado desenvolvimento está espalhado por várias equipes, com a responsabilidade de cada equipe 
em uma camada de funcionalidade; quando há um requisito de proteção multinível. 

Vantagens Desde que a interface seja mantida, permite a substituição de camadas inteiras. Recursos 
redundantes (por exemplo, autenticação) podem ser fornecidos em cada camada para 
aumentar a confiança do sistema. 

Desvantagens Na prática, costuma ser difícil proporcionar uma clara separação entre as camadas, e uma 
de alto nível pode ter de interagir diretamente com camadas de baixo nível, em vez da 
imediatamente abaixo dela. O desempenho pode ser um problema por causa dos múltiplos 
níveis de interpretação de uma solicitação de serviço, uma vez que são processados em 
cada camada. 

Fonte: Sommerville (2011, p. 110). 

Analise a Figura 1.5 para entendermos um exemplo. 

f— Figura 1.5 Exemplo de uma arquitetura em camadas. TN 

Interface de usuário 

Gerenciamento de interface de usuário 
Autenticação e autorização 

Lógica de negócio principal/funcionalidade de aplicação 
Recursos de sistema 

Apoio de sistema (SO, banco de dados etc.) 

Fonte: Sommerville (2011, p. 111). 

E, 

Você pôde constatar que existem quatro camadas, certo? A ca-
mada que está mais abaixo é composta pelo software de apoio ao 
sistema, o que normalmente inclui apoio de dados e de sistema 
operacional. A camada logo acima dela é a de aplicação, e consiste 



Conceitos arquiteturais, componentes, conectores e configurações) (1 9 

em componentes ligados diretamente à funcionalidade do progra-
ma, e também em componentes utilitários que são requeridos por 
outros elementos do aplicativo. Subindo para a camada de cima, 
encontramos o gerenciamento de interface de usuário, com os ser-

viços de autenticação e autorização. E finalmente, na camada su-
perior, estão os recursos da interface com o usuário. 

Em geral, podemos dizer que o padrão dessa arquitetura segue 
sempre essa lógica em que as camadas mais baixas estão ligadas di-
retamente com o sistema operacional, bancos de dados e as funções 

de hardware, e as camadas superiores se dedicam mais a funções pró-

ximas ao usuário, como interfaces. Sempre lembrando que aqui es-
tamos dando exemplos simples; na prática, por exemplo, as camadas 
da Figura 1.5 poderiam estar divididas em várias outras. O importante 
é que você entenda a lógica do padrão que está sendo apresentado. 

£T Figura 1.6 Arquitetura do sistema LIBSYS TN 

Interface de browser 

Login Formulários e Gerente 
LIBSYS gerente de consulta de impressão 

Busca Recuperação Gerente 
distribuída | de documentos de direitos Contabilidade 

Índice da biblioteca 

BD1 BD2 BD3 BD4 BDn 

Fonte: Sommerville (2011, p. 111) ) 

Pensando em um exemplo mais prático, na Figura 1.6 temos a 
demonstração do padrão de arquitetura em camadas implementa-
do em um sistema de biblioteca conhecido como LIBSYS. Com 
ele é possível que um grupo de bibliotecas universitárias acesse 
materiais protegidos por direitos autorais. O LIBSYS, como você 
pode ver na Figura 1.6, tem uma arquitetura dividida em cinco 
camadas. Na camada mais baixa estão os bancos de dados de cada 
uma das bibliotecas, e logo acima dela está o índice. Se você está 
acompanhando até aqui, já entendeu que, quando os bancos de 



20 ( irquitetura de software 

dados são alterados, precisamos modificar apenas o índice na ca-
mada de cima, sem precisar mexer na interface de browser — na 
camada superior, por exemplo. 

Arquitetura de repositório 

No nosso próximo exemplo de padrão de arquitetura vamos 
pensar na forma como um conjunto de componentes pode interagir 
para compartilhar os dados entre si. Se precisamos de um sistema 
que se baseia em um volume significativo de dados, seria perda 
de tempo e espaço replicar todas essas informações. Mas é aí que 

o problema pode começar, já que os processos talvez acabem se 
atropelando na hora de acessar o repositório compartilhado. 
Quadro 1.4 Padrão repositório. 

N 

Nome Repositório 
Descrição Todos os dados em um sistema são gerenciados em um repositório central, acessível a 
todos os componentes do sistema. Os componentes não interagem diretamente, apenas 
por meio do repositório. 

Exemplo A Figura 1.7 é um exemplo de um IDE em que os componentes usam um repositório de 
informações sobre projetos de sistema. Cada ferramenta de software gera informações 
que ficam disponíveis para uso por outras ferramentas. 

Quando é Você deve usar esse padrão quando tem um sistema no qual grandes volumes de 

usado informações são gerados e precisam ser armazenados por um longo tempo. Você 
também pode usá-lo em sistemas dirigidos a dados, nos quais a inclusão dos dados nos 
repositórios dispara uma ação ou ferramenta. 

Vantagens Os componentes podem ser independentes -eles não precisam saber da existência de 
outros componentes. As alterações feitas a um componente podem se propagar para 
os demais. Todos os dados podem ser gerenciados de forma consistente (por exemplo, 
backups feitos ao mesmo tempo), pois tudo está em um só lugar. 

Desvantagens O repositório é um ponto único de falha, assim, problemas nele podem afetar todo o 
sistema. Pode haver ineficiências na organização de toda a comunicação por intermédio 
do repositório. Distribuir o repositório a partir de vários computadores pode ser difícil. 

(onte Sommerville (2011, p. 112). 

J 

O padrão de arquitetura de repositório (Quadro 1.4) é im-
portante para organizar estruturas em que os dados são gerados 
por um componente, mas utilizados por outros. Existem vários 
exemplos desse tipo de software, como os sistemas de informa-
ção gerenciais, sistemas CAD, sistemas de comando e controle, 
e mesmo ambientes interativos de desenvolvimento de software. 



Conceitos arquiteturais, componentes, conectores e configurações) (21 

(TT Figura 1.7 Exemplo de arquitetura de repositório para um IDE. TN 

Editores Geradores 
UML de código 
| | Editores 
Pad Java 
Tradutor es! Repositório 
de projeto do projeto 
a Editor 
' ' Python 
Analisador Gerador 
de projeto de relatório 
Fonte: Sommerville (2011, p. 112) ) 

Observe atentamente a Figura 1.7 para entender como o repo-
sitório compartilhado pode ser utilizado. Aqui, o repositório atua 
como um ambiente controlado de versões, em que as alterações 
efetuadas no programa ficam sob controle, sendo possível retornar 
para versões anteriores caso seja necessário. 

Uma maneira interessante de compartilhar uma massa muito 
grande de dados é organizar as ferramentas ao redor do reposi-
tório. Os dados não precisam ser diretamente transmitidos entre 
os componentes. Contudo, isso já exige adaptação e muita com-
patibilidade entre os componentes e o formato dos dados, o que 
está longe de ser algo simples, considerando a complexidade dos 
sistemas e dos dados. Ainda mais se considerarmos a integração 
de novos componentes na estrutura. 

Saiba mais 

No exemplo mostrado na Figura 1.7, o repositório é passivo e o controle é 
de responsabilidade dos componentes que usam o repositório. Uma abor-
dagem alternativa, derivada de sistemas de inteligência artificial, usa um 
modelo "quadro-negro” que aciona os componentes do modelo quando 
dados específicos se tornam disponíveis. Isso é apropriado quando a forma 
de repositório de dados não é tão bem estruturada. As decisões sobre qual 
ferramenta ativar só podem ser feitas quando os dados são analisados. Esse 
modelo foi introduzido por Nii (1986). Bosch (2000) incluiu uma boa dis-
cussão sobre como esse estilo se relaciona com atributos de qualidade do 
sistema (SOMMERVILLE, 2011, p. 112-113). 



22) Arquitetura de software 
Arquitetura cliente-servidor 

Perceba que, quando falamos da arquitetura de repositório, 
consideramos mais a organização do espaço da estrutura. Mas e o 
tempo de execução? Esse está longe de ser o seu ponto forte, e é evi-
dente que é um fator fundamental para um software. Agora você vai 
conhecer um padrão baseado em sistemas distribuídos por tempo de 
execução: a arquitetura cliente-servidor (Quadro 1.5). 

A Quadro 1.5 O padrão cliente-servidor. s; 

Nome Cliente-servidor 
Descrição Em uma arquitetura cliente-servidor, a funcionalidade do sistema está organizada 
em serviços — cada serviço é prestado por um servidor. Os clientes são os usuários 
desses serviços e acessam os servidores para fazer uso deles. 

Exemplo A Figura 1.8 é um exemplo de uma biblioteca de filmes organizados como um sistema 
cliente-servidor. 

Quando é É usado quando os dados em um banco de dados compartilhado precisam ser 
usado acessados a partir de uma série de locais. Como os servidores podem ser replicados, 
também pode ser usado quando a carga em um sistema é variável. 

Vantagens A principal vantagem desse modelo é que os servidores podem ser distribuídos por meio 
de uma rede. A funcionalidade geral (por exemplo, um serviço de impressão) pode estar 
disponível para todos os clientes e não precisa ser implementada por todos os serviços. 

Desvantagens | Cada serviço é um ponto único de falha suscetível a ataques de negação de serviço 
ou falha do servidor. O desempenho, bem como o sistema, pode ser imprevisível, pois 
depende da rede. Pode haver problemas de gerenciamento se os servidores forem 
propriedade de diferentes organizações. 

(fome: Sommerville (2011,p 113). 

J 

Basicamente, podemos dizer que o padrão arquitetural cliente-
-servidor se organiza a partir de um conjunto de serviços e ser-
vidores associados em relação a clientes que acessam e utilizam 
esses serviços. Para ficar mais claro a você, vamos pensar nos 
componentes mais importantes que integram essa arquitetura. Se-
gundo Sommerville (2011, p. 113), eles são: 

1. Um conjunto de servidores que oferecem serviços a outros 
componentes. Exemplos de servidores incluem: servidores 
de impressão que oferecem serviços de impressão; servido-
res de arquivos que oferecem serviços de gerenciamento de 
arquivos; e um servidor de compilação, que oferece serviços 
de compilação de linguagens de programação. 

Concertos arquiteturas, componentes, conectores e configurações (23 

2. Umconjunto de clientes que podem chamar os serviços ofe-
recidos pelos servidores. Em geral, haverá várias instâncias 
de um programa cliente executando simultaneamente em 
computadores diferentes. 
3. Uma rede que permite aos clientes acessar esses serviços. A 
maioria dos sistemas cliente-servidor é implementada como 
sistemas distribuídos, conectados através de protocolos de 
Internet. 
Apesar de esse modelo poder ser implementado em uma única 
máquina, tradicionalmente esse padrão é utilizado para arquiteturas 
de sistemas distribuídos. Independência e separação são atributos im-
portantes no modelo cliente-servidor, permitindo que os serviços e 
os servidores sofram alterações sem que o restante do sistema seja 
modificado. Um sistema distribuído é constituído por um conjunto de 
computadores independentes entre si que se apresenta a seus usuários 
como único e coerente. Os sistemas distribuídos são amplamente uti-
lizados em diferentes soluções e aplicações nos dias atuais, mas não 
há um sistema operacional distribuído, ou seja, ainda não se criou um 
sistema específico com tal finalidade, muito embora existam estudos 
e algumas organizações importantes envolvidas nesse processo. 

O funcionamento desse sistema é razoavelmente simples. O 
cliente faz uma solicitação para algum servidor e fica no aguardo 
de uma resposta dele. Isso é feito por intermédio de chamadas de 
procedimento remoto, em que um protocolo solicitação-resposta 
é utilizado. Na Internet, por exemplo, o protocolo empregado é o 
bastante conhecido HTTP. 

7 Figura 1.8 Exemplo do padrão cliente-servidor. N 

Uma arquitetura cliente-servidor para uma biblioteca de filmes 

Cliente 1 Cliente 2 Cliente 3 Cliente 4 

Internet 

Servidor Servidor Servidor Servidor 
de catálogos de vídeos de fotos Web 

Catálogo Arquivo Informações sobre 
de biblioteca de filmes Arquivo de fotos vídeos e fotos 

q Fonte: Sommerville (2011, p. 113). ) 


24) ( irquitetura de software 
Agora vamos fazer uma análise utilizando um exemplo prático, 
tudo bem? Observe atentamente a Figura 1.8. Nela temos a repre-
sentação de um sistema multiusuário baseado em Web para distri-
buir uma biblioteca de arquivos de filmes e fotos. Vários servidores 
são utilizados para gerenciar e apresentar tipos de mídia diferentes. 

O que se demanda desse sistema hipotético com que estamos 
trabalhando é que ele transmita os dados para os clientes com a 
maior velocidade possível, sem perder a sincronia — não preci-
samos de uma resolução tão alta aqui. Assim sendo, eles podem 
permanecer comprimidos em algum arquivo, e o servidor opera a 
compressão e descompressão. Mas as fotos, por sua vez, precisam 
ficar com alta resolução, e, nesse caso, é melhor que elas fiquem 
em outro servidor. 

O cliente utiliza uma interface de usuário integrada, que é de-
senvolvida a partir de um browser simples de Internet. Essa inter-
face acessa o catálogo, que por sua vez deve conseguir suportar 
um grande volume de consultas, e ainda oferecer links para o sis-
tema de informação da Internet a fim de que os clientes recebam 
dados sobre os arquivos hospedados nos servidores. E não pode-
mos nos esquecer de que a interface também deve integrar um 
sistema de comércio eletrônico para vendermos o nosso material. 

Caso precisemos de uma arquitetura distribuída, o padrão 
cliente-servidor é muito interessante. Ele pode operar com siste-
mas em rede utilizando vários processadores distribuídos, e tam-
bém é muito simples adicionar um servidor novo ao sistema já 
operante — ou seja, ele é facilmente extensível. 

Arquitetura de duto e filtro 

Finalizando esta etapa, você vai conhecer agora o padrão arqui-
tetural de duto e filtro (Quadro 1.6). Assim como o cliente-servidor, 
ele se organiza em tempo de execução, operando um sistema em 
que as próprias transformações funcionais processam suas entradas 
e produzem saídas. Parece complicado, mas não é. Pense que, nes-
se modelo, cada etapa do processamento só se implementa como 
uma transformação. Existe uma sequência de processamento entre 
os componentes (que também pode ser executada paralelamente), e, 
enquanto os dados vão passando por ela, eles se transformam. 

Os dados de entrada vão fluindo, assim como se movessem e des-
lizassem pela estrutura, sendo processados até que sejam convertidos 
em saídas. Esse processamento pode ser feito por item ou em lotes. 



Conceitos arquiteturais, componentes, conectores e configurações) (25 

A Quadro 1.6 Padrão duto e filtro. N 

Nome Duto e filtro 

Descrição O processamento dos dados em um sistema está organizado de modo que cada 
componente de processamento (filtro) seja discreto e realize um tipo de transformação de 
dados. Os dados fluem (como em um duto) de um componente a outro para processamento. 

Exemplo A Figura 1.9 é um exemplo de um sistema de duto e filtro usado para o processamento 

das faturas. 
Quando é Comumente, é usado em aplicações de processamento de dados (tanto as baseadas em 
usado lotes como as baseadas em transações) em que as entradas são processadas em etapas 

separadas para gerarem saídas relacionadas. 
Vantagens O reuso da transformação é de fácil compreensão e suporte. Estilo de workflow corresponde à 
estrutura de muitos processos de negócios. Evolução por adição de transformações é simples. 
Pode ser implementado tanto como um sistema sequencial quanto concorrente. 
Desvantagens | O formato para transferência de dados tem de ser acordado entre as transformações de 
comunicação. Cada transformação deve analisar suas entradas e gerar as saídas para um 
formato acordado. Isso aumenta o overheaddo sistema e pode significar a impossibilidade 
de reuso de transformações funcionais que adotam estruturas incompatíveis de dados. 

(onte: Sommerville (2011, p. 114). ) 

Os termos “duto e filtro” são originários do sistema Unix. Nele 
os processos passaram a ser vinculados por meio dos chamados 
dutos, transferindo um fluxo de dados de um processo ao outro. 
O conceito de filtro se refere ao fato de que a cada transformação 
são filtrados os dados que podem ser operados considerando os 
dados de entrada. A respeito da influência e da aplicação desse 
padrão arquitetural, Sommerville (2011, p. 115) coloca que: 

[..] variantes desse padrão (duto e filtro) têm sido usadas desde que 
os computadores começaram a ser usados para o processamento 
automático de dados. Quando as transformações são sequenciais 
com dados transformados em lotes, esse modelo de arquitetura de 
duto e filtro torna-se um modelo sequencial, uma arquitetura co-
mum para sistemas de processamento de dados (por exemplo, um 
sistema de faturamento). A arquitetura de um sistema embarcado 
pode também ser organizada como um duto de processo, com cada 
processo em execução concorrente. 

Para refletir sobre o padrão de duto e filtro aplicado a um 
exemplo, vamos pensar em software de processamento em lote, 
que você pode acompanhar na Figura 1.9. No processamento em 
lotes, as informações são coletadas ou recebidas, armazenadas e 
submetidas a um processamento posterior. 



26) ( trquitetur de software 
Figura 1.9 Exemplo do padrão duto efiltro. 

Ler faturas ol Identificar 
emitidas pagamentos 
4 ) 
Faturas Pagamentos 

Fonte: Sommerville (2011, p. 115). 

No 
A cada 
foram 

qm Emitir recibos — Recibos 
=! 
Encontrar 
pagamentos 
devidos 
itrlembietes 
mento / | 
emb 
tem retes 

nosso exemplo, uma loja emitiu faturas aos seus clientes. 
semana as faturas são conferidas com os pagamentos que 
feitos. O aplicativo emite um recibo para cada conta paga. 

Se forem encontradas faturas que não foram pagas, mas que ain-
da estão dentro do prazo de pagamento, o nosso software emite 

um lembrete. 

Não é muito fácil desenvolver 
quitetura de duto e filtro por conta 
fluxos de dados constantemente. 
ples não são um problema para 
mas a coisa complica um pouco 

gráficas de usuários têm formatos de E/S 
falar nas estratégias de controle baseadas 
menu e clique de mouse, por exemplo). 
não impossível — trazer isso de um jeito 

com o padrão de 

Exercícios de fixação 

Explique o que é um software e qual a sua 

função. 
O que é o desempenho de um 
Explique de maneira concisa 
de definição. 
O que é o plano de projeto de 
O que é a especificação dos 
software? 
Explique em poucas palavras 
de desenvolvimento. 

software? 

o que é a fase 
software? 
requisitos de 

o que é a fase 
O que é a especificação de projeto? 

duto e filtro. 

softwares implementando a ar-

da necessidade de processar os 
Entradas e saídas de textos sim-
serem modeladas nesse padrão, 
se considerarmos que interfaces 

mais complexos, sem 
em eventos (seleção de 
Por isso é difícil -mas 
facilmente compatível 

Explique resumidamente o que é a fase de 
verificação, liberação e manutenção. 
O que é o debugging? 
Explique em suas palavras o que é a arquitetura 
de um software. 
O que significa querer que um software seja: 

a. flexível 
b. extensível 
c. portável 
d. reutilizável 
Resuma o modelo proposto por Perry e Wolf. 

Conceitos arquiteturais, componentes, conectores e configurações (27 

13. O que são elementos de conexão? b. Camadas 
14. O que é um padrão arquitetural? c. Repositório 
15. Faça um resumo em que constem as caracte-d. Cliente-servidor 
rísticas básicas, quando são utilizados e vanta-e. Duto e Filtro 
gens e desvantagens dos seguintes padrões 16. Explique o que são elementos de proces-
arquiteturais: samento. 
a. MVC 17. O que são elementos de dados? 
Panorama 

Categorias do software 

Software -conceitos e recursos -Softwares de sistema — programas escritos 
Verdadeiramente notável nos computadores não para e coordenar o

controlar software. 
é a alta velocidade nem a incrível capacidade de 2. Softwares de linguagens — programas que 
armazenamento de dados, mas, sim, a varieda-traduzem outros programas escritos em lin-
de ilimitada de usos que podem atender. O que guagens de programação, mais ou menos 
torna isso possível, com um número limitado de semelhantes à língua inglesa, para a forma 
componentes diferentes, é o software. É relevan-binária, ou seja, a linguagem utilizada pelos 
te entender que o mais sofisticado hardware de componentes do sistema computacional. 
computador do mundo não é importante sozinho. Além disso, eles ajudam os desenvolvedores 
Qualquer atitude que ele vai tomar deve ser expli-a escrever seus programas e manter os pro-
citamente ordenada por meio de instruções, que gramas já escritos a salvo em bancos de da-
são escritas por desenvolvedores e organizadas dos especiais. 
de forma sequencialmente lógica. Apenas após Softwares de aplicação -programas escri-
essas instruções estarem devidamente organiza-tos para resolver problemas comerciais ou 
das é que os componentes eletrônicos do siste-prestar outros serviços de processamento de 
ma de computação podem realizar suas tarefas dados aos usuários. 
na sequência correta para realizar seus objetivos. Já Pressman (1995) amplia essa classificação de 
As instruções processáveis por computadores são software para sete categorias: 
chamadas de software porque os desenvolvedo-1. Softwares básicos -coleção de programas 
res podem mudá-las facilmente, ao contrário do escritos para dar apoio a outros programas. 
hardware, no qual as modificações são mais difíceis. O software é caracterizado por: forte inte-

básico 
Categorias de software ração com o hardware de computador, intenso 
Verzello e Reutter (1984) classificam o software em uso por múltiplos usuários, operações concor-
três tipos: rentes que exigem escalonamento “schedule”, 


28) (ira uitetura de software 
compartilhamento de recursos e sofisticada ad-
ministração do processo, estruturas de dados 
complexas e múltiplas interfaces externas. 
Softwares de tempo real — monitora, ana-
lisa e controla eventos do mundo físico. 
O termo “tempo real" difere de "interativo" ou 
“time sharing” (tempo compartilhado). Um 
sistema de tempo real deve responder dentro 
de restrições de tempo estritas. O tempo de 
resposta de um sistema interativo pode ser 
normalmente ultrapassado sem resultados 
desastrosos. 
Softwares comerciais — as aplicações des-
sa área reestruturam os dados para facilitar 
as operações comerciais e as tomadas de 
decisões administrativas. Além da aplicação 
de processamento de dados convencional, 
as aplicações de software comerciais abran-
gem a computação interativa. 
Softwares científicos e de engenharia — 
caraterizados por algoritmos de processa-
mento de números. As aplicações variam 
da astronomia à vulcanologia, da análise 
de fadiga mecânica de automóveis à diná-
mica orbital de naves espaciais recuperá-
veis e da biologia molecular à manufatura 
automatizada. 
Softwares embarcados-utilizados para con-
trolar produtos e sistemas para os mercados 
industriais e de consumo. O software embuti-

do (embedded software) reside na memória só 
de leitura (read onty) e pode executar funções 
limitadas e particulares (por exemplo, contro-
le de teclado para fornos de micro-ondas) ou 
oferecer recursos funcionais de controle sig-
nificativos (por exemplo, funções digitais em 
automóveis, tais como controle, mostradores 
no painel, sistemas de freio etc). 
Softwares de computador pessoal — são 
destinados a computadores pessoais, que 

foram popularizados nos últimos anos, tais 
como processamento de textos, planilhas 
eletrônicas, computação gráfica, diversões, 
gerenciamento de dados, aplicações financei-
ras pessoais e comerciais, redes externas ou 
acesso a banco de dados etc. 

7. Softwares de inteligência artificial — utili-
zam algoritmos não numéricos para resolver 
problemas complexos que não sejam favorá-
veis à computação ou à análise direta. Atual-
mente, a área de Artificial Inteligency (Al) mais 
ativa é a dos “sistemas especialistas baseados 
em conhecimentos” porém outras áreas de 
aplicação para o software de Al são o reconhe-
cimento de padrões (voz e imagem), jogos e 
demonstração de teoremas. Uma rede neural 
simula a estrutura dos processos cerebrais (a 
função do neurônio biológico) e pode levar a 
uma nova classe de software que consegue 
reconhecer padrões complexos e aprender 
com a “experiência” passada. 
Conclusão 
Durante as décadas de 1950 a 1970, o principal 
desafio era desenvolver um hardware que redu-
zisse o custo de processamento e armazenagem 
de dados. Ao longo da década de 1980, avanços 
na microeletrônica resultaram em maior po-
der de computação a um custo cada vez mais 
baixo. O principal desafio durante a década de 
1990 era melhorar a qualidade e reduzir o cus-
to de soluções baseadas na computação, que 
são implementadas com software. O poder de 
um computador mainframe da década de 1980 
atualmente se encontra à disposição sobre uma 
escrivaninha. As assombrosas capacidades de 
processamento e armazenagem do moderno 
hardware representam um grande potencial de 
computação. O software é o mecanismo que nos 
possibilita aproveitar e dar vazão a esse potencial. 



Conceitos arquiteturals, componentes, conectores e configurações) (29 

O próprio Pressman, que classificou o software 
em sete categorias, admite ser uma tarefa um 
tanto difícil desenvolver categorias genéricas 
para aplicações de software. Como observamos, 
a classificação de Pressman se baseia no uso da 
tecnologia e no seu tipo de utilização. Se assumir-
mos que essa forma de classificação está dentro 
da nossa linha de pensamento, poderíamos tam-
bém citar novas categorias como: software para 
rede de computadores, software de controle de 
tráfego aéreo etc. 

Recapitulando 

omeçamos a unidade discutindo o que é 

um software, seus tipos básicos e, de ma-

neira geral, como ele atua. Em seguida, 
conversamos sobre duas características essenciais 
de um programa: função e desempenho. Você 
aprendeu o que são e qual a relação entre elas. 
Posteriormente, começamos a falar sobre como 
desenvolver um software. Vimos em detalhes cada 
uma das fases que envolve o processo de criação 
de um aplicativo. Iniciando pela fase de definição, 
você explorou o plano de projeto de software e a 
especificação dos requisitos de software. Passando 
para a fase de desenvolvimento, você conheceu o 
documento chamado de especificação de projeto 
e viu os procedimentos que envolvem o processo 
de codificação de um aplicativo. Por fim, na fase de 
verificação, liberação e manutenção, você enten-
deu as etapas finais que envolvem o trabalho de 
desenvolvimento e pôde compreender que ele é 
um processo constante. 
Na etapa seguinte, passamos para a conceituação 
específica do que é a arquitetura de um software. 

Será que a visão de Pressman “desvirtua” ou “am-
plia"o sentido de classificação ou categoria de evo-
lução de software? 

Fonte: adaptado de Azevedo (2015). 

Exercícios 

1. Discorra sobre a importância do software 
para a sociedade contemporânea e sobre a 
relação dele com outras tecnologias. 
O texto termina com uma pergunta em aberto. 
Escreva uma resposta pessoal para ela. 
Aprendemos que ela é a estrutura interna do seu 
sistema; que ela explana a forma como um softwa-
re se organiza e funciona, e o seu modo de imple-
mentação. Na mesma esteira, você estudou que é 
desejável que a arquitetura de um software seja 
flexível, extensível, portável e reutilizável -e o que 
isso significa. 
Passando para a composição da arquitetura, você 
aprendeu o modelo proposto por Perry e Wolf. 
Vimos que eles dividem os elementos de uma 
arquitetura em três tipos: elementos de proces-
samento, elementos de dados e elementos de 
conexão. 
No último tema desta unidade, abordamos as 
configurações e os padrões arquiteturais. Você co-
nheceu o padrão MVC, a arquitetura em camadas, 
a arquitetura de repositório, a arquitetura cliente-
-servidore a arquitetura de duto e filtro. Esperamos 
que você tenha aprendido bastante até aqui. Não 
deixe dúvidas para a etapa seguinte; estude e faça 
os exercícios. 
Até a próxima unidade! 


UNIDADE 

ra 

Modelagem e análises 
arquiteturais 

a Objetivos de aprendizagem 

& Saber o que é modelagem e conhecer os seus tipos básicos. 
&B Aprender a utilizar diferentes tipos de diagramas para a modelagem 

de softwares. 
B Conhecer as arquiteturas de aplicações e onde utilizá-las. 
B Entender o que são arquiteturas de sistemas confiáveis e como 

implementá-las. 
&B Ter dominio sobre os diferentes padrões de arquitetura para siste-
mas distribuídos. 

B 1 -Modelagem de sistemas 
No primeiro tema, vamos estudar a modelagem. Você vai aprender a 
interpretar e desenvolver diferentes tipos de diagramas, e também 
vai conhecer múltiplas formas de modelagem. 
B 2-Análise arquitetural 
Já no segundo tema, vamos analisar padrões distintos de arqui-
tetura. Você vai explorar a arquitetura de aplicações, a arquitetura 
de sistemas confiáveis e os padrões de arquitetura para sistemas 
distribuídos. 

Introdução 

Nesta unidade, vamos nos dedicar basicamente a dois conceitos de arqui-
tetura de softwares: modelagem e análise arquitetural, Para começarmos a 
nossa conversa, responda: o que vem à sua cabeça quando pensa na pala-
vra “modelar”? Geralmente, alunos respondem a essa pergunta dizendo 
que imaginam algo como brincar com massas, argila ou algum material 
desse tipo, e também que vem à mente a ideia de "fazer moldes”. 


32) ( arquitetura de software 
A modelagem de sistemas não está muito distante dessas possíveis 
respostas. Se eu penso em uma"massa de modelar”, imagino algo que 
pode assumir qualquer forma, desde que eu seja capaz de manipulá-la. 
Bem, podemos dizer que software é uma noção incrivelmente abstra-
ta e ampla, e, de fato, ele pode assumir a forma que o desenvolvedor 
quiser — desde que, é claro, ele consiga fazê-la operar funcionalmente. 
Unindo, então, esses dois conceitos, definimos a modelagem de siste-
mas como a construção de uma noção, um quadro abstrato sobre o 
que é e o que poderia ser um sistema. 
Modelar sistemas envolve basicamente criar modelos abstratos para 
que sejam aplicados a modelos reais. Podemos modelar um sistemajá 
existente e também um sistema que poderá ser desenvolvido. Além 
disso, diferentes modelagens podem ser feitas para concebermos o 
mesmo sistema, e para isso utilizamos recursos visuais distintos, cha-
mados de notações gráficas, em que hoje predomina a utilização de nota-
ções de modelo unificado de linguagem (UML, do inglês unified modeling 
language). Mas também podemos utilizar modelos mais formais, basica-
mente matemáticos, com a presença maior de detalhes do sistema. 
Podemos desenvolver diferentes perspectivas para o mesmo sistema, 
certo? Então, é possível produzir um modelo para representar cada 
uma delas. Como exemplo, vamos pensar em um conjunto de pers-
pectivas, atentando para o modo como elas se complementam: 

B Perspectiva externa — visão mais ampla, em que modelamos o 

ambiente do sistema, o seu contexto. 
&B Perspectiva de interação — aqui modelamos as relações possi-
veis entre o sistema, o ambiente em que ele estará inserido e os 
seus componentes. 
B Perspectiva estrutural — modelagem da estrutura dos dados 

que serão operados e a organização interna do sistema. 
B Perspectiva comportamental — é a modelagem do modo como 
os sistemas responderão aos eventos, estabelecendo o seu com-
portamento dinâmico. 

No entanto, o que caracteriza a modelagem é a forma como ela pro-
jeta uma visão do todo, e para isso os detalhes mais específicos ficam 
para um segundo momento. Como abstração do sistema, é impor-
tante ressaltar que ela deve preservar as características que compõem 
a sua estrutura, sem simplificarmos demais, nem escolher enfatizar 
alguns aspectos em detrimento de outros. A modelagem pode ser 


Modelagem e análises arquiteturas) (23 

utilizada para pensarmos requisitos (que discutimos na unidade ante-
rior), e por meio deles considerarmos os pontos fortes e fracos, discu-
tirmos propostas e alternativas e desenvolver a documentação 
necessária para a implementação. 
Nesta unidade, vamos desenvolver em detalhes a questão da mode-
lagem. Na segunda parte, veremos como ela se aplica em diferentes 
modelos de arquitetura de software. 

Modelagem de sistemas 

Modelos de contexto 

Se você fosse começar a especificar um sistema, qual seria a 
primeira coisa que faria? Sendo mais preciso na pergunta, o que 
você acha que seria mais adequado fazer? Caso você tenha res-
pondido “definir os seus limites”, acertou. Na prática, isso requer 
trabalhar com os stakeholders do sistema, e por eles pensar nas 
funcionalidades que serão fornecidas pelo ambiente, e quais você 
deverá inserir. 

O mais importante é que esse tipo de decisão não pode ser 
tomado no meio do caminho, não é mesmo? Esses aspectos têm 
de ser definidos no início, para que possamos economizar tempo e 
dinheiro, e concentrar os esforços naquilo que é mais importante. 

Ter clareza sobre as fronteiras entre o sistema e o seu ambien-
te também é essencial. Se estivermos substituindo um sistema, 
é bem provável que o seu ambiente seja bem parecido com o do 
anterior. Mas é evidente que se o novo sistema for bem diferente 
do anterior, é inevitável que a relação não seja tão similar. De ma-
neira geral, é muito comum que existam casos em que a fronteira 
é bem flexível, e deverá ser delimitada na etapa de planejamento. 

Imagine, como exemplo, que vamos criar um sistema para 
analisarmos o perfil dos pacientes de uma clínica de saúde mental. 
Antes de começar, devemos decidir se, por exemplo, vamos tra-
balhar só com os dados gerados nas consultas com os pacientes, 
ficando outros sistemas responsáveis por coletar os seus dados 
pessoais, ou se o nosso sistema coletará ele mesmo todos esses da-
dos. Perceba que são decisões que envolvem a dimensão e a forma 
do sistema, que demandarão necessidades operacionais distintas, 
que apresentam vantagens e desvantagens, e com elas diferentes 
custos e benefícios que devem ser avaliados. 



34) ( irquitetura de software 
Revendo o que discutimos na unidade anterior, depois de to-
madas essas decisões, o procedimento seguinte é elaborar um 
modelo simples da arquitetura do software. Ainda considerando 

o nosso exemplo, você pode observar na Figura 2.1 uma possível 
arquitetura em que o sistema coleta as informações das consultas 
em um ambiente com outros sistemas trabalhando com os demais 
dados dos pacientes. 
dE Figura 2.1 O contexto do MHC-PMS. N 
«sistema» 
Sistema de 
registro de pacientes 
«sistema» 
Sistema de 
gerenciamentoKde relatórios 
«sistema» 
Sistema deAadmissões 
«sistema» 
MHC-PMS 
«sistema» «sistema» 
Sistema de Sistema de 
estatísticas prescrições 
«sistema» 
Sistema de 
agendamentos 
q Fonte: Sommerville (2011, p. 84). ) 

Analise atentamente a Figura 2.1, e perceba que o MHC-PMS 
está ligado a outro sistema de agendamentos, e também está com-
partilhando os dados com um sistema de registro de pacientes. Há 
conexões também com um sistema de gerenciamento de relatórios, 
alocação de leitos hospitalares, estatísticas para coletar informações 
de pesquisa e um sistema de prescrições de receitas médicas. 

O modelo de contexto, basicamente, trabalha com um conjun-
to de sistemas peculiares automatizados. Como eles não são muito 
claros quanto aos tipos de relacionamentos entre o sistema que es-
tamos especificando e os sistemas no ambiente, os modelos de con-
texto simples costumam ser utilizados junto com outros modelos. 

Vamos pensar em um exemplo complementar para entender a im-
portância do modelo de contexto, e como ele pode ser utilizado. Pes-
soas que precisam de atenção especial em razão de questões relativas 
à sua saúde mental podem precisar de internação. É uma prática que 
tem sido reduzida, mas ainda existem casos em que o paciente pode 



Modelagem e análises arquiteturas) (35 

representar um risco para outros e a si mesmo, e a internação ainda 
é recomendada. Porém, é comum que essa internação seja contra a 
vontade expressa do paciente, e para que ela ocorra nessas condições 
é necessário que procedimentos sejam feitos e requisitos cumpridos. 
É aqui que o MHC-PMS pode ser muito útil, já que ele se ocuparia 
para que esses procedimentos e requisitos sejam atendidos. 
Na Figura 2.2 você pode conferir um diagrama da utilização da 
UML em que são demonstradas as atividades presentes nos pro-
cessos de sistema, dispostas de forma a seguir o fluxo de controle 
entre elas. O círculo preenchido no canto superior esquerdo repre-
senta o início do processo, e o final é representado pelo círculo 
preenchido dentro de outro círculo, no lado direito. Os retângulos 
com cantos arredondados representam os subprocessos específi-
cos. As setas representam o fluxo de trabalho, e as barras em ne-
grito indicam a coordenação de atividades. Se mais de uma seta é 
levada a uma barra em negrito, em todas elas devem terminar de 
realizar os seus procedimentos antes do processo seguir adiante. 
Mas se as setas partem de uma barra em negrito, elas podem — 
e devem — executar simultaneamente. No nosso diagrama, isso 
impediria que o paciente fosse transferido antes de ser informado 
sobre os seus direitos, por exemplo. 
O Figura 2.2 Modelo de processos de internação voluntária. N 
Confirmar Trans 
decisão [Não disponível] as 
de internação para delegaciade polícia 
Encontrarlocal ,
ocal seguro / [Disponível] 
Informarassistência — 
= 
Informar A 
Transferir 
para h hospital a 
social 
paciente 
dos direitos 
[Perigoso] seguro Informar 
parentes — 
próximos 
Registrar 
Lo» decisão + Admttir + Atualizar 
de internação [Não perigoso] no hospital registro 

«sistema» 
MHC-PMS 
«sistema» 
Sistema 
de admissões 
«sistema» 
MHC-PMS 
q Fonte: Sommerville (2011, p. 85) ) 


36) (irquiterura de software 
Saiba mais 

Stakeholder é qualquer pessoa ou organização que tenha interesse ou seja 
afetado pelo projeto. A palavra vem de: 
BB Stake — interesse, participação, risco. 
& Holder— aquele que possui. 
Entre os stakeholders, podemos destacar: 
EB Gerente de projeto — é ele que organiza o trabalho. Ele deve analisar o con-

texto, planejar o projeto (junto a sua equipe), conduzir o trabalho e realizar as 
entregas. O gerente de projetos vai fazer a integração do projeto, vai super-

visionar todo o trabalho, gerenciar os processos, manter as relações entre os 
stakeholders em equilíbrio, fazer as negociações de prazo, preço etc. 

& Analista de sistema — aquele que vai analisar o que deverá ter o software 
para atingir o objetivo final, o resultado desejado pelo cliente. É ele que 
vai analisar todas as especificidades que o software conterá. 

&B Programador — os desenvolvedores do software. Toda a parte da imple-
mentação lógica do software, toda a programação do software é feita 
pelo programador. 

&B Patrocinador — é aquele que libera os recursos, custeia a produção do 
projeto. Ele será o responsável por disponibilizar todas as ferramentas ne-
cessárias para o desenvolvimento de software. 

E Cliente (usuário) — aquele que encomenda o software de acordo com 

a sua necessidade. Poderá ser o único usuário, mas se o cliente for uma 
empresa, por exemplo, o software terá mais de um usuário. 

Fonte: Stakeholders (2015). 

Modelos de interação 

Um sistema propriamente dito só existe a partir do momento 
em que forem instituídas interações. Em outras palavras, o que 
faz que componentes isolados formem uma coisa maior que eles 
mesmos — o sistema; é necessário que eles interajam entre si de 
forma regular e padronizada. 

Por interação estamos pensando em trocas, ação e reação entre 
os componentes, e trabalho conjunto. Na prática, estamos falando 
de coisas como entradas e saídas, e a interação entre o sistema 
em desenvolvimento e os outros já existentes, ou que estão sendo 
também desenvolvidos para que atuem juntos. 

Não podemos esquecer da interação mais importante, a que 
dá sentido a todo o sistema, que é a estabelecida com o usuário. 



Modelagem e análises arquiteturas) (37 

Modelando a interação com o usuário, podemos identificar os seus 
requisitos e destacar os possíveis problemas de comunicação entre 
ele e o sistema. Desse modo, podemos analisar se o sistema será 
de fato prático, eficiente e confiável. A seguir, vamos discutir dois 
tipos de modelagem de interação: 

I. Modelagem de caso de uso. 
2. Diagramas de sequência. 
Modelagem de caso de uso 

Como o nome já dá a entender, a modelagem de caso de uso se 
baseia em simular situações em que o sistema seria utilizado. Ape-
sar de parecer simples, é um modelo bem interessante, que permi-
te que consigamos pensar bem nos requisitos feitos ao sistema. 

Na modelagem de uso, as situações são simplificadas, e bus-
cam representar o que um usuário pode esperar do sistema. Cada 
caso é a representação de uma tarefa que demonstra o modo como 

o usuário vai interagir com o ambiente. 
Observe atentamente a Figura 2.3. A modelagem de caso de 
uso, pensando de modo bem básico, utiliza elipses e os usuários 
são simulados por meio dos bonecos palito. Como explicamos 
quando falamos dos modelos de contexto, na UML as setas re-
presentam o sentido do fluxo de mensagens, porém, no exemplo 
acima nós recorremos a ela para deixar claro para você que o(a) 
recepcionista do médico é quem inicia o processo. Então, deve 
ficar bem claro para você que não se deve utilizar as setas normal-
mente na modelagem de caso de uso. 

Figura 2.3 Modelagem de caso de uso "Transferência de dados”. 

P— Transferir dados ————» 2 

Recepcionista Sistema de registro 
do médico de pacientes 

Fonte: Sommerville (2011, p. 86) 

Sem perder o foco no exemplo contido na Figura 2.3, preste 
atenção que ele demonstra a tarefa de abastecer o banco de dados 
do MHC-PMS para um sistema mais geral de registro de pacientes. 
Nele constarão resumos dos dados dos pacientes, em vez de dados 



38) (prquiterura de software 
mais específicos sobre as consultas. Os atores presentes nessa rela-

ção — nesse caso de uso — são o operador (que fará a transferência 

dos registros) e, é claro, o próprio sistema de registro de pacientes. 

Fique atento 

Apesar de os bonecos palito serem utilizados basicamente para representar 
usuários, ou seja, pessoas que interagem com o sistema, na modelagem de 
caso de uso elas também podem ser utilizadas para representar o hardware 
ou sistemas externos? 

Os diagramas de caso de uso enfatizam a interação por uma 
perspectiva simples, portanto, você precisará detalhar um pouco 
mais o que está acontecendo no caso em questão. Pense que não 
seria fácil para alguém ver a Figura 2.3 e logo entender do que ela 
se trata, não é mesmo? Esse detalhamento pode ser feito de vários 
modos, como escrevendo mesmo uma descrição, uma tabela e até 
mesmo um diagrama de sequência. Fica ao seu julgamento esco-
lher qual método de detalhamento será mais interessante dentro 
daquilo que você está querendo representar. 

Aqui traremos o exemplo de como você pode utilizar uma ta-
bela para fazer o detalhamento. No Quadro 2.1 está descrito o 
caso de uso “transferir dados”. 

(— Quadro 2.1 Descrição do caso de uso “Transferir dados” N 

Atores Recepcionista do médico, sistema de registros de pacientes (PRS, do inglês patient records 
system) 

Descrição Uma recepcionista pode transferir dados do MHC-PMS para um banco de dados geral de 
registros de pacientes mantido por uma autoridade de saúde. As informações transferidas 
podem ser atualizadas com as informações pessoais (endereço, telefone etc.) ou com um 
resumo do diagnóstico e tratamento do paciente. 

Dados Informações pessoais do paciente, resumo do tratamento. 

Estímulos Comando de usuário emitido pela recepcionista do médico. 
Resposta Confirmação de que o PRS foi atualizado. 

Comentários A recepcionista deve ter permissões de proteção adequadas para acessar as informações 
do paciente e o PRS. 

(ore Sommerville (2011, p. 87). ) 


Modelagem e análises arquiteturas) (39 

É possível que um único diagrama composto de casos de uso 
consiga representar todas as interações, mas isso não é regra. Você 
pode utilizar também diagramas distintos para representar dife-
rentes casos de uso. Na Figura 2.4 você pode conferir diferentes 
casos de uso do MHC-PMS que envolvem o mesmo ator, o(a) 
recepcionista do médico. Mas saiba que, independentemente de 
sua escolha, o importante é que o detalhamento consiga ser claro, 
objetivo e, evidentemente, cobrir todas as possibilidades de inte-
ração com o sistema. 

Figura 2.4 Diagrama de sequência "Ver informações de pacientes”. N 

Recepcionista do médico 

P: InfoPaciente D: MHC-PMS-DB AS: Autorização 
| | | 
| Vernfo (PD) | Relatónio | | 

(Info, PID, UID) | |

—DDD p 
Autorizar | 
(Info, UID) | 

Autorização

IS SE] 

I 
Alt | 

. Informações | 

[Autorização OK] de pacientes 

2000200] | 

E PA A O + 

[Falha de autorização] Erro (sem acesso) | 

pn | 

4 | | 

, | Í | 

I 1 I ) 
q Fonte: Sommerville (2011, p. 88). ) 

Diagramas de sequência 

Quando trabalhamos com UML, utilizamos os diagramas 
de sequência para modelar a interação tanto entre atores e ob-
jetos dentro de um sistema, como também entre os próprios 
objetos. Como se estivéssemos observando uma sequência de 
quadros que formam uma imagem em movimento, os diagramas 
de sequência procuram representar uma série de interações que 
são possíveis no decorrer de um caso específico ou então em 
alguma instância de caso de uso. 



40) ( arquitetura de software 
Observe atentamente a Figura 2.4. Nela estamos modelando 
um caso de uso em que o(a) recepcionista de um médico utiliza o 
sistema para ver informações de pacientes? Para que você entenda 
bem os conceitos utilizados no diagrama, guarde bem que: 

A sequência de interação deve ser lida de cima para baixo. 

Na parte superior estão listados os atores e objetos que estão 

interagindo no caso de uso, e deles parte uma linha vertical 

tracejada. 

A linha da vida do objeto (tempo em que a instância do obje-

to participa do processamento) é indicada pelo retângulo na 

linha tracejada. 

Sobre as setas estão as anotações que descrevem as chamadas 

para os objetos, os valores de retorno e os seus parâmetros. 

A caixa “Alt” designa as alternativas, sendo usada com as 

condições que são mostradas entre colchetes. 

Parece confuso? Acompanhe a seguir como o diagrama pode 
ser lido, e veja como na verdade é bem simples esse passo a passo 
em quatro etapas: 

1. A recepcionista requisita o método VerInfo, que está na ins-
tância P da classe de objeto InfoPaciente. Ela fornece o PID 
(Patients Identifier [Identificador do paciente]). 
A Instância P fornece o identificador da recepcionista e faz 
uma chamada ao banco de dados para que ele retorne os da-
dos requisitados. 
Por meio de um sistema de autorização o banco de dados 
confere se o usuário tem autorização para executar essa ação. 
Se a autorização for confirmada, o banco de dados retorna as 
informações requeridas, enquanto um formulário é preenchi-
do na tela do usuário. Mas caso não haja autorização, surgirá 
na tela uma mensagem de erro. 
Modelos estruturais 

A modelagem estrutural é aquela que se baseia em representar 
a estrutura de um sistema por intermédio dos relacionamentos dos 
componentes entre si. A modelagem estrutural estática enfatiza a 
organização do projeto do sistema, enquanto a modelagem estru-
tural dinâmica aborda a organização do sistema na medida em que 
ele estiver em operação. Na prática, são modelos bem diferentes. 



Modelagem e análises arquiteturas) (a1 

É fundamental para desenvolver a arquitetura de um software 
pensar nos modelos para a sua estrutura, e isso pode ser feito de 
várias formas diferentes. Nesse tópico vamos discutir como uti-
lizar diagramas de classe para modelarmos estruturas estáticas. 

Diagramas de classe 

Uma classe de objeto é basicamente um tipo de objeto presen-
te no sistema. Usamos os diagramas de classe para desenvolver 
um sistema orientado a objetos. Nele, os diagramas são utilizados 
para modelar as classes de objetos presentes, as associações entre 
elas e a forma como interagirão entre si. As associações são links 
entre as classes que apontam que há alguma relação entre elas. 
Nesse sentido, pode ser que as classes precisem conhecer aquelas 
com as quais estão associadas. 

Pense que quando começamos a desenvolver um sistema sem-
pre partimos de objetos físicos, como, no nosso exemplo, os mé-
dicos, pacientes e receitas médicas. Mas a partir do momento em 
que o aplicativo é elaborado, precisamos inserir também objetos 
que permitam que ele tenha suas funcionalidades. Em UML, os 
diagramas de classe podem ser detalhados em diversos níveis. 

Ao iniciar o desenvolvimento do modelo, começamos pelos 
objetos do mundo material, representando-os por meio de classes. 
Na montagem do diagrama, o modo mais simples é relatar os no-
mes das classes em caixas, e estabelecer uma associação traçando 
uma linha entre elas. Você pode observar esse exemplo simples de 
diagrama na Figura 2.5, em que existem duas classes associadas 
entre si, “Paciente” e “Registro de paciente”. 

Figura 2.5 Classes e Associação em UML. 

1 Registro

Paciente 

de paciente 

Fonte: Sommerville (2011, p. 90). 

Nos diagramas de classe podemos observar quantos objetos 
estão associados. Na Figura 2.5, a quantidade é representada pelo 
número “1” sobre as extremidades da linha. Desse modo, é pos-
sível pensar que existe uma relação 1:1 entre os objetos dessas 
respectivas classes. O que isso quer dizer? Que cada paciente tem 



42) (prquiterura de software 
exatamente um registro, e cada registro apresenta dados sobre so-
mente um paciente, ficou claro? 

A multiplicidade de associação entre objetos e classes em um nú-
mero indefinido pode ser representada por um asterisco (*), como 
você pode ver na Figura 2.6. E já falando dela, observe como po-
demos representar as associações entre diferentes classes de objetos 
diferentes. Sobre as linhas está a descrição da função do objeto dentro 
da associação. 

/(— Figura 2.6 Classes e associações em MHC-PMS DN 

Consultor 

1 
Indicado para 
1.* 
A LE =. 1 fi

Condição ———— Paciente ——>—>—>— Elric 

Diagnosticado Indicado por geral 
com 1* 
Frequenta 
1* 

Prescreve a

Consulta —>>>>—>——» Medlicação 
1 14 

1* 

Realiza] Prescreve 

14 Tratamento

1* 
Médico de 
hospital 

q Fonte: Sommerville (2011, p 91). ) 

Quanto mais simples as classes estiverem representadas, me-
lhor. Mas e se for preciso mais detalhes sobre elas? É só acres-
centar informações sobre os atributos (características de um 
objeto) e operações (o que pode ser requisitado a ele). Como 
exemplo, vamos pensar que o objeto “Paciente” terá como atri-
buto o “Endereço”, e nas operações poderá ser incluído “Mudar 
endereço” como uma chamada — ou seja, o endereço é uma ca-
racterística do objeto, mas podemos requisitar que esse endereço 
seja alterado. 

Na Figura 2.7, você pode acompanhar um exemplo de como 
podemos acrescentar essas informações a uma classe de objeto. 
Na parte de cima está o nome da classe (Consulta), no meio estão 
os atributos e embaixo estão as operações associadas àquela classe 
de objeto. 



Modelagem e análises arquiteturas) (az 

1 Figura 2.7 Classe de consultas. N 

Consulta 

Médicos 
Data 
Horário 
Clínica 
Motivo 
Medicação prescrita 
Tratamento prescrito 
Anotações de voz 
Transcrições 

Novo () 
Prescrever () 
RegistrarAnotações () 
Transcrever () 

q Fonte: Sommerville (2011, p. 91). » 

Agregação 

É muito comum que os objetos do mundo sejam compostos 
por diversas partes associadas entre si. Imagine que no objeto 

“banho” estão inclusas as partes “chuveiro”, “toalha”, “xampu” e 

“sabonete”, por exemplo. Utilizando o UML, é possível represen-
tar esse tipo de associação, que é chamada de agregação. Ela de-
monstra que um objeto (o conjunto) é composto por outras classes 
de objetos. Como você pode observar na Figura 2.8, isso é feito 
usando losangos ao lado da classe que representa o conjunto de 
objetos. No exemplo, o objeto “Registro de paciente” é composto 
por partes, como o próprio Paciente e as Consultas feitas por ele 
com o médico. 

Figura 2.8 Associação por agregação. 

Registro 
de paciente 

1 1 

1 1.4 

Paciente Consulta 

Fonte: Sommerville (2011, p. 93). 


44) ( irquiterur de software 
Modelos comportamentais 

A modelagem comportamental é aquela que pensa o sistema 
pela dinâmica do seu comportamento durante a execução. Con-
cebendo o sistema em movimento, esse modelo apresenta uma 
perspectiva das respostas do sistema a estímulos do ambiente. 
Mas o que seriam esses estímulos? Existem basicamente dois 
tipos: 

Dados — chegam batendo na porta do sistema esperando ser 
processados por ele. 
Eventos — acionam o processamento do sistema, colocando-o 
para trabalhar. 

Imaginemos o sistema de uma companhia telefônica. Quando 
você fizer uma chamada, gerará dados que acionarão o sistema, 
que por sua vez fará o cálculo do custo da ligação e emitirá sua 
conta mensal. Perceba que esse sistema só é acionado quando 
você faz a chamada, ou seja, o agente externo gera os dados 
que são o estímulo, esses dados serão processados, e o sistema 
produzirá uma saída. Por outro lado, pense em um sistema que 
emita um som quando o telefone estiver ocupado. Nesse caso, 

o estímulo se baseia muito mais em um evento, já que os dados 
são mínimos. 
Modelagem orientada a dados 

A modelagem orientada a dados é um recurso muito útil na 
etapa do desenvolvimento pela capacidade de mostrar do come-
ço até o fim como será o processamento do sistema. Com esse 
modelo, vemos como o sistema vai se portar durante toda a se-
quência, desde a introdução de dados até a geração das saídas 
correspondentes. 

A UML não trabalha com diagramas de fluxo de dados, já que 
eles eram anteriormente utilizados na modelagem de processa-
mento de dados. Mas como esses modelos são muito requisitados 
por aplicações no mundo dos negócios, a UML 2.0 passou a ofe-
recer diagramas de atividades, que são parecidos com diagramas 
de fluxo de dados. 



Modelagem e análises arquiteturas) (as 

7 Figura 2.9 Modelo de atividades do funcionamento de uma bomba de insulina. TON 

Escritório de compras Fornecedor 

<<repositório>> 
:Pedido Orçamento Pedidos 

| | | | 
Preencher() 1 | | 

|

TR Validar () | | | 

| | | 
| | 

[Validação OK] | | | 

Atualizar (Total) | | 
. | | 
! o 

1 | Salvar () Enviar () | 

| | I ; 

N 
N 
Fonte: Sommerville (2011, p. 94). 

Analise atentamente a Figura 2.9. Nela temos o diagrama de 
atividades do funcionamento de uma cadeia de processamento em 
torno de uma bomba de insulina. Cada etapa é representada como 

uma atividade, e você pode observar o modo como os dados trans-

correm entre elas, representados como objetos. 

TT Figura 2.10 Processamento de pedidos de bomba de insulina Ss 

Sensor de açúcar Obter valor Dados Calcular nível Nível de açúcar

: Ei 

no sangue de sensor de sensor de açúcar no sangue 

Calcular 
a entrega 
de insulina 

Calcular

Bomba Controlar Comandos Requisitos

+ 
de insulina bomba gede conti comandos de insulina

bomba de bomba 

Fonte: Sommerville (2011, p. 95).

Ne J 

Você também pode representar essa sequência de proces-
samento usando um diagrama de sequência, ao qual você já foi 
apresentado, lembra-se? Abordamos anteriormente sua utilização 
para modelar interações. Porém, preste bastante atenção, pois se 



46) (irauretura de software 
você escrevê-lo em uma sequência que só vai da esquerda para 
a direita ele também será capaz de representar bem a sequência 
do processamento de dados. Observe atentamente a Figura 2.10 e 
veja como esse diagrama representa o mesmo comportamento do 
sistema que o exemplo da Figura 2.9. 

Fique atento 

Mas qual é então a diferença entre esses dois diagramas? Os modelos de se-
quência enfatizam bem os objetos do sistema. Por outro lado, os diagramas 
de fluxo dão protagonismo às funções. 

Modelagem dirigida a eventos 

Guarde bem na sua memória que a modelagem dirigida a even-
tos é a que representa o modo como ele reage a eventos, que po-
dem ser externos ou internos. Essa modelagem concebe o sistema 
como dispondo de um número limitado e definido de estados, e os 
eventos — atuando como estímulos — acionam a mudança de um 
estado para outro. 

A modelagem dirigida a eventos é feita em UML por meio de 
diagramas de estado. Eles apresentam os estados e os eventos que 
seriam o gatilho para a sua mudança. Repare bem que ele não se 
preocupa em apresentar o fluxo de dados internamente; contudo, 
você pode introduzir algumas informações sobre o processamen-
to, caso ache necessário. 

Vamos pensar um exemplo simples para deixar claro como 
esse diagrama funciona. Imagine um forno de micro-ondas. Ele 
apresenta um interruptor que seleciona a sua potência, o teclado 
para que você dê a entrada do tempo de funcionamento, a tecla 
para Iniciar (que pode ser a mesma para cancelar) e o display alfa-
numérico, normalmente bem básico. 

Agora que você já visualizou mentalmente o micro-ondas, 
pense na sequência de eventos que ocorrerá nele quando for es-
tourar um pacote de pipocas. Primeiro, você seleciona a potência 
(pode ser meia ou total), depois vai digitar o tempo no teclado e 
apertar o botão “Iniciar”. É evidente que o micro-ondas não pode 
trabalhar com a porta aberta, e quando a pipoca estiver pronta, ele 



Modelagem e análises arquiteturas) (47 

vai emitir um som. Enquanto as ações forem executadas, o display 
apresentará mensagens correspondentes. 

Elaborando o nosso diagrama de estados em UML, devemos 
utilizar retângulos arredondados para representar cada um dos esta-
dos do sistema. Você pode inserir uma descrição bem concisa (após 
“Faça”) do que será executado naquele estado específico. Os even-
tos que serão os estímulos para mudança de estado são representa-
dos por setas rotuladas. Assim como nos diagramas de atividades, 
podemos indicar os estados inicial e final com círculos cheios. 

Preste muita atenção à Figura 2.11. O sistema fica em espera, e 
é estimulado pela seleção de potência. Em seguida, por intermédio 
do teclado, é feita a entrada do tempo. Isso feito, e conferindo se a 
porta estiver fechada, o botão “Iniciar” é acionado, fazendo a tran-
sição para outro estado. Encerrado o processo, o sistema retorna 
ao estado de espera. 

TT Figura 2.11 Diagrama de estados de um forno micro-ondas. 

Potência Potência total S

total 

Faça: definir 
potência = 600 

Relógio 
Aguardando NE 
o “exibi úmero 
Ed Potência Tempo definido 3] Operação 
total | Faça:obter número Faça: operar 
.
Meia 
Saída: definir tempo forno 
Meia potência N 
ãpotência Relógio Portafechada |Cancelar 
Porta 
Iniciar 
Meia potência 
aberta -
Habilitado 
Portaaberta Aguardando 
| Faça: definir Faça: exibir Faça: exibir 
potência = 300 “Pronto” tempo 
fas fechada ) 
Desabilitado 
Faça: Exibir 
"Não está pronto” 
q Fonte: Sommerville (2011, p. 96). ) 

O detalhamento das atividades em cada estado deve ser feito para 
que você apresente de maneira mais específica o que são os estados e 
os seus estímulos. No Quadro 2.2, temos uma descrição tabular que 
detalha o nosso exemplo do micro-ondas. Analise-a com atenção. 



48) ( arquitetura de software 
A Quadro 2.2 Estados e estímulos do micro-ondas. 

Estado Descrição 
Aguardando O forno está aguardando uma entrada. O display mostra a hora atual. 

Meia potência A potência do forno é definida para 300 watts. O display mostra "Meia potência”. 
Potência total A potência do forno é definida para 600 watts. O display mostra “Potência total”. 

Tempo definido O tempo de cozimento é definido como valor de entrada do usuário. O display 
mostra o tempo de cozimento selecionado e é atualizado conforme o tempo 
definido. 

Desabilitado A operação do forno está desabilitada por questões de segurança. A iluminação 
interna do forno está acesa. O display mostra “Não está pronto”. 
Habilitado A operação do forno está habilitada. A iluminação interna do forno está desligada. 
O display mostra “Pronto”. 

Operação Forno em operação. A iluminação interna está acesa. O display mostra a contagem 
regressiva do relógio. No fim do cozimento, a campainha soa por cinco segundos. 
A luz do forno está acesa. O display mostra “Cozimento completo” enquanto a 
campainha está soando. 

Estado Descrição 

Meia potência O usuário pressionou o botão de meia potência. 
Potência total O usuário pressionou o botão de potência total. 

Relógio O usuário pressionou um dos botões do relógio. 
Número O usuário pressionou uma tecla numérica. 

Porta aberta O interruptor da porta do forno não está fechado. 
Porta fechada O interruptor da porta do forno está fechado. 

Iniciar O usuário pressionou o botão Iniciar. 
Cancelar O usuário pressionou o botão Cancelar. 

(fome: Sommerville (2011, p. 97). 

J 

A dificuldade da modelagem dirigida em eventos que utiliza 
diagramas de estados é que a quantidade de estados pode não ser 
tão limitada quanto se pressupõe inicialmente. Imagine em um 
sistema complexo a quantidade de estados possíveis que poderiam 
ser modelados! Para lidar com esse dilema, trabalhamos com o 
conceito de superestado, que traz dentro de si vários subestados 
diferentes. Em um modelo de alto nível, o superestado vai ser re-
presentado como um só, e em diagramas separados ele será de-
composto e detalhado em estados específicos. 



Modelagem e análises arquiteturas) (ao 

Análise arquitetural 

Arquitetura de aplicações 

Os sistemas de aplicação existem para dar conta das necessida-
des de organizações, como empresas e órgãos públicos. Em geral, 
essas instituições têm muitas coisas em comum, como os padrões 
de contabilidade e finanças, lidar com funcionários, cumprir pra-
zos etc. Isso fica mais evidente se as empresas atuarem na mesma 
atividade. 

Nesse sentido, as arquiteturas de aplicações desenvolvem al-
guns modelos básicos de sistemas para que sejam utilizados no 
mesmo tipo de atividade, considerando que são desenvolvidos 
para atender um conjunto já familiar de necessidades. É claro que 
em certos níveis o software é personalizado para um cliente espe-
cífico, mas uma estrutura comum geralmente é mantida. 

Segundo Sommerville (2011), para desenvolvermos softwares, 
podemos recorrer a modelos de arquiteturas de aplicações de vários 
modos diferentes: 

Como ponto de partida para o processo de projeto de ar-
quitetura — se você não estiver familiarizado com o tipo de 
aplicação que está desenvolvendo, pode basear seu projeto ini-
cial em uma arquitetura genérica de aplicação. Naturalmente, 
ela precisará ser especializada para o sistema específico a ser 
desenvolvido, mas é um bom ponto de partida para o projeto. 
Como um checklist de projeto — se você desenvolveu um 
projeto de arquitetura para um sistema aplicativo, é possível 
compará-lo com a arquitetura de aplicação genérica. Você 
pode verificar se seu projeto é compatível com a arquitetura 
genérica. 
Como forma de organizar o trabalho da equipe de desen-
volvimento — as arquiteturas de aplicação identificam carac-
terísticas estruturais estáveis das arquiteturas do sistema, e, 
em muitos casos, é possível desenvolvê-las em paralelo. Você 
pode distribuir o trabalho aos membros da equipe para imple-
mentação dos diferentes componentes dentro da arquitetura. 
Como uma forma de avaliar os componentes para reúso — 
se você tem componentes que possam ser reutilizados, você 
pode compará-los com as estruturas genéricas para ver se exis-
tem componentes comparáveis na arquitetura da aplicação. 



50) ( prquiterura de software 
Como um vocabulário para falar sobre os tipos de aplica-
ções — se você está discutindo uma aplicação específica ou 
tentando comparar as aplicações do mesmo tipo, então pode 
usar os conceitos identificados na arquitetura genérica para 
falar sobre as aplicações (SOMMERVILLE, 2011, p. 116). 

Como podem ser encontrados inúmeros tipos de sistema de 
aplicação, você pode pensar que eles são significativamente dife-
rentes entre si. Contudo, as semelhanças entre elas é tão grande, 
a ponto de podermos representá-las por meio de uma arquitetura 
abstrata única de aplicação. 

Para deixar isso bem claro, vamos pensar em dois tipos de ar-
quitetura de aplicação. 

1. Aplicações de processamento de transações — utilizadas em 
sistemas bancários, comércio eletrônico, sistemas de reser-
vas e sistemas de informação, essas aplicações são baseadas 
em torno de um banco de dados. Elas operam atendendo as 
requisições de usuários para receber informações e também 
para que elas sejam atualizadas no banco de dados. Podemos 
dizer que este é o modelo mais encontrado em sistemas de 
negócios. As atividades dos usuários são isoladas de modo 
que não conseguem interferir entre si, e o banco de dados é 
preservado intacto (Figura 2.12). 
Figura 2.12 Estrutura de aplicações de processamento de transações. 
Processamento 
E/S 
Lógica 
Eda aplicação 
-— 
Gerente 
«
de transação 
-=——. Banco de dados 
Fonte: Sommerville (2011, p. 117). 

2. Sistema de processamento de linguagens — nesses siste-
mas, as entradas são feitas usando uma linguagem formal — 
Java, por exemplo. O sistema de processamento de lingua-
gem processa essas entradas, traduzindo-as em um formato 
que pode ser entendido em níveis inferiores. Sem dúvida, os 
modelos mais utilizados desse sistema são os compiladores 
que traduzem para linguagem de máquina os programas em 
linguagem de alto nível. Eles também são utilizados na inter-
pretação de linguagens de comando em sistemas de informa-
ção, banco de dados e linguagens de marcação (Figura 2.13). 

Modelagem e análises arquiteturas) (51 

/— Figura 2.13 Arquitetura de um sistema de processamento de 
linguagens. ) 

Tradutor 

Verificar sintaxe 

Instruções da 

———» | Verificar semântica

linguagem-fonte 

Gerar 

Instruções 
abstratas m/c 

Interpretador 

Buscar 
Dados ———» Executar —————» | Resultados 

Fonte: Sommerville (2011, p. 119). ) 

Perceba que, apesar da enorme variedade de sistemas de ne-
gócios baseados em Internet, a maioria deles é basicamente um 
sistema de processamento de transações. E é impossível desen-
volver softwares sem utilizarmos sistemas de processamento de 
linguagens. 

Arquitetura de sistemas confiáveis 

Desenvolver sistemas confiáveis requer processos confiáveis. 
E, mesmo assim, não podemos garantir por meio disso a confiabi-
lidade do sistema. Precisamos desenvolver uma arquitetura de sis-
temas de segurança, em especial quando existe tolerância a erros. 
Imagine o sistema de um avião: ele não pode parar por completo 
durante um voo em caso de um defeito, não é mesmo? Na prática, 
isso implica utilizar componentes e mecanismos redundantes para 
que o controle possa ser comutado entre eles. 

Lembra-se daquele velho conselho para nunca colocar todos 
os ovos no mesmo cesto? O modo mais simples para desenvol-
ver uma arquitetura confiável é utilizar servidores replicados, em 
que dois ou mais ficam responsáveis pelas mesmas operações. 
Um componente de gerenciamento de servidor fica responsável 
por canalizar os pedidos de processamento pelo encaminhamento 



52) (irquiterura de software 
das solicitações para os servidores individualmente. Se o servidor 
falhar — isso pode ser percebido pela falta de respostas —, ele é 
comutado para fora, impedindo que “contamine” o sistema, e os 
pedidos que não processou são enviados para que outros servido-
res realizem a tarefa. 

Essa estratégia de servidores replicados é bastante utiliza-
da em sistemas de processamento de transações, já que neles 
não há dificuldade para guardar cópias das transações que ain-
da precisam ser operadas. Nesses sistemas, o objetivo é que 
os dados das transações sejam atualizados assim que elas fo-
rem concluídas com exatidão. Dessa maneira, caso haja atra-
so, O sistema como um todo não é afetado. Contudo, perceba 
que esse modelo não nos dá muita diversidade. Os servidores 
são iguais, em hardware e software, e encaram os problemas 
que ocorram em uma máquina específica passando-o para ou-
tra igual. Se o problema for no projeto do software, todos os 
servidores vão cair do mesmo jeito. Assim, para prever essa 
possibilidade, os sistemas precisam trazer consigo diferentes 
hardwares e softwares. 

Sistemas de proteção 

O sistema de proteção é um modelo especializado que se man-
tém ligado a outro sistema. Eles ficam atentos ao ambiente de 
modo independente e, caso percebam problemas, intervêm com 
uma medida de emergência. Pense, como exemplo, em um siste-
ma que controle um reator. Ele monitora a temperatura e os níveis 
de pressão e, se ele perceber que existe um aumento em nível crí-
tico, imediatamente aciona medidas de contingenciamento, como 
desligar a alimentação, abrir válvulas para despressurização e até 
resfriamento de emergência. 

Observe atentamente a Figura 2.14, que demonstra a re-
lação entre um sistema controlado e um sistema de proteção. 
O sistema de proteção faz o monitoramento, e, se detectar pro-
blemas, automaticamente ele emite comandos para que o siste-
ma controlado desligue, e também chama outros mecanismos 
de proteção. Repare que coexistem dois conjuntos de sensores, 
um para cada sistema. E mesmo se o sensor falhar, ele tem 
backups que dão condições para que o sistema continue em 
funcionamento. 



Modelagem e análises arquiteturas) (53 

Figura 2.14 Arquitetura de sistemas de proteção. TON 

Ambiente de sistema 

t t 

Sensores 

Sensores 

de proteção 

, t 

Sistema Sistema 
de proteção de controle 

t t 

Atuadores 
I I 
Equipamento 
controlado 

o Fonte: Sommerville (2011, p 242) ) 
É claro que o sistema de proteção apresenta somente as funcio-
nalidades que são suficientes para que eles possam garantir a se-
gurança, levando o sistema de um estado possivelmente perigoso 
para um estado seguro (desligado, ou em mínimo funcionamento, 
quando o desligamento total não é desejável). Em termos de arqui-
tetura, estamos pensando em uma dimensão mais geral que tolere 
problemas do sistema principal, sendo ela mais básica e menor, 
apenas com as funções essenciais. 

Prevenção e capacidade de detectar defeitos são fatores que fa-
zem toda a diferença, e por isso devem ser muito bem projetados. 
O sistema de proteção, como um paraquedas ou o airbag, pode ser 
a última linha de defesa e, portanto, deve ter uma probabilidade 
de falha sob demanda baixíssima — por exemplo, 1/1.000 —, ainda 
mais se considerarmos que a demanda do sistema de proteção 
deve ser normalmente bem baixa. 

Arquitetura de automonitoramento 

Como o nome já dá a entender, a arquitetura de automonito-
ramento permite que o sistema monitore com muita atenção a si 
mesmo, e atue caso perceba alguma falha (Figura 2.15). Canais 
separados fazem cálculos que são comparados pelas suas saídas. 
Caso eles sejam iguais, então se assume que tudo está funcionan-
do tranquilamente. Mas se houver diferenças, então o sistema 



54) ( arquitetura de software 
considera que existe algum erro. Nesse caso, o sistema normal-

mente escreve uma exceção de falha na linha de status de saída, 

e o resultado é que o controle será transferido para outro sistema. 

a Figura 2.15 Arquitetura de automonitoramento. N 

Status 
Canal RR 
Valor y 
de entrad 

GL) Divisor Comparador —— 
Valor de saída 

Ds Canal 2 E, 

q Fonte: Sommerville (2011, p. 243). ) 

Segundo Sommerville (2011), para que os sistemas de auto-
monitoramento sejam eficientes, é muito importante que: 

O hardware usado em cada canal seja diversificado. Na prá-
tica, isso pode significar que cada canal usa um tipo diferen-
te de processador para realizar os cálculos necessários, ou o 
chipset que compõe o sistema pode ser proveniente de fabri-
cantes diferentes. Isso reduz a probabilidade de que defeitos 
comuns de projeto do processador afetem os cálculos. 
O software usado em cada canal seja diversificado. Caso con-
trário, os mesmos erros de software poderiam ocorrer ao mes-
mo tempo, em cada canal (SOMMERVILLE, 2011, p. 241). 

A arquitetura de automonitoramento é muito útil quando pre-
cisamos que os cálculos sejam precisos e que a disponibilidade 
não é o mais importante. Imagine um sistema de diagnóstico 
utilizado por algum equipamento médico. É claro que não é le-
gal que o sistema trave e desligue. Porém, é preferível que isso 
aconteça ao invés de o diagnóstico ser errado. 

Mas se a disponibilidade constante é essencial, então precisa-

mos implementar paralelamente vários sistemas de autoverificação, 

em que uma unidade de comutação perceba as inconsistências e 

escolha por um dos sistemas. Um ótimo exemplo é o sistema de 

controle de aeronaves do Airbus 340 (Figura 2.16). Ele utiliza cinco 

computadores de autoverificação, que operam os cálculos de ma-

neira separada por meio das mesmas entradas. Filtros de hardware 

atuam comparando as saídas e, se notam algum erro, eles desligam 



Modelagem e análises arquiteturas) (ss 

a saída do respectivo 
putador seguinte. Na 
res diferentes podem 
de pé e operante. 
computador, e passam a obter saídas do com-
prática, isso significa que quatro computado-
falhar e o sistema como um todo permanecerá 
Entrada 
Figura 2.16 Arquitetura do sistema de controle 
-Sistema primário de controle de voo 1 
de voo do Airbus. 
Saída 
———+. 
Do” 
Divisor 
Canal 1 v| 
Comparador 
Status 
Saída 
———>> +» 
Filtro ——+ 
Lo Canal 2 RR, 
— Sistema primário de controle de voo 2 
Status 
Saída 
DD > 
Filtro 
= Sistema primário de controle de voo 3 
Status 
Saída 
Do yo 
Filtro 
” 
Sistema secundário de controle de voo 1 
————+&. 
[OT 
Divisor 
Canal v| 
Comparador 
Status 
Saída 
>>>» +» 
Filtro — + 
Lo Canal 2 RR, 
op Sistema secundário de controle de voo 2 
Status 
Saída Filtro Hi» 
q Fonte: Sommerville (2011, p 244). » 
A diversidade desse sistema também é impressionante. Os 
sistemas utilizam hardwares diferentes, adquiridos de fabricantes 
distintos. Da mesma forma, os softwares são desenvolvidos por 
diversas equipes, utilizando diferentes linguagens de programa-
ção. O resultado é que em 15 anos de utilização nunca ocorreu al-
gum caso em que o sistema de controle tivesse falhado totalmente. 
Diversidade de software 
Já tocamos nesse tópico algumas vezes, mas agora vamos en-
fatizá-lo. A diversidade de software é o conceito de que a diferença 



56) ( arquitetura de software 
Saiba mais 

A POFOD (probability 
of failure on demand 
[probabilidade de 
falha na demandal) diz 
respeito à probabilidade 
de ocorrer uma falha 
durante um ciclo do 
sistema. Por exemplo, 
POFOD = 0,001 significa 
que existe uma chance 
em mil de ocorrer uma 
determinada falha 
durante uma execução 
do sistema. 

entre softwares atuantes no mesmo sistema evita a possível repe-
tição de erros causados por fatores comuns. Em outras palavras, 
softwares diferentes — em formato, origem e forma de desenvolvi-
mento — podem apoiar-se em garantir a segurança do sistema pela 
possibilidade da não repetição dos mesmos erros ou a não sujeição 
aos mesmos fatores. 

Uma das formas de garantir a diversidade é a divisão da equi-
pe no momento do desenvolvimento, formando grupos separa-
dos que vão trabalhar de forma independente. Os parâmetros 
para essa divisão podem ser estabelecidos pelo próprio cliente. 
É possível, por exemplo, que uma equipe desenvolva um projeto 
orientado a objetos, enquanto outra a funções. Outra maneira 
muito comum é a exigência de desenvolvimento em linguagens 
de programação distintas, assim como diferentes ferramentas e 
ambientes de desenvolvimento. Até algoritmos distintos podem 
ser exigidos para garantir a diversidade do software. 

As equipes normalmente trabalham com especificações deta-
lhadas, que se originam da especificação dos requisitos do sis-
tema — devendo esta ser bem específica para evitar confusões. 
Ninguém projeta um sistema para não funcionar, mas a ideia 
é que, caso as diferentes versões do sistema falhem, que seja, 
então, de modos completamente distintos. 

Aconfiabilidade do sistema é medida multiplicando a possibilidade 
de erro de cada canal. Então pense que em um sistema de três canais, 
em que a possibilidade de falha sob demanda de cada canal for 0,001, 

o resultado é uma POFOD global um milhão de vezes maior do que 
um sistema utilizando apenas um canal. Mas é claro que, na prática, 
não é fácil que tenhamos essa independência entre o desenvolvimen-
to dos canais. É comum que os desenvolvedores, por sua origem e 
formação parecida, acabem cometendo erros similares. E também 
podem acontecer erros de interpretação dos requisitos — ou mesmo os 
próprios requisitos não serem muito precisos — e, assim, eles acabam 
sendo levados para os diferentes canais do mesmo modo. 
Uma maneira modo de evitar possíveis erros de especificação 
é desenvolvê-las em diferentes linguagens, como uma equipe re-
cebendo uma linguagem formal, outra modelos baseados em es-
tados e um terceiro time recebendo especificações em linguagem 
natural. No entanto, perceba que isso tudo envolve muito trabalho 
e muitos custos, então devemos pensar bem em que casos o desen-
volvimento de um software multiversão é realmente necessário. 



Modelagem e análises arquiteturas) (57 

E claro que existem sistemas que requerem máxima segurança e 

confiabilidade, mas na maioria dos casos formas mais simples de 

arquitetura segura podem ser suficientes. 

Arquitetura mestre-escravo para sistemas 
distribuídos 

Pensando em arquiteturas para sistemas distribuídos, um dos 
tipos mais utilizados é a conhecida como mestre-escravo. Sua im-
plementação é mais comum ainda em sistemas de tempo real que 
trabalham como processadores separados que são associados ao 
processamento de dados, gerenciamento de atuadores e aquisição 
de dados do sistema. 

O conceito que pode ser novo aqui é o de atuadores. Eles são 
dispositivos que, sob o controle do sistema de software, agem al-
terando o ambiente do sistema. Para deixar isso mais claro, ima-
gine que uma válvula pode ser controlada por um atuador em que 
ele executa a mudança de seu estado para “fechada” ou “aberta”. 

Falando especificamente da arquitetura, entenda que ela atua 
com uma hierarquia entre processos. O processo chamado de 
“Mestre” se encarrega do processamento, da coordenação e das 
comunicações e, é claro, controla também os processos “escra-
vos”. Os processos escravos, por sua vez, atuam em ações especi-
ficas, como coletar dados de um sensor. 

TT Figura 2.17 Sistema de gerenciamento de tráfego com uma arquitetura mestre-escravo. DN 

Processador de 
sala de controle 

Coordenação e 
Processador processo de Processador de controle 
N de sensor exibição de semáforo 

Processo de Mestre Processo de 
———— controle controle 
+ de sensor de luzes 

Pá Escravo Escravo N. 

Consoles de operador 
Câmeras e sensores . 
de fluxo de tráfego Semáforos 

o Fonte: Sommerville (2011, p. 342). ) 

58) ( arquitetura de software 
Vamos analisar a Figura 2.17 para entender um exemplo práti-
co dessa arquitetura. Nela você pode observar a simulação de um 
sistema de controle de tráfego de uma cidade. O sistema é distri-
buído com três processadores separados executando os processos 
lógicos. O processo da sala de controle é o mestre, enquanto os 
processos escravos vão buscar os dados de tráfego nos sensores, 
responsáveis por medir o fluxo das ruas. O sistema de controle 
manda comandos para o processo que controla os semáforos. 

Em sistemas de tempo real, é essencial que os prazos de proces-
samento — os deadlines — sejam cumpridos. Para que isso seja feito 
de maneira eficiente, é importante que o processamento seja distri-
buído, e é aí que a arquitetura mestre-escravo se torna uma opção 
bastante interessante. Como ela, podemos implementar processos 
escravos para se ocuparem das ações intensivas, como gerenciar 
equipamentos e processar sinais, enquanto processos mestres cui-
dam da organização e comunicação. 

Arquitetura cliente-servidor multicamadas 

Na Unidade 1 já conversamos sobre a arquitetura cliente-servi-
dor, e agora vamos falar um pouco sobre a versão desse modelo que 
se utiliza de várias camadas. Pense nesse modelo como um modo em 

que as camadas do sistema, gerenciamento de dados, apresentação, 

banco de dados e processamento de aplicação se organizam com 

processos executados separadamente em processadores diferentes. 

Figura 2.18 Arquitetura em três camadas para um sistema de Internet Banking. DON 

Camada 1 Apresentação 

Cliente 

Interação HTTPS 

=. Servidor Web Servidor de banco de dados 

Prestação de € onsultalta SOÍ SOL saL Banco de dados 
serviços de conta de conta de cliente 

Cliente Epa À 
Camada 2 Processamento Camada 3. Processamento 
de aplicações e de banco de dados 
gerenciamento de dados 

Cliente 

q Fonte: Sommerville (2011, p 344). » 


Modelagem e análises arquiteturas) (so 

Como exemplo, analise a Figura 2.18, que simula o modelo 
de um sistema de Internet Banking. Aqui temos uma arquitetu-
ra cliente-servidor multicamadas — como você pode observar, 
são três camadas no sistema. Um servidor Web proporciona o 
serviço de gerenciamento de dados, que são fornecidos por um 
banco de dados dos clientes do banco. Implementados no ser-
vidor Web como scripts estão serviços como saldos, extratos e 
transferências, sendo executados pelo cliente por um browser 
em seu computador. 

Pensando em escalabilidade, esse sistema é muito interes-
sante, já que é bem tranquilo para adicionarmos novos servido-
res ou clientes. Utilizar as três camadas nos possibilita otimizar 

o sistema transferindo informações entre o servidor do banco 
de dados e o servidor Web — comunicação que pode ser feita 
por intermédio de protocolos de troca de dados rápidos e de 
baixo nível. 
O sistema multicamadas também é uma opção interessante 
para desenvolver uma aplicação em que serão acessados dados 
de bancos diferentes. Para facilitar esse procedimento, desen-
volvedores costumam implementar um servidor de integração 
ao sistema, que atua como intermediário na coleta dos dados 
distribuídos e entregando ao servidor de aplicação em um único 
pacote. 

Os sistemas cliente-servidor multicamadas podem ser imple-
mentados via arquiteturas de componentes distribuídos. Proces-
sar a aplicação pode acabar se mostrando o aspecto mais volátil 
do sistema, e um sistema cliente-servidor multicamadas (que 
distribui o processamento) pode atualizar tranquilamente por ter 
uma localização central. Em alguns casos, o processamento pode 
ser distribuído entre os servidores de gerenciamento de dados e 
de lógica de aplicação, e assim as solicitações dos clientes po-
dem receber respostas mais rápidas. 

Você deve considerar vários fatores no momento de escolher 
qual será a arquitetura de distribuição mais adequada para o sis-
tema que estiver desenvolvendo. Para que você entenda melhor o 
que está envolvido em possíveis situações, analise atentamente o 
Quadro 2.3. 



60) ( arquitetura de software 
TT Quadro 2.3 Usos do padrão cliente-servidor. N 

Arquitetura Aplicações 

Arquitetura cliente-Aplicações de sistema legado usadas quando a separação de 

-servidor de duas gerenciamento de dados e de processamento de aplicação são 

camadas com impraticáveis. Os clientes podem acessá-las como serviços. 

clientes-magros Aplicações computacionalmente intensivas, como compiladores com 

pouco ou nenhum gerenciamento de dados. 

Aplicações intensivas de dados (navegação e consulta) com processamento 

de aplicações não intensivo. Navegar na Web é o exemplo mais comum de 

uma situação em que essa arquitetura é usada. 

Arquitetura cliente-Aplicações em que o processamento de aplicação é fornecido por softwares 

-servidor de duas de prateleira (por exemplo, o Microsoft Excel) no cliente. 

camadas com Aplicações em que é requerido processamento computacionalmente 

clientes-gordos intensivo de dados (por exemplo, visualização de dados). 

Aplicações móveis em que a conectividade com a Internet não pode ser 
garantida. Algum processamento local usando informações armazenadas 
em banco de dados, portanto, é possível. 

Arquitetura cliente-Aplicações de grande porte com centenas ou milhares de clientes. 

-servidor multicamadas Aplicações nas quais os dados e a aplicação são voláteis e integrados a 
dados de várias fontes. 

q Fonte: Sommerville (2011, p. 345) ) 

Arquitetura de componentes distribuídos 

Vamos começar esse tópico analisando diretamente uma fi-
gura? Observe que na Figura 2.19 temos um processamento em 
camadas, em que servidores lógicos separados podem ser utili-
zados para implementar cada uma delas. Apesar de esse mode-
lo ser muito legal para vários aplicativos, ele apresenta alguns 
problemas para os desenvolvedores, partindo da necessidade de 
alocar os serviços em suas respectivas camadas. Isso fica um 
pouquinho mais complicado se pensarmos que nem sempre é 
tão evidente qual a categoria do serviço (se ele é serviço de ge-
renciamento de dados, serviço de aplicação ou serviço de banco 
de dados). E não podemos nos esquecer que o sistema deve ser 
escalável, com os servidores podendo ser replicados para com-
portar novos clientes. 



Modelagem e análises arquiteturas) (61 

( 
Figura 2.19 Modelo 
cliente-servidor. 
de arquitetura em camadas para aplicações TN 
Camada de apresentação 
Camada de gerenciamento de dados 
Camada de processamento de aplicação 
Camada de banco de dados 
Fonte: Sommerville (2011, p. 340). ) 
Uma proposta mais geral para lidar com essa questão é abordar 
o sistema como um conjunto de serviços, em vez de tentar dividi-
-los e alocá-los. Assim, os serviços, ou grupos de serviços, são 
implementados por meio de componentes separados. Por isso cha-
mamos esse modelo de arquitetura de componentes distribuídos. 
(T Figura 2.20 Exemplo 
Comp 1 
Serviços 
comuns 
de arquitetura de componentes 
Comp 2 
Serviços 
comuns 
distribuídos. 
Comp 3 
Serviços 
comuns 
Comp 4 
Serviços 
comuns 
N 
| 
Cliente 
Middleware 
| 
Cliente 
de comunicação 
Cliente 
| 
Cliente 
q Fonte: Sommerville (2011, p. 344). ) 
Nesse modelo, organizamos o sistema como conjunto de ob-
Jetos ou componentes que interagem entre si. Os próprios com-
ponentes acabam gerando uma interface para os serviços que eles 
oferecem, sendo chamados por outros componentes pelo middle-
ware. Para isso, utilizam chamadas de métodos ou chamadas de 



62) ( arquitetura de software 
procedimento remoto. O middleware gerencia as interações de 
componentes, providencia serviços comuns que podem ser ne-
cessários pelos componentes de aplicação e resolve as diferenças 
entre os tipos de parâmetros passados entre eles. Como você deve 
pensar, os sistemas de componentes distribuídos acabam se tor-
nando bem dependentes do middleware. 

Segundo Sommerville (2011, p. 346), as vantagens de imple-
mentarmos o modelo de componentes distribuídos em sistemas 
distribuídos são: 

1. A permissão ao projetista de sistema de atrasar decisões 
sobre onde e como os serviços deverão ser prestados. Os 
componentes fornecedores de serviços podem executar 
em qualquer nó da rede. Não é necessário decidir previa-
mente se um serviço é parte de uma camada de gerencia-
mento de dados, uma camada de aplicação etc. 
2. É uma arquitetura de sistemas muito aberta, a qual permi-
te a adição de novos recursos conforme necessário. Novos 
serviços de sistema podem ser adicionados facilmente sem 
grandes perturbações ao sistema existente. 
3. O sistema é flexível e escalável. Novos componentes ou 
componentes replicados podem ser adicionados quando a 
carga sobre o sistema aumenta, sem interromper as outras 
partes do sistema. 
4. É possível reconfigurar o sistema dinamicamente com com-
ponentes migrando por meio da rede, conforme necessário. 
Isso pode ser importante onde estão flutuando padrões de 
demanda de serviços. Um componente fornecedor de ser-
viços pode migrar para o mesmo processador como objetos 
requisitores de serviços, aumentando assim o desempenho 
do sistema (SOMMERVILLE, 2011, p. 346). 
Você pode utilizar a arquitetura de componentes distribuídos 
como modelo lógico, sendo uma ótima opção para estruturar e 
organizar um sistema. Vamos pensar no exemplo de um softwa-
re de um comércio virtual. Existe o interesse de que a aplicação 
faça o controle de mercadorias no estoque, envie mensagens aos 
clientes, faça pedidos aos fornecedores, e tudo mais que você pos-
sa pensar que é necessário nesse tipo de atividade. Considerando 
esses fatores, uma opção a ser considerada utilizando uma arqui-
tetura de componentes distribuídos é um sistema de mineração de 
dados (Data Mining) (Figura 2.21). Basicamente, podemos dizer 



Modelagem e análises arquiteturas) (63 

que ele opera buscando relações entre os dados guardados em di-
versos bancos de dados que compõem o ambiente, operando um 
processamento intensivo. 

TT Figura 2.21 Arquitetura de componentes distribuídos para um sistema de mineração de dados. TON 
Banco de dados 1 Gerador de relatório 
Integrador 1 

Banco de dados 2 = 
Visualizador 

Integrador 1 LL 

Banco de dados 3 

Display 

Clientes 

q Fonte: Sommerville (2011, p. 346). ) 

Um sistema de mineração de dados é uma ferramenta poderosa 
para buscar padrões e atuar por meio deles. Imagine, por exem-
plo, que processando os bancos de dados da loja virtual o sistema 
perceba que existe um padrão que liga pessoas de uma localidade, 
faixa etária ou mesmo que costumem comprar determinado tipo 
de tênis a uma tendência particular de comprar livros de algum 

autor de romances específico. Contando com essa informação, o 

sistema pode oferecer os novos livros desse autor para esse públi-
co assim que eles forem lançados. 
Pensando especificamente na arquitetura envolvida nesse pro-

cesso, primeiro temos uma interface que trabalha com a leitura dos 
bancos de dados de vendas, fazendo a síntese entre os componentes 
distribuídos. O segundo aspecto é a existência de componentes inte-
gradores. Eles são a chave que opera sobre os dados procurando por 
relações até então despercebidas. Eles podem ser de vários tipos e 
assumir diferentes funções dentro do mesmo sistema, como um com-
ponente integrador que pode analisar as variações das vendas dos 



64) ( arquitetura de software 
produtos ao longo do ano (detectando produtos que costumam ser 
mais vendidos em datas comemorativas, como o Dia dos Pais ou o 
Natal) ou outro que busque relações entre as vendas de diferentes pro-
dutos (para notar que clientes que compram tal marca de computado-
res também costumam usar tipos específicos de roupas e calçados). 

O terceiro elemento fundamental desse sistema são os com-
ponentes visualizadores. Ligados diretamente aos componentes 
integradores, eles geram uma saída dos padrões descobertos, nor-
malmente de maneira gráfica. Um componente display pode ser 
utilizado como complemento para enviar os modelos gráficos para 
a apresentação final para os clientes. 

Perceba que para desenvolvermos esse tipo de software é mais 
indicado recorrermos a uma arquitetura de componentes distribuí-
dos em vez de um modelo em camadas. Isso porque é bem mais 
simples para que possamos adicionar novos bancos de dados, sen-
do necessário apenas inserir outro componente distribuído. 

É claro que todo padrão de arquitetura dispõe de suas vantagens e 
desvantagens, não é mesmo? Segundo Sommerville (2011), as duas 
maiores desvantagens do modelo de componentes distribuídos são: 

1. Elas são mais complexas para projetar que sistemas cliente-
-servidor. Os sistemas cliente-servidor multicamadas pare-
cem ser uma forma bastante intuitiva de se pensar sobre os 
sistemas. Eles refletem muitas transações humanas em que 
os indivíduos solicitam e recebem serviços de outras pessoas 
que se especializaram em fornecer tais serviços. Por outro 
lado, as arquiteturas de componentes distribuídos são mais 
difíceis para se visualizar e compreender. 
2. O middleware padronizado para sistemas de componentes 
distribuídos nunca foi aceito pela comunidade. Diferentes 
fornecedores, como a Microsoft e a Sun, desenvolveram 
middlewares diferentes e incompatíveis. Eles são complexos 
e a confiança neles aumenta a complexidade geral dos siste-
mas distribuídos (SOMMERVILLE, 2011, p. 347). 
Em razão desses fatores, as arquiteturas orientadas a servi-
ços têm substituído muitas vezes as arquiteturas de componen-
tes distribuídos. Porém, elas ainda são as mais indicadas quando 
precisamos de um modelo que consiga lidar bem com a neces-
sidade de muitas transações que precisam ser rápidas e com uma 
taxa alta de transferência de dados. 



Modelagem e análises arquiteturas) (os 

Exercícios de fixação 

Explique em poucas palavras o que é a mode-O que é a arquitetura de aplicações e de que 
lagem. maneiras ela pode ser utilizada? 
O que é um modelo de contexto? O que são aplicações de processamento de 
Quem são os stakeholders? transações e onde são implementadas? 
Exemplifique uma situação em que o modelo O que são sistemas de processamento de lin-
de contexto pode ser utilizado. guagens e onde são mais utilizados? 
Explique como devemos compor um diagrama Qual a importância da arquitetura de sistemas 
de sequência. confiáveis, e quais são seus elementos básicos? 
O que são modelos estruturais? O que são sistemas de proteção? 
Explique a diferença entre a modelagem es-O que é a arquitetura de automonitoramento? 
trutural estática e a modelagem estrutural Qual a importância da diversidade de software? 
dinâmica. O que é a arquitetura mestre-escravo? 
O que é agregação? Explique o que é a arquitetura cliente-servidor 
O que são modelos comportamentais? multicamadas. 
Explique o que é a modelagem orientada a Explique o que é a arquitetura de componentes 
dados. distribuídos e qual a sua importância. 
Explique o que é a modelagem dirigida a O que é um sistema de mineração de dados e 
eventos. onde ele pode ser implementado? 

Panorama 

A era do raciocínio artificial 

Ninguém sabe muito bem do que se trata, mas, sobre as necessidades do usuário, para oferecer 
como disse recentemente Scott Prevost, diretor uma experiência personalizada, mais produtiva e 
de desenvolvimento do site de busca Bing, da intuitiva. 
Microsoft, “seja o que for, a Web 3.0 já está aqui”. A Web semântica -como os especialistas definem 
Ainda nem bem começamos a entender o que essa rede dinâmica e pensante. Imagine que o 
é a Web 2.0, e “gurus” tecnólogos, cientistas e texto, os gráficos e as fotos que vemos no nave-
empreendedores debatem a respeito dos apli-gador não correspondem a uma página estática, 
cativos e tecnologias que facilitarão e acelerarão mas provêm de diferentes lugares da rede e foram 

o desenvolvimento da terceira geração da Web: combinados de modo personalizado para o usuá-
uma Web aberta, onipresente, inteligente, ligada rio. Essa é sua natureza: reutilização e mashup, 
ao mundo físico, capaz de compreender a lingua-ou mistura. As ideias, os conceitos ou os dados 
gem natural, reconhecer o contexto e raciocinar podem ser reunidos e reorganizados de infinitas 

66) ( arquitetura de software 
maneiras, gerando novo significado, segundo as 
necessidades de cada pessoa. 
As três versões, explicadas didaticamente, são: 

B Emsua versão 1.0 (1990-1999), os espaços da 
Web eram páginas que representavam a visão 
da empresa ou da organização proprietária do 
domínio. 
| Na2.0(2000-2009), os espaços passaram a ser as 
contas pessoais dos usuários, embora alojadas 
em sites pensados e desenhados por um editor. 
&B Na 30 (2010-2020, segundo previsões), os 
espaços da Web serão uma coleção de recur-
sos de diferentes sites que se organizarão em 
tempo real, de acordo com a visão do usuário. 

Sonho pós-moderno 
Embora a Web semântica ainda esteja em uma fase 
preliminar, a ideia não é nova. Na verdade, é tema 
de discussão desde 1999, quando Timothy Berners-
-Lee, diretor do World Wide Web Consortium 
(W30), organização que promove os standards da 
Web, alcunhou o termo. 
Criador da linguagem de hipertexto HTML, do pro-
tocolo HTTP e do localizador uniforme de recursos 
(URL), Berners-Lee afirmou na época: “Sonho com 
uma Web na qual os computadores serão capazes 
de analisar o conteúdo e entender as transações 
entre as pessoas e as máquinas. Chama-se “Web se-
mântica! mas ainda tem de ser desenvolvida. Quan-
do se tornar realidade, nossa vida será manejada por 
computadores. O agente inteligente, que a humani-
dade buscou tanto, por fim se materializará” 
Ele estimou que seu sonho se concretizaria em 
2020, mais ou menos a data em que a versão 5 
da linguagem de programação da Web, o HTML, 
estará completa (hoje apenas algumas de suas es-
pecificações podem ser usadas). Com a evolução 
das tecnologias 2.0, as funcionalidades sintáticas 
simplificadas do HTML 5 para codificar conteúdo 
multimídia estão cumprindo as promessas da Web. 
Jogo aberto 
No centro do ecossistema 3.0 unem-se os dois ex-
tremos da corrente tecnológica: de um lado, o front-
-end, ou os aplicativos que interagem com o usuário; 

do outro, o back-end, ou os sistemas de administra-

ção e processamento de dados que gerenciam os 

aplicativos. O navegador, por exemplo, é o aplica-

tivo front-end da Web por excelência. Embora hoje 

esse tipo de programa ofereça inumeráveis exten-

sões ou componentes (plug-ins) que melhoram a 

navegação, o sistema não tem, ainda, inteligência 

para entender ou organizar a informação que o 

usuáio maneja. Quando os aplicativos e o conteúdo 

da Web se ordenarem em torno de standards se-

mânticos, será dado um grande passo para a rede 

inteligente. 
A principal barreira para que a Web 3.0 se desen-

volva tem a ver, justamente, com a organização 

dos dados. Quanto maior a densidade de informa-

ção, quanto mais dados interligados e etiquetados 

semanticamente e quanto mais metadados rela-

cionados com os modelos conceptuais, mais signi-

ficados poderão ser extraídos do conteúdo. 

Igualdade para todos 

As primeiras inovações que hoje podem ser defi-

nidas como os standards da Web 3.0 surgiram do 

Darpa Agent Markup Language (DAML), programa 

resultante do esforço secreto do Departamento de 

Defesa dos Estados Unidos para construir sua ver-

são da Web, em 2000. 

O projeto, finalmente concluído, deu à luz os 

standards RDF (Resource Description Framework), a 

linguagem semântica usada para descrever dados, 

metadados e outras linguagens; OWL (Web Ontology 

Language), extensão do modelo RDF desenhada 

para representar conhecimentos ricos e complexos 

sobre informações, grupos de informações e rela-

ções entre elas; e SPARQL (Protocol and RDF Query 

Language), a linguagem de consulta para RDF mais 

poderosa que SQL. 

Ao compartilhar paradigmas, todos os produtos e 

serviços on-line se converterão em facilitadores de 

novos serviços, e consumidores e empresas se be-

neficiarão dessas melhorias contínuas. Quem sabe, 

no final da década, a propriedade digital passe a ser 

um bem público ou coletivo. Talvez a Web esteja 

evoluindo de uma rede para um estado social. 



Modelagem e análises arquiteturas) (67 

O que a Web 3.0 pode fazer? 

& Infinitas tecnologias abertas — código aber-
to para desenvolvimento de plataformas e 
aplicativos;técnicas abertas para compartilhar 
dados (dados como serviço); identidade pes-
soal “portátil” (de um site para outro e de um 
dispositivo para outro). 
Infinita inteligência computacional — pa-
drões da Web semântica; sistemas de pro-
cessamento da linguagem natural (NLP); 
inteligência artificial; agentes de software 
(aplicativos com capacidade de raciocínio que 
trabalham para o usuário). 
Infinita conectividade onipresente — cone-
xão de banda larga à Internet em qualquer 
momento e em qualquer lugar; sistemas de 

Recapitulando 

brimos os trabalhos definindo o que é 

modelagem. Entrando de cabeça no as-

sunto, começamos falando sobre o mode-
lo de contexto. Você conheceu a sua importância 
e os contextos em que ele pode ser utilizado. Em 
seguida, você foi apresentado aos modelos de 
interação, e aprendeu a utilizar os diagramas de 
sequência. Passando para os modelos estruturais, 
você viu que eles são divididos entre modelos es-
táticos e dinâmicos, e entendeu como aplicar os 
diagramas de classe. 
Na mesma sequência, você conheceu os modelos 
comportamentais. Em detalhes, vimos como fun-
ciona a modelagem orientada a dados e a mode-
lagem dirigida a eventos. 
Passando para o tema seguinte, começamos a 
analisar alguns padrões de arquitetura de software. 
Iniciamos arquiteturas de aplicações, em que fala-

localização geográfica; desenvolvimento de 
aplicativos e dispositivos móveis. 
Infinita computação em rede — intero-
perabilidade dos serviços de site; compu-
tação em nuvem (SaaS ou software como 
serviço). 

& | Infinitas tecnologias de realidade virtual -
portais e navegadores 3D; avatares. 

Fonte: adaptado de LaFuente (2011). 

Exercício 
Escreva uma dissertação de 15 a 30 linhas discorren-
do sobre as transformações na Web. Considerando 
as possibilidades trazidas pela Web 3.0, analise os 
possíveis impactos sociais que ela pode causar em 
um futuro próximo. 

mos sobre as possibilidades de sua utilização. Como 
exemplo, discorremos sobre as aplicações de pro-
cessamento de transações e os sistemas de proces-
samento de linguagens. 
Sem deixar a bola cair, abordamos a arquitetura 
de sistemas confiáveis. Conhecemos os sistemas de 
proteção e a arquitetura de automonitoramento, e 
você aprendeu sobre a importância da diversidade 
de software. 
E, finalmente, conversamos sobre a arquitetura 
mestre-escravo para sistemas distribuídos. Em segui-
da, discutimos sobre a arquitetura cliente-servidor 
multicamadas, complementando um tópico ini-
ciado na unidade passada. E fechando mais esse 
bloco do nosso curso, você explorou arquitetura de 
componentes distribuídos e suas diferentes possi-
bilidades, como a sua utilização em um sistema de 
mineração de dados. 


UNIDADE 

Ze 

Projetando e implementando 
arquiteturas 

a Objetivos de aprendizagem 

B Conhecer os processos de projeto. 
& Aprender a utilizar diferentes tipos de modelos de projeto. 
B Dominar os conceitos gerais da implementação. 

& 1-Plataforma de software 
Abrindo a unidade, você vai conhecer os processos de projeto, indo 
do básico ao complexo neste tema essencial ao desenvolvimento de 
softwares. 

B 2-Modelos de projeto 
Dando sequência a nossa linha de raciocínio, aqui vamos estudar os 
diferentes modelos de projeto, conhecendo as características e utili-
dades de cada um. 

& 3-Implementação: questões de implementação 
Encerrando esta unidade, vamos discutir finalmente a implementa-
ção. Faremos uma interessante discussão sobre conceitos que orien-
tam a forma como os softwares são desenvolvidos hoje. 

Introdução N 

Nesta unidade, vamos nos dedicar a ensinar a você como projetar e im-
plementar arquiteturas. A implementação é uma novidade nessa con-
versa, não é mesmo? Basicamente, podemos dizer que ela é o estágio 
do desenvolvimento de um software em que convertemos especifica-
ções em um sistema real e executável. Já falamos um pouco sobre pro-
jetos nas unidades anteriores, e agora daremos uma ênfase maior a esse 
aspecto, avançando mais sobre os detalhes. Você já sabe que um 


70) (irquitetura de software 
projeto de software é uma descrição da sua estrutura, dos mode-

los e das interfaces entre os componentes do sistema, e eventual-

mente podejá conter os algoritmos. 

Projetar um sistema, diferentemente do que o termo possa dar a 

entender, não é uma etapa que começa e termina antes de sua im-

plementação. O projeto é uma atividade dinâmica, que é aprimora-

da durante todo o processo de desenvolvimento do software, e 

acompanha a sua evolução. Em sua constante revisão, são acrescen-

tados detalhes e formalidades. 
O projeto não é simplesmente um guia para mostrar o que deve ser 

feito, mas é também uma espécie de diário de bordo onde são relata-

dos os erros e acertos, dúvidas e novas necessidades percebidas. Na 

prática, ele pode ser pensado como uma espécie de mapa que per-

mite que os projetistas saibam onde eles se encontram, como chega-

ram até ali, e ajuda a manter o foco no objetivo a ser alcançado. 

A 

Plataforma de software 

Tenha sempre em mente que os softwares sempre vão interagir 
entre si. Essas conexões envolvem o sistema operacional, bancos 
de dados, o middleware e, é claro, outros softwares de aplicação — 
que deverão ser executados ao mesmo tempo, ou poderão ser exe-
cutados simultaneamente pelo usuário. O ambiente formado por es-
ses elementos, e onde se dará a execução do aplicativo que estamos 
desenvolvendo, é o que chamamos de plataforma de sofiware. 

Na Figura 3.1 você pode observar um modelo no qual estão 

dispostas de maneira abstrata as entradas do processo do projeto, 

as atividades elaboradas e os documentos que são gerados durante 

o seu desenvolvimento. Pode parecer que se trata de uma sequên-
cia linear de atividades, mas como estamos procurando deixar cla-
ro para você, cada uma dessas atividades envolvem feedbacks, de 
modo que essas atividades na prática se intercalam. 
Link 
Para ler um artigo esclarecedor sobre plataforma de software, acesse o 
link a seguir: <info.abril.com.br/noticias/rede/eu-virtual/2012/03/03/plata 
forma-de-software-os-fundamentos>. 


Projetando e implementando arquiteturas) (7 

(TT Figura 3.1 Modelo geral do processo de projeto. 

N 

Entradas de projeto 
Informação Especificação Descrição 
de plataforma de requisitos de dados 

| Atividades de projeto 

Projeto de Projeto de Projeto de 
arquitetura Interface componentes 

Projeto de banco de dados 

| Saídas de projeto 

Arquitetura Especificação de Especificação Especificação 
de sistema banco de dados de interface de componentes 

q Fonte: Sommeruville (2011, p. 26). 

É fundamental que tenhamos muitas informações sobre a plata-
forma, já que é considerando a interação com ela que o projeto será 
desenvolvido. Imagine que o aplicativo que estamos criando opere 
com um banco de dados, certo? Se o banco de dados utilizado já per-
tencer ao sistema, então ele deverá ser incluído na especificação da 
plataforma. Mas caso seja específico do nosso software, e deva tam-
bém ser projetado, então ele deverá constar na especificação de requi-
sitos, para que desse modo a sua organização seja também definida. 

Existem muitos caminhos diferentes que podem ser seguidos 
no desenvolvimento do projeto, considerando as múltiplas possi-
bilidades de sistemas que podem ser criados. Ainda observando 
a Figura 3.1, podemos pensar em quatro atividades que podem 
integrar o processo de projeto de sistemas de informação: 

1. Projeto de arquitetura, no qual você pode identificar a estru-
tura geral do sistema, os componentes principais (algumas 
vezes chamados subsistemas ou módulos), seus relaciona-
mentos e como eles são distribuídos. 
2. Projeto de interface, no qual você define as interfaces entre 
os componentes do sistema. Essa especificação de interface 

72) ( arquitetura de software 
deve ser inequívoca. Com uma interface precisa, um compo-
nente pode ser usado de maneira que outros componentes 
não precisam saber como ele é implementado. Uma vez que 
as especificações de interface são acordadas, os componen-
tes podem ser projetados e desenvolvidos simultaneamente. 

3. Projeto de componente, no qual você toma cada componen-
te do sistema e projeta seu funcionamento. Pode-se tratar 
de uma simples declaração da funcionalidade que se espera 
implementar, com o projeto específico para cada programa-
dor. Pode, também, ser uma lista de alterações a serem fei-
tas em um componente reusável ou um modelo de projeto 
detalhado. O modelo de projeto pode ser usado para gerar 
automaticamente uma implementação. 
4. Projeto de banco de dados, no qual você projeta as estruturas 
de dados do sistema e como eles devem ser representados 
em um banco de dados. Novamente, o trabalho aqui depen-
de da existência de um banco de dados a ser reusado ou da 
criação de um novo banco de dados (SOMMERVILLE, 2011, 
p. 25-26). 
Cada uma dessas atividades possíveis leva a um conjunto de 
saídas do projeto. Contudo, observe bem que a maneira de apre-
sentação pode oscilar muito por causa desse leque de variáveis. 
Sistemas críticos, por exemplo, exigirão documentos que deta-
lhem minuciosamente o projeto. Por outro lado, se seguirmos por 
uma abordagem dirigida a modelos, diagramas podem tranquila-
mente compor a maior parte dessas saídas. 

Perceba que programar não é seguir um livro de receitas. Exis-
tem meios que foram criados e implementados com sucesso para 
determinadas situações, mas não são dogmas. Programação é 
prática fortemente baseada em experimentação, tentativa e erro. 
Existem diferentes caminhos para se chegar aos mesmos lugares, 
e essa escolha é um tanto pessoal. Por exemplo, há programadores 
que preferem começar pelos componentes que eles já conhecem, 
constroem uma base, e depois partem para os componentes com 
que eles têm menos afinidade. Por outro lado, tem programado-
res que preferem fazer exatamente o contrário: começar pelo que 
conhecem menos, deixando para depois as partes que sabem que 
terão menos trabalho. 



Projetando e implementando arquiteturas) (73 

O importante neste curso é que você tenha uma visão geral que 
lhe permita saber quais as possibilidades, de acordo com o caso 
que você tiver diante de si. E também para poder ter consciência 
das escolhas em relação aos caminhos que você optará por seguir. 

Testes de defeitos e debugging 

Se a programação é uma atividade que envolve bastante ex-
perimentação, é evidente que os testes são uma parte essencial 
desse processo. A área que exige mais testes, sem dúvida, são os 
códigos. Considerando a sua complexidade, é interessante que 
sejam feitos testes em seus trechos menores, já que seria ainda 
muito mais complicado querer encontrar erros quando todas elas 
estiverem unidas. 

Existem dois tipos de testes diferentes, que normalmente 
acabam sendo confundidos por iniciantes. Testes de defeitos e o 
debugging são procedimentos que detectam erros de código que 
impedem o seu funcionamento adequado. A diferença entre eles é 
que, enquanto os testes de defeitos procuram pela existência deles, 

o debugging procura pela sua localização e efetua a correção. 
Durante o debugging é preciso simular hipóteses sobre o com-
portamento do programa, procurando nelas o fator que levou à 
geração de uma saída anormal. O teste das hipóteses pode ser feito 
rastreando manualmente o código, assim como recorrendo a fer-
ramentas interativas de depuração. Estas, por sua vez, trabalham 
mostrando os valores intermediários das variáveis do programa, 
e uma lista para que você confira quais instruções estão sendo 
executadas. 

Modelos de contexto e modelos de interação 

Relembrando o que já dissemos algumas vezes até aqui, o pri-
meiro estágio para desenvolver um software é entender as possí-
veis relações que podem ser estabelecidas entre ele e o ambiente 
em que ele será inserido, certo? Assim, podemos oferecer as fun-
cionalidades necessárias, e estruturá-lo para se comunicar corre-
tamente com o seu ambiente externo. Nesse sentido, conhecer o 
contexto possibilita o estabelecimento de limites para a aplicação, 
e estes, por sua vez, nos dão a noção de quais recursos poderão ser 
utilizados do ambiente e quais deverão ser implementados. 



74|| Arquitetura de software 

Vamos pensar, como exemplo, no caso de um sistema de con-
trole para estações meteorológicas e um aplicativo embutido na 
própria estação meteorológica. Aqui temos dois modelos possí-
veis, o modelo de contexto e o modelo de interação. Segundo 
Sommerville (2011), podemos distingui-los da seguinte forma: 

Um modelo de contexto do sistema é um modelo estrutural, 
que demonstra os outros sistemas no ambiente do sistema a 
ser desenvolvido. 
Um modelo de interação é um modelo dinâmico que mostra 
como o sistema interage com seu ambiente quando ativo 

Veja que podemos representar o modelo de contexto por 
meio de associações que demonstrem relacionamentos entre as 
entidades envolvidas ali. Aqui especificamos a natureza dos re-
lacionamentos e, desse modo, o ambiente do sistema pode ser 
documentado utilizando um diagrama de blocos simples que 
mostre as entidades do sistema e suas respectivas associações. 
É isso que você pode conferir na Figura 3.2. Observe-a aten-
tamente, e perceba que ela representa os sistemas no ambiente 
individual das estações meteorológicas, sendo um sistema de in-
formações meteorológicas, um sistema de satélites a bordo e um 
sistema de controle. Sobre o link constam informações de car-
dinalidade que revelam a existência de um sistema de controle 
com múltiplas estações meteorológicas, um sistema de informa-
ções climáticas gerais e um satélite. 

di Figura 3.2 Sistema de contexto para a estação de controle DN 
meteorológico. 

1 Sistema 
A de controle A, 

Sistema de 

Estação

informações 

meteorológica

meteorológicas 

NS sd 1n 

1 Satélite É 

q Fonte. Sommerville (2011, p 126) ) 


Projetando e implementando arquiteturas) (75 

Agora analise atentamente a Figura 3.3. É recomendável que 
você recorra a uma abordagem abstrata sem muitos detalhes quan-
do for modelar interações de um sistema com o seu ambiente. Um 
Jeito interessante de fazer isso é por meio dos modelos de caso 
de uso, que você conheceu na Unidade 2. Nele, elipses nomeiam 
cada uma das possíveis interações, e os bonequinhos palito repre-
sentam entidades externas envolvidas nas interações. Vemos nesse 
diagrama que a estação meteorológica interage com o sistema de 
informações meteorológicas, anunciando o status do hardware da 
estação e os dados meteorológicos. 

(T Figura 3.3 Modelo de caso de uso para a estação meteorológica. 2 
Relatar 
z clima 

Relatar 
Sistema de status 
informações 
meteorológicas 

Reiniciar 

Desligar 

z Reconfigurar 

Sistema de 
controle Economizar 
energia 

Controlar 
remoto 

q Fonte: Sommerville (2011, p. 127) » 

Modelo de arquitetura de alto nível 

Agora que estão relativamente claros os limites entre o sistema 
de software e o ambiente do sistema, partimos desse ponto para 
projetar especificamente a arquitetura da aplicação. Trazendo toda 
nossa bagagem de conhecimentos, identificamos os componentes, 
os requisitos, as interações e passamos a organizá-los por um pa-
drão de arquitetura que, a partir desses elementos, possa ser con-
siderado o mais indicado para o nosso software. 



76) ( irquiterura de software 
A 

Vejamos um modelo de arquitetura de alto nível, ainda utili-
zando o exemplo do software para a estação meteorológica. Nele, 
temos subsistemas independentes que trocam mensagens por 
meio de uma infraestrutura comum, que você pode acompanhar 
na Figura 3.4 como “Link de comunicação”. Os subsistemas indi-
vidualmente recebem as mensagens sobre a infraestrutura, toman-
do aquelas que são destinadas a si próprios. 

Figura 3.4 Arquitetura de alto nível da estação meteorológica. N 

«Subsistema» «Subsistema» «Subsistema» 
Gerenciador Gerenciador Gerenciador 
de defeitos de configuração de energia 

Link de comunicação 

«Subsistema» «Subsistema» «Subsistema» 
Comunicações Coleta de dados Instrumentos 
Fonte: Sommerville (2011, p. 128). ) 

Imagine que o subsistema de comunicações receba um coman-
do de controle, ordenando que ele desligue. Esse comando seria 
recebido por todos os outros subsistemas, que se desligariam cor-
retamente. Podemos dizer que um dos maiores diferenciais dessa 
arquitetura é que ela suporta diferentes configurações de sistemas, 
Já que não é preciso que a mensagem seja encaminhada a um sub-
sistema específico. 

Na Figura 3.5 você pode conferir a arquitetura do subsistema 
de coleta de dados, incluída na Figura 3.4. Analisando-a, pode-
mos perceber que os objetos “Transmissor” e “Receptor” estão se 
ocupando do gerenciamento das comunicações, e o objeto “Dados 
Meteorológicos”, por sua vez, faz o encapsulamento das informa-
ções que são coletadas por meio dos instrumentos, e enviadas ao 
sistema de informações meteorológicas. Essa organização segue o 
modelo chamado de produtor-consumidor. 



Projetando e implementando arquiteturas) (77 

7 Figura 3.5 Arquitetura do sistema de coleta de dados. DN 

Coleta de dados 

Transmissor Receptor 

/ 

DadosMeteo-
rológicos 

q Fonte: Sommerville (2011, p. 128). ) 

Identificação dos objetos de classe 

Nas primeiras etapas do desenvolvimento, temos uma ideia 
geral dos objetos que serão essenciais para o funcionamento do 
sistema. Conforme o projeto avança, a nossa perspectiva sobre 
os objetos se refina, tornando-se mais clara e objetiva. Para que 
fique mais fácil identificarmos objetos e operações no sistema é 
interessante utilizarmos a descrição de caso de uso. 

Observe atentamente o Quadro 3.1 para entender a descrição 
do caso de uso “Relatar Clima”. 

7 Quadro 3.1 Descrição do caso de uso "Relatar clima”, N 

Caso de uso: Relatar clima. 

Atores: Sistema de informações meteorológicas, estação meteorológica. 

Dados: A estação meteorológica envia um resumo dos dados meteorológicos coletados a partir dos 
instrumentos, no período de coleta, para o sistema de informações meteorológicas. Os dados enviados 
são o máximo, mínimo e médio das temperaturas de solo e de ar; a máxima, mínima e média da pressão 
do ar; as velocidades máxima, mínima e média do vento; a precipitação de chuva total e a direção do 
vento, amostrados a cada cinco minutos. 

Estímulo: O sistema de informações meteorológicas estabelece um link de comunicação via satélite com a 
estação e solicita a transmissão dos dados. 

Resposta: Os dados resumidos são enviados para o sistema de informações meteorológicas. 

Comentários: Geralmente, solicita-se que as estações meteorológicas enviem relatórios a cada hora, mas 
essa frequência pode diferir de uma estação para a outra e pode ser modificada no futuro. 

(one Sommerville (2011, p. 127). ) 


78) ( trquitetura de software 
Seguindo com o exemplo do sistema de estação meteoro-
lógica, pense na descrição do caso de uso “Relatar clima” (ou 
seja, um caso que seria requisitado ao sistema que ele relate as 
condições do clima, processando as informações recebidas por 
receptores). É evidente que alguns objetos são imprescindíveis, 
como os instrumentos que farão a captação dos dados do clima, 
do mesmo modo que objetos que vão processar e gerar saídas 
resumidas desses dados. Seguindo a linha de raciocínio, também 
podemos precisar de um objeto de sistema de alto nível ou obje-
tos que sintetizem as interações do sistema estabelecidas nos ca-
sos de uso. Assim que temos um panorama geral desses objetos, 
podemos então seguir para a identificação de classes de objeto 
presentes no sistema. 

Existem várias abordagens possíveis para essa etapa de identi-
ficação de classes de objetos em sistemas orientados para objetos. 
Sommerville (2011, p. 128) as resume da seguinte forma: 

1. Usar uma análise gramatical de uma descrição em lingua-
gem natural do sistema a ser construído. Objetos e atri-
butos são substantivos, operações ou serviços são verbos 
(ABBOT, 1983). 
2. Usar entidades tangíveis (coisas) no domínio de aplicação, 
como aviões; papéis, como gerente ou médico; eventos, co-
mo pedidos; interações, como reuniões; locais, como escri-
tórios; unidades organizacionais, como empresas, e assim 
por diante (COAD; YOURDON, 1990; SHLAER; MELLOR, 1988; 
WIRFS-BROCK et al., 1990). 
3. Usar uma análise baseada em cenários, na qual diversos 
cenários de uso do sistema são identificados e analisados 
separadamente. À medida que cada cenário é analisado, a 
equipe responsável pela análise deve identificar os objetos 
necessários, atributos e operações (BECK; CUNNIGHAM, 
1989). 
Não existe um único caminho a ser seguido para identificarmos 
as classes de objetos, e é necessário recorrermos a diferentes fon-
tes de conhecimento para isso. No nosso exemplo, que você pode 
conferir na Figura 3.6, baseamos a identificação dos objetos no 
hardware tangível do sistema. É claro que não colocamos 100% 
dos objetos, o importante aqui é fornecer detalhes suficientes para 



Projetando e implementando arquiteturas) 79 

que você entenda o tópico, então decidimos colocar cinco classes 
de objetos. 

A Figura 3.6 Objetos da estação meteorológica DN 
EstaçãoMeteorológica DadosMeteorológicos 
Identificador temperaturaAr 
temperaturaChão 

relatarClima () 

velocidadeVento

relatarStatus () 

direçãoVento 

economizarEnergia (instrumentos) 

pressão 

controlarRemoto (comandos) 

precipitaçãoChuva 

reconfigurar (comandos) 
reiniciar (instrumentos) coletar () 
desligar (instrumentos) resumir () 

Termô o A ô o Barômetro 
de chão 

an Ident bar Ident 
get Ident velocidadeVento pressão 
temperatura direçãoVento altura 

obter () obter () obter () 
testar () testar () testar () 

o Fonte: Sommerville (2011,p. 129). P, 
Perceba que os objetos “Termômetro de chão”, “Anemômetro” 
e “Barômetro” são de domínio de aplicação, enquanto os objetos 
“EstaçãoMeteorológica” e “DadosMeteorológicos” estão sendo 
identificados pela descrição do cenário — ou seja, descrição de caso 
de uso — e pela descrição do sistema. Sommerville (2011), de quem 
tomamos emprestado o exemplo do sistema, descreve as classes de 
objetos presentes nele do seguinte modo: 

1. Aclasse de objeto EstaçãoMeteorológica fornece a interface 
básica da estação meteorológica com seu ambiente. Suas 
operações refletem as interações mostradas no Quadro 3.1. 
Nesse caso, usa-se uma classe única de objeto para encap-
sular todas essas interações, mas em outros projetos você 
poderia projetar a interface do sistema como várias classes 
diferentes. 
2. A classe de objeto DadosMeteorológicos é responsável por 
processar o comando "Relatar clima”. Este envia os dados re-
sumidos dos instrumentos da estação meteorológica para o 
sistema de informações meteorológicas. 

80) ( arquitetura de software 
3. As classes de objeto Termômetro de chão, Anemômetro e 
Barômetro estão diretamente relacionadas com os instru-
mentos do sistema. Estes refletem as entidades tangíveis 
de hardware no sistema, e as operações estão interessadas 
em controlar o hardware. Esses objetos funcionam de forma 
autônoma para coletar dados na frequência especificada e 
armazenam os dados coletados localmente. Quando requi-
sitados, esses dados são entregues ao objeto DadosMeteo-
rológicos (SOMMERVILLE, 2011, p. 129). 
Preste muita atenção que, nesta etapa, você deve manter o foco 
nos objetos. Deixe para depois a preocupação com a sua imple-
mentação. Assim que os objetos estiverem identificados, devemos 
refinar o projeto do objeto. Para isso, analise as características co-
muns e, partir daí, projete uma hierarquia de herança para o sis-
tema. Deixando claro, pense que é possível que você identifique 
uma superclasse “instrumento”, definindo as características gerais 
de todos eles, especificando também um identificador, obtendo 
operações e fazendo testes. Essa superclasse ainda poderá ser uti-
lizada para acrescentar novos atributos, por exemplo, para manter 
a regularidade da obtenção de dados. 

Modelos de projeto 

Modelos de projeto ou modelos de sistema 

Os modelos de projeto ou de sistema são aqueles que apresen-
tam classes de objetos dentro deles, assim como as associações e 
os relacionamentos entre essas entidades do sistema. Eles são im-
portantes por fazerem o meio campo entre os requisitos do sistema 
e a sua efetiva implementação. 

Veja que é necessário que os modelos de projeto sejam abs-
tratos para que desse modo os detalhes não acabem roubando a 
atenção dos relacionamentos e os requisitos do sistema. Contudo, 
é claro que eles devem conter detalhes na medida em que auxiliem 
os desenvolvedores a tomar decisões de implementação. 

Uma forma de alcançar um equilíbrio saudável entre a quan-
tidade de detalhes que serão expostos ou ocultados é desenvol-
vendo modelos em diferentes níveis de detalhe. Se todos os 
envolvidos no desenvolvimento do projeto estão trabalhando 



Projetando e implementando arquiteturas) (a1 

com bastante proximidade, os detalhes podem ser discutidos e 
resolvidos de modo mais informal. Mas se o desenvolvimento 
é feito por meio de uma separação maior entre equipes, então 
alguns detalhes a mais serão necessários para que haja melhor 
comunicação entre elas. 

O tipo de sistema que estamos desenvolvendo é um fator cru-
cial para determinar qual tipo de modelos será adotado e quais 
os níveis de detalhamento. A UML oferece 13 tipos de modelos 
diferentes, mas é claro que dificilmente precisaremos disso tudo. 
Quanto menor o número de modelos, menores serão os custos e 

o tempo gasto no projeto. Ao usarmos a UML, geralmente desen-
volvemos dois tipos de projeto: 
1. Modelos estruturais, os quais descrevem a estrutura está-
tica do sistema, usando as classes de objetos e seus rela-
cionamentos. Relacionamentos importantes que podem 
ser documentados nesse estágio são os de generalização 
(herança), usa/usado por, e composição. 
2. Modelos dinâmicos, os quais descrevem a estrutura dinâmi-
ca do sistema e mostram as interações entre os objetos do 
sistema. Interações que podem ser documentadas incluem 
a sequência de solicitações de serviço feitas pelos objetos e 
as mudanças de estado que são disparadas por essas intera-
ções de objetos (SOMMERVILLE, 2011, p. 130). 
Sommerville acrescenta que existem, em especial, três mode-
los de projetos muito úteis nas primeiras etapas do processo do 
projeto para que você acrescente detalhes aos modelos de caso 
de uso: 

1. Modelos de subsistema, que mostram agrupamentos lógi-
cos de objetos em subsistemas coerentes. Estes são repre-
sentados por uma forma de diagrama de classe com cada 
subsistema exibido como um pacote de objetos. Modelos 
de subsistemas são modelos estáticos (estruturais). 
2. Modelos de sequência, que mostram a sequência de inte-
rações de objetos. Estes são representados por um diagra-
ma de sequência ou de colaboração da UML. Modelos de 
sequência são dinâmicos. 
3. Modelos de máquina de estado, que mostram como obje-
tos individuais mudam de estado em resposta aos eventos. 

82) ( irquitetura de software 
Fique atento 

Cuidado ao fazer 
modelagens demais. 
Devemos deixar 
aos programadores 
as decisões 
pormenorizadas sobre a 
implementação. 

Estes são representados na UML por diagramas de estado. 
Modelos de máquina de estados são modelos dinâmicos 
(SOMMERVILLE, 2011, p. 130). 

Os modelos de subsistema são muito importantes como mode-
los estáticos, expondo as relações lógicas entre grupos de objetos. 
E note que, da mesma maneira, também podemos projetar mode-
los de objetos detalhados, expondo assim as associações entre to-
dos os objetos presentes no sistema. 

Por sua vez, os modelos de sequência são dinâmicos, usados 
para descrever cada modo de interação, assim como a sequência 
em que elas podem ou devem ocorrer. Na documentação do proje-
to é preciso que para cada interação importante seja produzido um 
modelo de sequência, tudo bem? 

Na Figura 3.7, você pode acompanhar o exemplo de um mode-
lo de sequência. Ela utiliza um diagrama de sequência UML. Nele 
podemos ver a sequência de interações que acontecem assim que 
um sistema externo manda uma requisição de dados resumidos da 
estação meteorológica. 

A sequência de interações representadas no exemplo da Figura 

3.7 está descrita em seis etapas, a seguir: 
1. O objeto ComunicSat recebe uma solicitação do sistema de 
informações meteorológicas para coletar um relatório de cli-
ma de uma estação meteorológica. Ele acusa o recebimento 
da solicitação. A seta na mensagem enviada indica que o sis-
tema externo não espera uma resposta, mas pode continuar 
com outro processamento. 
2. O ComunicSat envia uma mensagem para EstaçãoMeteoro-
lógica por meio de um link de satélite para criar um resumo 
dos dados meteorológicos coletados. Novamente, a seta in-
dica que o ComunicSat não fica em suspenso esperando por 
uma resposta. 
3. EstaçãoMeteorológica envia uma mensagem a um objeto 
LinkComunic para resumir os dados meteorológicos. Nes-
se caso, o estilo quadrado da seta indica que a instância 
da classe de objeto EstaçãoMeteorológica aguarda uma 
resposta. 
4. LinkComunic chama o método resumir no objeto DadosMe-
teorológicos e aguarda uma resposta. 

82) ( irquitetura de software 
Fique atento 

Cuidado ao fazer 
modelagens demais. 
Devemos deixar 
aos programadores 
as decisões 
pormenorizadas sobre a 
implementação. 

Estes são representados na UML por diagramas de estado. 
Modelos de máquina de estados são modelos dinâmicos 
(SOMMERVILLE, 2011, p. 130). 

Os modelos de subsistema são muito importantes como mode-
los estáticos, expondo as relações lógicas entre grupos de objetos. 
E note que, da mesma maneira, também podemos projetar mode-
los de objetos detalhados, expondo assim as associações entre to-
dos os objetos presentes no sistema. 

Por sua vez, os modelos de sequência são dinâmicos, usados 
para descrever cada modo de interação, assim como a sequência 
em que elas podem ou devem ocorrer. Na documentação do proje-
to é preciso que para cada interação importante seja produzido um 
modelo de sequência, tudo bem? 

Na Figura 3.7, você pode acompanhar o exemplo de um mode-
lo de sequência. Ela utiliza um diagrama de sequência UML. Nele 
podemos ver a sequência de interações que acontecem assim que 
um sistema externo manda uma requisição de dados resumidos da 
estação meteorológica. 

A sequência de interações representadas no exemplo da Figura 

3.7 está descrita em seis etapas, a seguir: 
1. O objeto ComunicSat recebe uma solicitação do sistema de 
informações meteorológicas para coletar um relatório de cli-
ma de uma estação meteorológica. Ele acusa o recebimento 
da solicitação. A seta na mensagem enviada indica que o sis-
tema externo não espera uma resposta, mas pode continuar 
com outro processamento. 
2. O ComunicSat envia uma mensagem para EstaçãoMeteoro-
lógica por meio de um link de satélite para criar um resumo 
dos dados meteorológicos coletados. Novamente, a seta in-
dica que o ComunicSat não fica em suspenso esperando por 
uma resposta. 
3. EstaçãoMeteorológica envia uma mensagem a um objeto 
LinkComunic para resumir os dados meteorológicos. Nes-
se caso, o estilo quadrado da seta indica que a instância 
da classe de objeto EstaçãoMeteorológica aguarda uma 
resposta. 
4. LinkComunic chama o método resumir no objeto DadosMe-
teorológicos e aguarda uma resposta. 

84) (trauretura de software 
reconfigura. O diagrama de estado mostra que a reconfigura-
ção só é permitida se o sistema esteve desligado. 

2. No estado Executando, o sistema espera futuras mensagens. 
Se uma mensagem desligar ( ) é recebida, o objeto retorna 
para o estado Desligado. 
3. Se uma mensagem relatarClima ( ) é recebida, o sistema se 
move para o estado Resumindo. Quando o resumo estiver 
concluído, o sistema passa para um estado Transmitindo, no 
qual as informações são transmitidas para o sistema remoto. 
Em seguida, retorna ao estado Executando. 
4. Se uma mensagem relatarStatus ( ) é recebida, o sistema se 
move para o estado Testando, depois para o estado Transmi-
tindo, antes de retornar ao estado Executando. 
5. Se um sinal do relógio é recebido, o sistema passa ao estado 
Coletando, em que coleta os dados dos instrumentos. Cada 
instrumento, por sua vez, é instruído para coletar os dados 
dos sensores associados. 
6. Se uma mensagem controlarRemoto ( ) é recebida, o sistema 
se move para um estado Controlado, em que ele responde 
a um conjunto de diferentes mensagens da sala de controle 
remoto. Estas não são mostradas nesse diagrama. 
Veja que podemos implementar os objetos ComunicSat e Esta-
çãoMeteorológica como processos concorrentes, podendo suspen-
der e reiniciar as suas execuções. ComunicSat ouve as mensagens 
recebidas do sistema externo, decodifica-as, e dá início às opera-
ções da estação. 

É uma opção inteligente recorrer aos diagramas de sequência 
para modelar o comportamento coletivo de um grupo de objetos. 
Mas não se esqueça de que também é possível resumir o com-
portamento de um objeto ou de um subsistema em resposta aos 
eventos e às mensagens. É possível fazer isso por meio de um 
modelo de máquina de estado que mostre as alterações de estado 
da instância do objeto de acordo com as mensagens recebidas. 

Especificações de interface 

Agora vamos conversar um pouco sobre as especificações de 
interface. Já mencionamos algumas vezes esse aspecto e a partir 
daqui vamos discuti-lo com um pouco mais de detalhes. É funda-
mental no processo de projeto que especifiquemos as interfaces 



Projetando e implementando arquiteturas) (ss 

entre os componentes do sistema, de modo que os objetos e os 
subsistemas possam ser projetados paralelamente. 

Aqui estamos falando da preocupação com as definições da 
interface para um objeto ou um grupo deles. Na prática, estamos 
falando sobre definir as assinaturas e a semântica dos serviços que 
os objetos ou grupos fornecerão. 

Para definirmos as interfaces utilizando UML, podemos recor-
rer a um diagrama de classe. Porém, lembre-se que não há a seção 
de atributos, e devemos incluir na parte do nome o estereótipo 
UML <<interface>>. A definição da semântica da interface, por 
sua vez, pode ser feita pela OCL, a Linguagem de Restrição de 
Objetos (Object Constraint Language). 

Veja que no projeto de interface não devemos incluir detalhes 
sobre a representação de dados. Isso se dá pelo fato de que não 
definimos os atributos na especificação da interface, tudo bem? 
Contudo, as operações de acesso e atualização de dados não po-
dem ficar de fora. Considerando que a representação de dados é 
oculta, então podemos alterá-la tranquilamente, sem interferir 
nos objetos que precisam desses dados. Isso, sem dúvida, faz 
com que a manutenção do projeto seja muito mais fácil. 

Como exemplo, pense na representação de uma pilha, via ve-
tor. Podemos alterá-la para uma representação em lista, sem con-
sequências para os outros objetos que a utilizam. Ao invés disso, 
comumente é mais lógico expormos os atributos usando um mo-
delo de projeto estático, já que este é o modo mais compacto de 
representarmos características essenciais dos objetos. 

Que fiquei bem claro para você que a relação entre objetos e 
interfaces não é tão simples e direta, 1:1. Um único objeto pode 
ter múltiplas interfaces, cada uma delas apresentando diferentes 
perspectivas sobre os métodos fornecidos por ele. Java suporta 
isso diretamente. Nele, a declaração das interfaces é feita de modo 
separado a partir dos objetos, e as interfaces são “implementadas” 
por eles. E é claro, o contrário também ocorre: uma única interfa-
ce pode acessar todo um grupo de objetos. 

Analise a Figura 3.8. Nela, podemos observar duas interfaces 
possíveis para o nosso exemplo da estação meteorológica. Do 
lado esquerdo, temos uma interface de relatório que trabalha com 
a definição dos nomes das operações, gerando relatórios (daí o seu 
nome) de clima e status. Estes atuam no mapeamento direto para 
as operações no objeto EstaçãoMeteorológica. Do lado direito, 



86) (irqurerur de software 
temos uma interface de controle remoto que, como você pode no-
tar, oferece quatro operações mapeando para apenas um método 
no objeto EstaçãoMeteorológica. Desse modo, devemos codificar 
as operações individuais no string de comando que está associado 
ao método controlarRemoto, que você viu na Figura 3.6. 

Figura 3.8 Interfaces da Estação Meteorológica. 

«Interface»

«Interface» 

Controle remoto

Relatório 

iniciarinstrumento (instrumento) IStatus 

relatarClima (EM — Ident). relatórioC 

pararinstrumento (instrumento) iStatus

relatarStatus (EM — Ident). relatórios 

coletarDados (instrumento) iStatus 
fornecerDados (instrumento) string 

Fonte: Sommerville (2011, p. 133). 

Padrões de projeto 

Até aqui já conversamos muito sobre padrões de arquitetura, 
então, para começo de conversa, é importante que você não se 
confunda entre eles e os padrões de projeto (design patterns), 
tudo bem? Basicamente, podemos dizer de início que um padrão 
de projeto é uma orientação que descreve um problema e a base de 
uma solução possível dele. Portanto, ele não é uma especificação 
minuciosa, e sim parâmetros gerais para que essas soluções pos-
sam ser reusadas em diversas situações distintas. 

Link 
Conheça o site The Hillside Group e seu acervo sobre padrões no link: <hillside. 
net>. 

Você pode pensar em um padrão de projeto como orienta-
ções que são herdadas a partir da experiência de outros desen-
volvedores. Como certos problemas são relativamente comuns, 
compartilhamos soluções que tradicionalmente são eficazes para 
eles. O site The Hillside Group, conhecido pelas informações 
que disponibiliza sobre padrões, coloca que “padrões e lingua-
gens de padrões são formas de descrever as melhores práticas, 



Projetando e implementando arquiteturas) (27 

bons projetos e capturar a experiência de uma forma que torne 
possível a outros reusar essa experiência” (SOMMERVILLE, 
2011, p. 133). 

Além de revolucionar os projetos de software orientados a ob-
Jetos, os padrões foram uma grande inovação também por trazer 
uma nova linguagem comum para que eles sejam discutidos. Hoje 
você pode perfeitamente falar sobre o seu projeto descrevendo os 
padrões aos quais você recorreu para moldá-lo. 

O grande responsável pela popularização dos padrões de pro-
jeto é um grupo conhecido como “A Gangue dos Quatro” (Gang 
of Four, ou simplesmente, GoF). Ele é composto pelos cientistas 
Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides, 
que se tornaram célebres pelo livro Design Patterns: Elements of 
Reusable Object-Oriented Software, publicado no ano de 1995. 
Neste livro, eles propuseram quatro elementos básicos de padrões 
de projeto: 

1. Um nome que seja uma referência significativa para o 
padrão. 
2. Uma descrição da área de problema que explique quando o 
modelo pode ser aplicado. 
3. A descrição da solução das partes da solução de projeto, 
seus relacionamentos e suas responsabilidades. Essa não 
é uma descrição do projeto concreto; é um modelo para 
uma solução de projeto que pode ser instanciado de di-
ferentes maneiras. Costuma ser expresso graficamente e 
mostra os relacionamentos entre os objetos e suas classes 
na solução. 
4. Uma declaração das consequências — os resultados e com-
promissos — da aplicação do padrão. Pode ajudar os proje-
tistas a entenderem quando um padrão pode ou não ser 
usado em uma situação particular (SOMMERVILLE, 2011, 
p. 133-134). 
Gamma et al. (1995 apud SOMMERVILLE, 2011) e outros 
pesquisadores que propuseram quebrar a descrição do problema 
em duas partes: motivação (o motivo pelo qual o padrão é útil) 
e aplicabilidade (circunstâncias em que ele pode ser aplicado). No 
que se refere a solução, ela é descrita por ele como a estrutura do 
padrão, participantes, colaboração e implementação. 



88) ( irquiterura de software 
Para ilustrar a descrição do padrão, usa-se o padrão Observer, 
extraído do livro de Gamma et al. (1995, apud SOMMERVILLE, 
2011), que é mostrado no Quadro 3.2. Nessa descrição, usam-se 
os quatro elementos descritivos essenciais e é incluída uma breve 
declaração do que o padrão pode fazer. Esse padrão pode ser usado 
em situações nas quais as diferentes apresentações do estado do ob-
jeto são requeridas. Ele separa o objeto que deve ser exibido a partir 
de diferentes formas de apresentação. Essa situação é ilustrada na 
Figura 3.9, que mostra duas representações gráficas do mesmo con-
junto de dados. As representações gráficas são normalmente usadas 
para ilustrar as classes de objeto em padrões e seus relacionamentos. 

ET Quadro 3.2 O padrão Observer. N 

Nome do Observer 

padrão 

Descrição Separa o display do estado de um objeto a partir do objeto em si e permite que 
sejam fornecidos displays alternativos. 
Quando o estado do objeto muda, todos os displays são automaticamente 
notificados e atualizados para refletir a mudança. 

Descrição do Em muitas situações, você precisa fornecer vários displays de informações do estado, 

problema como um display gráfico e em tabela. Nem todos eles podem ser conhecidos quando 
a informação é especificada. Todas as apresentações alternativas devem apoiar a 
interação e, quando o estado é alterado, todos os displays devem ser atualizados. 
Esse padrão pode ser usado em todas as situações em que mais de um formato de 
display de informações de estado é necessário, e quando nos formatos de display 
específicos usados não é necessário para o objeto que mantém as informações do 
estado. 

Descrição da Tratam-se de dois objetos abstratos, Subject e Observer, e dois objetos concretos, 

solução ConcreteSubject e ConcreteObject, que herdam os atributos dos objetos abstratos 
relacionados. Os objetos abstratos incluem as operações gerais aplicáveis em todas 
as situações. O estado a ser exibido é mantido no ConcreteSubject, que herda as 
operações de Subject permitindo adicionar ou remover Observers (cada Observer 
corresponde a um display) e emitir uma notificação quando o estado mudar. 
O ConcreteObserver mantém uma cópia do estado do ConcreteSubject e 
implementa a interface atualizar () do Observer, que permite que essas cópias 
sejam mantidas nessa etapa. Automaticamente, o ConcreteObserver exibe o estado 
e reflete as mudanças sempre que o estado é atualizado. O modelo UML do padrão 
é mostrado na Figura 7.10. 

Consequências O Subject só conhece o Observer abstrato e não sabe detalhes da classe concreta. 
Portanto, há um acoplamento mínimo entre esses objetos. Devido a essa falta 
de conhecimento, as otimizações que melhoram o desempenho do display são 
impraticáveis. As alterações no Subject podem causar uma série de atualizações 
ligadas aos Observers relacionados para serem geradas, algumas das quais podem 
não ser necessárias. 

Fonte: Sommerville (2011, p. 134). ) 


Projetando e implementando arquiteturas) (29 

£— Figura 3.9 Múltiplos displays. N 

Ea 

| Subject | 

A: 40 
Observer! <—S B.25 —. Observer 2 

Gs 
D: 20 

Fonte. Sommerville (2011, p. 135) ) 

A Figura 3.10 Observerem UML. N 

Subject O Observer 

Anexar (Observer) Atualizar () 
Separar (Observer)

Notificar () ---4-+ Para todos em observers 
o -> Atualizar () 

ConcreteSubject ConcreteObserver 

: estadoObserver = 
obterEstado () -— — — — Retornar estadoSubject Atualizar () -— ==)=: subject -> obterEstado () 

estadoSubject estadoObserver 

onte: Sommerville (2011,p 135). ) 

Na Figura 3.10 você pode acompanhar a representação em 
UML do padrão Observer. Pense que você pode utilizar padrão 
em seu projeto, desde que reconheça que quaisquer eventuais pro-
blemas podem ter um padrão associado que poderia ser aplicado. 
O livro original da “Gangue dos Quatro” traz uma lista de exem-
plos de problemas que podem surgir. Sommerville (2011, p. 135) 
menciona quatro: 

1. Dizer a vários objetos que o estado de algum outro objeto 
mudou (padrão Observer. 
2. Arrumar as interfaces para vários objetos relacionados que, 
muitas vezes, foram desenvolvidos de forma incremental 
(padrão Façade). 
3. Fornecer uma forma padronizada de acesso aos elementos 
de uma coleção, independentemente de como essa coleção 
é implementada (padrão Iteraton. 

90) (irquiterura de software 
4. Permitir a possibilidade de estender a funcionalidade de 
uma classe existente em run-time (padrão Decorator). 
Outro aspecto muito importante é que os padrões são capazes 
de suportar reúso de conceito em alto nível. Se você for tentar reu-
sar alguns componentes executáveis, não haverá como deixar de se 
confrontar com certos limites que se originam das decisões dos seus 
implementadores. Estamos falando aqui de coisas que vão desde 
algoritmos específicos até objetos e os tipos na interface de com-
ponentes, ficou claro? Desse modo, se houver conflitos entre essas 
decisões de projeto e os seus requisitos específicos, então você terá 
problemas, como ineficiência ou mesmo de não funcionamento. 

Sabemos que é difícil ter certeza de antemão (quando esta-
mos nas fases iniciais do projeto) sobre quais padrões poderão 
ser necessários. Então, não se preocupe e tenha paciência, porque 
é comum que a necessidade de padrões, e as consequentes rea-
dequações, possam e vão surgir no meio do caminho, em meio 
a tentativas e erros. E isso porque estamos falando de problemas 
que podem demandar alguns dos 23 padrões gerais, que estão no 
livro da Gangue dos Quatro. A coisa vai complicar um pouquinho 
mais se surgir algo que estiver fora desse escopo. Por isso, o uso 
de padrões, assim como todo recurso de alta complexidade, exige 
experiência e estudo. 

Implementação: questões de 
implementação 

Agora chegamos ao momento crucial do desenvolvimento de 
softwares: a implementação. Depois de tudo que envolve a con-
cepção da aplicação, este é o momento em que criaremos uma 
versão executável do sistema. Essa etapa pode envolver progra-
mas com alto ou baixo nível de linguagens de programação, como 
também a personalização de sistemas genéricos já existentes, 
atendendo a requisitos específicos. 

A proposta deste texto é oferecer a você uma visão geral sobre 
a arquitetura de softwares, e por isso nos empenhamos para que, 
na medida do possível, não entremos em qualquer linguagem de 
programação específica. Quando falamos de implementação, é evi-
dente que cada linguagem tem suas especificidades. Porém, existem 
conceitos gerais que são aplicáveis, independentemente de qual de-
las estejamos utilizando, e é neles que focaremos neste tema. 



Projetando e implementando arquiteturas) (91 

Os conceitos que vamos discutir a partir de agora são: 

reúso; 

gerenciamento de configurações; 

desenvolvimento de host-target. 

Reúso 

Entre os anos 1960 até 1990, desenvolver softwares foi uma 
atividade que se baseou em construí-los a partir do zero. Escre-
viam-se códigos cada vez maiores, mais complexos e em lingua-
gens de alto nível. Podemos dizer que o único reúso realmente 
importante foi em bibliotecas de linguagem de programação, em 
suas funções e objetos. Porém, com a necessidade cada vez maior 
de softwares, o longo tempo gasto e os altos custos envolvidos 
tornaram pouco viável esse modelo em um contexto que demanda 
softwares cada vez mais baratos e produzidos o mais rápido pos-
sível — sobretudo quando falamos em sistemas baseados em Web. 

Seguindo uma mudança que ocorreu em quase todos os seto-
res da produção em um sistema capitalista, o desenvolvimento de 
softwares passou a se estruturar mais em termos de montagem e 
adaptação do que propriamente de criação. É claro que, conside-
rando a natureza da atividade, não se compara a mudança feita em 
atividades como carros, roupas e alimentos, em que a manufatura 
e a produção próxima ao artesanal deram lugar às linhas de mon-
tagem e produção padronizada em série. Mas se tornou cada vez 
mais presente a abordagem do desenvolvimento baseado no reúso 
de softwares, aproveitando e adaptando suas arquiteturas. 

Sommerville (2011) coloca que o reúso de softwares pode ser 
feito em quatro diferentes níveis: 

1. Onível de abstração. Nesse nível, você não reúsa o software 
diretamente, mas usa o conhecimento das abstrações de 
sucesso no projeto de seu software. Os padrões de projeto 
e de arquitetura são formas de representar o conhecimento 
abstrato para reúso. 
2. Onível de objeto. Nesse nível, você reúsa objetos diretamente 
de uma biblioteca em vez de escrever um código. Para imple-
mentar esse tipo de reúso, você tem de encontrar bibliotecas 
adequadas e descobrir se os objetos e métodos oferecem a 
funcionalidade de que precisa. Por exemplo, se precisa pro-
cessar mensagens de correio em um programa Java, você 
pode usar objetos e métodos de uma biblioteca JavaMail. 

92) ( prquiterura de software 
3. Onível de componentes. Componentes são coleções de obje-
tos e classes de objetos que funcionam em conjunto para for-
necer funções e serviços relacionados. Muitas vezes, você tem 
de se adaptar e ampliar o componente adicionando um códi-
go próprio. Um exemplo de reúso em nível de componente é 
aquele no qual você constrói sua interface de usuário usando 
um framework. Este é um conjunto de classes de objetos em 
geral que implementam manipulação de eventos, gerencia-
mento de displays etc. Você adiciona as conexões com os da-
dos a serem exibidos e escreve o código para definir detalhes 
específicos do display, como o layout da tela e as cores. 
O nível de sistema. Nesse nível, você reúsa os sistemas de apli-
cação inteiros, o que geralmente envolve algum tipo de confi-
guração desses sistemas. Essas configurações podem ser feitas 
por meio da adição e modificação do código (se você estiver 
reusando uma linha de produtos de software) ou pelo uso de 
interface de configuração do próprio sistema. A maioria dos 
sistemas comerciais é criada dessa forma, em que sistemas 
genéricos de COTS (commercial off-the-shelf) são adaptados 
e reusados. Às vezes, essa abordagem pode envolver o reú-
so e a integração de diversos sistemas para criar um novo 
(SOMMERVILLE, 2011, p. 136). 

As vantagens de reusar sistemas que já existem são evidentes 
em muitos aspectos: é mais rápido, mais barato e os riscos são 
menores. Considerando que ele, em sua forma básica, já está sen-
do testado em diferentes aplicações — que podemos chamar até de 
versões —, a tendência é que sejam bastante confiáveis, o que para 
softwares comerciais é uma característica primordial. 

No entanto, nem tudo são flores. É claro que o reúso também co-
loca alguns fatores do outro lado da balança, que devem ser consi-
derados seriamente antes da tomada da decisão. Sommerville (2011, 

p. 136-137) elenca quatro custos do reúso de softwares, como: 
1. Os custos de tempo gasto na procura do software para reúso 
e na avaliação sobre ele atender ou não às necessidades.
Tal-
vez você precise testar o software para ter certeza de que vai 
funcionar em seu ambiente, sobretudo se ele for diferente 
do ambiente de desenvolvimento. 

Quando se aplicam os custos de aquisição do software reu-
sável. Para grandes sistemas de prateleira, esses custos po-
dem ser muito elevados. 



Projetando e implementando arquiteturas) (o3 

3. Os custos de adaptação e configuração dos componentes 
de software reusável ou sistemas para refletir os requisitos 
do sistema que você está desenvolvendo. 
4. Os custos de integração de componentes de software reu-
sável (se você estiver usando software de diferentes fontes) 
com o novo código que você desenvolveu. A integração de 
softwares reusáveis de diferentes fornecedores pode ser difícil 
e cara, pois os fornecedores podem fazer suposições confli-
tantes sobre como seus respectivos softwares serão reusados. 
A primeira coisa que você deveria pensar ao começar algum 
projeto de desenvolvimento de um software é em como o conheci-
mento e o software existente podem ser reusados. Antes dos deta-
lhes, você deve considerar as possibilidades de reúso, como alguns 
elementos reusáveis, e só a partir daí fazer alterações. É claro que 
a criatividade e a inovação são sempre bem-vindas, mas o reúso é 
uma parte inseparável da engenharia de software atual e, portanto, 
é algo que você deverá inevitavelmente dominar. 

Gerenciamento de configuração 

Nessa altura do campeonato, não deve restar dúvida para você 
de que as mudanças são o fato mais concreto no desenvolvimento de 
um software. Ela é praticamente a nossa única certeza de que tudo 
vai mudar bastante no caminho entre o projeto e a versão final da 
aplicação. Tendo isso em mente, é fundamental que tenhamos um 
modo de gerenciar todas essas transformações. 

Considere também que, como o desenvolvimento de softwares, 
via de regra, é um trabalho coletivo, é importante estabelecermos 
meios para que o trabalho de alguns membros da equipe não atra-
palhe o dos outros. Não dá para, por exemplo, diferentes pessoas 
trabalharem com o mesmo componente, e cada um alterá-lo a sua 
maneira. Precisa haver coordenação entre as transformações. 

Como extensão lógica, também precisamos assegurar que todos 
os membros da equipe tenham acesso às versões mais atuais dos 
componentes e configurações. Caso contrário, é provável que per-
camos tempo e recursos refazendo algo que já estava pronto. Con-
tudo, se a versão atual apresenta problemas crônicos, é necessário 
também que possamos voltar para a versão anterior. 

Tudo isso que estamos falando aqui tem um nome: gerencia-
mento de configuração. Ele é o processo geral de organizar um 
sistema de software que está em constante transformação. O seu 



94) ( arquitetura de software 
objeto central é fazer que haja ordem e harmonia, integrando o de-
senvolvimento de modo que todos possam remar na mesma dire-
ção. Ou seja, é garantir que todos tenham acesso aos documentos 
do projeto e ao código atualizado, tendo ciência do que está sendo 
feito, quais requisitos precisam ser atendidos, e quais os proble-
mas que estão precisando de soluções — além, é claro, de criar um 
sistema propriamente dito, compilando e ligando componentes. 

Sommerville (2011, p. 137) nos diz que o gerenciamento de 
configuração envolve três atividades essenciais. São elas: 

1. Gerenciamento de versões, em que o suporte é fornecido para 
manter o controle das diferentes versões de componentes de 
software. Sistemas de gerenciamento de versões incluem recur-
sos para coordenar o desenvolvimento de diversos programa-
dores. Eles bloqueiam um desenvolvedor que esteja escrevendo 
sobre um código submetido ao sistema por outra pessoa. 
2. Integração de sistemas, em que o suporte é fornecido para 
ajudar os desenvolvedores a definir quais versões dos compo-
nentes são usadas para criar cada versão de um sistema. Essa 
descrição é, então, usada para construir um sistema automati-
camente, compilando e ligando os componentes necessários. 
3. Rastreamento de problemas, em que o suporte é fornecido 
para permitir aos usuários reportar bugs e outros problemas, 
além de permitir que todos os desenvolvedores possam ver 
quem está trabalhando nesses problemas e quando eles são 
resolvidos (SOMMERVILLE, 2011, p. 137). 
Não podemos pensar nessas atividades sem as ferramentas 
de gerenciamento. Em um sistema amplo de gerenciamento de 
mudanças, eles podem ser projetados para operar em conjun-
to. Em sistemas integrados de gerenciamento de configuração, 

o rastreamento de problemas, a integração de sistemas e o ge-
renciamento de versão são projetados ao mesmo tempo, como 
partes de uma mesma coisa. Desse modo, nós as integramos por 
meio de um repositório de código comum, e elas compartilham 
entre si um mesmo estilo de interface de usuário. 
Por outro lado, existe também a possibilidade de trabalhar com 
as ferramentas separadamente. Nesse caso, elas estariam ligadas 
a sistemas de apoio em um ambiente de desenvolvimento integra-
do. O Subversion, para o gerenciamento de versões, o sistema de 
construção GNU e o Unix Make para a integração; e o Bugzilla, 
para rastreamento de problemas, são exemplos de recursos muito 



Projetando e implementando arquiteturas) (95 

utilizados para esse modelo de ferramentas separadas para o ge-
renciamento de configuração. 

Desenvolvimento host-target 

No universo da Engenharia de Softwares, dizemos que o host 
(anfitrião) é o computador em que o software é desenvolvido, e o 
target (alvo) é a máquina em que ele será executado. O modelo 
host-target predomina na maioria dos softwares de desenvolvi-
mento; e, em linhas gerais, podemos falar em uma plataforma de 
desenvolvimento e uma plataforma de execução. 

Tenha em mente que uma plataforma não se limita ao hardware. 
Ela envolve também um sistema operacional, e softwares de apoio, 
como um sistema de gerenciamento de bancos de dados, por exem-
plo, ou, no caso de plataformas de desenvolvimento, um ambiente 
de desenvolvimento interativo. 

Pode acontecer de as plataformas de desenvolvimento e exe-
cução serem as mesmas, o que possibilita executar e testar no 
mesmo computador. Para elaborarmos sistemas embarcados, é 
muito comum recorrermos aos simuladores. Eles trabalham simu-
lando componentes do hardware — sensores, por exemplo —, assim 
como eventos no ambiente em que queremos que o sistema seja 
implementado. Com os simuladores, cada um dos desenvolvedo-
res pode atuar com uma plataforma de execução, dispensando o 
trabalho de instalar o software no hardware target. 

A plataforma de desenvolvimento precisa oferecer muitos 
recursos. Entre muitas ferramentas que podem ser necessárias, 
Sommerville (2011, p. 138) destaca cinco: 

1. Um sistema compilador integrado e editor dirigido a sintaxe, 
que permita criar, editar e compilar o código. 
2. Um sistema de depuração de linguagem. 
3. Ferramentas de edição gráfica, como ferramentas para editar 
modelos da UML. 
4. Ferramentas de teste, como JUnit, que podem executar, au-
tomaticamente, um conjunto de testes sobre uma nova ver-
são de um programa. 
5. Ferramentas de apoio ao projeto, que ajudem a organizar o 
código para diferentes projetos de desenvolvimento. 
Ambientes de desenvolvimento voltados para equipes geral-
mente também trazem consigo um servidor compartilhado que exe-
cuta as mudanças, e um sistema de gerenciamento de configuração. 



96) (irauretura de software 
Pode ser também que tenha, inclusive, um sistema de apoio ao ge-

renciamento de requisitos. 

O IDE (Integrated Development Environment — Ambiente 
de Desenvolvimento Integrado) reúne as ferramentas de desen-
volvimento de software, suportando múltiplos aspectos em um 
framework comum, assim como uma interface de usuário. Normal-
mente, os IDEs são utilizados para desenvolvermos uma linguagem 
de programação específica, Java, por exemplo. A linguagem IDE 
pode ser tanto uma instância de propósito geral, incluindo ferra-
mentas específicas de suporte de linguagem, como também pode 
ser especialmente desenvolvida. As IDEs de propósito geral são 
estruturas que servem para hospedarmos ferramentas de software, 
providenciando recursos de gerenciamento de dados e mecanismos 

de integração. 

Saiba mais 

O ambiente Eclipse é o mais conhecido IDE de uso geral. Ele é baseado em 
uma arquitetura plug-in, o que permite que seja especializado em múltiplas 
linguagens e domínios de aplicação. Ou seja, você pode adaptá-lo tranquila-
mente, apenas acrescentando plug-ins. 

Preste bastante atenção no fato de que é necessário tomar deci-

sões sobre a implantação do software na plataforma target já como 

parte do processo de desenvolvimento. Se pensarmos em sistemas 

embarcados, em que o target normalmente é apenas um computador, 

isso é fácil. Mas a coisa complica um pouquinho se pensarmos em 

sistemas distribuídos, em que é necessário tomar decisões sobre as 

plataformas específicas nas quais implantaremos os componentes. 

Para nos ajudar nesse momento, Sommerville (2011, p. 139) 

destaca três problemas que devem ser especialmente considera-

dos quando tomamos essas decisões, são eles: 

1. Os requisitos de hardware e software de um componente. Se um 
componente é projetado para uma arquitetura de hardware 
específica ou depende de algum outro software do sistema, 
deve, certamente, ser implantado em uma plataforma que for-
neça O hardware requerido e o suporte de software. 
2. Os requisitos de disponibilidade de sistema. Sistemas de alta 
disponibilidade podem exigir componentes a serem im-
plantados em mais de uma plataforma. Isso significa que, em 

Projetando e implementando arquiteturas (97 

caso de falha da plataforma, uma implementação alternativa 
do componente estará disponível. 

3. Comunicações de componente. Se houver um elevado nível 
de tráfego de comunicações entre os componentes, faz 
sentido implantá-los na mesma plataforma ou em platafor-
mas que estejam fisicamente próximas. Isso reduz a latência 
de comunicações, o atraso entre o momento em que uma 
mensagem é enviada por um componente e recebida por 
outro (SOMMERVILLE, 2071, p. 139). 
Os diagramas de implantação da UML podem ser muito úteis 
para que você documente as suas decisões em hardware. Com eles, 
podemos visualizar com clareza a distribuição em diferentes pla-
taformas de hardware dos componentes de software. Lembre-se 
bem que, se você estiver desenvolvendo um sistema embarcado, 
é fundamental considerar as características do target, como o seu 
tamanho físico e capacidades de energia. No mesmo sentido, você 
também precisa considerar como serão as necessidades de respostas 
em tempo real aos eventos de sensores, e as características físicas 
dos atuadores, assim como o seu sistema operacional de tempo real. 

Exercícios de fixação 

O que é a plataforma de software? 13. Quais são os quatro elementos básicos para 
Quais são algumas das atividades que podem os padrões de projeto propostos pela Gangue 
compor o processo de projeto? dos Quatro? 
Qual a diferença entre testes de defeitos e o Em quais níveis o reúso de um software pode 
debugging? ser feito? 
O que é a descrição de caso de uso? Explique o que é o IDE. 
Explique em poucas palavras como fazer a Quais são os custos de fazer o reúso de 
identificação de objetos de classe. software? 
Qual a diferença entre modelos de projeto Explique o que é o gerenciamento de confi-
estruturais e dinâmicos? guração e cite quais as três atividades essen-
O que são as especificações de interface? ciais que o compõem. 

O que é a OCL e para que ela é utilizada? O que são as ferramentas de gerenciamento? 

Explique como se dá a relação entre os obje-Explique o que é o modelo host-target. 
tos e as interfaces. Explique que é uma plataforma de desenvol-
O que são padrões de projeto? vimento. 

O que é a implementação? O que é uma plataforma de execução? 
O que é o reúso de um software? O que são os simuladores? 


98 ) ( arquitetura de software 
Documento de requisitos: 
essencial ao desenvolvimento de software 

Um engenheiro de software é um profissional 
que deve ter a habilidade de antecipar e geren-
ciar mudanças de requisitos de um produto de 
software. Além disso, ele precisa saber se expres-
sar e se comunicar bem a fim de capturar e regis-
trar adequadamente o documento de requisitos. 
Os principais problemas no desenvolvimento de 
um sistema de software decorrem do entendi-
mento errado entre engenheiro de software (pro-
dutor), responsável em apresentar o documento 
de requisitos, e usuário (consumidor). Um docu-
mento de requisitos de software precisa ser claro, 
consistente e completo, porque ele servirá de re-
ferência aos desenvolvedores, gerente de projeto, 
engenheiros de software (responsáveis pelos tes-
tes e manutenção do sistema), além de servir de 
base para definir o escopo das funcionalidades a 
serem registradas num contrato. Perceba que os 
requisitos compreendem o cerne de qualquer 
produto e mudanças sobre eles podem ocorrer 
ao longo do ciclo de vida de um software. 
Requisitos de software 
Desenvolver um sistema de software requer um 
processo, o qual informa um conjunto de ativida-
des a serem realizadas, quem as executam, quais 
artefatos de entrada são necessários e quais ar-
tefatos de saída são produzidos. Nesse sentido, 
detectar erros ou quaisquer outros problemas, 
como inconsistência e falta de clareza, é de suma 
importância para tornar o processo mais efetivo 
sob o ponto de vista de custo. Além disso, envol-
ver o usuário no processo é determinante para o 
sucesso do produto e do processo. Dentro desse 
contexto, entender adequadamente o requisito 
é essencial, e essa é a tarefa do engenheiro de 

software. Um requisito compreende uma carac-
terística ou funcionalidade que o sistema deve 
apresentar ou uma restrição que deve satisfazer 
para atender uma necessidade do usuário. Dessa 
forma, o engenheiro de software, desempenhan-
do o papel de engenheiro de requisitos, deve 
executar duas atividades essenciais para a elabo-
ração do documento de requisitos: 
& | Elicitação de requisitos — atividade na qual 

os requisitos do sistema a ser desenvolvido 

são levantados; 

Análise de requisitos — atividade na qual os 

requisitos são analisados e confirmados pelos 

principais interessados do projeto (isto é, os 

stakeholders), que incluem cliente, usuário fi-

nal e gerente de projetos, entre outros. 
Considera-se ainda que a elicitação de requisitos 
tem por objetivo definir características do sistema 
sob a perspectiva do cliente, enquanto a análise de 
requisitos visa obter a especificação de requisitos, 
do ponto de vista técnico, conforme entendimen-
to dos desenvolvedores. 
Durante a realização dessas atividades, o engenheiro 
de software está preocupado em levantar, entender, 
analisar e, por fim, documentar os requisitos. Para 
tanto, ele deve se concentrar nas características do 
sistema e atributos de qualidade, e não em como 
obtê-los. Aqui, é preciso identificar quais requisitos fa-
zem parte ou não do escopo do sistema a ser desen-
volvido; ou, em outras palavras, entender a interface 
do sistema considerado e o ambiente externo. 
É importante ressaltar a necessidade de definir o 
“limite” ou também denominado escopo do siste-
ma, a fim de tratar os requisitos funcionais e não 
funcionais do sistema. Além disso, quando da 


Projetando e implementando arquiteturas) (99 

elaboração do documento de requisitos, o enge-
nheiro de software deve levar em consideração 
os diferentes pontos de vistas dos stakeholders, de 
modo que o documento resultante possa comu-
nicar adequadamente o conjunto de requisitos do 
sistema a ser construído. 
Documento de requisitos 
O documento de requisitos delimita o escopo do 
conjunto de funcionalidades que um sistema deve 
prover, bem como descreve os atributos de quali-
dade que devem ser suportados. 
B Serve como mecanismo de comunicação 

para os stakeholders (i. e. as partes interessa-
das do projeto). 
Captura e documenta os requisitos do proje-
to e serve de referência para testes, manuten-
ção e evolução do sistema. 

Recapitulando 

omeçamos esta unidade falando sobre 

o Processo de Projeto. Você aprendeu como 
elaborá-lo e os elementos que o compõe. No 
Tema 1, a conversa partiu da plataforma de software, 
passando pelos testes de defeitos e debugging, até 
chegar nos modelos de contexto, modelos interação 
e nos modelos de arquitetura de alto nível. Quando 
chegamos à identificação de objetos de classe, você 
aprendeu a utilizar a descrição de caso e uso. 
Passando para os modelos de projeto, discutimos 
as diferenças entre os modelos estruturais e os 
modelos dinâmicos. Ainda neste tópico, também 
conversamos sobre os modelos de subsistema, 

B O documento de requisitos de um projeto 
tem o objetivo de documentar o escopo do 
sistema a ser desenvolvido. Nesse sentido, ele 
deve conter: 
introdução e visão geral do documento; 
descrição de requisitos funcionais; 
descrição de requisitos não funcionais; 
escopo não contemplado (de funciona-
lidades); 
B documentação de apoio. 

Fonte: Silva Filho (2009, p. 24-29). 

Exercício 
Escreva um texto de 15 a 25 linhas explicando o 
que é um Documento de Requisitos e qual a sua 
importância para o processo de desenvolvimento 
de softwares. 

os modelos de sequência e os modelos de máquina 
de estado. 
Sem perder tempo, entramos nas especificações 
de interface. Aqui, você conheceu a OCL, a lingua-
gem de restrição de objetos e entendeu como é 
a relação entre os objetos e as interfaces. Em se-
guida, abordamos os padrões de projeto, e você 
conheceu as contribuições da Gangue dos Quatro 
para o desenvolvimento de softwares. 
E finalmente chegamos à implementação. Bate-
mos um papo sobre os conceitos de reúso, geren-
ciamento de configurações e o desenvolvimento 
de host-target. 


” 

UNIDADE 

Frameworks e projetos 
de requisitos formais e 
não formais 

ra Objetivos da aprendizagem 

& Conhecer os processos de projeto. 
B Aprender a utilizar diferentes tipos de modelos de projeto. 
8 Dominar os conceitos gerais da implementação. 

Vá Temas 

B 1-Frameworks de aplicações existentes 
Abrindo a nossa conversa, você vai conhecer os processos de proje-
to, indo do básico ao complexo neste tema essencial ao desenvolvi-
mento de softwares. 

8 2--Projetando requisitos não funcionais 
Dando sequência a nossa linha de raciocínio, aqui vamos falar sobre 
os diferentes modelos de projeto, conhecendo as características e 
utilidades de cada um. 

B 3 -Documento de requisitos de software 
Encerrando mais esta etapa, vamos abordar a implementação. Fare-
mos uma interessante discussão sobre conceitos que orientam a 
forma como os softwares são desenvolvidos hoje. 

Introdução 

Os defensores do desenvolvimento orientado a objetos argumentam que 
uma das maiores vantagens desta abordagem é a possibilidade de reúso 
em outros sistemas diferentes. Porém, na prática podemos constatar que é 
bem comum que os objetos sejam muito pequenos e especializados já 


102) ( arquitetura de software 
para uma aplicação em especial. Dá mais trabalho compreendê-lo e 
adaptá-lo do que simplesmente reimplementá-lo. 
É aqui que entram os frameworks! Traduzindo do inglês como “quadros 
de trabalho” eles são uma opção melhor de reúso em um processo de 
desenvolvimento orientado a objetos, consistindo em abstrações de alta 
granularidade. Pode parecer complicado, mas não é. Os frameworks são 
basicamente estruturas genéricas, que se estendem para criarmos um 
aplicativo ou algum subsistema que seja mais específico. Essas estrutu-
ras genéricas são um conjunto de classes, objetos e componentes que 
atuam para disponibilizar uma arquitetura que possa ser reusável para 
uma família de sistemas relacionados. 
Em outras palavras, os frameworks suportam recursos genéricos de 
modo que eles sejam utilizados em todas as aplicações do mesmo 
tipo. Vamos pensar no exemplo de um framework de uma interface de 
usuário. O suporte fornecido por ele atenderá eventos de interface, 
incluindo também recursos que permitam que construamos displays. 
Cabe ao desenvolvedor a responsabilidade por especializá-los, fazen-
do o trabalho de adicionar funcionalidades próprias para aplicações 
específicas. 
No caso do framework de interface de usuário, layouts de display são 
definidos pelo desenvolvedor para cada aplicação que está sendo tra-
balhada. Graças aos frameworks, temos suporte ao reúso do projeto e 
também de classes específicas do sistema, já que eles nos são uma 
"arquitetura de esqueleto” para o sistema. Essa arquitetura se caracte-
riza por classes de objetos e por suas interações. As classes, por sua 
vez, podem ser reusadas de maneira direta, e se utilizarmos recursos 
(como a herança), nós também podemos prorrogá-las. 

Frameworks de aplicações existentes 

Para começo de conversa, tenha em mente que os frameworks 
são específicos da linguagem utilizada, e existem modelos dispo-
níveis na maioria delas. Em sua implementação, nós os criamos 
como uma coleção de classes de objetos concretos e abstratos — 
evidentemente, em abordagem orientada a objetos. 

Um framework é capaz de incorporar outros, de modo que cada 
um deles cuida de parte do desenvolvimento do sistema. Nesse 



Frameworks e projetos de requisitos formais e não formais) ( 03 

sentido, os frameworks podem ser utilizados para todo o aplicativo 
ou apenas partes dele, como a interface gráfica do usuário. 
Fayad e Schmidt (1997 apud SOMMERVILLE, 2011, p. 301) 
dividiram os frameworks em três classes: 

1. Frameworks de infraestrutura de sistema — ajudam a de-
senvolver infraestruturas do sistema, como comunicações, 
compiladores e interface. 
2. Frameworks de integração de middleware — grupo de clas-
ses e normas de objetos associados que dão suporte para 
componentes de troca de informações e comunicação. 
3. Frameworks de aplicações corporativas — estes estão li-
gados a domínios de aplicações específicas, como sistemas 
financeiros. 
Os WAFs (Web Application Frameworks), Frameworks de Apli-
cação Web, são uma categoria que surgiu mais recentemente, e hoje 
são fundamentais. Sua arquitetura normalmente é baseada no pa-
drão Composite do MVC, que você pode conferir na Figura 4.1. 

do Figura 4.1 O padrão-modelo-visão do controlador N 

Entradasde Estado de controlador Mensagens de Estado de visão 
usuário modificação de visão 

>» R —> 

Métodos de 

Métodos de visão 
controlador 

O padrão MVC apareceu nos anos 1980 como uma abordagem 
de projeto GUI, possibilitando múltiplas apresentações de um ob-
jeto e diferentes modos de interação com cada uma delas. Assim, 
podemos separar o estado da aplicação da interface de usuário da 
aplicação. Se os dados sofrerem alterações a partir das apresenta-
ções, então o modelo de sistema é alterado, assim como os contro-
ladores que estão associados a cada visão, fazendo a atualização 
de sua apresentação. 



104) (irqurerur de software 
Saiba mais 

Existe uma relação 
muito íntima entre 
os frameworks e os 
padrões de projeto. 
Como os padrões 
estabelecem 
parâmetros gerais e 
trabalham com classes 
concretas e abstratas, 
eles criam as condições 
para que os frameworks 
sejam implementados. 
Sem os padrões, 
seria praticamente 
impossível utilizá-los. 

Pensando especificamente nos WAFs, em geral, eles absorvem 
um ou mais frameworks especializados em razão de seu suporte 
a recursos específicos de aplicações. Apesar de cada framework 
apresentar uma funcionalidade basicamente diferente, segundo 
Sommerville (2011, p. 301-302), a maioria dos WAFs é capaz de 
suportar os recursos que se seguem: 

1. Proteção. WAFs podem incluir classes para ajudar a imple-
mentar a autenticação de usuário (login) e controle de aces-
so, para garantir que os usuários só possam acessar a funcio-
nalidade permitida no sistema. 
2. Páginas Web dinâmicas. As classes são fornecidas para aju-
dar na definição de templates de páginas Web e para preen-
chê-los dinamicamente, com dados específicos do banco 
de dados do sistema. 
3. Suporte de banco de dados. Geralmente, os frameworks não 
incluem um banco de dados, mas assumem que um ban-
co de dados separado, como MySQL, será usado. O quadro 
pode fornecer classes que proporcionam uma interface 
abstrata para bancos de dados diferentes. 
4. Gerenciamento de sessão. Classes para criar e gerenciar sessões 
(um número de interações com o sistema por um usuário) são 
geralmente parte de um WAF. 
5. Interação de usuário. Atualmente, a maioria dos frameworks 
Web fornece suporte a AJAX, que permite que sejam cria-
das mais páginas Web interativas. 
Perceba que não precisamos mudar o código para estender um 
framework. Basta apenas adicionar classes concretas, e elas her-
darão das classes abstratas as suas operações. 

Um elemento importante aqui são os chamados callbacks. De 

maneira geral, podemos dizer que eles são métodos requisitados 

como resposta a algum evento que o framework perceba. Eles 

também são chamados de “inversão de controle”. Isso porque os 

objetos do framework é que são os responsáveis pelo controle no 

sistema, e não objetos específicos do aplicativo. Respondendo a 

eventos — que podem ser de interface do usuário, banco de dados, 

enfim, eventos externos — os objetos do framework recorrem aos 

métodos hook, que por sua vez são anexados à funcionalidade que 

está sendo fornecida ao user. 

Acompanhe atentamente a Figura 4.2. Nela você pode ver 

como um callback funciona, invertendo o controle. 



Frameworks e projetos de requisitos formais e não formais) (1 05 

A Figura 4.2 Inversão de controles em frameworks. TN 
Loop de

GUI 

eventos O) 
| Callbacks 

Classes específicas de aplicação 

Callbacks | | Callbacks 
Banco de 
dados 
Loop de 
eventos Plataforma 
Loop de 
eventos 6) 
Ni 
Fonte: Sommerville (2011, p. 302). 
J 

Vamos imaginar juntos um exemplo de um método do framework 
que opera com um clique de mouse que vem do ambiente. Este méto-
do fará a chamada do método hook, que deverá estar configurado para 
conseguir convocar os métodos de aplicação pertinentes para cuidar 
do clique de mouse. 

Guarde bem o conceito de linhas de produtos de software ou 
família de aplicações, que usaremos para nos referir a aplicativos 
que são desenvolvidos por frameworks, e nesse sentido importan-
tes meios para reúso. Considerando o framework, podemos di-
zer que é fácil fazer mudanças na família para criar instâncias do 
sistema. Teremos que reescrever classes concretas e métodos que 
foram adicionados ao framework. 

Em todo caso, os frameworks tendem a ser mais gerais que as 
próprias linhas de produtos de software, que ainda se restringe mais 
sobre uma família específica de programas. Pense, por exemplo, 
que um mesmo framework baseado em Web pode ser utilizado para 
desenvolver incontáveis aplicações baseadas em Web diferentes. 

Fechando este bloco, espero que esteja claro para você que 
frameworks são uma forma bem interessante de reúso. Porém, 
não se esqueça de que eles são dispendiosos e complexos — pode 
levar meses somente para que os desenvolvedores aprendam a 
utilizá-los. Do mesmo modo, também é complicado e custoso 
fazer a avaliação de qual dos frameworks é o mais pertinente 
para o seu caso específico. Outro aspecto que também deve ser 



106) ( arquitetura de software 
considerado é a dificuldade de fazer depurações em aplicações 
que se baseiam em frameworks, em especial por não ser simples 
entender o modo como os métodos dele interagem entre si. 

Linhas de produto de software 

Uma linha de produtos de software, reforçando a introdução 
feita no tópico anterior, é um conjunto de programas que apresen-
tam uma arquitetura comum e componentes compartilhados. As 
diferentes aplicações de linha surgem por meio de especializações 
feitas para atender necessidades específicas diferentes. 

O núcleo do sistema já é projetado de um modo aberto, possibi-
litando as novas configurações e adaptações. Elas podem englobar 
as configurações próprias de alguns componentes, a modificação de 
componentes e mesmo a implementação de componentes novos. 

Na prática, desenvolver programas por uma aplicação genérica 
implica reusar uma quantidade significativa de códigos. É comum 
que a experiência de aplicação seja tranquilamente transferida 
para outros sistemas. Mesmo os testes são simples, já que a maio-
ria deles também pode ser reusada. Somando esses fatores, o tem-
po e os recursos gastos com o desenvolvimento são bem menores. 

Existem também linhas de produtos genéricos, em que são 
identificadas funcionalidades comuns nas instâncias dos produtos 
que acabam sendo inclusas em uma aplicação de base. Esta é feita 
intencionalmente de uma maneira que torna o mais prático possí-
velo reúso e a reconfiguração. 

Como você pode notar, frameworks de aplicações e linhas de pro-
dutos de softwares são muito similares em vários aspectos. Os dois 
dão suporte para uma arquitetura e componentes comuns, e necessi-
tam de uma nova etapa de desenvolvimento para que seja criada uma 
versão específica da aplicação. Contudo, é importante ficar claro que 
eles não são a mesma coisa. Sommerville (2011, p. 303) aponta as se-
guintes diferenças entre frameworks e linhas de produtos de software: 

1. Frameworks de aplicação dependem de recursos orientados 
a objetos como herança e polimorfismo para implemen-
tar as extensões para O framework. Geralmente, o código 
de framework não é modificado, e possíveis modificações 
limitam-se ao que é permitido pelo framework. Linhas de 
produtos de software não são necessariamente criadas 
usando-se uma abordagem orientada a objetos. Os compo-
nentes de aplicação são alterados, deletados ou reescritos. 

Frameworks e projetos de requisitos formais e não formais) (107 

Em princípio, pelo menos, não há limites para as alterações 
que podem ser feitas. 

2. Frameworks de aplicação concentram-se principalmente no 
apoio técnico e não de domínio específico. Por exemplo, 
existem frameworks de aplicações para se criar aplicações 
baseadas em Web. Uma linha de produtos de software ge-
ralmente incorpora informações detalhadas de domínio e 
de plataforma. Um exemplo poderia ser uma linha de pro-
dutos de software relacionada com aplicações baseadas em 
Web para o gerenciamento de registros de saúde. 
3. Muitas vezes, as linhas de produtos de software são aplica-
ções de controle para o equipamento. Por exemplo, pode 
haver uma linha de produtos de software para uma família 
de impressoras. Isso significa que a linha de produtos deve 
fornecer suporte para a interface de hardware. Geralmente, 
os frameworks de aplicação são orientados para software e 
raramente fornecem suporte para a interface de hardware. 
4. Linhas de produtos de software são compostas de uma fa-
mília de aplicações relacionadas, de propriedade da mesma 
organização. Quando você cria uma nova aplicação, o pon-
to de partida frequentemente é o membro mais próximo 
da família de aplicações, e não a aplicação central genérica. 
É muito interessante o modo como frameworks e linhas de 
produtos de software interagem. Caso você esteja utilizando uma 
linguagem orientada a objetos para desenvolver uma linha de pro-
dutos, por exemplo, você pode recorrer a um framework para que 
ele seja a base do sistema. Pensando no núcleo da linha de produtos, 

o framework poderá ser estendido, é só utilizarmos componentes 
específicos de domínio recorrendo aos seus mecanismos internos. 
Na segunda fase do desenvolvimento, as diferentes versões 
são criadas para atendermos aos requisitos de clientes distintos. 
Existem várias especializações possíveis em linha de produtos de 
softwares, e Sommerville (2011, p. 303-304) lista as seguintes: 

1. Especialização de plataforma. As versões da aplicação são 
desenvolvidas para diferentes plataformas. Por exemplo, 
versões da aplicação podem existir para plataformas Linux, 
Windows e Mac OS. Nesse caso, a funcionalidade da aplica-
ção costuma ser inalterada. Apenas os componentes que 
fazem interface com o hardware e o sistema operacional 
são modificados. 

108) ( arquitetura de software 
Especialização de ambiente. Versões da aplicação são criadas 
para lidar com ambientes operacionais específicos e dispo-
sitivos periféricos. Por exemplo, um sistema para os serviços 
de emergência pode existir em versões diferentes, depen-
dendo do sistema de comunicações do veículo. Nesse caso, 
os componentes de sistema são alterados para refletir a fun-
cionalidade do equipamento de comunicação usado. 

Especialização funcional. Versões da aplicação são criadas 
para diferentes clientes, com requisitos específicos. Por 
exemplo, um sistema de automação de biblioteca pode ser 
modificado dependendo se ele é usado em uma bibliote-
ca pública, uma biblioteca de referência ou uma biblioteca 
universitária. Nesse caso, os componentes que implemen-
tam a funcionalidade podem ser modificados, e novos com-
ponentes, adicionados ao sistema. 

Especialização de processo. O sistema é adaptado para lidar 
com processos específicos de negócios. Por exemplo, um 
sistema de pedidos pode ser adaptado para lidar com um 
processo de solicitação centralizado, em uma empresa, e 
um processo distribuído, em outra. 

Pode ser que, no momento de criação de uma nova versão, seja 
necessário modificar componentes individuais. Imagine comigo 
como exemplo que a polícia possui muitos veículos no geral, mas 
poucos “tipos” de veículos diferentes, enquanto os bombeiros, ape-
sar de terem normalmente uma frota menor, possuem um número 
maior de tipos de viaturas especializadas. Nesse sentido, pode ser 
que você precise recorrer a uma estrutura de bancos de dados dife-
rentes quando for implementar uma aplicação para cada um deles. 

Observe atentamente a Figura 4.3. Nela você pode conferir as 
etapas que precisarão ser percorridas para estender uma linha de 
produtos de software, criando assim uma nova versão do programa. 

Figura 4.3 Desenvolvimento de instância de produto. 
Elicitar 
requisitos 
de stakeholders 
——» 
Escolher 
instância de sistema 
mais próximo 
Renegociar 
requisitos 
| 
Adaptar sistema 
existente 
Entregar 
instância de 
nova 
sistema 

Fonte: Sommerville (2011, p. 305). 


Frameworks e projetos de requisitos formais e não formas) ( 09 

Sommerville (2011, p. 305) nos diz que, em geral, as etapas 
envolvidas nesse processo são: 

1. licitar requisitos de stakeholders. Você pode começar com 
um processo normal de engenharia de requisitos. No entan-
to, comojá existe um sistema, você precisará demonstrá-lo, 
e que os stakeholders o experimentem expressando suas 
necessidades como modificações nas funções fornecidas. 
2. Selecionar o sistema mais próximo aos requisitos. Ao criar um 
novo membro de uma linha de produtos, você pode come-
çar com a instância de produtos mais próxima. Os requisitos 
são analisados e o membro da família, que é a opção mais 
próxima, é escolhido para a modificação. 
3. Renegociar requisitos. Assim que surgirem mais detalhes 
sobre as alterações necessárias e o projeto for planejado, 
podem ocorrer algumas renegociações de requisitos para 
minimizar as mudanças necessárias. 
4. Adaptar sistema existente. Novos módulos são desenvolvidos 
para o sistema existente e módulos de sistemas existentes 
são adaptados para novos requisitos. 
5. Entregar novo membro da família. A nova instância da linha 
de produtos é entregue ao cliente. Nessa etapa, você deve 
documentar suas principais características para que possam 
ser usadas como base para futuros desenvolvimentos de 
sistema. 
O seu desafio ao criar um novo membro de uma família de pro-
dutos é achar o equilíbrio ideal entre o reúso da aplicação genérica 
e o atendimento dos requisitos bem específicos dos stakeholders. 
É claro que, quanto mais detalhes houver nos requisitos, mais 
complicado será fazer o reúso. Mas se os stakeholders forem fle-
xíveis (e mesmo realistas), você poderá fazer o seu trabalho em 
um tempo menor, e eles terão um custo igualmente proporcional. 

Projetando requisitos não funcionais 
Engenharia de requisitos 

Os requisitos são descrições formais do que se quer que o 
software faça, os serviços que se espera que ele ofereça e também 
as restrições esperadas para o seu funcionamento. Aqui estamos 
pensando em requisitos que busquem determinar as necessidades 



10) (irqurerur de software 
que os clientes querem que sejam atendidas, e nesse sentido esta-
mos falando de softwares que têm uma finalidade específica bem 
determinada, como controlar dispositivos ou organizar um banco 
de dados. 

ARE (Requirements Engineering), que aqui chamamos de Enge-
nharia de Requisitos, é o processo fundamental do desenvolvimento 
de softwares que pauta por descobrir, analisar, documentar e testar os 
serviços e as restrições. Pode haver muita confusão em relação ao ter-
mo “requisito”, e em grande parte isso se dá pelos diferentes usos que 
são feitos dele na indústria do software. Ele pode ser tanto uma decla-
ração abstrata em alto nível de uma restrição ou serviço que deve ser 
oferecido, como também uma descrição formal, bem documentada e 
detalhada, de uma função que deve ser desempenhada pelo sistema. 

Esta diferença não é uma mera imprecisão. Imagine que uma or-
ganização quer contratar no mercado o serviço de desenvolvimento 
de um software. Nesse caso, ela lança uma descrição dos requisitos 
de modo abstrato justamente para que os interessados possam con-
correr entre si, desenvolvendo diferentes propostas, e mostrando o 
modo como pensam e o que têm a oferecer. Depois de escolhida 
uma das empresas de desenvolvimento de software, aí sim será ela-
borado um documento detalhado dos requisitos do software (docu-
mentos de requisitos do sistema, que conversamos na Unidade 1). 

Um dos maiores problemas da engenharia de requisitos é jus-
tamente quando não é feita a adequada separação entre estes di-
ferentes níveis de descrição. Sommerville (2011) faz a distinção 
entre eles por dois conceitos diferentes: requisitos de usuário, para 
expressar os requisitos abstratos de alto nível, e requisitos de sis-
tema, para expressar a descrição detalhada do que o sistema deve 
fazer (SOMMERVILLE, 2011, p. 58). 

1. Requisitos de usuário são declarações, em uma linguagem 
natural com diagramas, de quais serviços o sistema deverá 
fornecer a seus usuários e as restrições com as quais este 
deve operar. 
2. Requisitos de sistema são descrições mais detalhadas das 
funções, serviços e restrições operacionais do sistema de 
software. O documento de requisitos do sistema (às vezes 
chamado de especificação funcional) deve definir exatamen-
te o que deve ser implementado. Pode ser parte do contra-
to entre o comprador do sistema e os desenvolvedores de 
software. 

Frameworks e projetos de requisitos formais e não formais) ( “ 

Ambos os níveis de requisitos são muito importantes pela ca-
pacidade que têm de se comunicar para diferentes tipos de leitores 
dessas informações. Observe atentamente o Quadro 4.1, onde temos 
um exemplo dessa distinção para um Sistema de Gerenciamento 
de Saúde Mental de Pacientes, o MHC-PMS (Mental Health Care 
Patient Management), que já utilizamos como referência em uni-
dades passadas, lembra-se? Veja como os requisitos de usuário são 
mais gerais, e também repare como um único requisito de usuário 
pode ser ampliado para diversos requisitos de sistema. 

Na Figura 4.4, você pode acompanhar quais seriam os possí-
veis tipos de leitores desses requisitos. Em geral, o tipo de leitor 
que lida com os requisitos de usuário não está preocupado com as 
minúcias da implementação do sistema. Por outro lado, os leitores 
dos requisitos do sistema precisam do máximo possível de deta-
lhes para que possam fazer o seu trabalho. 

Aa Quadro 4.1 Requisitos de usuário e de sistema. DON 
Definição de requisitos de usuário 

1 O MHC-PMS deve gerar relatórios gerenciais 
mensais que mostrem o custo dos medicamentos 
prescritos por cada clínica durante aquele mês 

Especificação de requisitos de sistema 

1.1 No último dia útil de cada mês, deve ser 
gerado um resumo dos medicamentos 
prescritos, seus custos e as prescrições 
de cada clínica. 
1.2 Após as 17h30 do último dia útil do mês, 
o sistema deve gerar automaticamente o 
relatório para impressão. 
1.3 Um relatório será criado para cada clínica, 
listando os nomes dos medicamentos, 
o número total de prescrições, o número de 
doses prescritas e o custo total dos 
medicamentos prescritos 
1.4 Se os medicamentos estão disponíveis em 
diferentes unidades de dosagem 
(por exemplo, 10 mg e 20 mg), devem 
ser criados relatórios separados 
para cada uma delas. 
1.5 O acesso aos relatórios de custos deve ser 
restrito a usuários autorizados por uma lista 
de controle de gerenciamento de acesso 
Fonte: adaptado de Sommerville (2011, p. 58).

A 


1 12) (rquiterura de software 
(TT Figura 4.4 Leitores de diferentes tipos de especificação 
de requisitos. ) 

Gerentes clientes 
Usuários finais do sistema

Requisitos . E

de usuário ——». Engenheiros clientes 
Gerentes contratantes 
Arquitetos de sistema 

Usuários finais do sistema 
Requisitos Engenheiros clientes

———— . 

de sistema Arquitetos de sistema 
Desenvolvedores de software 

Fonte: Sommerville (2011, p. 59).

A J 

Requisitos funcionais e não funcionais 

A classificação mais importante dos requisitos, sem dúvida, é 
a divisão entre requisitos funcionais e não funcionais. Antes de 
tudo, vamos defini-los do seguinte modo: 

1. Requisitos funcionais. São declarações de serviços que o sis-
tema deve fornecer, de como o sistema deve reagir a en-
tradas específicas e de como o sistema deve se comportar 
em determinadas situações. Em alguns casos, os requisitos 
funcionais também podem explicitar o que o sistema não 
deve fazer. 
2. Requisitos não funcionais. São restrições aos serviços ou fun-
ções oferecidos pelo sistema. Incluem restrições de timing, 
restrições no processo de desenvolvimento e restrições im-
postas pelas normas. Ao contrário das características indivi-
duais ou serviços do sistema, os requisitos não funcionais 
muitas vezes aplicam-se ao sistema como um todo (SOM-
MERVILLE, 2011, p. 59). 
É claro que, por ser tratar de uma primeira definição geral, ela 
deve ser lida com ressalvas. Por exemplo, um requisito de usuário 
ligado a proteção (uma declaração limitando o acesso de possíveis 
usuários não autorizados), em um primeiro momento, pode ser 
pensado como um requisito não funcional. No entanto, perceba 
que no decorrer do seu desenvolvimento este primeiro requisito 
pode implicar novos requisitos, estes caracteristicamente funcio-
nais, como a óbvia demanda de inserir um sistema de autenticação 
dos usuários. 



Frameworks e projetos de requisitos formais e não formais) ( 13 

O que estamos querendo dizer, então, é que você deve com-
preender que os requisitos são dependentes entre si, e podem gerar 
ou restringir outros requisitos. Desse modo, podemos conceituar 
que os requisitos não se referem somente aos serviços ou caracte-
rísticas, mas também à funcionalidade operacional como um todo. 

Requisitos funcionais 

Eles descrevem o que deve ser feito pelo sistema. São direta-
mente dependentes da abordagem escolhida para escrevê-los, do 
tipo de aplicação desejada e do público-alvo. Se quando especi-
ficados como requisitos de usuário, eles se apresentam em lin-
guagem abstrata, quando são requisitos funcionais de sistema eles 
se baseiam em detalhes das funções, como exceções, entradas e 
saídas, e assim por diante. 

Podemos dizer, então, que requisitos funcionais englobam des-
de os requisitos gerais, sobre o que se espera que o sistema faça, 
até os requisitos mais específicos, que manifestam os sistemas e 
os modos de operação de uma organização. 

Como exemplo, vamos pensar nos requisitos funcionais do sis-
tema MHC-PMS: 

Um usuário deve ser capaz de pesquisar as listas de agenda-
mentos para todas as clínicas. 

O sistema deve gerar a cada dia, para cada clínica, a lista dos 

pacientes para as consultas daquele dia. 

Cada membro da equipe que usa o sistema deve ser identifi-

cado apenas por seu número de oito dígitos (SOMMERVILLE, 

2011, p. 59). 

Perceba que esses requisitos funcionais estabelecem quais 
serão os recursos específicos que o sistema terá de fornecer. Eles 
se originam do documento de requisitos de usuário, e por meio 
deles podemos ver como os requisitos funcionais podem ser re-
digidos em múltiplos níveis de detalhamento — compare o pri-
meiro e o último itens do nosso exemplo. 

Requisitos imprecisos são um dos maiores problemas que você 
pode encontrar na engenharia de software. Nem sempre a simpli-
ficação do requisito feita pelo desenvolvedor agrada o cliente, e 
acaba sendo necessário elaborar novos requisitos, e com eles mu-
danças no sistema. Evidentemente, isso aumenta o prazo de con-
clusão, e o custo. 



14) (trauretura de software 
A especificação dos requisitos funcionais deve ser sólida, 
completa e coerente. Quando falamos de completude, estamos 
nos referindo à definição de todos os serviços requeridos pelo 
usuário. Isso quer dizer que, em sistemas grandes e complexos, 
é muito difícil que haja plena completude e consistência de todos 
os requisitos. 

Quando elaboramos especificações para sistemas complexos, 
é muito difícil não cometer qualquer erro ou acabar se esquecendo 
de alguma coisa. Além do que, sistemas de grande porte geral-
mente apresentam vários stakeholders, e eles têm necessidades 
diferentes, que não são facilmente conciliáveis. E o pior é que 
essas inconsistências entre as necessidades dos stakeholders não 
são simples de antever, e acabamos dando de cara com eles assim 
que o sistema é enviado para o cliente. Resultado: teremos que 
voltar aos requisitos e refazer parte do sistema. 

Requisitos não funcionais 
Os requisitos não funcionais são aqueles que não têm uma re-
lação direta com os serviços específicos pensados para o sistema 
e os seus usuários. Mas nem por isso são menos importantes. Po-
dem estar ligados a coisas como confiabilidade, tempo de resposta 
e ocupação de área. 
Desempenho, proteção e disponibilidade são requisitos não fun-
cionais que afetam todo o sistema. Podemos dizer, inclusive, que 
eles são até mais críticos que os requisitos funcionais, individual-
mente falando. Os usuários de uma aplicação podem dar um jeito 
de compensar uma funcionalidade do sistema que não corresponda 
bem ao que ele precisa, mas requisitos funcionais não atendidos 
podem tornar o sistema como um todo inútil. 
Por exemplo, se um sistema de transações bancárias ou um 
sistema de controle de aviões não for confiável, ele vai servir para 
alguma coisa? 
Não é difícil relacionar diretamente componentes com requi-
sitos funcionais, mas a coisa já fica bem mais complicada quando 
pensamos em requisitos não funcionais. É por isso que eles devem 
ser difundidos pelo sistema todo. Sommerville (2011, p. 60) apon-
ta que isso se deve a duas razões: 

1. Requisitos não funcionais podem afetar a arquitetura geral de 
um sistema em vez de apenas componentes individuais. Por 
exemplo, para assegurar que sejam cumpridos os requisitos 

Frameworks e projetos de requisitos formais e não formais (1 15 

de desempenho, será necessário organizar o sistema para mi-
nimizar a comunicação entre os componentes. 

2. Um único requisito não funcional, tal como um requisito 
de proteção, pode gerar uma série de requisitos funcionais 
relacionados que definam os serviços necessários no novo 
sistema. Além disso, também podem gerar requisitos que 
restrinjam requisitos existentes. 
A origem dos requisitos não funcionais também está nas neces-
sidades dos usuários, podendo ser restrições orçamentárias, políti-
ca interna da organização, necessidades de operação conjunta entre 
sistemas de hardware e software, ou mesmo elementos externos, 
como leis e regulamentos. 

Observe atentamente a Figura 4.5. Nela temos uma classifica-
ção geral dos tipos de requisitos não funcionais. 

(TT Figura 4.5 Tipos de requisitos não funcionais. N 

Requisitos 
não funcionais 

Requisitos Requisitos Requisitos 
de produto organizacionais externos 

Requisitos Requisitos Requisitos Requisitos Requisitos 
de eficiência de confiança de proteção reguladores éticos 

Requisitos Requisitos Requisitos Requisitos de Requisitos 
de usabilidade ambientais operacionais | | desenvolvimento legais 

Requisitos Requisitos Requisitos Requisitos de 
de desempenho | | de espaço contábeis segurança/proteção 

q Fonte: Sommerville (2011, p. 61). 

» 

Na imagem, você pode conferir que os requisitos não fun-
cionais podem ser oriundos das características exigidas para o 
software (requisitos de produto), da organização responsável 
pelo desenvolvimento do software (requisitos organizacionais) 
ou de fontes externas (requisitos externos): 



1 16) ( irquretur de software 
é 

Requisitos de produto. Esses requisitos especificam ou res-

tringem o comportamento do software. Exemplos incluem 

os requisitos de desempenho quanto à rapidez com que 

o sistema deve executar e quanta memória ele requer, os 
requisitos de confiabilidade que estabelecem a taxa acei-
tável de falhas, os requisitos de proteção e os requisitos de 
usabilidade. 
Requisitos organizacionais. Esses são os requisitos gerais de 
sistemas derivados das políticas e procedimentos da orga-
nização do cliente e do desenvolvedor. Exemplos incluem 
os requisitos do processo operacional, que definem como 

o sistema será usado, os requisitos do processo de desen-
volvimento que especificam a linguagem de programação, 
o ambiente de desenvolvimento ou normas de processo a 
serem usadas, bem como os requisitos ambientais que es-
pecificam o ambiente operacional do sistema. 
Requisitos externos. Esse tipo abrange todos os requisitos 
que derivam de fatores externos ao sistema e seu processo 
de desenvolvimento. Podem incluir requisitos reguladores, 
que definem o que deve ser feito para que o sistema seja 
aprovado para uso, por um regulador, tal como um banco 
central; requisitos legais, que devem ser seguidos para ga-
rantir que o sistema opere dentro da lei; e requisitos éticos, 
que asseguram que o sistema será aceitável para seus usuá-
rios e o público em geral (SOMMERVILLE, 2011, p. 61). 

EN 
Exemplos 

Requisito de produto — o MHC-PMS deve estar disponível para todas as 

clínicas durante todo o horário comercial. Períodos de não operação den-

tro do horário normal de trabalho não podem exceder cinco em um dia. 

Requisito organizacional — usuários do sistema MHC-PMS devem se au-

tenticar com seus cartões de identificação da autoridade da saúde. 

Requisito externo -— o sistema deve implementar as disposições de pri-

vacidade dos pacientes, tal como estabelecido no HStan-03-2006-priv. 

Fonte: Sommerville (2011, p. 62). 

d 

No box Exemplo, é possível perceber que o requisito de produto 
um requisito de disponibilidade: ele estabelece que o sistema deve 


Frameworks e projetos de requisitos formais e não formais) (1 17 

estar disponível e a quantidade máxima de vezes em que ele pode fi-
car inativo. Não estamos falando, então, de uma funcionalidade di-
reta do MHC-PMS, mas de uma restrição que não pode ser ignorada 
por aqueles que estarão encarregados de desenvolver a aplicação. 

O modo como os usuários vão fazer sua autenticação no siste-
ma compõe o requisito organizacional. O sistema de saúde do Rei-
no Unido estabeleceu um procedimento de autenticação-padrão 
para todas as aplicações, e, em vez do tradicional nome de login e 
senha, agora haverá em leitor de cartão de identificação. Este novo 
requisito externo advém da preocupação em atender a legislação 
de privacidade, esta que é fundamental em todos os aspectos, ain-
da mais quando se trata de saúde. 

Uma dificuldade bem constante sobre os requisitos não fun-
cionais é que frequentemente eles são metas gerais propostas por 
clientes ou usuários. É claro que elas surgem da intenção de tornar 

o sistema melhor; contudo, isso pode acarretar em problemas, já 
que deixam brechas para interpretações que, consequentemente, 
geram também disputas. A seguir, veja a maneira como uma meta 
pode ser expressa por um gerente como um requisito de usabilida-
de: “O sistema deve ser de fácil uso pelo pessoal médico e deve 
ser organizado de tal maneira que os erros dos usuários sejam mi-
nimizados” (SOMMERVILLE, 2011, p. 62). 
Simplesmente não é possível verificar com objetividade a fina-
lidade do sistema. Todavia, podemos refazer a mesma descrição 
de modo que ela inclua ao menos a instrumentação de software 
para contar os erros que ocorram durante os testes feitos pelos 
usuários. Veja a diferença: 

A equipe médica deve ser capaz de usar todas as funções do sis-
tema após quatro horas de treinamento. Após esse treinamento, o 
número médio de erros cometidos por usuários experientes não 
deve exceder dois por hora de uso do sistema (SOMMERVILLE, 
2011,p. 62). 

Os requisitos não funcionais devem ser transcritos de modo 
quantitativo sempre que for possível. Isso permite que façamos 
testes objetivos. No Quadro 4.2 constam as métricas a sua dispo-
sição para que você especifique as propriedades não funcionais do 
programa. Assim, você será capaz de medir objetivamente essas 
características durante os testes e analisar se ele está ou não cum-
prindo requisitos não funcionais. 



18) (iraurerur de software 
TT Quadro 4.2 Métricas para especificar mecanismos não funcionais. TN 

Propriedade Medida 

Velocidade Transações processadas/segundo 
Tempo de resposta de usuário/evento 
Tempo de atualização de tela 

Tamanho Megabytes 
Número de chips de memória ROM 

Facilidade de uso | Tempo de treinamento 
Número de frames de ajuda 

Confiabilidade Tempo médio para falha 
Probabilidade de indisponibilidade 
Taxa de ocorrência de falhas 
Disponibilidade 

Robustez Tempo de reinício após falha 
Percentual de eventos que causam falhas 
Probabilidade de corrupção de dados em caso de falha 

Portabilidade Percentual de declarações dependentes do sistema-alvo 
Número de sistemas-alvo 

Fonte: Sommerville (2011, p 63). )

N 

" 
Fique atento 

Na prática, os clientes de um sistema geralmente consideram difícil traduzir 
suas metas em requisitos mensuráveis. Para algumas metas, como manute-
nibilidade, não existem métricas que possam ser usadas. Em outros casos, 
mesmo quando a especificação quantitativa é possível, os clientes podem 
não ser capazes de relacionar suas necessidades com essas especificações. 
Eles não entendem o que significa um número definindo a confiabilidade 
necessária (por exemplo), em termos de sua experiência cotidiana com os 
sistemas computacionais. Além disso, o custo de verificar requisitos objeti-
vamente não funcionais mensuráveis pode ser muito elevado, e os clientes, 
que pagam pelo sistema, podem não achar que os custos sejam justificados. 
Fonte: Sommerville (2011, p. 62).

N d 

É importante ter em mente que muitas vezes os requisitos 
não funcionais acabam interagindo e conflitando com outros re-
quisitos, funcionais ou não funcionais. Pense como no requisito 
de autenticação, que sem dúvida requer a instalação de um leitor 



Frameworks e projetos de requisitos formais e não formais) ( 19 

de cartões em todos os computadores que estiverem conectados 
ao sistema. Porém, imagine que outro requisito pode exigir acesso 
móvel ao sistema, como por meio de notebooks ou tablets de mé-
dicos e enfermeiros, e como estes normalmente não têm leitores 
de cartões, então precisaremos de um método alternativo. 

No limite, é muito complicado separar nos documentos de requi-
sitos os funcionais dos não funcionais. Caso os separemos, aqueles 
que se relacionam entre eles podem ficar mais difíceis de identificar-
mos e entendermos. Porém, não se esqueça que aqueles requisitos 
que confiadamente se relacionam com propriedades emergentes do 
sistema — como manutenibilidade, confiabilidade e desempenho — 
devem receber um destaque especial. Essa ênfase pode ser pela aber-
tura de uma seção própria nos documentos de requisitos, ou então 
simplesmente podemos usar algum recurso gráfico para distingui-los 
dos outros requisitos do sistema. 

Documento de requisitos de software 

Também chamado de especificação de requisitos de software 
(SRS — software Requirements Specification), o documento de re-
quisitos de software é uma declaração oficial do que exatamente os 
desenvolvedores devem implementar como sistema. Inclui tanto 
os requisitos de usuário, como os requisitos detalhados do sistema. 
Pode ocorrer que ambas sejam sintetizadas em uma única descrição — 

o que é até preferível, pelo que temos conversado até aqui. 
Em todo caso, os requisitos de usuário também podem servir 
como uma introdução, e os requisitos de sistema venham a seguir. 
Caso haja muitos requisitos, os requisitos do sistema podem ser 
inclusos em um documento paralelo. 

O documento de requisitos é fundamental quando uma organi-
zação externa está desenvolvendo o sistema. Porém, já existe uma 
abordagem que considera que os requisitos são tão voláteis que o 
documento de requisitos já nasce ultrapassado. Assim, ele seria 
um grande desperdício de tempo e trabalho. 

Em vez de documentos formais, estão sendo utilizadas aborda-
gens como a Extreme Programming, em que os requisitos são co-
lhidos com o usuário de uma maneira incremental, e escritos como 
estórias de usuários em cartões. Esta pode ser uma abordagem 
interessante para aplicações de negócios, por exemplo, em que de 
fato os requisitos mudam muito. Porém, por menor que seja, ainda 
é importante ter um documento formal de apoio. 



120) (arquitetura de software 
Muitas pessoas diferentes utilizam o documento de requisitos, 
desde os clientes que contratam o produto até os desenvolvedores 
responsáveis por sua implementação. Na Figura 4.6, você pode 
acompanhar os possíveis usuários. Note que a diversidade só re-
força a necessidade do documento de requisitos como uma ponte 
de comunicação dos requisitos para os clientes, do detalhamento 
dos requisitos para os desenvolvedores e testadores, além, é claro, 
do registro de informações sobre a evolução do processo. 

1 Figura 4.6 Usuários do documento de requisitos. TN 

Especificam e leem os 
requisitos para verificar se estes

Clientes ) E 

. > satisfazem suas necessidades.

do sistema . k 

Os clientes especificam as 
alterações nos requisitos. 

Usam o documento de 
requisitos para planejar uma 

Gerentes —————» proposta para o sistema e para 
planejar o processo de 
desenvolvimento do sistema. 

Usam os requisitos para

Engenheiros 

————», entender o sistema que

de sistema 

será desenvolvido. 

Usam os requisitos para

Engenheiros de 

——————», desenvolver testes de

teste de sistema 

validação do sistema. 

Usam os requisitos para

Engenheiros 

entender o sistema e os

de manutenção ———— 

relacionamentos entre

de sistema 

suas partes. 

q Fonte: Sommerville (2011, p. 64). 

J 

O tipo de sistema em desenvolvimento e o processo utilizado 
é que vão determinar o nível de detalhamento do documento. Sis-
temas críticos precisam de muitos detalhes, já que a segurança e a 
proteção devem ser cuidadosamente analisadas. Do mesmo modo, 
se o desenvolvimento estiver sendo feito por uma organização ex-
terna, os detalhes devem ser muito precisos. Por outro lado, se 
ele é realizado internamente, precisamos de menos detalhes e as 
divergências são mais fáceis de ser resolvidas. 



Frameworks e projetos de requisitos formais e não formais) (1 21 

O Quadro 4.3 apresenta um modelo de organização de um do-
cumento de requisitos baseada em uma norma IEEE criada para 
eles. Vale lembrar que esta é uma norma genérica, dando abertura 
para adaptações. 

A Quadro 4.3 A estrutura de um documento de requisitos. N 

Capítulo Descrição 

Prefácio Deve definir os possíveis leitores do documento e descrever seu histórico de versões, 
incluindo uma justificativa para a criação de uma nova versão e um resumo das mudanças 
feitas em cada versão. 

Introdução Deve descrever a necessidade para o sistema. Deve descrever brevemente as funções do 
sistema e explicar como ele vai funcionarcom outros sistemas. Também deve descrever 
como o sistema atende aos objetivos globais de negócio ou estratégicos da organização 
que encomendou o software. 

Glossário Deve definir os termos técnicos usados no documento. Você não deve fazer suposições 
sobre a experiência ou o conhecimento do leitor. 

Definição de | Deve descrever os serviços fornecidos ao usuário. Os requisitos não funcionais de 
requisitos sistema também devem ser descritos nessa seção Essa descrição pode usar a linguagem 
de usuário natural, diagramas ou outras notações compreensíveis para os clientes. É preciso especificar 

normas de produto e processos que devem ser seguidos. 

Arquitetura Deve apresentar uma visão geral em alto nível da arquitetura do sistema previsto, mostrando 
do sistema a distribuição de funções entre os módulos do sistema. Componentes de arquitetura que são 
reusados devem ser destacados. 

Especificação | Deve descrever em detalhes os requisitos funcionais e não funcionais. Se necessário, também 
de requisitos | podem ser adicionados mais detalhes aos requisitos não funcionais. Interfaces com outros 
do sistema sistemas podem ser definidas. 

Modelos Pode incluir modelos gráficos do sistema que mostram os relacionamentos entre os 
do sistema componentes do sistema, o sistema e seu ambiente. Exemplos de possíveis modelos 
são modelos de objetos, modelos de fluxo de dados ou modelos semânticos de dados. 

Evolução Deve descrever os pressupostos fundamentais em que o sistema se baseia, bem como 

do sistema quaisquer mudanças previstas, em decorrência da evolução de hardware, de mudanças 
nas necessidades do usuário etc. Essa seção é útil para projetistas de sistema, pois pode 
ajudá-los a evitar decisões capazes de restringir possíveis mudanças futuras no sistema. 

Apêndices Deve fornecer informações detalhadas e específicas relacionadas à aplicação em 
desenvolvimento, além de descrições de hardware e banco de dados, por exemplo. 
Os requisitos de hardware definem as configurações mínimas ideais para o sistema. 
Requisitos de banco de dados determinam a organização lógica dos dados usados pelo 
sistema e os relacionamentos entre esses dados. 

Índice Vários índices podem ser incluídos no documento. Pode haver, além de um índice 
alfabético normal, índices de diagramas e de funções, entre outros pertinentes. 

(onte: adaptado de Sommerville (2011, p. 65). ) 


122) (irauretura de software 
Além do tipo de sistema que está sendo desenvolvido, um fator 
importante para a definição da estrutura do documento é a abor-
dagem utilizada. Por exemplo, uma abordagem evolutiva pode 
excluir alguns itens do Quadro 4.3, focando na definição dos re-
quisitos de usuário e nos requisitos não funcionais de alto nível 
de sistema. 

Contudo, se um software for parte de um projeto de um sistema 
de grande porte, incluindo interações tanto em hardware como em 
software, então normalmente é preciso definirmos os requisitos com 
um alto nível de detalhamento. Na prática, isso implica documentos 
longos que incluam todos (ou quase todos) os itens do Quadro 4.3. 

Especificações de requisitos 

Especificar requisitos é a etapa em que escrevemos os requisitos 
de usuário e de sistema no documento de requisitos. Em tese, os re-
quisitos devem ser bem claros, objetivos, precisos, completos e con-
sistentes, mas sabemos que isso não é tão simples, não é mesmo? 

Os requisitos de usuário devem conseguir propor os requisitos 
funcionais e não funcionais de uma maneira que possam ser en-
tendidos por pessoas que não têm conhecimento técnico avançado 
sobre o desenvolvimento de softwares. O ideal é que eles con-
sigam especificar somente a maneira como um sistema deva se 
comportar externamente. 

É importante ressaltar que o documento de requisitos não deve 
conter minúcias do projeto do sistema ou da arquitetura. Para es-
crever requisitos de usuário, não devemos usar termos técnicos, 
notações estruturadas ou formais. Use linguagem natural e apoie-
-se em quadros simples, formas e diagramas que possam ser en-
tendidos por qualquer pessoa minimamente escolarizada. 

Já nos requisitos de sistema temos uma versão mais ampla e com-
plexa dos requisitos de usuário, e eles serão o mapa inicial do traba-
lho. Acrescentando detalhes, vão expor como os requisitos de usuário 
serão suportados pelo sistema. Muito mais abrangentes, os requisitos 
de sistema devem dar conta de todo o seu conjunto, e podem ser usa-
dos inclusive como parte do contrato para a sua implementação. 

Diferentemente dos requisitos de usuário, os requisitos de siste-
ma não devem se ater ao comportamento externo no sistema, mas se 
ocupar, acima de tudo, de como ele será construído e implementado 
na prática. Porém, pense que para atingir o nível de detalhamen-
to necessário para especificar inteiramente um sistema complexo, 



Frameworks e projetos de requisitos formais e não formais) ( 23 

não é possível eliminar todas as informações de projeto. Segundo 
Sommerville (2011, p. 66), isso se deve a vários motivos, como: 

Você pode precisar projetar uma arquitetura inicial do siste-
ma para ajudar a estruturar a especificação de requisitos. Os 
requisitos de sistema são organizados de acordo com os di-
ferentes subsistemas que compõem o sistema. Essa definição 
da arquitetura é essencial caso você queira reusar componen-
tes de software na implementação do sistema. 
Na maioria dos casos, os sistemas devem interoperar com 
os sistemas existentes, que restringem o projeto e impõem 
requisitos sobre o novo sistema. 
O uso de uma arquitetura específica para atender aos re-
quisitos não funcionais pode ser necessário. Um regulador 
externo que precisa certificar que o sistema é seguro pode 
especificar que um projeto já certificado de arquitetura 
pode ser usado. 

Requisitos de sistema também podem ser escritos em lingua-
gem natural, mas formulários, modelos gráficos ou matemáticos 
para o sistema são outras notações também possíveis. No Quadro 
4.4, você pode analisar uma lista de notações que podem ser utili-
zadas para que você escreva requisitos de sistema. 

A Quadro 4.4 Formas de especificação de requisitos de sistema. N 

Notação Descrição 

Sentenças em Os requisitos são escritos em frases numeradas em linguagem natural. Cada frase 
linguagem natural | deve expressar um requisito. 

Linguagem Os requisitos são escritos em linguagem natural em um formulário-padrão 
natural ou template. Cada campo fornece informações sobre um aspecto do requisito. 
estruturada 

Linguagem Essa abordagem usa uma linguagem como de programação, mas com características 
de descrição mais abstratas, para especificar os requisitos, definindo um modelo operacional do 
de projeto sistema. Essa abordagem é pouco usada atualmente, embora possa ser útil para as 

especificações de interface. 

Notações Para definição dos requisitos funcionais para o sistema são utilizados modelos 
gráficas gráficos, suplementados por anotações de texto; diagramas de caso de uso e 
de sequência da UML são comumente aplicados. 

Especificações Essas notações são baseadas em conceitos matemáticos, como máquinas de estado 

matemáticas finito ou conjuntos. Embora essas especificações inequívocas possam reduzir a 
ambiguidade de um documento de requisitos, a maioria dos clientes não entende 
uma especificação formal Eles não podem verificar que elas representam o que eles 
querem e são relutantes em aceitá-las como um contrato de sistema. 

(onte: adaptado de Sommerville (2011, p. 66) ) 


124) (irauretura de software 
Caso você precise mostrar o modo como um estado vai se 
alterar ou queira descrever uma sequência de ações, os modelos 
gráficos são opções mais interessantes. Diagramas de sequência 
e de estado da UML apresentam bem como ações são desenca-
deadas após mensagens ou eventos. As especificações matemáti-
cas formais são mais usadas para descrevermos sistemas críticos 
de proteção ou segurança, mas fora isso é muito raro que sejam 
utilizadas. 

Especificação em linguagem natural 

Sempre se utilizou linguagem natural para escrever requisitos. 
Trata-se de uma forma rica de expressões, intuitiva e também uni-
versal. É claro que também traz consigo certa imprecisão, e dá 
margem a interpretações, e como estamos falando de algo exato, 
isso não deve ocorrer. 

Existem muitas propostas diferentes para escrevermos os requi-
sitos, dependendo cada vez menos da linguagem natural. Contudo, 
nenhum conseguiu se tornar amplamente aceito, e a linguagem na-
tural continua tendo um papel muito importante. 

Mas entre uma linguagem natural aberta e uma nova lingua-
gem técnica para requisitos, há a possibilidade de chegarmos a 
alguns denominadores comuns que reduzam os mal-entendidos e 
a imprecisão. Sommerville (2011) propõe as seguintes diretrizes: 

1. Invente um formato-padrão e garanta que todas as defini-
ções de requisitos aderem a esse formato. A padronização 
do formato torna menos prováveis as omissões e mais fácil 
a verificação dos requisitos. O formato que eu uso expressa 
o requisito em uma única frase. Eu associo uma declaração 
com a justificativa para cada requisito de usuário para expli-
car por que o requisito foi proposto. A justificativa também 
pode incluir informações sobre quem propôs o requisito (a 
fonte do requisito), para saber quem consultar caso o requi-
sito tenha de ser mudado. 
2. Use uma linguagem consistente para distinguir entre os 
requisitos obrigatórios e os desejáveis. Os obrigatórios são 
requisitos aos quais o sistema tem de dar suporte e geral-
mente são escritos usando-se “deve”. Requisitos desejáveis 
não são essenciais e são escritos usando-se “pode”. 
3. Use uma forma de destacar as partes fundamentais do re-
quisito (negrito, itálico ou cores). 

Frameworks e projetos de requisitos formais e não formais) (1 25 

4. Não suponha que os leitores compreendem a linguagem 
técnica da engenharia de software. Frequentemente, pala-
vras como “arquitetura”e "módulo" são mal interpretadas. Você 
deve, portanto, evitar o uso de jargões, siglas e acrônimos. 
5. Sempre que possível, tente associar uma lógica a cada um dos 
requisitos de usuário. Essa justificativa deve explicar por que o re-
quisito foi incluído, e é particularmente útil quando os requisitos 
são alterados, uma vez que pode ajudar a decidir sobre quais mu-
danças seriam indesejáveis (SOMMERVILLE, 2011, p. 67). 
Você pode conferir no box a seguir um exemplo de como essas 
diretrizes podem ser utilizadas. Ele considera um software em-
butido de uma bomba automática de insulina. O quadro não está 
completo, constando apenas dois requisitos, apenas para que você 
entenda como a escrita pode ser feita, certo? 

" 

Exemplo 

Escrita de requisitos em li | para o software de uma 
bomba de insulina 

O sistema deve medir o açúcar no sangue e fornecer insulina, se necessá-
rio, a cada dez minutos. Mudanças de açúcar no sangue são relativamente 
lentas, portanto, medições mais frequentes são desnecessárias; medições 
menos frequentes podem levar a níveis de açúcar desnecessariamente 
elevados. 

O sistema deve, a cada minuto, executar uma rotina de autoteste com 
as condições a serem testadas e as ações associadas definidas. A rotina 
de autoteste pode descobrir problemas de hardware e software e pode 
alertar usuários para a impossibilidade de operar normalmente. 

Fonte: Sommerville (2011, p. 67). ) 

Especificações estruturadas 

A linguagem natural estruturada é um modelo de escrita de requi-
sitos que restringe um pouco a liberdade de quem os escreve, resul-
tando em uma escrita em forma-padrão dos requisitos. Resguardando 
boa parte da expressividade da linguagem natural, a linguagem natu-
ral estruturada garante maior uniformidade sobre as especificações. 

A notação na linguagem estruturada é feita por templates que 
especificam os requisitos de sistema. Aqui, já podemos utilizar 



126) ( irquitetura de software 
construções de linguagem de programação para representar alterna-
tivas e iteração. Outro recurso importante é podermos dar destaque 
para elementos-chave, usando fontes diferentes ou sombreamento. 

Sommerville (2011) cita os Robertson, que em seu livro sobre o 
método Volere de engenharia de requisitos propõem o uso de cartões 
para descrevermos os requisitos pela primeira vez, um em cada car-
tão separado. Eles sugerem um número de campos em cada cartão, 
algo como a lógica dos requisitos, as dependências de outros requi-
sitos, a origem dos requisitos, materiais de apoio, e assim por diante. 

No Quadro 4.5, temos um exemplo de uma abordagem parecida 
com essa proposta pelos Robertson, ainda pensando no software da 
bomba de insulina. Uma abordagem estruturada para a especifica-
ção de requisitos de sistema pode ser feita por meio da definição de 
um ou mais templates para que representem esses requisitos como 
se fossem formulários estruturados. 

— Quadro 4.5 Especificação estruturada de requisitos para o software da bomba de insulina. os 
Bomba de insulina/software de controle/SRS/3.3.2 
Função Calcula doses de insulina: nível seguro de açúcar. 
Descrição Calcula a dose de insulina a ser fornecida quando o nível de açúcar está na zona de 
segurança entre três e sete unidades. 
Entradas Leitura atual de açúcar (2), duas leituras anteriores (r0 e r1). 
Fonte Leitura atual da taxa de açúcar pelo sensor. Outras leituras da memória. 
Saídas CompDose — a dose de insulina a ser fornecida. 
Destino Loop principal de controle. 
Ação CompbDose é zero se o nível de açúcar está estável ou em queda ou se o nível está 
aumentando, mas a taxa de aumento está diminuindo. Se o nível está aumentando e a 
taxa de aumento está subindo, então CompDose é calculado dividindo a diferença entre 
o nível atual de açúcar e o nível anterior por quatro e arredondando o resultado. Se o 
resultado é arredondado para zero, então CompDose é definida como a dose mínima que 
pode ser fornecida. 
Requisitos Duas leituras anteriores, de modo que a taxa de variação do nível de açúcar pode ser 
calculada. 
Pré-condição | O reservatório de insulina contém pelo menos o máximo de dose única permitida de insulina. 
Pós-condições | rO é substituída por r1 e r1 é substituída por 12. 
Efeitos Nenhum. 
colaterais 

À fonte; adaptado de Sommerville (2011, p. 68). ) 


Frameworks e projetos de requisitos formais e não formais) (127 

Podemos estruturar a especificação em torno dos objetos que são 
operados pelo software, das funções que ele desempenha, ou pelos 
eventos que são processados por ele. No Quadro 4.5, temos o exem-
plo de como funciona uma especificação baseada em formulários, 
estabelecendo o modelo de cálculo da dosagem de insulina quando o 
nível de açúcar no sangue estiver dentro de uma faixa de segurança. 

Ao especificar requisitos funcionais com um formulário-padrão, 
não devemos nos esquecer de incluir as seguintes informações: 

A descrição da função ou entidade a ser especificada. 
Uma descrição de suas entradas e de onde elas vieram. 
Uma descrição de suas saídas e para onde elas irão. 
Informações sobre a informação necessária para o processa-

mento ou outras entidades usadas no sistema (a parte “requires”. 
Uma descrição da ação a ser tomada. 
Se uma abordagem funcional é usada, uma pré-condição 

define o que deve ser verdade antes que a função seja cha-

mada, e é chamada uma pós-condição, especificando o que 

é verdade depois da função. 

Uma descrição dos efeitos colaterais da operação (caso haja 
algum) (SOMMERVILLE, 2011, p. 68). 

As especificações estruturadas certamente evitam alguns pro-
blemas da livre linguagem natural. As variações são reduzidas, e há 
uma organização mais eficiente dos requisitos. Contudo, ainda se 
torna inevitável escrever requisitos de um jeito claro e inequívoco, 
sobretudo quando se trata de especificar processamentos bem com-
plicados (como a dose de insulina no nosso exemplo). 

Para evitar esses problemas, devemos incluir informações adi-
cionais lançando mão de recursos como os quadros ou os modelos 
gráficos do sistema. Com eles, podemos representar a execução 
dos cálculos, mudanças de estado do sistema, interação de usuá-
rios e sequenciamento de ações. 

Lembre-se especialmente dos quadros, certo? Eles são formi-
dáveis para lidarmos com circunstâncias em que existem várias si-
tuações alternativas possíveis, e precisamos descrever quais serão 
as ações executadas caso cada uma delas ocorra. 

Analise atentamente o Quadro 4.6, e veja como o tabulamento 
de requisitos pode ser um recurso muito útil. A bomba de insulina 
do nosso exemplo organiza seus cálculos sobre a quantidade de 
insulina necessária por meio da variação dos níveis de açúcar no 



128) ( arquitetura de software 
sangue, ficou claro? Assim, obtêm-se os valores pelo cálculo das 
variações entre as leituras atuais e anteriores. 

(1 Quadro 4.6 Especificação tabular para uma bomba de Insulina. N 

Condição Ação 

Nível de açúcar diminuindo (12 < r1) CompDose = 0 

Nível de açúcar estável (12 = 11) CompDose = 0 

Nível de açúcar aumentando e a taxa de aumento CompDose = 0 
decrescente [(12 — 11) < (11 — r0)] 

Nível de açúcar aumentando e a taxa de aumento CompDose = arredondar 
estável ou crescente [(r2 — r1) > (11 — r0)] [(r2 — / 4)]. Se o resultado

11) 

arredondado = 0, então 
CompbDose = MinimumDose 

q Fonte: Sommerville (2011, p 69) ) 

Processos de engenharia de requisitos 

Os processos de engenharia de requisitos podem abranger qua-
tro diferentes atividades de alto nível: 

1. O estudo de viabilidade analisa se o sistema é útil para a 
organização. 
A elicitação e a análise descobrem requisitos. 
3. Aespecificação converte os requisitos em alguma forma-padrão. 
4. Avalidação verifica se os requisitos se enquadram nas neces-
sidades do cliente. 
Pensando de maneira abstrata, pode parecer que essas atividades 
são processos separados e sequenciais, mas na prática podemos dizer 
que elas compõem uma espécie de espiral, em que um processo itera-
tivo produz o documento de requisitos do sistema. No começo, o foco 
se dá sobre a compreensão dos requisitos de negócio e não funcionais 
em alto nível, assim como os requisitos de usuário para o sistema. 
Depois, nos anéis externos da espiral, as atenções estarão voltadas 
para elicitar e compreender em seus detalhes os requisitos do sistema. 

Essa abordagem em espiral é interessante quando pensamos 
no desenvolvimento dos requisitos por meio de níveis de detalha-
mento. O número de iterações em volta da espiral varia de acordo 
com a necessidade de definição dos requisitos. Em vez de desen-
volvermos protótipos, podemos recorrer ao desenvolvimento ágil, 
em que os requisitos e a implementação ocorrem em conjunto. 



Frameworks e projetos de requisitos formais e não formais) ( 29 

Outro modo de pensar a engenharia de requisitos é concebendo-
-a como o processo de aplicar um método de análise estruturada, 
como a análise orientada a objetos. Nesse caso, os procedimentos 
se baseiam em analisar o sistema, e a partir daí desenvolver mo-
delos gráficos dele, como modelos de caso de uso. Esses modelos 
serviriam também como uma especificação. 

Os modelos agrupados apresentam o comportamento do sis-
tema como um todo. Em seguida, são feitas anotações, inserindo 
informações adicionais e descrições, como a da confiabilidade e o 
desempenho que é requerido pelo sistema. 

Os métodos estruturados são muito importantes na engenha-
ria de requisitos, mas é claro que apresentam suas limitações. 
A elicitação, por exemplo, é a atividade em que os engenheiros 
de software trabalham com clientes e usuários finais do sistema 
para obter informações sobre o domínio da aplicação, os serviços 
que o sistema deve oferecer, o desempenho do sistema, restrições 
de hardware etc. Por ser uma etapa baseada em pessoas, não é tão 
simples desempenhá-la seguindo restrições que sejam impostas 
por um rígido modelo de sistema. 

E para encerrar, a engenharia de requisitos não se baseia so-
mente em lidar com eles como um elemento “prévio” do desen-
volvimento de softwares. É raro encontrar um sistema em que os 
requisitos não mudem. Essa é praticamente uma característica geral 
dos sistemas. Todos os envolvidos amadurecem a sua compreensão 
do que desejam da aplicação, os percalços vão sendo superados, e 
também as necessidades dos clientes mudam, os hardwares evo-
luem, bem como o ambiente operacional dos sistemas. Para atender 
a essas constantes mudanças, existe o gerenciamento de requisitos, 
no qual é feito o controle dessas transformações, de modo a manter 
os softwares sempre atualizados. 

Exercícios de fixação 

O que é a plataforma de software? O que é a descrição de caso de uso? 
Cite algumas das atividades que podem com-Explique em poucas palavras como fazer a 
por o processo de projeto. identificação de objetos de classe. 
Qual a diferença entre testes de defeitos e o Qual a diferença entre modelos de projeto 
debugging? estruturais e dinâmicos? 


130) ( arquitetura de software 
O que são as especificações de interface? 
O que é a OCL e para que ela é utilizada? 
Explique como se dá a relação entre os obje-
tos e as interfaces. 
O que são padrões de projeto? 
Quais são os quatro elementos básicos para 
os padrões de projeto propostos pela gangue 
dos quatro? 
O que é a implementação? 
O que é o reúso de um software? 
Em quais níveis o reúso de um software pode 
ser feito? 

Quais são os custos de fazer o reúso de 
software? 
O que é o gerenciamento de configuração 
e quais as três atividades essenciais que o 
compõe? 
O que são as ferramentas de gerenciamento? 
Explique o que é o modelo host-target. 
O que é uma plataforma de desenvolvi-
mento? 
Em que consiste a plataforma de execução? 
O que são os simuladores? 
Explique o que é o IDE. 

Documento de requisitos essencial 
ao desenvolvimento de software 

Um engenheiro de software é um profissional que 
deve ter a habilidade de antecipar e gerenciar mu-
danças de requisitos de um produto de software. 
Além disso, ele precisa saber se expressar e se co-
municar bem, a fim de capturar e registrar adequa-
damente o documento de requisitos. Os principais 
problemas no desenvolvimento de um sistema de 
software decorrem do entendimento errado entre 
engenheiro de software (produtor), responsável 
por apresentar o documento de requisitos e usuá-
rio (consumidor). Um documento de requisitos de 
software precisa ser claro, consistente e completo, 
porque esse documento servirá de referência aos 
desenvolvedores, gerente de projeto, engenheiros 
de software (responsáveis pelos testes e manuten-
ção do sistema), além de servir de base para definir 

o escopo das funcionalidades a serem registradas 
em um contrato. Perceba que os requisitos com-
preendem o cerne de qualquer produto, e mudan-
ças sobre eles podem ocorrer ao longo do ciclo de 
vida de um software. 
Requisitos de software 
Desenvolver um sistema de software requer um 
processo, o qual informa um conjunto de ativida-
des a serem realizadas, quem as executam, quais 
artefatos de entrada são necessários e quais ar-
tefatos de saída são produzidos. Nesse sentido, 
detectar erros ou quaisquer outros problemas, 
como inconsistência e falta de clareza, é de suma 
importância, de modo a tornar o processo mais 
efetivo sob o ponto de vista de custo. Além dis-
so, envolver o usuário no desenvolvimento é 

Frameworks e projetos de requisitos formais e não formais) (1 31 

determinante para o sucesso do produto e do 
processo. Dentro desse contexto, entender ade-
quadamente o requisito é essencial, e essa é tarefa 
do engenheiro de software. Um requisito compre-
ende uma característica ou funcionalidade que o 
sistema deve ter ou uma restrição que deve satis-
fazer para atender uma necessidade do usuário. 
Dessa forma, o engenheiro de software, desem-
penhando o papel de engenheiro de requisitos, 
deve executar duas atividades essenciais para a 
elaboração do documento de requisitos: 

1. Elicitação de requisitos — atividade na qual 
os requisitos do sistema a ser desenvolvido 
são levantados. 
2. Análise de requi itos — atividade na qual os 
requisitos são analisados e confirmados pelos 
principais interessados do projeto (isto é, os 
stakeholders) que incluem cliente, usuário final 
e gerente de projetos, dentre outros. 
Considera-se, ainda, que a elicitação de requisitos 
objetiva definir características do sistema sob a 
perspectiva do cliente, enquanto que a análise de 
requisitos visa obter a especificação de requisitos, 
do ponto de vista técnico, conforme entendimen-
to dos desenvolvedores. 
Durante a realização destas atividades, o engenheiro 
de software está preocupado em levantar, entender, 
analisar e, por fim, documentar os requisitos. Para 
tanto, ele deve se concentrar nas características do 
sistema e atributos de qualidade, e não em como 
obtê-los. Aqui, é preciso identificar quais requisitos 
fazem parte ou não do escopo do sistema a ser de-
senvolvido, ou, em outras palavras, entender a inter-
face do sistema considerado e o ambiente externo. 
É importante ressaltar a necessidade de definir 

o limite”, também denominado escopo do siste-
ma, a fim de tratar os requisitos funcionais e não 
funcionais do sistema. Além disso, quando da 
elaboração do documento de requisitos, o enge-
nheiro de software deve levar em consideração 
os diferentes pontos de vista dos stakeholders, de 
modo que o documento resultante possa comu-
nicar adequadamente o conjunto de requisitos 
do sistema a ser construído. 

Documento de requisitos 
O documento de requisitos delimita o escopo do 
conjunto de funcionalidades que um sistema deve 
prover, bem como descreve os atributos de quali-
dade que devem ser suportados. 

B Serve como mecanismo de comunicação 
para os stakeholders (isto é, as partes interes-
sadas do projeto). 

B Captura e documenta os requisitos do proje-
to, e serve de referência para testes, manuten-
ção e evolução do sistema. 

O documento de requisitos de um projeto tem o 
objetivo de documentar o escopo do sistema a ser 
desenvolvido. Nesse sentido, o documento de re-
quisitos deve conter: 

&B introdução e visão geral do documento; 
B descrição de requisitos funcionais; 
B descrição de requisitos não funcionais; 
B escopo não contemplado (de funcionali-
dades); 
B documentação de apoio. 

É importante perceber a importância do documen-
to de requisitos como determinante para o sucesso 
de um projeto. Ele identifica quais funcionalidades 
fazem parte ou não do escopo do sistema. 
Comentários finais 

Requisitos de software compreendem a essência 
de um produto. Eles definem as funcionalidades 



132) ( arquitetura de software 
que o sistema deve prover e restrições que ele 
deve satisfazer. Documentá-los bem é atividade 
de suma importância para um engenheiro de 
software, que deve levar em consideração o 
público diverso que fará uso desse documento. 
Portanto, o engenheiro de software deve ter em 
mente que tanto cliente quanto gerente de ne-
gócios, gerente de projeto, desenvolvedores e 

Recapitulando 

omeçamos esta unidade falando sobre 

o processo de projeto. Você compreen-
deu como elaborá-lo e os elementos 
que o compõem. No Tema 1, a conversa par-
tiu da plataforma de software, passando pelos 
testes de defeitos e debugging, até chegar nos 
modelos de contexto, modelos de interação e 
aos modelos de arquitetura de alto nível. Quan-
do abordamos a identificação de objetos de 
classe, você aprendeu a utilizar a descrição de caso 

e uso. 

Passando para os modelos de projeto, discutimos 
as diferenças entre os modelos estruturais e os 
modelos dinâmicos. Ainda neste tópico, também 

engenheiros de testes irão consultar as informa-
ções contidas nesse documento. 
Fonte: adaptado de Silva Filho (2009). 

Exercício 
Redija um texto de 15 a 25 linhas explicando o que é 
um documento de requisitos e a importância deste 
para o processo de desenvolvimento de softwares. 

conversamos sobre os modelos de subsistema, os 
modelos de sequência e os modelos de máquina 
de estado. 
Sem perder tempo, entramos nas especificações 
de interface. Aqui, você conheceu a OCL, a lingua-
gem de restrição de objetos e entendeu como é a 
relação entre os objetos e as interfaces. 
À seguir, introduzimos os padrões de projeto, e 
você conheceu as contribuições da gangue dos 
quatro para o desenvolvimento de softwares. 
E, finalmente, chegamos à implementação. Entre 
os tópicos, batemos um papo sobre os conceitos 
de reúso, gerenciamento de configurações e o de-
senvolvimento de host-target. 


REFERÊNCIAS 

AZEVEDO, D. J. P. de. Evolução de software. Bate Byte. Dispo-
nível em: <www.batebyte.pr.gov.br/modules/conteudo/conteudo. 
php?conteudo=299>. Acesso em: 23 jul. 2015. 

BARBOSA, G. M. G. Um livro-texto para o ensino de projeto 
de arquitetura de software. Dissertação (Mestrado em Ciência da 
Computação) — Universidade Federal de Campina Grande, Centro 
de Engenharia Elétrica e Informática, 2009. 

LAFUENTE, F. A era do raciocínio artificial. HSM Management, 
n. 86, maio/jun. 2011. 

PETERS, J. F. Engenharia de software. Rio de Janeiro: Campus, 
2001. 

PRESSMAN,R.S. Engenharia de software. São Paulo: Makron, 
1995. 

. Software engineering: a practitioner's approach. New 
York: Makron, 1997. 

-. Engenharia de software. 6. ed. Rio de Janeiro: MacGraw-
-Hill, 2006. 

SHOOMAN, M.L. Software Engineerings Singapore. New York: 
McGraw-Hill, 1983. 

SILVA FILHO, A. M. da. Documento de requisitos: essencial ao 
desenvolvimento de software. Engenharia de Software Magazine, 
ano I,n. 10, p. 24-29, 18 fev. 2009. Disponível em: <academico.ifrr. 
edu.br/uploads/MATERIAIS AULAS/7243-DOCUMENTO | 
DE REQUISITOS Acesso em: 14 set. 2015.

.pdf>. 

SOMMERVILLE, 1. Software engineering. 4. ed. Columbia: 
Addison-Wesley, 1992. 

. Engenharia de software. 9. ed. São Paulo: Pearson Pren-
tice Hall, 2011. 

STAKEHOLDERS. Noções de engenharia de software, 10 mar. 
2010. Disponível em: <nocoesengsw.blogspot.com.br/2010/03/ 
stakeholders.html>. Acesso em: 12. ago. 2015. 


134) (irauretura de software 
UCSD P-SYSTEM. Wikipédia — a enciclopédia livre. Disponível 
em: <pt.wikipedia.org/wiki/UCSD p-System>. Acesso em: 23 

Jul. 2015. 

VERZELLO, R. J.; REUTTER HI, J. Processamento de dados. 
São Paulo: McGraw-Hill, 1984. 



ARQUITETURA 
DE SOFTWARE 

ORGANIZADOR GiIOCONDO MARINO GALLOTTI 

Baseados na premissa de que o ensino atual exige um pro-
cesso flexível de construção do saber, os livros que compõem a 
Bibliografia Universitária Pearson são concisos sem serem rasos 
e simples sem serem simplistas. Para tanto, eles apresentam 
os principais conceitos dos temas propostos em uma estrutura 
didática única, com linguagem dialógica, diagramação diferen-
ciada e hipertextos, entre outros elementos 

Em Arquitetura de software, isso não é diferente. Nele, tópicos 
como modelagem e implementação de arquiteturas e frame-
works que, dependendo da abordagem, podem parecer compli-
cados são apresentados de um ponto de vista inusitado que, 
ao mostrar como as coisas funcionam na prática, possibilita ao 
leitor um processo intensivo (e real) de aprendizagem. 


